
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2021-08-16T13:24:18.623Z" itemprop="datePublished">
          2021-08-16
      </time>
    
    
    | 
    <a href='/tags/mess/'>mess</a>
    
    
</span>
                <h1>记一次ubuntu18.04的glibc调教</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>
    <div id="aplayer-OkYnucNG" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="7342554262" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"
    ></div> 

<h4 id="1）概述"><a href="#1）概述" class="headerlink" title="1）概述"></a>1）概述</h4><p>这是一件悲伤的事情，我的ubuntu它又崩了。</p>
<p>最开始的时候，发现pwndbg无法查看heap等信息，这个问题我之前也遇到过，但是情况有非常大的区别。</p>
<p>之前是我2.32的本地默认libc，执行程序时加载2.23，然后因为指定的lbc-2.23.so没有附带调试符号信息，所以也看不了heap，但是这一次，本机都看不了了？</p>
<p>经过一番排查，我们认为是libc本身出现了问题。然后寻找libc-2.27.so的文件打算一探究竟，但找到本应该储存着它的文件夹时，惊奇地发现它居然从文件夹中消失了。</p>
<p>它并不是无缘无故消失的，我大致分析了一下原因。之前我做题时试图切换libc版本，然后在镜像站下载了（应该）带调试符号的libc-2.27.so。但是并不是很清楚，所以喊来了pwn爷爷，pwn爷爷并不熟悉我的电脑，一通操作猛如虎，干了啥我也不知道，反正好像是把libc丢进了根目录。</p>
<p>可能就是在那会儿，新下载的libc和已有的libc产生了冲突，然后启动了什么奇怪的过程，把libc彻底搞崩了。</p>
<p>但是这个pwn大哥完全没锅，因为挺有趣的其实。</p>
<p>然后大致明了的问题的方向我开始寻找解决方案。</p>
<p>虽然pwn大哥不费吹灰之力帮我重新装了一个系统并且完善好了环境，但是还有一个报废的系统等着我蹂躏呢（）</p>
<h3 id="2-record"><a href="#2-record" class="headerlink" title="2)record"></a>2)record</h3><p>记录一下所有调教的操作。</p>
<ol>
<li>普通地在/usr/lib/x86_64-linux-gnu文件夹中添加ld，无效。</li>
<li>普通地在/usr/lib/x86_64-linux-gnu文件夹中添加带有调试符号的libc，无效。</li>
</ol>
<p>等等为什么ld和libc都没了。。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg: created $rebase, $<span class="function">ida gdb <span class="title">functions</span> <span class="params">(can be used with print/<span class="keyword">break</span>)</span></span></span><br><span class="line"><span class="function">Reading symbols from ./worldline...done.</span></span><br><span class="line"><span class="function">Attaching to program: /home/fur1n/pwn/heap/merely_game/wordline/worldline, process 12250</span></span><br><span class="line"><span class="function">Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...</span></span><br><span class="line"><span class="function">warning: the debug information found in &quot;/usr/lib/debug<span class="comment">//lib/x86_64-linux-gnu/libc-2.27.so&quot; does not match &quot;/lib/x86_64-linux-gnu/libc.so.6&quot; (CRC mismatch)</span></span></span><br></pre></td></tr></table></figure>

<p>好嘛。</p>
<blockquote>
<h6 id="About-CRC-Errors"><a href="#About-CRC-Errors" class="headerlink" title="About CRC Errors"></a>About CRC Errors</h6><p>A CRC error indicates that some data in your Zip file (.zip or .zipx) is damaged. CRC stands for <strong>cyclic redundancy check</strong>. It is a calculation made from all the data in a file to insure accuracy. When you add a file to a Zip file, WinZip calculates a CRC value for the file and saves the value in the Zip file. When you later extract the file from the Zip file, WinZip calculates the CRC of the extracted file and compares it to the value stored when the file was zipped. If these two CRC values do not match, the file that was extracted does not match the original file, and WinZip will display a <strong>CRC Error</strong> message.</p>
<p>When the data in a Zip file is damaged, it may not be possible to extract all of the files from the Zip file correctly. Damaged data can affect the entire Zip file, multiple files, or just one file.</p>
</blockquote>
<p>crc的官方定义是文件被损坏导致错误，但是实际并没有损坏。。感觉并不是可以随便解决的问题</p>
<p>​      3.替换libc.so.6文件。他不是不匹配嘛，不匹配我就弄个匹配的。结果无效。</p>
<p>查了一下，查出一堆奇怪的问题。网上大多都是完全无法调试，但是我这就很离谱。</p>
<p>难道只能硬啃那个又臭又长的gdb的文档吗？</p>
<p><a target="_blank" rel="noopener" href="https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html">18.3 Debugging Information in Separate Files</a></p>
<blockquote>
<p>GDB supports two ways of specifying the separate debug info file:</p>
<ul>
<li>The executable contains a <em>debug link</em> that specifies the name of the separate debug info file. The separate debug file’s name is usually executable.debug, where executable is the name of the corresponding executable file without leading directories (e.g., ls.debug for /usr/bin/ls). In addition, the debug link specifies a 32-bit <em>Cyclic Redundancy Check</em> (CRC) checksum for the debug file, which GDB uses to validate that the executable and the debug file came from the same build.</li>
<li>The executable contains a <em>build ID</em>, a unique bit string that is also present in the corresponding debug info file. (This is supported only on some operating systems, when using the ELF or PE file formats for binary files and the GNU Binutils.) For more details about this feature, see the description of the –build-id command-line option in <a target="_blank" rel="noopener" href="http://sourceware.org/binutils/docs/ld/Options.html#Options">Command Line Options</a> in The GNU Linker. The debug info file’s name is not specified explicitly by the build ID, but can be computed from the build ID, see below.</li>
</ul>
</blockquote>
<p>在某些系统中（比如我们的ubunut），由于调试文件可能比可执行程序都大，所以通常将可执行文件以及调试文件分开存放。一般来说调试信息</p>
<p>的后缀是<code>.debug</code>。</p>
<p>gdb支持两种寻找调试info文件的方式。</p>
<p>一种是可执行文件包含指向调试信息文件的路径。就比如ls在<code> /usr/bin/ls)</code>中，同时这个文件夹还包含<code>ls.debug</code>文件。</p>
<p>然后调试链接器还通过crc检查来使来源于同一个编译的可执行文件和调试文件生效。</p>
<p>此外还有就是通过匹配build ID来指定。关于build ID，这个确实是有的。</p>
<p>然后当可执行文件已经指定好调试文件，gdb还需要去寻找它。就像小张跟小静说我要找小王，小静只是知道他需要找到小王，但是还不知道怎么找。</p>
<blockquote>
<p>Depending on the way the debug info file is specified, GDB uses two different methods of looking for the debug file:</p>
<ul>
<li>For the “debug link” method, GDB looks up the named file in the directory of the executable file, then in a subdirectory of that directory named .debug, and finally under each one of the global debug directories, in a subdirectory whose name is identical to the leading directories of the executable’s absolute file name. (On MS-Windows/MS-DOS, the drive letter of the executable’s leading directories is converted to a one-letter subdirectory, i.e. d:/usr/bin/ is converted to /d/usr/bin/, because Windows filesystems disallow colons in file names.)</li>
<li>For the “build ID” method, GDB looks in the .build-id subdirectory of each one of the global debug directories for a file named nn/nnnnnnnn.debug, where nn are the first 2 hex characters of the build ID bit string, and nnnnnnnn are the rest of the bit string. (Real build ID strings are 32 or more hex characters, not 10.)</li>
</ul>
<p>So, for example, suppose you ask GDB to debug /usr/bin/ls, which has a debug link that specifies the file ls.debug, and a build ID whose value in hex is <code>abcdef1234</code>. If the list of the global debug directories includes /usr/lib/debug, then GDB will look for the following debug information files, in the indicated order:</p>
<ul>
<li>- /usr/lib/debug/.build-id/ab/cdef1234.debug</li>
<li>- /usr/bin/ls.debug</li>
<li>- /usr/bin/.debug/ls.debug</li>
<li>- /usr/lib/debug/usr/bin/ls.debug.</li>
</ul>
</blockquote>
<p>一个就是普通的在子目录中寻找对应的文件，</p>
<p>另外一个根据build ID，在名为<code>.build-id</code>的子目录中寻找build ID对应的文件夹。</p>
<p>也就是说如果要调试<code> /usr/bin/ls</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/debug/.build-id/ab/cdef1234.debug</span><br><span class="line">/usr/bin/ls.debug</span><br><span class="line">/usr/bin/.debug/ls.debug</span><br><span class="line">/usr/lib/debug/usr/bin/ls.debug.</span><br></pre></td></tr></table></figure>

<p>这四种路径都能帮助gdb找到对应的调试文件。</p>
<p>所以无论如何实际上没有解决任何问题。比如我找到的在stackoverflow上的相同报错，基本上都是在对应文件夹中缺少他编译文件的<code>.debug</code>文件，但是这个和我感觉咩有关系。因为感觉libc这种本来就是咩有debug文件的。。。。</p>
<p>网上也一会儿找不到和我相同的情况。好离谱</p>
<p>我只能暂且顺着这个思路走一走，看看能不能添加什么<code>libc-2.27.so</code>的debug文件。但是好奇怪，就算缺少也应该是我们需要调试的程序缺少调试文件，为什么是libc缺少调试文件，难道我们调的不是程序而是libc？</p>
<p>就跟之前我看那个源码级调试堆题，給的源码也是malloc的源码。</p>
<p>对了，18.04的应该是把debug信息一起整合到了一个叫debug的文件夹里<code>/usr/lib/debug</code></p>
<p>里面感觉和libc如出一撤，所以我才猜测这就是对应的所谓的调试信息。</p>
<p>然后检查发现都比较完善，没有缺少什么。</p>
<p>这就很怪了。</p>
<p>想一下，之前报错就是说libc.so.6和libc的调试文件不匹配</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warning: the debug information found <span class="keyword">in</span> <span class="string">&quot;/usr/lib/debug//lib/x86_64-linux-gnu/ld-2.27.so&quot;</span> does not match <span class="string">&quot;/lib64/ld-linux-x86-64.so.2&quot;</span> (CRC mismatch).</span><br><span class="line">warning: the debug information found <span class="keyword">in</span> <span class="string">&quot;/usr/lib/debug//lib/x86_64-linux-gnu/libc-2.27.so&quot;</span> does not match <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span> (CRC mismatch).</span><br></pre></td></tr></table></figure>

<p><code>/lib64/ld-linux-x86-64.so.2</code>是一个软连接，在这里链接的是<code>/lib/x86_64-linux-gnu/ld-2.27.so</code>,也就相当于ld-2.27.so</p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="../../17/Tcache%E5%AD%A6%E4%B9%A0/" style="float: left;">
        ← Tcahce学习
    </a>
    
    
    <a class="pull-right" href="../../13/ELF%E6%96%87%E4%BB%B6%E4%B8%8B%E5%AF%B9%E4%BA%8EPIE%E4%BF%9D%E6%8A%A4%E5%92%8CASLR%E7%9A%84%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86/">
        ELF文件下对于PIE保护和ASLR的重新认识 →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>

<!-- Highlight.js -->

<link rel="stylesheet"
href="//highlightjs.org/static/demo/styles/atom-one-light.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js">
</script>
<script>
hljs.initHighlightingOnLoad();

</script>

